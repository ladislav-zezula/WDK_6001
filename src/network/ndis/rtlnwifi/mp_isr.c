/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:
    MP_Isr.h

Abstract:
    Interrupt handling routines
    
Revision History:
      When        What
    ----------    ----------------------------------------------
    08-01-2005    Created

Notes:

--*/
#include "precomp.h"

#include "Mp_main.h"


/**
 * Called by NDIS when an interrupt occurs that may belong this this miniport
 * 
 * \param MiniportInterruptContext          The Interrupt Context registered with NDIS
 * \param pbQueueMiniportHandleInterrupt    Set to true by this function if we want to
 * queue the Handle Interrupt DPC
 * \param TargetProcessors                  Ununsed
 * \return TRUE if the interrupt was generated by this adapter
 * \sa MPHandleInterrupt
 */
BOOLEAN 
MPISR(
    IN  NDIS_HANDLE     MiniportInterruptContext,
    OUT PBOOLEAN        pbQueueMiniportHandleInterrupt,
    OUT PULONG          TargetProcessors
    )
{
    PNIC        pNic;
    PADAPTER    pAdapter = (PADAPTER)MiniportInterruptContext;
    BOOLEAN     bInterruptRecognized;

    UNREFERENCED_PARAMETER(TargetProcessors);

    do
    {        
        //
        // If the NIC is in low power state, this cannot be our interrupt
        //
        if (MP_IS_LOW_POWER_STATE(pAdapter->DevicePowerState))
        {
            *pbQueueMiniportHandleInterrupt = FALSE;
            bInterruptRecognized = FALSE;
            break;
        }

        pNic = pAdapter->pNic;

        //
        // If the Interrupts are not already disabled and the NIC did generate an interrupt
        // claim this interrupt
        //
        if (Hw11InterruptEnabled(pNic))
        {
            bInterruptRecognized = Hw11InterruptRecognized(pNic, pbQueueMiniportHandleInterrupt);
            
            if (bInterruptRecognized)
            {
                //
                // This hardware has generated an interrupt
                //
                if (*pbQueueMiniportHandleInterrupt)
                {
                    // 
                    // The driver requires a DPC to handle this interrupt.
                    // Disable other interrupts so we can handle this one.
                    // This will be re-enabled in MpHandleInterrupt routine.
                    //
                    Hw11DisableInterrupt(pNic);
                }
                
                //
                // Clear this interrupt so that we do not wrongly keep claiming
                // this same interrupt
                //
                Hw11ClearInterrupt(pNic);
            }
        }
        else
        {
            //
            // Interrupts are disabled so we are not the source of this interrupt
            //
            bInterruptRecognized = FALSE;
            *pbQueueMiniportHandleInterrupt = FALSE;
        }
    } while(FALSE);

    return bInterruptRecognized;
}




/**
 * Called by NDIS when the miniport claims an interrupt and requests this DPC to
 * be queued during a previous call to MPISR
 * 
 * \param MiniportAdapterContext    The adapter context for this miniport
 * \sa MPISR
 */
VOID
MPHandleInterrupt(
    IN  NDIS_HANDLE     MiniportAdapterContext,
    IN  PVOID           MiniportDpcContext,
    IN  PULONG          NdisReserved1,
    IN  PULONG          NdisReserved2
    )
{
    PADAPTER pAdapter = (PADAPTER)MiniportAdapterContext;

    UNREFERENCED_PARAMETER(NdisReserved1);
    UNREFERENCED_PARAMETER(NdisReserved2);
    UNREFERENCED_PARAMETER(MiniportDpcContext);
    
    //
    // Call the custom interfaces and allow for any custom actions
    // that need to be taken.
    //
    MpEventHandleInterrupt(pAdapter);


    //
    // The ordering of Send Complete and Receive handling is
    // significant. Depending on successful send completion of
    // certain packets like PS-POLL, we expect to receive
    // buffered frames from another machine.
    // For wireless medium, we care about successful sends having
    // occurred before we receive particular frames.
    //
    
    MpHandleSendCompleteInterrupt(pAdapter);

    //
    // Perform receives
    //
    pAdapter->ReceiveHandlerFunction(pAdapter);
    
    //
    // Enable back the interrupts. These were disabled in MpISR routine.
    //
    NdisMSynchronizeWithInterruptEx(
        pAdapter->InterruptHandle,
        0,
        (PVOID)Hw11EnableInterrupt,
        (PVOID)pAdapter->pNic
        );
}


/**
 * Called by NDIS to Enable Interrupts on this miniport
 * 
 * \param MiniportInterruptContext  The Interrupt context for this miniport
 * \sa MPDisableInterrupt
 */
VOID
MPEnableInterrupt(
    IN  NDIS_HANDLE  MiniportInterruptContext
    )
{
    PADAPTER pAdapter = (PADAPTER)MiniportInterruptContext;

    Hw11EnableInterrupt(pAdapter->pNic);
}


/**
 * Called by NDIS to disable interrupts on this miniport
 * 
 * \param MiniportInterruptContext  The Interrupt context for this miniport
 * \sa MPEnableInterrupt
 */
VOID
MPDisableInterrupt(
    IN  NDIS_HANDLE  MiniportInterruptContext
    )
{
    PADAPTER pAdapter = (PADAPTER)MiniportInterruptContext;

    Hw11DisableInterrupt(pAdapter->pNic);
}

BOOLEAN
Mp11SynchronizeWithInterrupt(
    IN  PADAPTER        pAdapter,
    IN  PVOID           SynchronizeFunction,
    IN  PVOID           SynchronizeContext
    )
{
    return NdisMSynchronizeWithInterruptEx(
        pAdapter->InterruptHandle,
        0,
        (PVOID)SynchronizeFunction,
        (PVOID)SynchronizeContext
        );
}

