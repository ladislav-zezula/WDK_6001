#ifndef CHAPLIN_BF_FUNC_H
#define CHAPLIN_BF_FUNC_H

#ifdef  DEFAULT_PITCH
// Apparently Microsoft defines the symbol DEFAULT_PITCH someplace,
// but this is the name of a field in one of the registers.
// This results in a compilation conflict.
#undef  DEFAULT_PITCH
#endif
#ifndef qLittleEndian
#define qLittleEndian
#endif
#include "chaplin_registers.h"
#include "atidxhsl.h"
#include "stdio.h"

///////////////////////////////////////////////////////////////
typedef union GENENB regGENENB;

#ifdef DEBUG
__inline void set_GENENB_blk_io_base(regGENENB *reg, unsigned int blk_io_base)
{
  reg->bitfields.BLK_IO_BASE = blk_io_base;
  if (reg->bitfields.BLK_IO_BASE != blk_io_base) HSLDPF(E_ERROR_MESSAGE,"GENENB::BLK_IO_BASE data too large\n");
}
#else
#define set_GENENB_blk_io_base(reg, blk_io_base) (reg)->bitfields.BLK_IO_BASE = blk_io_base

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MM_INDEX regMM_INDEX;

#ifdef DEBUG
__inline void set_MM_INDEX_mm_addr(regMM_INDEX *reg, unsigned int mm_addr)
{
  reg->bitfields.MM_ADDR = mm_addr;
  if (reg->bitfields.MM_ADDR != mm_addr) HSLDPF(E_ERROR_MESSAGE,"MM_INDEX::MM_ADDR data too large\n");
}
__inline void set_MM_INDEX_mm_aper(regMM_INDEX *reg, unsigned int mm_aper)
{
  reg->bitfields.MM_APER = mm_aper;
  if (reg->bitfields.MM_APER != mm_aper) HSLDPF(E_ERROR_MESSAGE,"MM_INDEX::MM_APER data too large\n");
}
#else
#define set_MM_INDEX_mm_addr(reg, mm_addr) (reg)->bitfields.MM_ADDR = mm_addr
#define set_MM_INDEX_mm_aper(reg, mm_aper) (reg)->bitfields.MM_APER = mm_aper

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MM_DATA regMM_DATA;

#ifdef DEBUG
__inline void set_MM_DATA_mm_data(regMM_DATA *reg, unsigned int mm_data)
{
  reg->bitfields.MM_DATA = mm_data;
  if (reg->bitfields.MM_DATA != mm_data) HSLDPF(E_ERROR_MESSAGE,"MM_DATA::MM_DATA data too large\n");
}
#else
#define set_MM_DATA_mm_data(reg, mm_data) (reg)->bitfields.MM_DATA = mm_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BUS_CNTL regBUS_CNTL;

#ifdef DEBUG
__inline void set_BUS_CNTL_bus_dbl_resync(regBUS_CNTL *reg, unsigned int bus_dbl_resync)
{
  reg->bitfields.BUS_DBL_RESYNC = bus_dbl_resync;
  if (reg->bitfields.BUS_DBL_RESYNC != bus_dbl_resync) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_DBL_RESYNC data too large\n");
}
__inline void set_BUS_CNTL_bus_mstr_reset(regBUS_CNTL *reg, unsigned int bus_mstr_reset)
{
  reg->bitfields.BUS_MSTR_RESET = bus_mstr_reset;
  if (reg->bitfields.BUS_MSTR_RESET != bus_mstr_reset) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_MSTR_RESET data too large\n");
}
__inline void set_BUS_CNTL_bus_flush_buf(regBUS_CNTL *reg, unsigned int bus_flush_buf)
{
  reg->bitfields.BUS_FLUSH_BUF = bus_flush_buf;
  if (reg->bitfields.BUS_FLUSH_BUF != bus_flush_buf) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_FLUSH_BUF data too large\n");
}
__inline void set_BUS_CNTL_bus_stop_req_dis(regBUS_CNTL *reg, unsigned int bus_stop_req_dis)
{
  reg->bitfields.BUS_STOP_REQ_DIS = bus_stop_req_dis;
  if (reg->bitfields.BUS_STOP_REQ_DIS != bus_stop_req_dis) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_STOP_REQ_DIS data too large\n");
}
__inline void set_BUS_CNTL_bus_read_combine_en(regBUS_CNTL *reg, unsigned int bus_read_combine_en)
{
  reg->bitfields.BUS_READ_COMBINE_EN = bus_read_combine_en;
  if (reg->bitfields.BUS_READ_COMBINE_EN != bus_read_combine_en) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_READ_COMBINE_EN data too large\n");
}
__inline void set_BUS_CNTL_bus_wrt_combine_en(regBUS_CNTL *reg, unsigned int bus_wrt_combine_en)
{
  reg->bitfields.BUS_WRT_COMBINE_EN = bus_wrt_combine_en;
  if (reg->bitfields.BUS_WRT_COMBINE_EN != bus_wrt_combine_en) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_WRT_COMBINE_EN data too large\n");
}
__inline void set_BUS_CNTL_bus_master_dis(regBUS_CNTL *reg, unsigned int bus_master_dis)
{
  reg->bitfields.BUS_MASTER_DIS = bus_master_dis;
  if (reg->bitfields.BUS_MASTER_DIS != bus_master_dis) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_MASTER_DIS data too large\n");
}
__inline void set_BUS_CNTL_bios_rom_wrt_en(regBUS_CNTL *reg, unsigned int bios_rom_wrt_en)
{
  reg->bitfields.BIOS_ROM_WRT_EN = bios_rom_wrt_en;
  if (reg->bitfields.BIOS_ROM_WRT_EN != bios_rom_wrt_en) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BIOS_ROM_WRT_EN data too large\n");
}
__inline void set_BUS_CNTL_bus_prefetch_mode(regBUS_CNTL *reg, unsigned int bus_prefetch_mode)
{
  reg->bitfields.BUS_PREFETCH_MODE = bus_prefetch_mode;
  if (reg->bitfields.BUS_PREFETCH_MODE != bus_prefetch_mode) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_PREFETCH_MODE data too large\n");
}
__inline void set_BUS_CNTL_bus_vga_prefetch_en(regBUS_CNTL *reg, unsigned int bus_vga_prefetch_en)
{
  reg->bitfields.BUS_VGA_PREFETCH_EN = bus_vga_prefetch_en;
  if (reg->bitfields.BUS_VGA_PREFETCH_EN != bus_vga_prefetch_en) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_VGA_PREFETCH_EN data too large\n");
}
__inline void set_BUS_CNTL_bus_sgl_read_disable(regBUS_CNTL *reg, unsigned int bus_sgl_read_disable)
{
  reg->bitfields.BUS_SGL_READ_DISABLE = bus_sgl_read_disable;
  if (reg->bitfields.BUS_SGL_READ_DISABLE != bus_sgl_read_disable) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_SGL_READ_DISABLE data too large\n");
}
__inline void set_BUS_CNTL_bios_dis_rom(regBUS_CNTL *reg, unsigned int bios_dis_rom)
{
  reg->bitfields.BIOS_DIS_ROM = bios_dis_rom;
  if (reg->bitfields.BIOS_DIS_ROM != bios_dis_rom) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BIOS_DIS_ROM data too large\n");
}
__inline void set_BUS_CNTL_bus_pci_read_retry_en(regBUS_CNTL *reg, unsigned int bus_pci_read_retry_en)
{
  reg->bitfields.BUS_PCI_READ_RETRY_EN = bus_pci_read_retry_en;
  if (reg->bitfields.BUS_PCI_READ_RETRY_EN != bus_pci_read_retry_en) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_PCI_READ_RETRY_EN data too large\n");
}
__inline void set_BUS_CNTL_bus_agp_ad_stepping_en(regBUS_CNTL *reg, unsigned int bus_agp_ad_stepping_en)
{
  reg->bitfields.BUS_AGP_AD_STEPPING_EN = bus_agp_ad_stepping_en;
  if (reg->bitfields.BUS_AGP_AD_STEPPING_EN != bus_agp_ad_stepping_en) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_AGP_AD_STEPPING_EN data too large\n");
}
__inline void set_BUS_CNTL_bus_pci_wrt_retry_en(regBUS_CNTL *reg, unsigned int bus_pci_wrt_retry_en)
{
  reg->bitfields.BUS_PCI_WRT_RETRY_EN = bus_pci_wrt_retry_en;
  if (reg->bitfields.BUS_PCI_WRT_RETRY_EN != bus_pci_wrt_retry_en) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_PCI_WRT_RETRY_EN data too large\n");
}
__inline void set_BUS_CNTL_bus_retry_ws(regBUS_CNTL *reg, unsigned int bus_retry_ws)
{
  reg->bitfields.BUS_RETRY_WS = bus_retry_ws;
  if (reg->bitfields.BUS_RETRY_WS != bus_retry_ws) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_RETRY_WS data too large\n");
}
__inline void set_BUS_CNTL_bus_mstr_rd_mult(regBUS_CNTL *reg, unsigned int bus_mstr_rd_mult)
{
  reg->bitfields.BUS_MSTR_RD_MULT = bus_mstr_rd_mult;
  if (reg->bitfields.BUS_MSTR_RD_MULT != bus_mstr_rd_mult) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_MSTR_RD_MULT data too large\n");
}
__inline void set_BUS_CNTL_bus_mstr_rd_line(regBUS_CNTL *reg, unsigned int bus_mstr_rd_line)
{
  reg->bitfields.BUS_MSTR_RD_LINE = bus_mstr_rd_line;
  if (reg->bitfields.BUS_MSTR_RD_LINE != bus_mstr_rd_line) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_MSTR_RD_LINE data too large\n");
}
__inline void set_BUS_CNTL_bus_suspend(regBUS_CNTL *reg, unsigned int bus_suspend)
{
  reg->bitfields.BUS_SUSPEND = bus_suspend;
  if (reg->bitfields.BUS_SUSPEND != bus_suspend) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_SUSPEND data too large\n");
}
__inline void set_BUS_CNTL_lat_16x(regBUS_CNTL *reg, unsigned int lat_16x)
{
  reg->bitfields.LAT_16X = lat_16x;
  if (reg->bitfields.LAT_16X != lat_16x) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::LAT_16X data too large\n");
}
__inline void set_BUS_CNTL_bus_rd_discard_en(regBUS_CNTL *reg, unsigned int bus_rd_discard_en)
{
  reg->bitfields.BUS_RD_DISCARD_EN = bus_rd_discard_en;
  if (reg->bitfields.BUS_RD_DISCARD_EN != bus_rd_discard_en) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_RD_DISCARD_EN data too large\n");
}
__inline void set_BUS_CNTL_enfrcwrdy(regBUS_CNTL *reg, unsigned int enfrcwrdy)
{
  reg->bitfields.ENFRCWRDY = enfrcwrdy;
  if (reg->bitfields.ENFRCWRDY != enfrcwrdy) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::ENFRCWRDY data too large\n");
}
__inline void set_BUS_CNTL_bus_mstr_ws(regBUS_CNTL *reg, unsigned int bus_mstr_ws)
{
  reg->bitfields.BUS_MSTR_WS = bus_mstr_ws;
  if (reg->bitfields.BUS_MSTR_WS != bus_mstr_ws) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_MSTR_WS data too large\n");
}
__inline void set_BUS_CNTL_bus_parking_dis(regBUS_CNTL *reg, unsigned int bus_parking_dis)
{
  reg->bitfields.BUS_PARKING_DIS = bus_parking_dis;
  if (reg->bitfields.BUS_PARKING_DIS != bus_parking_dis) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_PARKING_DIS data too large\n");
}
__inline void set_BUS_CNTL_bus_mstr_disconnect_en(regBUS_CNTL *reg, unsigned int bus_mstr_disconnect_en)
{
  reg->bitfields.BUS_MSTR_DISCONNECT_EN = bus_mstr_disconnect_en;
  if (reg->bitfields.BUS_MSTR_DISCONNECT_EN != bus_mstr_disconnect_en) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_MSTR_DISCONNECT_EN data too large\n");
}
__inline void set_BUS_CNTL_serr_en(regBUS_CNTL *reg, unsigned int serr_en)
{
  reg->bitfields.SERR_EN = serr_en;
  if (reg->bitfields.SERR_EN != serr_en) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::SERR_EN data too large\n");
}
__inline void set_BUS_CNTL_bus_read_burst(regBUS_CNTL *reg, unsigned int bus_read_burst)
{
  reg->bitfields.BUS_READ_BURST = bus_read_burst;
  if (reg->bitfields.BUS_READ_BURST != bus_read_burst) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_READ_BURST data too large\n");
}
__inline void set_BUS_CNTL_bus_rdy_read_dly(regBUS_CNTL *reg, unsigned int bus_rdy_read_dly)
{
  reg->bitfields.BUS_RDY_READ_DLY = bus_rdy_read_dly;
  if (reg->bitfields.BUS_RDY_READ_DLY != bus_rdy_read_dly) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL::BUS_RDY_READ_DLY data too large\n");
}
#else
#define set_BUS_CNTL_bus_dbl_resync(reg, bus_dbl_resync) (reg)->bitfields.BUS_DBL_RESYNC = bus_dbl_resync
#define set_BUS_CNTL_bus_mstr_reset(reg, bus_mstr_reset) (reg)->bitfields.BUS_MSTR_RESET = bus_mstr_reset
#define set_BUS_CNTL_bus_flush_buf(reg, bus_flush_buf) (reg)->bitfields.BUS_FLUSH_BUF = bus_flush_buf
#define set_BUS_CNTL_bus_stop_req_dis(reg, bus_stop_req_dis) (reg)->bitfields.BUS_STOP_REQ_DIS = bus_stop_req_dis
#define set_BUS_CNTL_bus_read_combine_en(reg, bus_read_combine_en) (reg)->bitfields.BUS_READ_COMBINE_EN = bus_read_combine_en
#define set_BUS_CNTL_bus_wrt_combine_en(reg, bus_wrt_combine_en) (reg)->bitfields.BUS_WRT_COMBINE_EN = bus_wrt_combine_en
#define set_BUS_CNTL_bus_master_dis(reg, bus_master_dis) (reg)->bitfields.BUS_MASTER_DIS = bus_master_dis
#define set_BUS_CNTL_bios_rom_wrt_en(reg, bios_rom_wrt_en) (reg)->bitfields.BIOS_ROM_WRT_EN = bios_rom_wrt_en
#define set_BUS_CNTL_bus_prefetch_mode(reg, bus_prefetch_mode) (reg)->bitfields.BUS_PREFETCH_MODE = bus_prefetch_mode
#define set_BUS_CNTL_bus_vga_prefetch_en(reg, bus_vga_prefetch_en) (reg)->bitfields.BUS_VGA_PREFETCH_EN = bus_vga_prefetch_en
#define set_BUS_CNTL_bus_sgl_read_disable(reg, bus_sgl_read_disable) (reg)->bitfields.BUS_SGL_READ_DISABLE = bus_sgl_read_disable
#define set_BUS_CNTL_bios_dis_rom(reg, bios_dis_rom) (reg)->bitfields.BIOS_DIS_ROM = bios_dis_rom
#define set_BUS_CNTL_bus_pci_read_retry_en(reg, bus_pci_read_retry_en) (reg)->bitfields.BUS_PCI_READ_RETRY_EN = bus_pci_read_retry_en
#define set_BUS_CNTL_bus_agp_ad_stepping_en(reg, bus_agp_ad_stepping_en) (reg)->bitfields.BUS_AGP_AD_STEPPING_EN = bus_agp_ad_stepping_en
#define set_BUS_CNTL_bus_pci_wrt_retry_en(reg, bus_pci_wrt_retry_en) (reg)->bitfields.BUS_PCI_WRT_RETRY_EN = bus_pci_wrt_retry_en
#define set_BUS_CNTL_bus_retry_ws(reg, bus_retry_ws) (reg)->bitfields.BUS_RETRY_WS = bus_retry_ws
#define set_BUS_CNTL_bus_mstr_rd_mult(reg, bus_mstr_rd_mult) (reg)->bitfields.BUS_MSTR_RD_MULT = bus_mstr_rd_mult
#define set_BUS_CNTL_bus_mstr_rd_line(reg, bus_mstr_rd_line) (reg)->bitfields.BUS_MSTR_RD_LINE = bus_mstr_rd_line
#define set_BUS_CNTL_bus_suspend(reg, bus_suspend) (reg)->bitfields.BUS_SUSPEND = bus_suspend
#define set_BUS_CNTL_lat_16x(reg, lat_16x) (reg)->bitfields.LAT_16X = lat_16x
#define set_BUS_CNTL_bus_rd_discard_en(reg, bus_rd_discard_en) (reg)->bitfields.BUS_RD_DISCARD_EN = bus_rd_discard_en
#define set_BUS_CNTL_enfrcwrdy(reg, enfrcwrdy) (reg)->bitfields.ENFRCWRDY = enfrcwrdy
#define set_BUS_CNTL_bus_mstr_ws(reg, bus_mstr_ws) (reg)->bitfields.BUS_MSTR_WS = bus_mstr_ws
#define set_BUS_CNTL_bus_parking_dis(reg, bus_parking_dis) (reg)->bitfields.BUS_PARKING_DIS = bus_parking_dis
#define set_BUS_CNTL_bus_mstr_disconnect_en(reg, bus_mstr_disconnect_en) (reg)->bitfields.BUS_MSTR_DISCONNECT_EN = bus_mstr_disconnect_en
#define set_BUS_CNTL_serr_en(reg, serr_en) (reg)->bitfields.SERR_EN = serr_en
#define set_BUS_CNTL_bus_read_burst(reg, bus_read_burst) (reg)->bitfields.BUS_READ_BURST = bus_read_burst
#define set_BUS_CNTL_bus_rdy_read_dly(reg, bus_rdy_read_dly) (reg)->bitfields.BUS_RDY_READ_DLY = bus_rdy_read_dly

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union HI_STAT regHI_STAT;

#ifdef DEBUG
__inline void set_HI_STAT_agp_busy(regHI_STAT *reg, unsigned int agp_busy)
{
  reg->bitfields.AGP_BUSY = agp_busy;
  if (reg->bitfields.AGP_BUSY != agp_busy) HSLDPF(E_ERROR_MESSAGE,"HI_STAT::AGP_BUSY data too large\n");
}
#else
#define set_HI_STAT_agp_busy(reg, agp_busy) (reg)->bitfields.AGP_BUSY = agp_busy

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BUS_CNTL1 regBUS_CNTL1;

#ifdef DEBUG
__inline void set_BUS_CNTL1_pmi_io_disable(regBUS_CNTL1 *reg, unsigned int pmi_io_disable)
{
  reg->bitfields.PMI_IO_DISABLE = pmi_io_disable;
  if (reg->bitfields.PMI_IO_DISABLE != pmi_io_disable) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL1::PMI_IO_DISABLE data too large\n");
}
__inline void set_BUS_CNTL1_pmi_mem_disable(regBUS_CNTL1 *reg, unsigned int pmi_mem_disable)
{
  reg->bitfields.PMI_MEM_DISABLE = pmi_mem_disable;
  if (reg->bitfields.PMI_MEM_DISABLE != pmi_mem_disable) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL1::PMI_MEM_DISABLE data too large\n");
}
__inline void set_BUS_CNTL1_pmi_bm_disable(regBUS_CNTL1 *reg, unsigned int pmi_bm_disable)
{
  reg->bitfields.PMI_BM_DISABLE = pmi_bm_disable;
  if (reg->bitfields.PMI_BM_DISABLE != pmi_bm_disable) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL1::PMI_BM_DISABLE data too large\n");
}
__inline void set_BUS_CNTL1_pmi_int_disable(regBUS_CNTL1 *reg, unsigned int pmi_int_disable)
{
  reg->bitfields.PMI_INT_DISABLE = pmi_int_disable;
  if (reg->bitfields.PMI_INT_DISABLE != pmi_int_disable) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL1::PMI_INT_DISABLE data too large\n");
}
__inline void set_BUS_CNTL1_bus2_wbf_during_reg_wrt_en(regBUS_CNTL1 *reg, unsigned int bus2_wbf_during_reg_wrt_en)
{
  reg->bitfields.BUS2_WBF_DURING_REG_WRT_EN = bus2_wbf_during_reg_wrt_en;
  if (reg->bitfields.BUS2_WBF_DURING_REG_WRT_EN != bus2_wbf_during_reg_wrt_en) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL1::BUS2_WBF_DURING_REG_WRT_EN data too large\n");
}
__inline void set_BUS_CNTL1_bus2_immediate_pmi_disable(regBUS_CNTL1 *reg, unsigned int bus2_immediate_pmi_disable)
{
  reg->bitfields.BUS2_IMMEDIATE_PMI_DISABLE = bus2_immediate_pmi_disable;
  if (reg->bitfields.BUS2_IMMEDIATE_PMI_DISABLE != bus2_immediate_pmi_disable) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL1::BUS2_IMMEDIATE_PMI_DISABLE data too large\n");
}
__inline void set_BUS_CNTL1_bus2_vga_reg_coherency_dis(regBUS_CNTL1 *reg, unsigned int bus2_vga_reg_coherency_dis)
{
  reg->bitfields.BUS2_VGA_REG_COHERENCY_DIS = bus2_vga_reg_coherency_dis;
  if (reg->bitfields.BUS2_VGA_REG_COHERENCY_DIS != bus2_vga_reg_coherency_dis) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL1::BUS2_VGA_REG_COHERENCY_DIS data too large\n");
}
__inline void set_BUS_CNTL1_bus2_vga_mem_coherency_dis(regBUS_CNTL1 *reg, unsigned int bus2_vga_mem_coherency_dis)
{
  reg->bitfields.BUS2_VGA_MEM_COHERENCY_DIS = bus2_vga_mem_coherency_dis;
  if (reg->bitfields.BUS2_VGA_MEM_COHERENCY_DIS != bus2_vga_mem_coherency_dis) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL1::BUS2_VGA_MEM_COHERENCY_DIS data too large\n");
}
__inline void set_BUS_CNTL1_bus2_hdp_reg_coherency_dis(regBUS_CNTL1 *reg, unsigned int bus2_hdp_reg_coherency_dis)
{
  reg->bitfields.BUS2_HDP_REG_COHERENCY_DIS = bus2_hdp_reg_coherency_dis;
  if (reg->bitfields.BUS2_HDP_REG_COHERENCY_DIS != bus2_hdp_reg_coherency_dis) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL1::BUS2_HDP_REG_COHERENCY_DIS data too large\n");
}
__inline void set_BUS_CNTL1_bus2_gui_initiator_coherency_dis(regBUS_CNTL1 *reg, unsigned int bus2_gui_initiator_coherency_dis)
{
  reg->bitfields.BUS2_GUI_INITIATOR_COHERENCY_DIS = bus2_gui_initiator_coherency_dis;
  if (reg->bitfields.BUS2_GUI_INITIATOR_COHERENCY_DIS != bus2_gui_initiator_coherency_dis) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL1::BUS2_GUI_INITIATOR_COHERENCY_DIS data too large\n");
}
__inline void set_BUS_CNTL1_bus2_vga_fw_coherency_dis(regBUS_CNTL1 *reg, unsigned int bus2_vga_fw_coherency_dis)
{
  reg->bitfields.BUS2_VGA_FW_COHERENCY_DIS = bus2_vga_fw_coherency_dis;
  if (reg->bitfields.BUS2_VGA_FW_COHERENCY_DIS != bus2_vga_fw_coherency_dis) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL1::BUS2_VGA_FW_COHERENCY_DIS data too large\n");
}
__inline void set_BUS_CNTL1_bus2_accel_fw_coherency_dis(regBUS_CNTL1 *reg, unsigned int bus2_accel_fw_coherency_dis)
{
  reg->bitfields.BUS2_ACCEL_FW_COHERENCY_DIS = bus2_accel_fw_coherency_dis;
  if (reg->bitfields.BUS2_ACCEL_FW_COHERENCY_DIS != bus2_accel_fw_coherency_dis) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL1::BUS2_ACCEL_FW_COHERENCY_DIS data too large\n");
}
__inline void set_BUS_CNTL1_bus2_rd_panic_val(regBUS_CNTL1 *reg, unsigned int bus2_rd_panic_val)
{
  reg->bitfields.BUS2_RD_PANIC_VAL = bus2_rd_panic_val;
  if (reg->bitfields.BUS2_RD_PANIC_VAL != bus2_rd_panic_val) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL1::BUS2_RD_PANIC_VAL data too large\n");
}
__inline void set_BUS_CNTL1_bus2_wrt_panic_val(regBUS_CNTL1 *reg, unsigned int bus2_wrt_panic_val)
{
  reg->bitfields.BUS2_WRT_PANIC_VAL = bus2_wrt_panic_val;
  if (reg->bitfields.BUS2_WRT_PANIC_VAL != bus2_wrt_panic_val) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL1::BUS2_WRT_PANIC_VAL data too large\n");
}
__inline void set_BUS_CNTL1_mobile_platform_sel(regBUS_CNTL1 *reg, unsigned int mobile_platform_sel)
{
  reg->bitfields.MOBILE_PLATFORM_SEL = mobile_platform_sel;
  if (reg->bitfields.MOBILE_PLATFORM_SEL != mobile_platform_sel) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL1::MOBILE_PLATFORM_SEL data too large\n");
}
__inline void set_BUS_CNTL1_send_sba_latency(regBUS_CNTL1 *reg, unsigned int send_sba_latency)
{
  reg->bitfields.SEND_SBA_LATENCY = send_sba_latency;
  if (reg->bitfields.SEND_SBA_LATENCY != send_sba_latency) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL1::SEND_SBA_LATENCY data too large\n");
}
__inline void set_BUS_CNTL1_agpclk_valid(regBUS_CNTL1 *reg, unsigned int agpclk_valid)
{
  reg->bitfields.AGPCLK_VALID = agpclk_valid;
  if (reg->bitfields.AGPCLK_VALID != agpclk_valid) HSLDPF(E_ERROR_MESSAGE,"BUS_CNTL1::AGPCLK_VALID data too large\n");
}
#else
#define set_BUS_CNTL1_pmi_io_disable(reg, pmi_io_disable) (reg)->bitfields.PMI_IO_DISABLE = pmi_io_disable
#define set_BUS_CNTL1_pmi_mem_disable(reg, pmi_mem_disable) (reg)->bitfields.PMI_MEM_DISABLE = pmi_mem_disable
#define set_BUS_CNTL1_pmi_bm_disable(reg, pmi_bm_disable) (reg)->bitfields.PMI_BM_DISABLE = pmi_bm_disable
#define set_BUS_CNTL1_pmi_int_disable(reg, pmi_int_disable) (reg)->bitfields.PMI_INT_DISABLE = pmi_int_disable
#define set_BUS_CNTL1_bus2_wbf_during_reg_wrt_en(reg, bus2_wbf_during_reg_wrt_en) (reg)->bitfields.BUS2_WBF_DURING_REG_WRT_EN = bus2_wbf_during_reg_wrt_en
#define set_BUS_CNTL1_bus2_immediate_pmi_disable(reg, bus2_immediate_pmi_disable) (reg)->bitfields.BUS2_IMMEDIATE_PMI_DISABLE = bus2_immediate_pmi_disable
#define set_BUS_CNTL1_bus2_vga_reg_coherency_dis(reg, bus2_vga_reg_coherency_dis) (reg)->bitfields.BUS2_VGA_REG_COHERENCY_DIS = bus2_vga_reg_coherency_dis
#define set_BUS_CNTL1_bus2_vga_mem_coherency_dis(reg, bus2_vga_mem_coherency_dis) (reg)->bitfields.BUS2_VGA_MEM_COHERENCY_DIS = bus2_vga_mem_coherency_dis
#define set_BUS_CNTL1_bus2_hdp_reg_coherency_dis(reg, bus2_hdp_reg_coherency_dis) (reg)->bitfields.BUS2_HDP_REG_COHERENCY_DIS = bus2_hdp_reg_coherency_dis
#define set_BUS_CNTL1_bus2_gui_initiator_coherency_dis(reg, bus2_gui_initiator_coherency_dis) (reg)->bitfields.BUS2_GUI_INITIATOR_COHERENCY_DIS = bus2_gui_initiator_coherency_dis
#define set_BUS_CNTL1_bus2_vga_fw_coherency_dis(reg, bus2_vga_fw_coherency_dis) (reg)->bitfields.BUS2_VGA_FW_COHERENCY_DIS = bus2_vga_fw_coherency_dis
#define set_BUS_CNTL1_bus2_accel_fw_coherency_dis(reg, bus2_accel_fw_coherency_dis) (reg)->bitfields.BUS2_ACCEL_FW_COHERENCY_DIS = bus2_accel_fw_coherency_dis
#define set_BUS_CNTL1_bus2_rd_panic_val(reg, bus2_rd_panic_val) (reg)->bitfields.BUS2_RD_PANIC_VAL = bus2_rd_panic_val
#define set_BUS_CNTL1_bus2_wrt_panic_val(reg, bus2_wrt_panic_val) (reg)->bitfields.BUS2_WRT_PANIC_VAL = bus2_wrt_panic_val
#define set_BUS_CNTL1_mobile_platform_sel(reg, mobile_platform_sel) (reg)->bitfields.MOBILE_PLATFORM_SEL = mobile_platform_sel
#define set_BUS_CNTL1_send_sba_latency(reg, send_sba_latency) (reg)->bitfields.SEND_SBA_LATENCY = send_sba_latency
#define set_BUS_CNTL1_agpclk_valid(reg, agpclk_valid) (reg)->bitfields.AGPCLK_VALID = agpclk_valid

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CONFIG_CNTL regCONFIG_CNTL;

#ifdef DEBUG
__inline void set_CONFIG_CNTL_aper_reg_endian(regCONFIG_CNTL *reg, unsigned int aper_reg_endian)
{
  reg->bitfields.APER_REG_ENDIAN = aper_reg_endian;
  if (reg->bitfields.APER_REG_ENDIAN != aper_reg_endian) HSLDPF(E_ERROR_MESSAGE,"CONFIG_CNTL::APER_REG_ENDIAN data too large\n");
}
__inline void set_CONFIG_CNTL_cfg_vga_ram_en(regCONFIG_CNTL *reg, unsigned int cfg_vga_ram_en)
{
  reg->bitfields.CFG_VGA_RAM_EN = cfg_vga_ram_en;
  if (reg->bitfields.CFG_VGA_RAM_EN != cfg_vga_ram_en) HSLDPF(E_ERROR_MESSAGE,"CONFIG_CNTL::CFG_VGA_RAM_EN data too large\n");
}
__inline void set_CONFIG_CNTL_cfg_vga_io_dis(regCONFIG_CNTL *reg, unsigned int cfg_vga_io_dis)
{
  reg->bitfields.CFG_VGA_IO_DIS = cfg_vga_io_dis;
  if (reg->bitfields.CFG_VGA_IO_DIS != cfg_vga_io_dis) HSLDPF(E_ERROR_MESSAGE,"CONFIG_CNTL::CFG_VGA_IO_DIS data too large\n");
}
__inline void set_CONFIG_CNTL_cfg_ati_rev_id(regCONFIG_CNTL *reg, unsigned int cfg_ati_rev_id)
{
  reg->bitfields.CFG_ATI_REV_ID = cfg_ati_rev_id;
  if (reg->bitfields.CFG_ATI_REV_ID != cfg_ati_rev_id) HSLDPF(E_ERROR_MESSAGE,"CONFIG_CNTL::CFG_ATI_REV_ID data too large\n");
}
#else
#define set_CONFIG_CNTL_aper_reg_endian(reg, aper_reg_endian) (reg)->bitfields.APER_REG_ENDIAN = aper_reg_endian
#define set_CONFIG_CNTL_cfg_vga_ram_en(reg, cfg_vga_ram_en) (reg)->bitfields.CFG_VGA_RAM_EN = cfg_vga_ram_en
#define set_CONFIG_CNTL_cfg_vga_io_dis(reg, cfg_vga_io_dis) (reg)->bitfields.CFG_VGA_IO_DIS = cfg_vga_io_dis
#define set_CONFIG_CNTL_cfg_ati_rev_id(reg, cfg_ati_rev_id) (reg)->bitfields.CFG_ATI_REV_ID = cfg_ati_rev_id

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CONFIG_MEMSIZE regCONFIG_MEMSIZE;

#ifdef DEBUG
__inline void set_CONFIG_MEMSIZE_config_memsize(regCONFIG_MEMSIZE *reg, unsigned int config_memsize)
{
  reg->bitfields.CONFIG_MEMSIZE = config_memsize;
  if (reg->bitfields.CONFIG_MEMSIZE != config_memsize) HSLDPF(E_ERROR_MESSAGE,"CONFIG_MEMSIZE::CONFIG_MEMSIZE data too large\n");
}
#else
#define set_CONFIG_MEMSIZE_config_memsize(reg, config_memsize) (reg)->bitfields.CONFIG_MEMSIZE = config_memsize

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CONFIG_APER_0_BASE regCONFIG_APER_0_BASE;

#ifdef DEBUG
__inline void set_CONFIG_APER_0_BASE_aper_0_base(regCONFIG_APER_0_BASE *reg, unsigned int aper_0_base)
{
  reg->bitfields.APER_0_BASE = aper_0_base;
  if (reg->bitfields.APER_0_BASE != aper_0_base) HSLDPF(E_ERROR_MESSAGE,"CONFIG_APER_0_BASE::APER_0_BASE data too large\n");
}
#else
#define set_CONFIG_APER_0_BASE_aper_0_base(reg, aper_0_base) (reg)->bitfields.APER_0_BASE = aper_0_base

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CONFIG_APER_1_BASE regCONFIG_APER_1_BASE;

#ifdef DEBUG
__inline void set_CONFIG_APER_1_BASE_aper_1_base(regCONFIG_APER_1_BASE *reg, unsigned int aper_1_base)
{
  reg->bitfields.APER_1_BASE = aper_1_base;
  if (reg->bitfields.APER_1_BASE != aper_1_base) HSLDPF(E_ERROR_MESSAGE,"CONFIG_APER_1_BASE::APER_1_BASE data too large\n");
}
#else
#define set_CONFIG_APER_1_BASE_aper_1_base(reg, aper_1_base) (reg)->bitfields.APER_1_BASE = aper_1_base

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CONFIG_APER_SIZE regCONFIG_APER_SIZE;

#ifdef DEBUG
__inline void set_CONFIG_APER_SIZE_aper_size(regCONFIG_APER_SIZE *reg, unsigned int aper_size)
{
  reg->bitfields.APER_SIZE = aper_size;
  if (reg->bitfields.APER_SIZE != aper_size) HSLDPF(E_ERROR_MESSAGE,"CONFIG_APER_SIZE::APER_SIZE data too large\n");
}
#else
#define set_CONFIG_APER_SIZE_aper_size(reg, aper_size) (reg)->bitfields.APER_SIZE = aper_size

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CONFIG_REG_1_BASE regCONFIG_REG_1_BASE;

#ifdef DEBUG
__inline void set_CONFIG_REG_1_BASE_reg_aper_1_select(regCONFIG_REG_1_BASE *reg, unsigned int reg_aper_1_select)
{
  reg->bitfields.REG_APER_1_SELECT = reg_aper_1_select;
  if (reg->bitfields.REG_APER_1_SELECT != reg_aper_1_select) HSLDPF(E_ERROR_MESSAGE,"CONFIG_REG_1_BASE::REG_APER_1_SELECT data too large\n");
}
__inline void set_CONFIG_REG_1_BASE_reg_1_base(regCONFIG_REG_1_BASE *reg, unsigned int reg_1_base)
{
  reg->bitfields.REG_1_BASE = reg_1_base;
  if (reg->bitfields.REG_1_BASE != reg_1_base) HSLDPF(E_ERROR_MESSAGE,"CONFIG_REG_1_BASE::REG_1_BASE data too large\n");
}
#else
#define set_CONFIG_REG_1_BASE_reg_aper_1_select(reg, reg_aper_1_select) (reg)->bitfields.REG_APER_1_SELECT = reg_aper_1_select
#define set_CONFIG_REG_1_BASE_reg_1_base(reg, reg_1_base) (reg)->bitfields.REG_1_BASE = reg_1_base

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CONFIG_REG_APER_SIZE regCONFIG_REG_APER_SIZE;

#ifdef DEBUG
__inline void set_CONFIG_REG_APER_SIZE_reg_aper_size(regCONFIG_REG_APER_SIZE *reg, unsigned int reg_aper_size)
{
  reg->bitfields.REG_APER_SIZE = reg_aper_size;
  if (reg->bitfields.REG_APER_SIZE != reg_aper_size) HSLDPF(E_ERROR_MESSAGE,"CONFIG_REG_APER_SIZE::REG_APER_SIZE data too large\n");
}
#else
#define set_CONFIG_REG_APER_SIZE_reg_aper_size(reg, reg_aper_size) (reg)->bitfields.REG_APER_SIZE = reg_aper_size

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PAD_AGPINPUT_DELAY regPAD_AGPINPUT_DELAY;

#ifdef DEBUG
__inline void set_PAD_AGPINPUT_DELAY_pad_agpinput_delay(regPAD_AGPINPUT_DELAY *reg, unsigned int pad_agpinput_delay)
{
  reg->bitfields.PAD_AGPINPUT_DELAY = pad_agpinput_delay;
  if (reg->bitfields.PAD_AGPINPUT_DELAY != pad_agpinput_delay) HSLDPF(E_ERROR_MESSAGE,"PAD_AGPINPUT_DELAY::PAD_AGPINPUT_DELAY data too large\n");
}
#else
#define set_PAD_AGPINPUT_DELAY_pad_agpinput_delay(reg, pad_agpinput_delay) (reg)->bitfields.PAD_AGPINPUT_DELAY = pad_agpinput_delay

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PAD_CTLR_STRENGTH regPAD_CTLR_STRENGTH;

#ifdef DEBUG
__inline void set_PAD_CTLR_STRENGTH_pad_n_strength_read_back(regPAD_CTLR_STRENGTH *reg, unsigned int pad_n_strength_read_back)
{
  reg->bitfields.PAD_N_STRENGTH_READ_BACK = pad_n_strength_read_back;
  if (reg->bitfields.PAD_N_STRENGTH_READ_BACK != pad_n_strength_read_back) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_STRENGTH::PAD_N_STRENGTH_READ_BACK data too large\n");
}
__inline void set_PAD_CTLR_STRENGTH_pad_p_strength_read_back(regPAD_CTLR_STRENGTH *reg, unsigned int pad_p_strength_read_back)
{
  reg->bitfields.PAD_P_STRENGTH_READ_BACK = pad_p_strength_read_back;
  if (reg->bitfields.PAD_P_STRENGTH_READ_BACK != pad_p_strength_read_back) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_STRENGTH::PAD_P_STRENGTH_READ_BACK data too large\n");
}
__inline void set_PAD_CTLR_STRENGTH_pad_n_manual_strength(regPAD_CTLR_STRENGTH *reg, unsigned int pad_n_manual_strength)
{
  reg->bitfields.PAD_N_MANUAL_STRENGTH = pad_n_manual_strength;
  if (reg->bitfields.PAD_N_MANUAL_STRENGTH != pad_n_manual_strength) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_STRENGTH::PAD_N_MANUAL_STRENGTH data too large\n");
}
__inline void set_PAD_CTLR_STRENGTH_pad_p_manual_strength(regPAD_CTLR_STRENGTH *reg, unsigned int pad_p_manual_strength)
{
  reg->bitfields.PAD_P_MANUAL_STRENGTH = pad_p_manual_strength;
  if (reg->bitfields.PAD_P_MANUAL_STRENGTH != pad_p_manual_strength) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_STRENGTH::PAD_P_MANUAL_STRENGTH data too large\n");
}
__inline void set_PAD_CTLR_STRENGTH_pad_manual_override(regPAD_CTLR_STRENGTH *reg, unsigned int pad_manual_override)
{
  reg->bitfields.PAD_MANUAL_OVERRIDE = pad_manual_override;
  if (reg->bitfields.PAD_MANUAL_OVERRIDE != pad_manual_override) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_STRENGTH::PAD_MANUAL_OVERRIDE data too large\n");
}
__inline void set_PAD_CTLR_STRENGTH_pad_test_out(regPAD_CTLR_STRENGTH *reg, unsigned int pad_test_out)
{
  reg->bitfields.PAD_TEST_OUT = pad_test_out;
  if (reg->bitfields.PAD_TEST_OUT != pad_test_out) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_STRENGTH::PAD_TEST_OUT data too large\n");
}
__inline void set_PAD_CTLR_STRENGTH_pad_dummy_out(regPAD_CTLR_STRENGTH *reg, unsigned int pad_dummy_out)
{
  reg->bitfields.PAD_DUMMY_OUT = pad_dummy_out;
  if (reg->bitfields.PAD_DUMMY_OUT != pad_dummy_out) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_STRENGTH::PAD_DUMMY_OUT data too large\n");
}
__inline void set_PAD_CTLR_STRENGTH_pad_hi_io_dfr(regPAD_CTLR_STRENGTH *reg, unsigned int pad_hi_io_dfr)
{
  reg->bitfields.PAD_HI_IO_DFR = pad_hi_io_dfr;
  if (reg->bitfields.PAD_HI_IO_DFR != pad_hi_io_dfr) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_STRENGTH::PAD_HI_IO_DFR data too large\n");
}
__inline void set_PAD_CTLR_STRENGTH_pad_hi_io_schmen(regPAD_CTLR_STRENGTH *reg, unsigned int pad_hi_io_schmen)
{
  reg->bitfields.PAD_HI_IO_SCHMEN = pad_hi_io_schmen;
  if (reg->bitfields.PAD_HI_IO_SCHMEN != pad_hi_io_schmen) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_STRENGTH::PAD_HI_IO_SCHMEN data too large\n");
}
__inline void set_PAD_CTLR_STRENGTH_pad_hi_io_dren(regPAD_CTLR_STRENGTH *reg, unsigned int pad_hi_io_dren)
{
  reg->bitfields.PAD_HI_IO_DREN = pad_hi_io_dren;
  if (reg->bitfields.PAD_HI_IO_DREN != pad_hi_io_dren) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_STRENGTH::PAD_HI_IO_DREN data too large\n");
}
__inline void set_PAD_CTLR_STRENGTH_pad_hi_io_vdiff(regPAD_CTLR_STRENGTH *reg, unsigned int pad_hi_io_vdiff)
{
  reg->bitfields.PAD_HI_IO_VDIFF = pad_hi_io_vdiff;
  if (reg->bitfields.PAD_HI_IO_VDIFF != pad_hi_io_vdiff) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_STRENGTH::PAD_HI_IO_VDIFF data too large\n");
}
__inline void set_PAD_CTLR_STRENGTH_pad_hi_io_dfr_override(regPAD_CTLR_STRENGTH *reg, unsigned int pad_hi_io_dfr_override)
{
  reg->bitfields.PAD_HI_IO_DFR_OVERRIDE = pad_hi_io_dfr_override;
  if (reg->bitfields.PAD_HI_IO_DFR_OVERRIDE != pad_hi_io_dfr_override) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_STRENGTH::PAD_HI_IO_DFR_OVERRIDE data too large\n");
}
__inline void set_PAD_CTLR_STRENGTH_pad_hi_io_schmen_override(regPAD_CTLR_STRENGTH *reg, unsigned int pad_hi_io_schmen_override)
{
  reg->bitfields.PAD_HI_IO_SCHMEN_OVERRIDE = pad_hi_io_schmen_override;
  if (reg->bitfields.PAD_HI_IO_SCHMEN_OVERRIDE != pad_hi_io_schmen_override) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_STRENGTH::PAD_HI_IO_SCHMEN_OVERRIDE data too large\n");
}
__inline void set_PAD_CTLR_STRENGTH_pad_hi_io_dren_override(regPAD_CTLR_STRENGTH *reg, unsigned int pad_hi_io_dren_override)
{
  reg->bitfields.PAD_HI_IO_DREN_OVERRIDE = pad_hi_io_dren_override;
  if (reg->bitfields.PAD_HI_IO_DREN_OVERRIDE != pad_hi_io_dren_override) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_STRENGTH::PAD_HI_IO_DREN_OVERRIDE data too large\n");
}
__inline void set_PAD_CTLR_STRENGTH_pad_hi_io_vdiff_override(regPAD_CTLR_STRENGTH *reg, unsigned int pad_hi_io_vdiff_override)
{
  reg->bitfields.PAD_HI_IO_VDIFF_OVERRIDE = pad_hi_io_vdiff_override;
  if (reg->bitfields.PAD_HI_IO_VDIFF_OVERRIDE != pad_hi_io_vdiff_override) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_STRENGTH::PAD_HI_IO_VDIFF_OVERRIDE data too large\n");
}
__inline void set_PAD_CTLR_STRENGTH_pad_hi_io_slewn(regPAD_CTLR_STRENGTH *reg, unsigned int pad_hi_io_slewn)
{
  reg->bitfields.PAD_HI_IO_SLEWN = pad_hi_io_slewn;
  if (reg->bitfields.PAD_HI_IO_SLEWN != pad_hi_io_slewn) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_STRENGTH::PAD_HI_IO_SLEWN data too large\n");
}
__inline void set_PAD_CTLR_STRENGTH_pad_hi_io_slewp(regPAD_CTLR_STRENGTH *reg, unsigned int pad_hi_io_slewp)
{
  reg->bitfields.PAD_HI_IO_SLEWP = pad_hi_io_slewp;
  if (reg->bitfields.PAD_HI_IO_SLEWP != pad_hi_io_slewp) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_STRENGTH::PAD_HI_IO_SLEWP data too large\n");
}
__inline void set_PAD_CTLR_STRENGTH_pad_hi_io_slew_override(regPAD_CTLR_STRENGTH *reg, unsigned int pad_hi_io_slew_override)
{
  reg->bitfields.PAD_HI_IO_SLEW_OVERRIDE = pad_hi_io_slew_override;
  if (reg->bitfields.PAD_HI_IO_SLEW_OVERRIDE != pad_hi_io_slew_override) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_STRENGTH::PAD_HI_IO_SLEW_OVERRIDE data too large\n");
}
#else
#define set_PAD_CTLR_STRENGTH_pad_n_strength_read_back(reg, pad_n_strength_read_back) (reg)->bitfields.PAD_N_STRENGTH_READ_BACK = pad_n_strength_read_back
#define set_PAD_CTLR_STRENGTH_pad_p_strength_read_back(reg, pad_p_strength_read_back) (reg)->bitfields.PAD_P_STRENGTH_READ_BACK = pad_p_strength_read_back
#define set_PAD_CTLR_STRENGTH_pad_n_manual_strength(reg, pad_n_manual_strength) (reg)->bitfields.PAD_N_MANUAL_STRENGTH = pad_n_manual_strength
#define set_PAD_CTLR_STRENGTH_pad_p_manual_strength(reg, pad_p_manual_strength) (reg)->bitfields.PAD_P_MANUAL_STRENGTH = pad_p_manual_strength
#define set_PAD_CTLR_STRENGTH_pad_manual_override(reg, pad_manual_override) (reg)->bitfields.PAD_MANUAL_OVERRIDE = pad_manual_override
#define set_PAD_CTLR_STRENGTH_pad_test_out(reg, pad_test_out) (reg)->bitfields.PAD_TEST_OUT = pad_test_out
#define set_PAD_CTLR_STRENGTH_pad_dummy_out(reg, pad_dummy_out) (reg)->bitfields.PAD_DUMMY_OUT = pad_dummy_out
#define set_PAD_CTLR_STRENGTH_pad_hi_io_dfr(reg, pad_hi_io_dfr) (reg)->bitfields.PAD_HI_IO_DFR = pad_hi_io_dfr
#define set_PAD_CTLR_STRENGTH_pad_hi_io_schmen(reg, pad_hi_io_schmen) (reg)->bitfields.PAD_HI_IO_SCHMEN = pad_hi_io_schmen
#define set_PAD_CTLR_STRENGTH_pad_hi_io_dren(reg, pad_hi_io_dren) (reg)->bitfields.PAD_HI_IO_DREN = pad_hi_io_dren
#define set_PAD_CTLR_STRENGTH_pad_hi_io_vdiff(reg, pad_hi_io_vdiff) (reg)->bitfields.PAD_HI_IO_VDIFF = pad_hi_io_vdiff
#define set_PAD_CTLR_STRENGTH_pad_hi_io_dfr_override(reg, pad_hi_io_dfr_override) (reg)->bitfields.PAD_HI_IO_DFR_OVERRIDE = pad_hi_io_dfr_override
#define set_PAD_CTLR_STRENGTH_pad_hi_io_schmen_override(reg, pad_hi_io_schmen_override) (reg)->bitfields.PAD_HI_IO_SCHMEN_OVERRIDE = pad_hi_io_schmen_override
#define set_PAD_CTLR_STRENGTH_pad_hi_io_dren_override(reg, pad_hi_io_dren_override) (reg)->bitfields.PAD_HI_IO_DREN_OVERRIDE = pad_hi_io_dren_override
#define set_PAD_CTLR_STRENGTH_pad_hi_io_vdiff_override(reg, pad_hi_io_vdiff_override) (reg)->bitfields.PAD_HI_IO_VDIFF_OVERRIDE = pad_hi_io_vdiff_override
#define set_PAD_CTLR_STRENGTH_pad_hi_io_slewn(reg, pad_hi_io_slewn) (reg)->bitfields.PAD_HI_IO_SLEWN = pad_hi_io_slewn
#define set_PAD_CTLR_STRENGTH_pad_hi_io_slewp(reg, pad_hi_io_slewp) (reg)->bitfields.PAD_HI_IO_SLEWP = pad_hi_io_slewp
#define set_PAD_CTLR_STRENGTH_pad_hi_io_slew_override(reg, pad_hi_io_slew_override) (reg)->bitfields.PAD_HI_IO_SLEW_OVERRIDE = pad_hi_io_slew_override

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PAD_CTLR_UPDATE regPAD_CTLR_UPDATE;

#ifdef DEBUG
__inline void set_PAD_CTLR_UPDATE_pad_update_rate(regPAD_CTLR_UPDATE *reg, unsigned int pad_update_rate)
{
  reg->bitfields.PAD_UPDATE_RATE = pad_update_rate;
  if (reg->bitfields.PAD_UPDATE_RATE != pad_update_rate) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_UPDATE::PAD_UPDATE_RATE data too large\n");
}
__inline void set_PAD_CTLR_UPDATE_pad_sample_delay(regPAD_CTLR_UPDATE *reg, unsigned int pad_sample_delay)
{
  reg->bitfields.PAD_SAMPLE_DELAY = pad_sample_delay;
  if (reg->bitfields.PAD_SAMPLE_DELAY != pad_sample_delay) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_UPDATE::PAD_SAMPLE_DELAY data too large\n");
}
__inline void set_PAD_CTLR_UPDATE_pad_inc_threshold(regPAD_CTLR_UPDATE *reg, unsigned int pad_inc_threshold)
{
  reg->bitfields.PAD_INC_THRESHOLD = pad_inc_threshold;
  if (reg->bitfields.PAD_INC_THRESHOLD != pad_inc_threshold) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_UPDATE::PAD_INC_THRESHOLD data too large\n");
}
__inline void set_PAD_CTLR_UPDATE_pad_dec_threshold(regPAD_CTLR_UPDATE *reg, unsigned int pad_dec_threshold)
{
  reg->bitfields.PAD_DEC_THRESHOLD = pad_dec_threshold;
  if (reg->bitfields.PAD_DEC_THRESHOLD != pad_dec_threshold) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_UPDATE::PAD_DEC_THRESHOLD data too large\n");
}
#else
#define set_PAD_CTLR_UPDATE_pad_update_rate(reg, pad_update_rate) (reg)->bitfields.PAD_UPDATE_RATE = pad_update_rate
#define set_PAD_CTLR_UPDATE_pad_sample_delay(reg, pad_sample_delay) (reg)->bitfields.PAD_SAMPLE_DELAY = pad_sample_delay
#define set_PAD_CTLR_UPDATE_pad_inc_threshold(reg, pad_inc_threshold) (reg)->bitfields.PAD_INC_THRESHOLD = pad_inc_threshold
#define set_PAD_CTLR_UPDATE_pad_dec_threshold(reg, pad_dec_threshold) (reg)->bitfields.PAD_DEC_THRESHOLD = pad_dec_threshold

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union FW_CNTL regFW_CNTL;

#ifdef DEBUG
__inline void set_FW_CNTL_wbf_wm_max(regFW_CNTL *reg, unsigned int wbf_wm_max)
{
  reg->bitfields.WBF_WM_MAX = wbf_wm_max;
  if (reg->bitfields.WBF_WM_MAX != wbf_wm_max) HSLDPF(E_ERROR_MESSAGE,"FW_CNTL::WBF_WM_MAX data too large\n");
}
__inline void set_FW_CNTL_wbf_wm_min(regFW_CNTL *reg, unsigned int wbf_wm_min)
{
  reg->bitfields.WBF_WM_MIN = wbf_wm_min;
  if (reg->bitfields.WBF_WM_MIN != wbf_wm_min) HSLDPF(E_ERROR_MESSAGE,"FW_CNTL::WBF_WM_MIN data too large\n");
}
__inline void set_FW_CNTL_disconnect_w_data_stoptrdy_min(regFW_CNTL *reg, unsigned int disconnect_w_data_stoptrdy_min)
{
  reg->bitfields.DISCONNECT_W_DATA_STOPTRDY_MIN = disconnect_w_data_stoptrdy_min;
  if (reg->bitfields.DISCONNECT_W_DATA_STOPTRDY_MIN != disconnect_w_data_stoptrdy_min) HSLDPF(E_ERROR_MESSAGE,"FW_CNTL::DISCONNECT_W_DATA_STOPTRDY_MIN data too large\n");
}
__inline void set_FW_CNTL_disconnect_wo_data_stoptrdy_min(regFW_CNTL *reg, unsigned int disconnect_wo_data_stoptrdy_min)
{
  reg->bitfields.DISCONNECT_WO_DATA_STOPTRDY_MIN = disconnect_wo_data_stoptrdy_min;
  if (reg->bitfields.DISCONNECT_WO_DATA_STOPTRDY_MIN != disconnect_wo_data_stoptrdy_min) HSLDPF(E_ERROR_MESSAGE,"FW_CNTL::DISCONNECT_WO_DATA_STOPTRDY_MIN data too large\n");
}
__inline void set_FW_CNTL_hold_fw_fifo(regFW_CNTL *reg, unsigned int hold_fw_fifo)
{
  reg->bitfields.HOLD_FW_FIFO = hold_fw_fifo;
  if (reg->bitfields.HOLD_FW_FIFO != hold_fw_fifo) HSLDPF(E_ERROR_MESSAGE,"FW_CNTL::HOLD_FW_FIFO data too large\n");
}
__inline void set_FW_CNTL_force_fw_wbf(regFW_CNTL *reg, unsigned int force_fw_wbf)
{
  reg->bitfields.FORCE_FW_WBF = force_fw_wbf;
  if (reg->bitfields.FORCE_FW_WBF != force_fw_wbf) HSLDPF(E_ERROR_MESSAGE,"FW_CNTL::FORCE_FW_WBF data too large\n");
}
__inline void set_FW_CNTL_dis_fw_wbf(regFW_CNTL *reg, unsigned int dis_fw_wbf)
{
  reg->bitfields.DIS_FW_WBF = dis_fw_wbf;
  if (reg->bitfields.DIS_FW_WBF != dis_fw_wbf) HSLDPF(E_ERROR_MESSAGE,"FW_CNTL::DIS_FW_WBF data too large\n");
}
__inline void set_FW_CNTL_disconnect_mode(regFW_CNTL *reg, unsigned int disconnect_mode)
{
  reg->bitfields.DISCONNECT_MODE = disconnect_mode;
  if (reg->bitfields.DISCONNECT_MODE != disconnect_mode) HSLDPF(E_ERROR_MESSAGE,"FW_CNTL::DISCONNECT_MODE data too large\n");
}
__inline void set_FW_CNTL_dis_wbf_wait_for_frame(regFW_CNTL *reg, unsigned int dis_wbf_wait_for_frame)
{
  reg->bitfields.DIS_WBF_WAIT_FOR_FRAME = dis_wbf_wait_for_frame;
  if (reg->bitfields.DIS_WBF_WAIT_FOR_FRAME != dis_wbf_wait_for_frame) HSLDPF(E_ERROR_MESSAGE,"FW_CNTL::DIS_WBF_WAIT_FOR_FRAME data too large\n");
}
__inline void set_FW_CNTL_en_trdy_wait_for_fifoavl(regFW_CNTL *reg, unsigned int en_trdy_wait_for_fifoavl)
{
  reg->bitfields.EN_TRDY_WAIT_FOR_FIFOAVL = en_trdy_wait_for_fifoavl;
  if (reg->bitfields.EN_TRDY_WAIT_FOR_FIFOAVL != en_trdy_wait_for_fifoavl) HSLDPF(E_ERROR_MESSAGE,"FW_CNTL::EN_TRDY_WAIT_FOR_FIFOAVL data too large\n");
}
__inline void set_FW_CNTL_trdy_ws_count(regFW_CNTL *reg, unsigned int trdy_ws_count)
{
  reg->bitfields.TRDY_WS_COUNT = trdy_ws_count;
  if (reg->bitfields.TRDY_WS_COUNT != trdy_ws_count) HSLDPF(E_ERROR_MESSAGE,"FW_CNTL::TRDY_WS_COUNT data too large\n");
}
__inline void set_FW_CNTL_dis_fw_rotation(regFW_CNTL *reg, unsigned int dis_fw_rotation)
{
  reg->bitfields.DIS_FW_ROTATION = dis_fw_rotation;
  if (reg->bitfields.DIS_FW_ROTATION != dis_fw_rotation) HSLDPF(E_ERROR_MESSAGE,"FW_CNTL::DIS_FW_ROTATION data too large\n");
}
__inline void set_FW_CNTL_force_trdy_1ws(regFW_CNTL *reg, unsigned int force_trdy_1ws)
{
  reg->bitfields.FORCE_TRDY_1WS = force_trdy_1ws;
  if (reg->bitfields.FORCE_TRDY_1WS != force_trdy_1ws) HSLDPF(E_ERROR_MESSAGE,"FW_CNTL::FORCE_TRDY_1WS data too large\n");
}
__inline void set_FW_CNTL_ignore_strap_fw_dis(regFW_CNTL *reg, unsigned int ignore_strap_fw_dis)
{
  reg->bitfields.IGNORE_STRAP_FW_DIS = ignore_strap_fw_dis;
  if (reg->bitfields.IGNORE_STRAP_FW_DIS != ignore_strap_fw_dis) HSLDPF(E_ERROR_MESSAGE,"FW_CNTL::IGNORE_STRAP_FW_DIS data too large\n");
}
__inline void set_FW_CNTL_fw_misc(regFW_CNTL *reg, unsigned int fw_misc)
{
  reg->bitfields.FW_MISC = fw_misc;
  if (reg->bitfields.FW_MISC != fw_misc) HSLDPF(E_ERROR_MESSAGE,"FW_CNTL::FW_MISC data too large\n");
}
#else
#define set_FW_CNTL_wbf_wm_max(reg, wbf_wm_max) (reg)->bitfields.WBF_WM_MAX = wbf_wm_max
#define set_FW_CNTL_wbf_wm_min(reg, wbf_wm_min) (reg)->bitfields.WBF_WM_MIN = wbf_wm_min
#define set_FW_CNTL_disconnect_w_data_stoptrdy_min(reg, disconnect_w_data_stoptrdy_min) (reg)->bitfields.DISCONNECT_W_DATA_STOPTRDY_MIN = disconnect_w_data_stoptrdy_min
#define set_FW_CNTL_disconnect_wo_data_stoptrdy_min(reg, disconnect_wo_data_stoptrdy_min) (reg)->bitfields.DISCONNECT_WO_DATA_STOPTRDY_MIN = disconnect_wo_data_stoptrdy_min
#define set_FW_CNTL_hold_fw_fifo(reg, hold_fw_fifo) (reg)->bitfields.HOLD_FW_FIFO = hold_fw_fifo
#define set_FW_CNTL_force_fw_wbf(reg, force_fw_wbf) (reg)->bitfields.FORCE_FW_WBF = force_fw_wbf
#define set_FW_CNTL_dis_fw_wbf(reg, dis_fw_wbf) (reg)->bitfields.DIS_FW_WBF = dis_fw_wbf
#define set_FW_CNTL_disconnect_mode(reg, disconnect_mode) (reg)->bitfields.DISCONNECT_MODE = disconnect_mode
#define set_FW_CNTL_dis_wbf_wait_for_frame(reg, dis_wbf_wait_for_frame) (reg)->bitfields.DIS_WBF_WAIT_FOR_FRAME = dis_wbf_wait_for_frame
#define set_FW_CNTL_en_trdy_wait_for_fifoavl(reg, en_trdy_wait_for_fifoavl) (reg)->bitfields.EN_TRDY_WAIT_FOR_FIFOAVL = en_trdy_wait_for_fifoavl
#define set_FW_CNTL_trdy_ws_count(reg, trdy_ws_count) (reg)->bitfields.TRDY_WS_COUNT = trdy_ws_count
#define set_FW_CNTL_dis_fw_rotation(reg, dis_fw_rotation) (reg)->bitfields.DIS_FW_ROTATION = dis_fw_rotation
#define set_FW_CNTL_force_trdy_1ws(reg, force_trdy_1ws) (reg)->bitfields.FORCE_TRDY_1WS = force_trdy_1ws
#define set_FW_CNTL_ignore_strap_fw_dis(reg, ignore_strap_fw_dis) (reg)->bitfields.IGNORE_STRAP_FW_DIS = ignore_strap_fw_dis
#define set_FW_CNTL_fw_misc(reg, fw_misc) (reg)->bitfields.FW_MISC = fw_misc

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union FW_STATUS regFW_STATUS;

#ifdef DEBUG
__inline void set_FW_STATUS_fw_idle(regFW_STATUS *reg, unsigned int fw_idle)
{
  reg->bitfields.FW_IDLE = fw_idle;
  if (reg->bitfields.FW_IDLE != fw_idle) HSLDPF(E_ERROR_MESSAGE,"FW_STATUS::FW_IDLE data too large\n");
}
__inline void set_FW_STATUS_stat_fw_clean(regFW_STATUS *reg, unsigned int stat_fw_clean)
{
  reg->bitfields.STAT_FW_CLEAN = stat_fw_clean;
  if (reg->bitfields.STAT_FW_CLEAN != stat_fw_clean) HSLDPF(E_ERROR_MESSAGE,"FW_STATUS::STAT_FW_CLEAN data too large\n");
}
__inline void set_FW_STATUS_fw_wavl(regFW_STATUS *reg, unsigned int fw_wavl)
{
  reg->bitfields.FW_WAVL = fw_wavl;
  if (reg->bitfields.FW_WAVL != fw_wavl) HSLDPF(E_ERROR_MESSAGE,"FW_STATUS::FW_WAVL data too large\n");
}
#else
#define set_FW_STATUS_fw_idle(reg, fw_idle) (reg)->bitfields.FW_IDLE = fw_idle
#define set_FW_STATUS_stat_fw_clean(reg, stat_fw_clean) (reg)->bitfields.STAT_FW_CLEAN = stat_fw_clean
#define set_FW_STATUS_fw_wavl(reg, fw_wavl) (reg)->bitfields.FW_WAVL = fw_wavl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union AGP_CNTL regAGP_CNTL;

#ifdef DEBUG
__inline void set_AGP_CNTL_max_idle_clk(regAGP_CNTL *reg, unsigned int max_idle_clk)
{
  reg->bitfields.MAX_IDLE_CLK = max_idle_clk;
  if (reg->bitfields.MAX_IDLE_CLK != max_idle_clk) HSLDPF(E_ERROR_MESSAGE,"AGP_CNTL::MAX_IDLE_CLK data too large\n");
}
__inline void set_AGP_CNTL_hold_rd_fifo(regAGP_CNTL *reg, unsigned int hold_rd_fifo)
{
  reg->bitfields.HOLD_RD_FIFO = hold_rd_fifo;
  if (reg->bitfields.HOLD_RD_FIFO != hold_rd_fifo) HSLDPF(E_ERROR_MESSAGE,"AGP_CNTL::HOLD_RD_FIFO data too large\n");
}
__inline void set_AGP_CNTL_hold_rq_fifo(regAGP_CNTL *reg, unsigned int hold_rq_fifo)
{
  reg->bitfields.HOLD_RQ_FIFO = hold_rq_fifo;
  if (reg->bitfields.HOLD_RQ_FIFO != hold_rq_fifo) HSLDPF(E_ERROR_MESSAGE,"AGP_CNTL::HOLD_RQ_FIFO data too large\n");
}
__inline void set_AGP_CNTL_en_2x_stbb(regAGP_CNTL *reg, unsigned int en_2x_stbb)
{
  reg->bitfields.EN_2X_STBB = en_2x_stbb;
  if (reg->bitfields.EN_2X_STBB != en_2x_stbb) HSLDPF(E_ERROR_MESSAGE,"AGP_CNTL::EN_2X_STBB data too large\n");
}
__inline void set_AGP_CNTL_force_full_sba(regAGP_CNTL *reg, unsigned int force_full_sba)
{
  reg->bitfields.FORCE_FULL_SBA = force_full_sba;
  if (reg->bitfields.FORCE_FULL_SBA != force_full_sba) HSLDPF(E_ERROR_MESSAGE,"AGP_CNTL::FORCE_FULL_SBA data too large\n");
}
__inline void set_AGP_CNTL_sba_dis(regAGP_CNTL *reg, unsigned int sba_dis)
{
  reg->bitfields.SBA_DIS = sba_dis;
  if (reg->bitfields.SBA_DIS != sba_dis) HSLDPF(E_ERROR_MESSAGE,"AGP_CNTL::SBA_DIS data too large\n");
}
__inline void set_AGP_CNTL_agp_rev_id(regAGP_CNTL *reg, unsigned int agp_rev_id)
{
  reg->bitfields.AGP_REV_ID = agp_rev_id;
  if (reg->bitfields.AGP_REV_ID != agp_rev_id) HSLDPF(E_ERROR_MESSAGE,"AGP_CNTL::AGP_REV_ID data too large\n");
}
__inline void set_AGP_CNTL_reg_cripple_agp4x(regAGP_CNTL *reg, unsigned int reg_cripple_agp4x)
{
  reg->bitfields.REG_CRIPPLE_AGP4X = reg_cripple_agp4x;
  if (reg->bitfields.REG_CRIPPLE_AGP4X != reg_cripple_agp4x) HSLDPF(E_ERROR_MESSAGE,"AGP_CNTL::REG_CRIPPLE_AGP4X data too large\n");
}
__inline void set_AGP_CNTL_reg_cripple_agp2x4x(regAGP_CNTL *reg, unsigned int reg_cripple_agp2x4x)
{
  reg->bitfields.REG_CRIPPLE_AGP2X4X = reg_cripple_agp2x4x;
  if (reg->bitfields.REG_CRIPPLE_AGP2X4X != reg_cripple_agp2x4x) HSLDPF(E_ERROR_MESSAGE,"AGP_CNTL::REG_CRIPPLE_AGP2X4X data too large\n");
}
__inline void set_AGP_CNTL_force_int_vref(regAGP_CNTL *reg, unsigned int force_int_vref)
{
  reg->bitfields.FORCE_INT_VREF = force_int_vref;
  if (reg->bitfields.FORCE_INT_VREF != force_int_vref) HSLDPF(E_ERROR_MESSAGE,"AGP_CNTL::FORCE_INT_VREF data too large\n");
}
__inline void set_AGP_CNTL_pending_slots_val(regAGP_CNTL *reg, unsigned int pending_slots_val)
{
  reg->bitfields.PENDING_SLOTS_VAL = pending_slots_val;
  if (reg->bitfields.PENDING_SLOTS_VAL != pending_slots_val) HSLDPF(E_ERROR_MESSAGE,"AGP_CNTL::PENDING_SLOTS_VAL data too large\n");
}
__inline void set_AGP_CNTL_pending_slots_sel(regAGP_CNTL *reg, unsigned int pending_slots_sel)
{
  reg->bitfields.PENDING_SLOTS_SEL = pending_slots_sel;
  if (reg->bitfields.PENDING_SLOTS_SEL != pending_slots_sel) HSLDPF(E_ERROR_MESSAGE,"AGP_CNTL::PENDING_SLOTS_SEL data too large\n");
}
__inline void set_AGP_CNTL_en_extended_ad_stb_2x(regAGP_CNTL *reg, unsigned int en_extended_ad_stb_2x)
{
  reg->bitfields.EN_EXTENDED_AD_STB_2X = en_extended_ad_stb_2x;
  if (reg->bitfields.EN_EXTENDED_AD_STB_2X != en_extended_ad_stb_2x) HSLDPF(E_ERROR_MESSAGE,"AGP_CNTL::EN_EXTENDED_AD_STB_2X data too large\n");
}
__inline void set_AGP_CNTL_dis_queued_gnt_fix(regAGP_CNTL *reg, unsigned int dis_queued_gnt_fix)
{
  reg->bitfields.DIS_QUEUED_GNT_FIX = dis_queued_gnt_fix;
  if (reg->bitfields.DIS_QUEUED_GNT_FIX != dis_queued_gnt_fix) HSLDPF(E_ERROR_MESSAGE,"AGP_CNTL::DIS_QUEUED_GNT_FIX data too large\n");
}
__inline void set_AGP_CNTL_en_rdata2x4x_multireset(regAGP_CNTL *reg, unsigned int en_rdata2x4x_multireset)
{
  reg->bitfields.EN_RDATA2X4X_MULTIRESET = en_rdata2x4x_multireset;
  if (reg->bitfields.EN_RDATA2X4X_MULTIRESET != en_rdata2x4x_multireset) HSLDPF(E_ERROR_MESSAGE,"AGP_CNTL::EN_RDATA2X4X_MULTIRESET data too large\n");
}
__inline void set_AGP_CNTL_en_rbfcalm(regAGP_CNTL *reg, unsigned int en_rbfcalm)
{
  reg->bitfields.EN_RBFCALM = en_rbfcalm;
  if (reg->bitfields.EN_RBFCALM != en_rbfcalm) HSLDPF(E_ERROR_MESSAGE,"AGP_CNTL::EN_RBFCALM data too large\n");
}
__inline void set_AGP_CNTL_force_ext_vref(regAGP_CNTL *reg, unsigned int force_ext_vref)
{
  reg->bitfields.FORCE_EXT_VREF = force_ext_vref;
  if (reg->bitfields.FORCE_EXT_VREF != force_ext_vref) HSLDPF(E_ERROR_MESSAGE,"AGP_CNTL::FORCE_EXT_VREF data too large\n");
}
__inline void set_AGP_CNTL_dis_rbf(regAGP_CNTL *reg, unsigned int dis_rbf)
{
  reg->bitfields.DIS_RBF = dis_rbf;
  if (reg->bitfields.DIS_RBF != dis_rbf) HSLDPF(E_ERROR_MESSAGE,"AGP_CNTL::DIS_RBF data too large\n");
}
__inline void set_AGP_CNTL_delay_first_sba_en(regAGP_CNTL *reg, unsigned int delay_first_sba_en)
{
  reg->bitfields.DELAY_FIRST_SBA_EN = delay_first_sba_en;
  if (reg->bitfields.DELAY_FIRST_SBA_EN != delay_first_sba_en) HSLDPF(E_ERROR_MESSAGE,"AGP_CNTL::DELAY_FIRST_SBA_EN data too large\n");
}
__inline void set_AGP_CNTL_delay_first_sba_val(regAGP_CNTL *reg, unsigned int delay_first_sba_val)
{
  reg->bitfields.DELAY_FIRST_SBA_VAL = delay_first_sba_val;
  if (reg->bitfields.DELAY_FIRST_SBA_VAL != delay_first_sba_val) HSLDPF(E_ERROR_MESSAGE,"AGP_CNTL::DELAY_FIRST_SBA_VAL data too large\n");
}
__inline void set_AGP_CNTL_agp_misc(regAGP_CNTL *reg, unsigned int agp_misc)
{
  reg->bitfields.AGP_MISC = agp_misc;
  if (reg->bitfields.AGP_MISC != agp_misc) HSLDPF(E_ERROR_MESSAGE,"AGP_CNTL::AGP_MISC data too large\n");
}
#else
#define set_AGP_CNTL_max_idle_clk(reg, max_idle_clk) (reg)->bitfields.MAX_IDLE_CLK = max_idle_clk
#define set_AGP_CNTL_hold_rd_fifo(reg, hold_rd_fifo) (reg)->bitfields.HOLD_RD_FIFO = hold_rd_fifo
#define set_AGP_CNTL_hold_rq_fifo(reg, hold_rq_fifo) (reg)->bitfields.HOLD_RQ_FIFO = hold_rq_fifo
#define set_AGP_CNTL_en_2x_stbb(reg, en_2x_stbb) (reg)->bitfields.EN_2X_STBB = en_2x_stbb
#define set_AGP_CNTL_force_full_sba(reg, force_full_sba) (reg)->bitfields.FORCE_FULL_SBA = force_full_sba
#define set_AGP_CNTL_sba_dis(reg, sba_dis) (reg)->bitfields.SBA_DIS = sba_dis
#define set_AGP_CNTL_agp_rev_id(reg, agp_rev_id) (reg)->bitfields.AGP_REV_ID = agp_rev_id
#define set_AGP_CNTL_reg_cripple_agp4x(reg, reg_cripple_agp4x) (reg)->bitfields.REG_CRIPPLE_AGP4X = reg_cripple_agp4x
#define set_AGP_CNTL_reg_cripple_agp2x4x(reg, reg_cripple_agp2x4x) (reg)->bitfields.REG_CRIPPLE_AGP2X4X = reg_cripple_agp2x4x
#define set_AGP_CNTL_force_int_vref(reg, force_int_vref) (reg)->bitfields.FORCE_INT_VREF = force_int_vref
#define set_AGP_CNTL_pending_slots_val(reg, pending_slots_val) (reg)->bitfields.PENDING_SLOTS_VAL = pending_slots_val
#define set_AGP_CNTL_pending_slots_sel(reg, pending_slots_sel) (reg)->bitfields.PENDING_SLOTS_SEL = pending_slots_sel
#define set_AGP_CNTL_en_extended_ad_stb_2x(reg, en_extended_ad_stb_2x) (reg)->bitfields.EN_EXTENDED_AD_STB_2X = en_extended_ad_stb_2x
#define set_AGP_CNTL_dis_queued_gnt_fix(reg, dis_queued_gnt_fix) (reg)->bitfields.DIS_QUEUED_GNT_FIX = dis_queued_gnt_fix
#define set_AGP_CNTL_en_rdata2x4x_multireset(reg, en_rdata2x4x_multireset) (reg)->bitfields.EN_RDATA2X4X_MULTIRESET = en_rdata2x4x_multireset
#define set_AGP_CNTL_en_rbfcalm(reg, en_rbfcalm) (reg)->bitfields.EN_RBFCALM = en_rbfcalm
#define set_AGP_CNTL_force_ext_vref(reg, force_ext_vref) (reg)->bitfields.FORCE_EXT_VREF = force_ext_vref
#define set_AGP_CNTL_dis_rbf(reg, dis_rbf) (reg)->bitfields.DIS_RBF = dis_rbf
#define set_AGP_CNTL_delay_first_sba_en(reg, delay_first_sba_en) (reg)->bitfields.DELAY_FIRST_SBA_EN = delay_first_sba_en
#define set_AGP_CNTL_delay_first_sba_val(reg, delay_first_sba_val) (reg)->bitfields.DELAY_FIRST_SBA_VAL = delay_first_sba_val
#define set_AGP_CNTL_agp_misc(reg, agp_misc) (reg)->bitfields.AGP_MISC = agp_misc

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BM_STATUS regBM_STATUS;

#ifdef DEBUG
__inline void set_BM_STATUS_bus_master_status(regBM_STATUS *reg, unsigned int bus_master_status)
{
  reg->bitfields.BUS_MASTER_STATUS = bus_master_status;
  if (reg->bitfields.BUS_MASTER_STATUS != bus_master_status) HSLDPF(E_ERROR_MESSAGE,"BM_STATUS::BUS_MASTER_STATUS data too large\n");
}
#else
#define set_BM_STATUS_bus_master_status(reg, bus_master_status) (reg)->bitfields.BUS_MASTER_STATUS = bus_master_status

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PAD_CTLR_MISC regPAD_CTLR_MISC;

#ifdef DEBUG
__inline void set_PAD_CTLR_MISC_pad_hi_io_preamph(regPAD_CTLR_MISC *reg, unsigned int pad_hi_io_preamph)
{
  reg->bitfields.PAD_HI_IO_PREAMPH = pad_hi_io_preamph;
  if (reg->bitfields.PAD_HI_IO_PREAMPH != pad_hi_io_preamph) HSLDPF(E_ERROR_MESSAGE,"PAD_CTLR_MISC::PAD_HI_IO_PREAMPH data too large\n");
}
#else
#define set_PAD_CTLR_MISC_pad_hi_io_preamph(reg, pad_hi_io_preamph) (reg)->bitfields.PAD_HI_IO_PREAMPH = pad_hi_io_preamph

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VENDOR_ID regVENDOR_ID;

#ifdef DEBUG
__inline void set_VENDOR_ID_vendor_id(regVENDOR_ID *reg, unsigned int vendor_id)
{
  reg->bitfields.VENDOR_ID = vendor_id;
  if (reg->bitfields.VENDOR_ID != vendor_id) HSLDPF(E_ERROR_MESSAGE,"VENDOR_ID::VENDOR_ID data too large\n");
}
#else
#define set_VENDOR_ID_vendor_id(reg, vendor_id) (reg)->bitfields.VENDOR_ID = vendor_id

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DEVICE_ID regDEVICE_ID;

#ifdef DEBUG
__inline void set_DEVICE_ID_device_id(regDEVICE_ID *reg, unsigned int device_id)
{
  reg->bitfields.DEVICE_ID = device_id;
  if (reg->bitfields.DEVICE_ID != device_id) HSLDPF(E_ERROR_MESSAGE,"DEVICE_ID::DEVICE_ID data too large\n");
}
#else
#define set_DEVICE_ID_device_id(reg, device_id) (reg)->bitfields.DEVICE_ID = device_id

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union COMMAND regCOMMAND;

#ifdef DEBUG
__inline void set_COMMAND_io_access_en(regCOMMAND *reg, unsigned int io_access_en)
{
  reg->bitfields.IO_ACCESS_EN = io_access_en;
  if (reg->bitfields.IO_ACCESS_EN != io_access_en) HSLDPF(E_ERROR_MESSAGE,"COMMAND::IO_ACCESS_EN data too large\n");
}
__inline void set_COMMAND_mem_access_en(regCOMMAND *reg, unsigned int mem_access_en)
{
  reg->bitfields.MEM_ACCESS_EN = mem_access_en;
  if (reg->bitfields.MEM_ACCESS_EN != mem_access_en) HSLDPF(E_ERROR_MESSAGE,"COMMAND::MEM_ACCESS_EN data too large\n");
}
__inline void set_COMMAND_bus_master_en(regCOMMAND *reg, unsigned int bus_master_en)
{
  reg->bitfields.BUS_MASTER_EN = bus_master_en;
  if (reg->bitfields.BUS_MASTER_EN != bus_master_en) HSLDPF(E_ERROR_MESSAGE,"COMMAND::BUS_MASTER_EN data too large\n");
}
__inline void set_COMMAND_special_cycle_en(regCOMMAND *reg, unsigned int special_cycle_en)
{
  reg->bitfields.SPECIAL_CYCLE_EN = special_cycle_en;
  if (reg->bitfields.SPECIAL_CYCLE_EN != special_cycle_en) HSLDPF(E_ERROR_MESSAGE,"COMMAND::SPECIAL_CYCLE_EN data too large\n");
}
__inline void set_COMMAND_mem_write_invalidate_en(regCOMMAND *reg, unsigned int mem_write_invalidate_en)
{
  reg->bitfields.MEM_WRITE_INVALIDATE_EN = mem_write_invalidate_en;
  if (reg->bitfields.MEM_WRITE_INVALIDATE_EN != mem_write_invalidate_en) HSLDPF(E_ERROR_MESSAGE,"COMMAND::MEM_WRITE_INVALIDATE_EN data too large\n");
}
__inline void set_COMMAND_pal_snoop_en(regCOMMAND *reg, unsigned int pal_snoop_en)
{
  reg->bitfields.PAL_SNOOP_EN = pal_snoop_en;
  if (reg->bitfields.PAL_SNOOP_EN != pal_snoop_en) HSLDPF(E_ERROR_MESSAGE,"COMMAND::PAL_SNOOP_EN data too large\n");
}
__inline void set_COMMAND_parity_error_en(regCOMMAND *reg, unsigned int parity_error_en)
{
  reg->bitfields.PARITY_ERROR_EN = parity_error_en;
  if (reg->bitfields.PARITY_ERROR_EN != parity_error_en) HSLDPF(E_ERROR_MESSAGE,"COMMAND::PARITY_ERROR_EN data too large\n");
}
__inline void set_COMMAND_ad_stepping(regCOMMAND *reg, unsigned int ad_stepping)
{
  reg->bitfields.AD_STEPPING = ad_stepping;
  if (reg->bitfields.AD_STEPPING != ad_stepping) HSLDPF(E_ERROR_MESSAGE,"COMMAND::AD_STEPPING data too large\n");
}
__inline void set_COMMAND_serr_en(regCOMMAND *reg, unsigned int serr_en)
{
  reg->bitfields.SERR_EN = serr_en;
  if (reg->bitfields.SERR_EN != serr_en) HSLDPF(E_ERROR_MESSAGE,"COMMAND::SERR_EN data too large\n");
}
__inline void set_COMMAND_fast_b2b_en(regCOMMAND *reg, unsigned int fast_b2b_en)
{
  reg->bitfields.FAST_B2B_EN = fast_b2b_en;
  if (reg->bitfields.FAST_B2B_EN != fast_b2b_en) HSLDPF(E_ERROR_MESSAGE,"COMMAND::FAST_B2B_EN data too large\n");
}
#else
#define set_COMMAND_io_access_en(reg, io_access_en) (reg)->bitfields.IO_ACCESS_EN = io_access_en
#define set_COMMAND_mem_access_en(reg, mem_access_en) (reg)->bitfields.MEM_ACCESS_EN = mem_access_en
#define set_COMMAND_bus_master_en(reg, bus_master_en) (reg)->bitfields.BUS_MASTER_EN = bus_master_en
#define set_COMMAND_special_cycle_en(reg, special_cycle_en) (reg)->bitfields.SPECIAL_CYCLE_EN = special_cycle_en
#define set_COMMAND_mem_write_invalidate_en(reg, mem_write_invalidate_en) (reg)->bitfields.MEM_WRITE_INVALIDATE_EN = mem_write_invalidate_en
#define set_COMMAND_pal_snoop_en(reg, pal_snoop_en) (reg)->bitfields.PAL_SNOOP_EN = pal_snoop_en
#define set_COMMAND_parity_error_en(reg, parity_error_en) (reg)->bitfields.PARITY_ERROR_EN = parity_error_en
#define set_COMMAND_ad_stepping(reg, ad_stepping) (reg)->bitfields.AD_STEPPING = ad_stepping
#define set_COMMAND_serr_en(reg, serr_en) (reg)->bitfields.SERR_EN = serr_en
#define set_COMMAND_fast_b2b_en(reg, fast_b2b_en) (reg)->bitfields.FAST_B2B_EN = fast_b2b_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union STATUS regSTATUS;

#ifdef DEBUG
__inline void set_STATUS_cap_list(regSTATUS *reg, unsigned int cap_list)
{
  reg->bitfields.CAP_LIST = cap_list;
  if (reg->bitfields.CAP_LIST != cap_list) HSLDPF(E_ERROR_MESSAGE,"STATUS::CAP_LIST data too large\n");
}
__inline void set_STATUS_pci_66_en(regSTATUS *reg, unsigned int pci_66_en)
{
  reg->bitfields.PCI_66_EN = pci_66_en;
  if (reg->bitfields.PCI_66_EN != pci_66_en) HSLDPF(E_ERROR_MESSAGE,"STATUS::PCI_66_EN data too large\n");
}
__inline void set_STATUS_udf_en(regSTATUS *reg, unsigned int udf_en)
{
  reg->bitfields.UDF_EN = udf_en;
  if (reg->bitfields.UDF_EN != udf_en) HSLDPF(E_ERROR_MESSAGE,"STATUS::UDF_EN data too large\n");
}
__inline void set_STATUS_fast_back_capable(regSTATUS *reg, unsigned int fast_back_capable)
{
  reg->bitfields.FAST_BACK_CAPABLE = fast_back_capable;
  if (reg->bitfields.FAST_BACK_CAPABLE != fast_back_capable) HSLDPF(E_ERROR_MESSAGE,"STATUS::FAST_BACK_CAPABLE data too large\n");
}
__inline void set_STATUS_devsel_timing(regSTATUS *reg, unsigned int devsel_timing)
{
  reg->bitfields.DEVSEL_TIMING = devsel_timing;
  if (reg->bitfields.DEVSEL_TIMING != devsel_timing) HSLDPF(E_ERROR_MESSAGE,"STATUS::DEVSEL_TIMING data too large\n");
}
__inline void set_STATUS_signal_target_abort(regSTATUS *reg, unsigned int signal_target_abort)
{
  reg->bitfields.SIGNAL_TARGET_ABORT = signal_target_abort;
  if (reg->bitfields.SIGNAL_TARGET_ABORT != signal_target_abort) HSLDPF(E_ERROR_MESSAGE,"STATUS::SIGNAL_TARGET_ABORT data too large\n");
}
__inline void set_STATUS_received_target_abort(regSTATUS *reg, unsigned int received_target_abort)
{
  reg->bitfields.RECEIVED_TARGET_ABORT = received_target_abort;
  if (reg->bitfields.RECEIVED_TARGET_ABORT != received_target_abort) HSLDPF(E_ERROR_MESSAGE,"STATUS::RECEIVED_TARGET_ABORT data too large\n");
}
__inline void set_STATUS_received_master_abort(regSTATUS *reg, unsigned int received_master_abort)
{
  reg->bitfields.RECEIVED_MASTER_ABORT = received_master_abort;
  if (reg->bitfields.RECEIVED_MASTER_ABORT != received_master_abort) HSLDPF(E_ERROR_MESSAGE,"STATUS::RECEIVED_MASTER_ABORT data too large\n");
}
__inline void set_STATUS_signaled_system_error(regSTATUS *reg, unsigned int signaled_system_error)
{
  reg->bitfields.SIGNALED_SYSTEM_ERROR = signaled_system_error;
  if (reg->bitfields.SIGNALED_SYSTEM_ERROR != signaled_system_error) HSLDPF(E_ERROR_MESSAGE,"STATUS::SIGNALED_SYSTEM_ERROR data too large\n");
}
__inline void set_STATUS_parity_error_detected(regSTATUS *reg, unsigned int parity_error_detected)
{
  reg->bitfields.PARITY_ERROR_DETECTED = parity_error_detected;
  if (reg->bitfields.PARITY_ERROR_DETECTED != parity_error_detected) HSLDPF(E_ERROR_MESSAGE,"STATUS::PARITY_ERROR_DETECTED data too large\n");
}
#else
#define set_STATUS_cap_list(reg, cap_list) (reg)->bitfields.CAP_LIST = cap_list
#define set_STATUS_pci_66_en(reg, pci_66_en) (reg)->bitfields.PCI_66_EN = pci_66_en
#define set_STATUS_udf_en(reg, udf_en) (reg)->bitfields.UDF_EN = udf_en
#define set_STATUS_fast_back_capable(reg, fast_back_capable) (reg)->bitfields.FAST_BACK_CAPABLE = fast_back_capable
#define set_STATUS_devsel_timing(reg, devsel_timing) (reg)->bitfields.DEVSEL_TIMING = devsel_timing
#define set_STATUS_signal_target_abort(reg, signal_target_abort) (reg)->bitfields.SIGNAL_TARGET_ABORT = signal_target_abort
#define set_STATUS_received_target_abort(reg, received_target_abort) (reg)->bitfields.RECEIVED_TARGET_ABORT = received_target_abort
#define set_STATUS_received_master_abort(reg, received_master_abort) (reg)->bitfields.RECEIVED_MASTER_ABORT = received_master_abort
#define set_STATUS_signaled_system_error(reg, signaled_system_error) (reg)->bitfields.SIGNALED_SYSTEM_ERROR = signaled_system_error
#define set_STATUS_parity_error_detected(reg, parity_error_detected) (reg)->bitfields.PARITY_ERROR_DETECTED = parity_error_detected

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union REVISION_ID regREVISION_ID;

#ifdef DEBUG
__inline void set_REVISION_ID_minor_rev_id(regREVISION_ID *reg, unsigned int minor_rev_id)
{
  reg->bitfields.MINOR_REV_ID = minor_rev_id;
  if (reg->bitfields.MINOR_REV_ID != minor_rev_id) HSLDPF(E_ERROR_MESSAGE,"REVISION_ID::MINOR_REV_ID data too large\n");
}
__inline void set_REVISION_ID_major_rev_id(regREVISION_ID *reg, unsigned int major_rev_id)
{
  reg->bitfields.MAJOR_REV_ID = major_rev_id;
  if (reg->bitfields.MAJOR_REV_ID != major_rev_id) HSLDPF(E_ERROR_MESSAGE,"REVISION_ID::MAJOR_REV_ID data too large\n");
}
#else
#define set_REVISION_ID_minor_rev_id(reg, minor_rev_id) (reg)->bitfields.MINOR_REV_ID = minor_rev_id
#define set_REVISION_ID_major_rev_id(reg, major_rev_id) (reg)->bitfields.MAJOR_REV_ID = major_rev_id

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union REGPROG_INF regREGPROG_INF;

#ifdef DEBUG
__inline void set_REGPROG_INF_reg_level_prog_inf(regREGPROG_INF *reg, unsigned int reg_level_prog_inf)
{
  reg->bitfields.REG_LEVEL_PROG_INF = reg_level_prog_inf;
  if (reg->bitfields.REG_LEVEL_PROG_INF != reg_level_prog_inf) HSLDPF(E_ERROR_MESSAGE,"REGPROG_INF::REG_LEVEL_PROG_INF data too large\n");
}
#else
#define set_REGPROG_INF_reg_level_prog_inf(reg, reg_level_prog_inf) (reg)->bitfields.REG_LEVEL_PROG_INF = reg_level_prog_inf

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUB_CLASS regSUB_CLASS;

#ifdef DEBUG
__inline void set_SUB_CLASS_sub_class_inf(regSUB_CLASS *reg, unsigned int sub_class_inf)
{
  reg->bitfields.SUB_CLASS_INF = sub_class_inf;
  if (reg->bitfields.SUB_CLASS_INF != sub_class_inf) HSLDPF(E_ERROR_MESSAGE,"SUB_CLASS::SUB_CLASS_INF data too large\n");
}
#else
#define set_SUB_CLASS_sub_class_inf(reg, sub_class_inf) (reg)->bitfields.SUB_CLASS_INF = sub_class_inf

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BASE_CODE regBASE_CODE;

#ifdef DEBUG
__inline void set_BASE_CODE_base_class_code(regBASE_CODE *reg, unsigned int base_class_code)
{
  reg->bitfields.BASE_CLASS_CODE = base_class_code;
  if (reg->bitfields.BASE_CLASS_CODE != base_class_code) HSLDPF(E_ERROR_MESSAGE,"BASE_CODE::BASE_CLASS_CODE data too large\n");
}
#else
#define set_BASE_CODE_base_class_code(reg, base_class_code) (reg)->bitfields.BASE_CLASS_CODE = base_class_code

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CACHE_LINE regCACHE_LINE;

#ifdef DEBUG
__inline void set_CACHE_LINE_cache_line_size(regCACHE_LINE *reg, unsigned int cache_line_size)
{
  reg->bitfields.CACHE_LINE_SIZE = cache_line_size;
  if (reg->bitfields.CACHE_LINE_SIZE != cache_line_size) HSLDPF(E_ERROR_MESSAGE,"CACHE_LINE::CACHE_LINE_SIZE data too large\n");
}
#else
#define set_CACHE_LINE_cache_line_size(reg, cache_line_size) (reg)->bitfields.CACHE_LINE_SIZE = cache_line_size

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union LATENCY regLATENCY;

#ifdef DEBUG
__inline void set_LATENCY_latency_timer(regLATENCY *reg, unsigned int latency_timer)
{
  reg->bitfields.LATENCY_TIMER = latency_timer;
  if (reg->bitfields.LATENCY_TIMER != latency_timer) HSLDPF(E_ERROR_MESSAGE,"LATENCY::LATENCY_TIMER data too large\n");
}
#else
#define set_LATENCY_latency_timer(reg, latency_timer) (reg)->bitfields.LATENCY_TIMER = latency_timer

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union HEADER regHEADER;

#ifdef DEBUG
__inline void set_HEADER_header_type(regHEADER *reg, unsigned int header_type)
{
  reg->bitfields.HEADER_TYPE = header_type;
  if (reg->bitfields.HEADER_TYPE != header_type) HSLDPF(E_ERROR_MESSAGE,"HEADER::HEADER_TYPE data too large\n");
}
__inline void set_HEADER_device_type(regHEADER *reg, unsigned int device_type)
{
  reg->bitfields.DEVICE_TYPE = device_type;
  if (reg->bitfields.DEVICE_TYPE != device_type) HSLDPF(E_ERROR_MESSAGE,"HEADER::DEVICE_TYPE data too large\n");
}
#else
#define set_HEADER_header_type(reg, header_type) (reg)->bitfields.HEADER_TYPE = header_type
#define set_HEADER_device_type(reg, device_type) (reg)->bitfields.DEVICE_TYPE = device_type

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BIST regBIST;

#ifdef DEBUG
__inline void set_BIST_bist_comp(regBIST *reg, unsigned int bist_comp)
{
  reg->bitfields.BIST_COMP = bist_comp;
  if (reg->bitfields.BIST_COMP != bist_comp) HSLDPF(E_ERROR_MESSAGE,"BIST::BIST_COMP data too large\n");
}
__inline void set_BIST_bist_strt(regBIST *reg, unsigned int bist_strt)
{
  reg->bitfields.BIST_STRT = bist_strt;
  if (reg->bitfields.BIST_STRT != bist_strt) HSLDPF(E_ERROR_MESSAGE,"BIST::BIST_STRT data too large\n");
}
__inline void set_BIST_bist_cap(regBIST *reg, unsigned int bist_cap)
{
  reg->bitfields.BIST_CAP = bist_cap;
  if (reg->bitfields.BIST_CAP != bist_cap) HSLDPF(E_ERROR_MESSAGE,"BIST::BIST_CAP data too large\n");
}
#else
#define set_BIST_bist_comp(reg, bist_comp) (reg)->bitfields.BIST_COMP = bist_comp
#define set_BIST_bist_strt(reg, bist_strt) (reg)->bitfields.BIST_STRT = bist_strt
#define set_BIST_bist_cap(reg, bist_cap) (reg)->bitfields.BIST_CAP = bist_cap

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MEM_BASE regMEM_BASE;

#ifdef DEBUG
__inline void set_MEM_BASE_prefetch_en(regMEM_BASE *reg, unsigned int prefetch_en)
{
  reg->bitfields.PREFETCH_EN = prefetch_en;
  if (reg->bitfields.PREFETCH_EN != prefetch_en) HSLDPF(E_ERROR_MESSAGE,"MEM_BASE::PREFETCH_EN data too large\n");
}
__inline void set_MEM_BASE_mem_base(regMEM_BASE *reg, unsigned int mem_base)
{
  reg->bitfields.MEM_BASE = mem_base;
  if (reg->bitfields.MEM_BASE != mem_base) HSLDPF(E_ERROR_MESSAGE,"MEM_BASE::MEM_BASE data too large\n");
}
#else
#define set_MEM_BASE_prefetch_en(reg, prefetch_en) (reg)->bitfields.PREFETCH_EN = prefetch_en
#define set_MEM_BASE_mem_base(reg, mem_base) (reg)->bitfields.MEM_BASE = mem_base

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union IO_BASE regIO_BASE;

#ifdef DEBUG
__inline void set_IO_BASE_block_io_bit(regIO_BASE *reg, unsigned int block_io_bit)
{
  reg->bitfields.BLOCK_IO_BIT = block_io_bit;
  if (reg->bitfields.BLOCK_IO_BIT != block_io_bit) HSLDPF(E_ERROR_MESSAGE,"IO_BASE::BLOCK_IO_BIT data too large\n");
}
__inline void set_IO_BASE_io_base(regIO_BASE *reg, unsigned int io_base)
{
  reg->bitfields.IO_BASE = io_base;
  if (reg->bitfields.IO_BASE != io_base) HSLDPF(E_ERROR_MESSAGE,"IO_BASE::IO_BASE data too large\n");
}
#else
#define set_IO_BASE_block_io_bit(reg, block_io_bit) (reg)->bitfields.BLOCK_IO_BIT = block_io_bit
#define set_IO_BASE_io_base(reg, io_base) (reg)->bitfields.IO_BASE = io_base

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union REG_BASE regREG_BASE;

#ifdef DEBUG
__inline void set_REG_BASE_reg_base(regREG_BASE *reg, unsigned int reg_base)
{
  reg->bitfields.REG_BASE = reg_base;
  if (reg->bitfields.REG_BASE != reg_base) HSLDPF(E_ERROR_MESSAGE,"REG_BASE::REG_BASE data too large\n");
}
#else
#define set_REG_BASE_reg_base(reg, reg_base) (reg)->bitfields.REG_BASE = reg_base

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ADAPTER_ID regADAPTER_ID;

#ifdef DEBUG
__inline void set_ADAPTER_ID_subsystem_vendor_id(regADAPTER_ID *reg, unsigned int subsystem_vendor_id)
{
  reg->bitfields.SUBSYSTEM_VENDOR_ID = subsystem_vendor_id;
  if (reg->bitfields.SUBSYSTEM_VENDOR_ID != subsystem_vendor_id) HSLDPF(E_ERROR_MESSAGE,"ADAPTER_ID::SUBSYSTEM_VENDOR_ID data too large\n");
}
__inline void set_ADAPTER_ID_subsystem_id(regADAPTER_ID *reg, unsigned int subsystem_id)
{
  reg->bitfields.SUBSYSTEM_ID = subsystem_id;
  if (reg->bitfields.SUBSYSTEM_ID != subsystem_id) HSLDPF(E_ERROR_MESSAGE,"ADAPTER_ID::SUBSYSTEM_ID data too large\n");
}
#else
#define set_ADAPTER_ID_subsystem_vendor_id(reg, subsystem_vendor_id) (reg)->bitfields.SUBSYSTEM_VENDOR_ID = subsystem_vendor_id
#define set_ADAPTER_ID_subsystem_id(reg, subsystem_id) (reg)->bitfields.SUBSYSTEM_ID = subsystem_id

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BIOS_ROM regBIOS_ROM;

#ifdef DEBUG
__inline void set_BIOS_ROM_bios_rom_en(regBIOS_ROM *reg, unsigned int bios_rom_en)
{
  reg->bitfields.BIOS_ROM_EN = bios_rom_en;
  if (reg->bitfields.BIOS_ROM_EN != bios_rom_en) HSLDPF(E_ERROR_MESSAGE,"BIOS_ROM::BIOS_ROM_EN data too large\n");
}
__inline void set_BIOS_ROM_bios_base_addr(regBIOS_ROM *reg, unsigned int bios_base_addr)
{
  reg->bitfields.BIOS_BASE_ADDR = bios_base_addr;
  if (reg->bitfields.BIOS_BASE_ADDR != bios_base_addr) HSLDPF(E_ERROR_MESSAGE,"BIOS_ROM::BIOS_BASE_ADDR data too large\n");
}
#else
#define set_BIOS_ROM_bios_rom_en(reg, bios_rom_en) (reg)->bitfields.BIOS_ROM_EN = bios_rom_en
#define set_BIOS_ROM_bios_base_addr(reg, bios_base_addr) (reg)->bitfields.BIOS_BASE_ADDR = bios_base_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAPABILITIES_PTR regCAPABILITIES_PTR;

#ifdef DEBUG
__inline void set_CAPABILITIES_PTR_cap_ptr(regCAPABILITIES_PTR *reg, unsigned int cap_ptr)
{
  reg->bitfields.CAP_PTR = cap_ptr;
  if (reg->bitfields.CAP_PTR != cap_ptr) HSLDPF(E_ERROR_MESSAGE,"CAPABILITIES_PTR::CAP_PTR data too large\n");
}
#else
#define set_CAPABILITIES_PTR_cap_ptr(reg, cap_ptr) (reg)->bitfields.CAP_PTR = cap_ptr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union INTERRUPT_LINE regINTERRUPT_LINE;

#ifdef DEBUG
__inline void set_INTERRUPT_LINE_interrupt_line(regINTERRUPT_LINE *reg, unsigned int interrupt_line)
{
  reg->bitfields.INTERRUPT_LINE = interrupt_line;
  if (reg->bitfields.INTERRUPT_LINE != interrupt_line) HSLDPF(E_ERROR_MESSAGE,"INTERRUPT_LINE::INTERRUPT_LINE data too large\n");
}
#else
#define set_INTERRUPT_LINE_interrupt_line(reg, interrupt_line) (reg)->bitfields.INTERRUPT_LINE = interrupt_line

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union INTERRUPT_PIN regINTERRUPT_PIN;

#ifdef DEBUG
__inline void set_INTERRUPT_PIN_interrupt_pin(regINTERRUPT_PIN *reg, unsigned int interrupt_pin)
{
  reg->bitfields.INTERRUPT_PIN = interrupt_pin;
  if (reg->bitfields.INTERRUPT_PIN != interrupt_pin) HSLDPF(E_ERROR_MESSAGE,"INTERRUPT_PIN::INTERRUPT_PIN data too large\n");
}
#else
#define set_INTERRUPT_PIN_interrupt_pin(reg, interrupt_pin) (reg)->bitfields.INTERRUPT_PIN = interrupt_pin

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MIN_GRANT regMIN_GRANT;

#ifdef DEBUG
__inline void set_MIN_GRANT_min_gnt(regMIN_GRANT *reg, unsigned int min_gnt)
{
  reg->bitfields.MIN_GNT = min_gnt;
  if (reg->bitfields.MIN_GNT != min_gnt) HSLDPF(E_ERROR_MESSAGE,"MIN_GRANT::MIN_GNT data too large\n");
}
#else
#define set_MIN_GRANT_min_gnt(reg, min_gnt) (reg)->bitfields.MIN_GNT = min_gnt

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MAX_LATENCY regMAX_LATENCY;

#ifdef DEBUG
__inline void set_MAX_LATENCY_max_lat(regMAX_LATENCY *reg, unsigned int max_lat)
{
  reg->bitfields.MAX_LAT = max_lat;
  if (reg->bitfields.MAX_LAT != max_lat) HSLDPF(E_ERROR_MESSAGE,"MAX_LATENCY::MAX_LAT data too large\n");
}
#else
#define set_MAX_LATENCY_max_lat(reg, max_lat) (reg)->bitfields.MAX_LAT = max_lat

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ADAPTER_ID_W regADAPTER_ID_W;

#ifdef DEBUG
__inline void set_ADAPTER_ID_W_subsystem_vendor_id(regADAPTER_ID_W *reg, unsigned int subsystem_vendor_id)
{
  reg->bitfields.SUBSYSTEM_VENDOR_ID = subsystem_vendor_id;
  if (reg->bitfields.SUBSYSTEM_VENDOR_ID != subsystem_vendor_id) HSLDPF(E_ERROR_MESSAGE,"ADAPTER_ID_W::SUBSYSTEM_VENDOR_ID data too large\n");
}
__inline void set_ADAPTER_ID_W_subsystem_id(regADAPTER_ID_W *reg, unsigned int subsystem_id)
{
  reg->bitfields.SUBSYSTEM_ID = subsystem_id;
  if (reg->bitfields.SUBSYSTEM_ID != subsystem_id) HSLDPF(E_ERROR_MESSAGE,"ADAPTER_ID_W::SUBSYSTEM_ID data too large\n");
}
#else
#define set_ADAPTER_ID_W_subsystem_vendor_id(reg, subsystem_vendor_id) (reg)->bitfields.SUBSYSTEM_VENDOR_ID = subsystem_vendor_id
#define set_ADAPTER_ID_W_subsystem_id(reg, subsystem_id) (reg)->bitfields.SUBSYSTEM_ID = subsystem_id

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PMI_CAP_ID regPMI_CAP_ID;

#ifdef DEBUG
__inline void set_PMI_CAP_ID_pmi_cap_id(regPMI_CAP_ID *reg, unsigned int pmi_cap_id)
{
  reg->bitfields.PMI_CAP_ID = pmi_cap_id;
  if (reg->bitfields.PMI_CAP_ID != pmi_cap_id) HSLDPF(E_ERROR_MESSAGE,"PMI_CAP_ID::PMI_CAP_ID data too large\n");
}
#else
#define set_PMI_CAP_ID_pmi_cap_id(reg, pmi_cap_id) (reg)->bitfields.PMI_CAP_ID = pmi_cap_id

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PMI_NXT_CAP_PTR regPMI_NXT_CAP_PTR;

#ifdef DEBUG
__inline void set_PMI_NXT_CAP_PTR_pmi_nxt_cap_ptr(regPMI_NXT_CAP_PTR *reg, unsigned int pmi_nxt_cap_ptr)
{
  reg->bitfields.PMI_NXT_CAP_PTR = pmi_nxt_cap_ptr;
  if (reg->bitfields.PMI_NXT_CAP_PTR != pmi_nxt_cap_ptr) HSLDPF(E_ERROR_MESSAGE,"PMI_NXT_CAP_PTR::PMI_NXT_CAP_PTR data too large\n");
}
#else
#define set_PMI_NXT_CAP_PTR_pmi_nxt_cap_ptr(reg, pmi_nxt_cap_ptr) (reg)->bitfields.PMI_NXT_CAP_PTR = pmi_nxt_cap_ptr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PMI_PMC_REG regPMI_PMC_REG;

#ifdef DEBUG
__inline void set_PMI_PMC_REG_pmi_version(regPMI_PMC_REG *reg, unsigned int pmi_version)
{
  reg->bitfields.PMI_VERSION = pmi_version;
  if (reg->bitfields.PMI_VERSION != pmi_version) HSLDPF(E_ERROR_MESSAGE,"PMI_PMC_REG::PMI_VERSION data too large\n");
}
__inline void set_PMI_PMC_REG_pmi_pme_clock(regPMI_PMC_REG *reg, unsigned int pmi_pme_clock)
{
  reg->bitfields.PMI_PME_CLOCK = pmi_pme_clock;
  if (reg->bitfields.PMI_PME_CLOCK != pmi_pme_clock) HSLDPF(E_ERROR_MESSAGE,"PMI_PMC_REG::PMI_PME_CLOCK data too large\n");
}
__inline void set_PMI_PMC_REG_pmi_dev_specific_init(regPMI_PMC_REG *reg, unsigned int pmi_dev_specific_init)
{
  reg->bitfields.PMI_DEV_SPECIFIC_INIT = pmi_dev_specific_init;
  if (reg->bitfields.PMI_DEV_SPECIFIC_INIT != pmi_dev_specific_init) HSLDPF(E_ERROR_MESSAGE,"PMI_PMC_REG::PMI_DEV_SPECIFIC_INIT data too large\n");
}
__inline void set_PMI_PMC_REG_pmi_d1_support(regPMI_PMC_REG *reg, unsigned int pmi_d1_support)
{
  reg->bitfields.PMI_D1_SUPPORT = pmi_d1_support;
  if (reg->bitfields.PMI_D1_SUPPORT != pmi_d1_support) HSLDPF(E_ERROR_MESSAGE,"PMI_PMC_REG::PMI_D1_SUPPORT data too large\n");
}
__inline void set_PMI_PMC_REG_pmi_d2_support(regPMI_PMC_REG *reg, unsigned int pmi_d2_support)
{
  reg->bitfields.PMI_D2_SUPPORT = pmi_d2_support;
  if (reg->bitfields.PMI_D2_SUPPORT != pmi_d2_support) HSLDPF(E_ERROR_MESSAGE,"PMI_PMC_REG::PMI_D2_SUPPORT data too large\n");
}
__inline void set_PMI_PMC_REG_pmi_pme_support(regPMI_PMC_REG *reg, unsigned int pmi_pme_support)
{
  reg->bitfields.PMI_PME_SUPPORT = pmi_pme_support;
  if (reg->bitfields.PMI_PME_SUPPORT != pmi_pme_support) HSLDPF(E_ERROR_MESSAGE,"PMI_PMC_REG::PMI_PME_SUPPORT data too large\n");
}
#else
#define set_PMI_PMC_REG_pmi_version(reg, pmi_version) (reg)->bitfields.PMI_VERSION = pmi_version
#define set_PMI_PMC_REG_pmi_pme_clock(reg, pmi_pme_clock) (reg)->bitfields.PMI_PME_CLOCK = pmi_pme_clock
#define set_PMI_PMC_REG_pmi_dev_specific_init(reg, pmi_dev_specific_init) (reg)->bitfields.PMI_DEV_SPECIFIC_INIT = pmi_dev_specific_init
#define set_PMI_PMC_REG_pmi_d1_support(reg, pmi_d1_support) (reg)->bitfields.PMI_D1_SUPPORT = pmi_d1_support
#define set_PMI_PMC_REG_pmi_d2_support(reg, pmi_d2_support) (reg)->bitfields.PMI_D2_SUPPORT = pmi_d2_support
#define set_PMI_PMC_REG_pmi_pme_support(reg, pmi_pme_support) (reg)->bitfields.PMI_PME_SUPPORT = pmi_pme_support

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PM_STATUS regPM_STATUS;

#ifdef DEBUG
__inline void set_PM_STATUS_pmi_power_state(regPM_STATUS *reg, unsigned int pmi_power_state)
{
  reg->bitfields.PMI_POWER_STATE = pmi_power_state;
  if (reg->bitfields.PMI_POWER_STATE != pmi_power_state) HSLDPF(E_ERROR_MESSAGE,"PM_STATUS::PMI_POWER_STATE data too large\n");
}
__inline void set_PM_STATUS_pmi_pme_en(regPM_STATUS *reg, unsigned int pmi_pme_en)
{
  reg->bitfields.PMI_PME_EN = pmi_pme_en;
  if (reg->bitfields.PMI_PME_EN != pmi_pme_en) HSLDPF(E_ERROR_MESSAGE,"PM_STATUS::PMI_PME_EN data too large\n");
}
__inline void set_PM_STATUS_pmi_data_select(regPM_STATUS *reg, unsigned int pmi_data_select)
{
  reg->bitfields.PMI_DATA_SELECT = pmi_data_select;
  if (reg->bitfields.PMI_DATA_SELECT != pmi_data_select) HSLDPF(E_ERROR_MESSAGE,"PM_STATUS::PMI_DATA_SELECT data too large\n");
}
__inline void set_PM_STATUS_pmi_data_scale(regPM_STATUS *reg, unsigned int pmi_data_scale)
{
  reg->bitfields.PMI_DATA_SCALE = pmi_data_scale;
  if (reg->bitfields.PMI_DATA_SCALE != pmi_data_scale) HSLDPF(E_ERROR_MESSAGE,"PM_STATUS::PMI_DATA_SCALE data too large\n");
}
__inline void set_PM_STATUS_pmi_pme_status(regPM_STATUS *reg, unsigned int pmi_pme_status)
{
  reg->bitfields.PMI_PME_STATUS = pmi_pme_status;
  if (reg->bitfields.PMI_PME_STATUS != pmi_pme_status) HSLDPF(E_ERROR_MESSAGE,"PM_STATUS::PMI_PME_STATUS data too large\n");
}
#else
#define set_PM_STATUS_pmi_power_state(reg, pmi_power_state) (reg)->bitfields.PMI_POWER_STATE = pmi_power_state
#define set_PM_STATUS_pmi_pme_en(reg, pmi_pme_en) (reg)->bitfields.PMI_PME_EN = pmi_pme_en
#define set_PM_STATUS_pmi_data_select(reg, pmi_data_select) (reg)->bitfields.PMI_DATA_SELECT = pmi_data_select
#define set_PM_STATUS_pmi_data_scale(reg, pmi_data_scale) (reg)->bitfields.PMI_DATA_SCALE = pmi_data_scale
#define set_PM_STATUS_pmi_pme_status(reg, pmi_pme_status) (reg)->bitfields.PMI_PME_STATUS = pmi_pme_status

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PMI_DATA regPMI_DATA;

#ifdef DEBUG
__inline void set_PMI_DATA_pmi_data(regPMI_DATA *reg, unsigned int pmi_data)
{
  reg->bitfields.PMI_DATA = pmi_data;
  if (reg->bitfields.PMI_DATA != pmi_data) HSLDPF(E_ERROR_MESSAGE,"PMI_DATA::PMI_DATA data too large\n");
}
#else
#define set_PMI_DATA_pmi_data(reg, pmi_data) (reg)->bitfields.PMI_DATA = pmi_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union AGP_CAP_ID regAGP_CAP_ID;

#ifdef DEBUG
__inline void set_AGP_CAP_ID_cap_id(regAGP_CAP_ID *reg, unsigned int cap_id)
{
  reg->bitfields.CAP_ID = cap_id;
  if (reg->bitfields.CAP_ID != cap_id) HSLDPF(E_ERROR_MESSAGE,"AGP_CAP_ID::CAP_ID data too large\n");
}
__inline void set_AGP_CAP_ID_next_ptr(regAGP_CAP_ID *reg, unsigned int next_ptr)
{
  reg->bitfields.NEXT_PTR = next_ptr;
  if (reg->bitfields.NEXT_PTR != next_ptr) HSLDPF(E_ERROR_MESSAGE,"AGP_CAP_ID::NEXT_PTR data too large\n");
}
__inline void set_AGP_CAP_ID_agp_minor(regAGP_CAP_ID *reg, unsigned int agp_minor)
{
  reg->bitfields.AGP_MINOR = agp_minor;
  if (reg->bitfields.AGP_MINOR != agp_minor) HSLDPF(E_ERROR_MESSAGE,"AGP_CAP_ID::AGP_MINOR data too large\n");
}
__inline void set_AGP_CAP_ID_agp_major(regAGP_CAP_ID *reg, unsigned int agp_major)
{
  reg->bitfields.AGP_MAJOR = agp_major;
  if (reg->bitfields.AGP_MAJOR != agp_major) HSLDPF(E_ERROR_MESSAGE,"AGP_CAP_ID::AGP_MAJOR data too large\n");
}
#else
#define set_AGP_CAP_ID_cap_id(reg, cap_id) (reg)->bitfields.CAP_ID = cap_id
#define set_AGP_CAP_ID_next_ptr(reg, next_ptr) (reg)->bitfields.NEXT_PTR = next_ptr
#define set_AGP_CAP_ID_agp_minor(reg, agp_minor) (reg)->bitfields.AGP_MINOR = agp_minor
#define set_AGP_CAP_ID_agp_major(reg, agp_major) (reg)->bitfields.AGP_MAJOR = agp_major

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union AGP_STATUS regAGP_STATUS;

#ifdef DEBUG
__inline void set_AGP_STATUS_rate1x(regAGP_STATUS *reg, unsigned int rate1x)
{
  reg->bitfields.RATE1X = rate1x;
  if (reg->bitfields.RATE1X != rate1x) HSLDPF(E_ERROR_MESSAGE,"AGP_STATUS::RATE1X data too large\n");
}
__inline void set_AGP_STATUS_rate2x(regAGP_STATUS *reg, unsigned int rate2x)
{
  reg->bitfields.RATE2X = rate2x;
  if (reg->bitfields.RATE2X != rate2x) HSLDPF(E_ERROR_MESSAGE,"AGP_STATUS::RATE2X data too large\n");
}
__inline void set_AGP_STATUS_rate4x(regAGP_STATUS *reg, unsigned int rate4x)
{
  reg->bitfields.RATE4X = rate4x;
  if (reg->bitfields.RATE4X != rate4x) HSLDPF(E_ERROR_MESSAGE,"AGP_STATUS::RATE4X data too large\n");
}
__inline void set_AGP_STATUS_fw(regAGP_STATUS *reg, unsigned int fw)
{
  reg->bitfields.FW = fw;
  if (reg->bitfields.FW != fw) HSLDPF(E_ERROR_MESSAGE,"AGP_STATUS::FW data too large\n");
}
__inline void set_AGP_STATUS_mode_4g(regAGP_STATUS *reg, unsigned int mode_4g)
{
  reg->bitfields.MODE_4G = mode_4g;
  if (reg->bitfields.MODE_4G != mode_4g) HSLDPF(E_ERROR_MESSAGE,"AGP_STATUS::MODE_4G data too large\n");
}
__inline void set_AGP_STATUS_sba(regAGP_STATUS *reg, unsigned int sba)
{
  reg->bitfields.SBA = sba;
  if (reg->bitfields.SBA != sba) HSLDPF(E_ERROR_MESSAGE,"AGP_STATUS::SBA data too large\n");
}
__inline void set_AGP_STATUS_rq(regAGP_STATUS *reg, unsigned int rq)
{
  reg->bitfields.RQ = rq;
  if (reg->bitfields.RQ != rq) HSLDPF(E_ERROR_MESSAGE,"AGP_STATUS::RQ data too large\n");
}
#else
#define set_AGP_STATUS_rate1x(reg, rate1x) (reg)->bitfields.RATE1X = rate1x
#define set_AGP_STATUS_rate2x(reg, rate2x) (reg)->bitfields.RATE2X = rate2x
#define set_AGP_STATUS_rate4x(reg, rate4x) (reg)->bitfields.RATE4X = rate4x
#define set_AGP_STATUS_fw(reg, fw) (reg)->bitfields.FW = fw
#define set_AGP_STATUS_mode_4g(reg, mode_4g) (reg)->bitfields.MODE_4G = mode_4g
#define set_AGP_STATUS_sba(reg, sba) (reg)->bitfields.SBA = sba
#define set_AGP_STATUS_rq(reg, rq) (reg)->bitfields.RQ = rq

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union AGP_COMMAND regAGP_COMMAND;

#ifdef DEBUG
__inline void set_AGP_COMMAND_data_rate(regAGP_COMMAND *reg, unsigned int data_rate)
{
  reg->bitfields.DATA_RATE = data_rate;
  if (reg->bitfields.DATA_RATE != data_rate) HSLDPF(E_ERROR_MESSAGE,"AGP_COMMAND::DATA_RATE data too large\n");
}
__inline void set_AGP_COMMAND_fw_en(regAGP_COMMAND *reg, unsigned int fw_en)
{
  reg->bitfields.FW_EN = fw_en;
  if (reg->bitfields.FW_EN != fw_en) HSLDPF(E_ERROR_MESSAGE,"AGP_COMMAND::FW_EN data too large\n");
}
__inline void set_AGP_COMMAND_mode_4g_en(regAGP_COMMAND *reg, unsigned int mode_4g_en)
{
  reg->bitfields.MODE_4G_EN = mode_4g_en;
  if (reg->bitfields.MODE_4G_EN != mode_4g_en) HSLDPF(E_ERROR_MESSAGE,"AGP_COMMAND::MODE_4G_EN data too large\n");
}
__inline void set_AGP_COMMAND_agp_en(regAGP_COMMAND *reg, unsigned int agp_en)
{
  reg->bitfields.AGP_EN = agp_en;
  if (reg->bitfields.AGP_EN != agp_en) HSLDPF(E_ERROR_MESSAGE,"AGP_COMMAND::AGP_EN data too large\n");
}
__inline void set_AGP_COMMAND_sba_en(regAGP_COMMAND *reg, unsigned int sba_en)
{
  reg->bitfields.SBA_EN = sba_en;
  if (reg->bitfields.SBA_EN != sba_en) HSLDPF(E_ERROR_MESSAGE,"AGP_COMMAND::SBA_EN data too large\n");
}
__inline void set_AGP_COMMAND_rq_depth(regAGP_COMMAND *reg, unsigned int rq_depth)
{
  reg->bitfields.RQ_DEPTH = rq_depth;
  if (reg->bitfields.RQ_DEPTH != rq_depth) HSLDPF(E_ERROR_MESSAGE,"AGP_COMMAND::RQ_DEPTH data too large\n");
}
#else
#define set_AGP_COMMAND_data_rate(reg, data_rate) (reg)->bitfields.DATA_RATE = data_rate
#define set_AGP_COMMAND_fw_en(reg, fw_en) (reg)->bitfields.FW_EN = fw_en
#define set_AGP_COMMAND_mode_4g_en(reg, mode_4g_en) (reg)->bitfields.MODE_4G_EN = mode_4g_en
#define set_AGP_COMMAND_agp_en(reg, agp_en) (reg)->bitfields.AGP_EN = agp_en
#define set_AGP_COMMAND_sba_en(reg, sba_en) (reg)->bitfields.SBA_EN = sba_en
#define set_AGP_COMMAND_rq_depth(reg, rq_depth) (reg)->bitfields.RQ_DEPTH = rq_depth

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_VENDOR_ID regF1_VENDOR_ID;

#ifdef DEBUG
__inline void set_F1_VENDOR_ID_f1_vendor_id(regF1_VENDOR_ID *reg, unsigned int f1_vendor_id)
{
  reg->bitfields.F1_VENDOR_ID = f1_vendor_id;
  if (reg->bitfields.F1_VENDOR_ID != f1_vendor_id) HSLDPF(E_ERROR_MESSAGE,"F1_VENDOR_ID::F1_VENDOR_ID data too large\n");
}
#else
#define set_F1_VENDOR_ID_f1_vendor_id(reg, f1_vendor_id) (reg)->bitfields.F1_VENDOR_ID = f1_vendor_id

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_DEVICE_ID regF1_DEVICE_ID;

#ifdef DEBUG
__inline void set_F1_DEVICE_ID_f1_device_id(regF1_DEVICE_ID *reg, unsigned int f1_device_id)
{
  reg->bitfields.F1_DEVICE_ID = f1_device_id;
  if (reg->bitfields.F1_DEVICE_ID != f1_device_id) HSLDPF(E_ERROR_MESSAGE,"F1_DEVICE_ID::F1_DEVICE_ID data too large\n");
}
#else
#define set_F1_DEVICE_ID_f1_device_id(reg, f1_device_id) (reg)->bitfields.F1_DEVICE_ID = f1_device_id

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_COMMAND regF1_COMMAND;

#ifdef DEBUG
__inline void set_F1_COMMAND_f1_io_access_en(regF1_COMMAND *reg, unsigned int f1_io_access_en)
{
  reg->bitfields.F1_IO_ACCESS_EN = f1_io_access_en;
  if (reg->bitfields.F1_IO_ACCESS_EN != f1_io_access_en) HSLDPF(E_ERROR_MESSAGE,"F1_COMMAND::F1_IO_ACCESS_EN data too large\n");
}
__inline void set_F1_COMMAND_f1_mem_access_en(regF1_COMMAND *reg, unsigned int f1_mem_access_en)
{
  reg->bitfields.F1_MEM_ACCESS_EN = f1_mem_access_en;
  if (reg->bitfields.F1_MEM_ACCESS_EN != f1_mem_access_en) HSLDPF(E_ERROR_MESSAGE,"F1_COMMAND::F1_MEM_ACCESS_EN data too large\n");
}
__inline void set_F1_COMMAND_f1_bus_master_en(regF1_COMMAND *reg, unsigned int f1_bus_master_en)
{
  reg->bitfields.F1_BUS_MASTER_EN = f1_bus_master_en;
  if (reg->bitfields.F1_BUS_MASTER_EN != f1_bus_master_en) HSLDPF(E_ERROR_MESSAGE,"F1_COMMAND::F1_BUS_MASTER_EN data too large\n");
}
__inline void set_F1_COMMAND_f1_ad_stepping(regF1_COMMAND *reg, unsigned int f1_ad_stepping)
{
  reg->bitfields.F1_AD_STEPPING = f1_ad_stepping;
  if (reg->bitfields.F1_AD_STEPPING != f1_ad_stepping) HSLDPF(E_ERROR_MESSAGE,"F1_COMMAND::F1_AD_STEPPING data too large\n");
}
__inline void set_F1_COMMAND_f1_fast_b2b_en(regF1_COMMAND *reg, unsigned int f1_fast_b2b_en)
{
  reg->bitfields.F1_FAST_B2B_EN = f1_fast_b2b_en;
  if (reg->bitfields.F1_FAST_B2B_EN != f1_fast_b2b_en) HSLDPF(E_ERROR_MESSAGE,"F1_COMMAND::F1_FAST_B2B_EN data too large\n");
}
#else
#define set_F1_COMMAND_f1_io_access_en(reg, f1_io_access_en) (reg)->bitfields.F1_IO_ACCESS_EN = f1_io_access_en
#define set_F1_COMMAND_f1_mem_access_en(reg, f1_mem_access_en) (reg)->bitfields.F1_MEM_ACCESS_EN = f1_mem_access_en
#define set_F1_COMMAND_f1_bus_master_en(reg, f1_bus_master_en) (reg)->bitfields.F1_BUS_MASTER_EN = f1_bus_master_en
#define set_F1_COMMAND_f1_ad_stepping(reg, f1_ad_stepping) (reg)->bitfields.F1_AD_STEPPING = f1_ad_stepping
#define set_F1_COMMAND_f1_fast_b2b_en(reg, f1_fast_b2b_en) (reg)->bitfields.F1_FAST_B2B_EN = f1_fast_b2b_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_STATUS regF1_STATUS;

#ifdef DEBUG
__inline void set_F1_STATUS_f1_cap_list(regF1_STATUS *reg, unsigned int f1_cap_list)
{
  reg->bitfields.F1_CAP_LIST = f1_cap_list;
  if (reg->bitfields.F1_CAP_LIST != f1_cap_list) HSLDPF(E_ERROR_MESSAGE,"F1_STATUS::F1_CAP_LIST data too large\n");
}
__inline void set_F1_STATUS_f1_pci_66_en(regF1_STATUS *reg, unsigned int f1_pci_66_en)
{
  reg->bitfields.F1_PCI_66_EN = f1_pci_66_en;
  if (reg->bitfields.F1_PCI_66_EN != f1_pci_66_en) HSLDPF(E_ERROR_MESSAGE,"F1_STATUS::F1_PCI_66_EN data too large\n");
}
__inline void set_F1_STATUS_f1_udf_en(regF1_STATUS *reg, unsigned int f1_udf_en)
{
  reg->bitfields.F1_UDF_EN = f1_udf_en;
  if (reg->bitfields.F1_UDF_EN != f1_udf_en) HSLDPF(E_ERROR_MESSAGE,"F1_STATUS::F1_UDF_EN data too large\n");
}
__inline void set_F1_STATUS_f1_fast_back_capable(regF1_STATUS *reg, unsigned int f1_fast_back_capable)
{
  reg->bitfields.F1_FAST_BACK_CAPABLE = f1_fast_back_capable;
  if (reg->bitfields.F1_FAST_BACK_CAPABLE != f1_fast_back_capable) HSLDPF(E_ERROR_MESSAGE,"F1_STATUS::F1_FAST_BACK_CAPABLE data too large\n");
}
__inline void set_F1_STATUS_f1_devsel_timing(regF1_STATUS *reg, unsigned int f1_devsel_timing)
{
  reg->bitfields.F1_DEVSEL_TIMING = f1_devsel_timing;
  if (reg->bitfields.F1_DEVSEL_TIMING != f1_devsel_timing) HSLDPF(E_ERROR_MESSAGE,"F1_STATUS::F1_DEVSEL_TIMING data too large\n");
}
__inline void set_F1_STATUS_f1_signal_target_abort(regF1_STATUS *reg, unsigned int f1_signal_target_abort)
{
  reg->bitfields.F1_SIGNAL_TARGET_ABORT = f1_signal_target_abort;
  if (reg->bitfields.F1_SIGNAL_TARGET_ABORT != f1_signal_target_abort) HSLDPF(E_ERROR_MESSAGE,"F1_STATUS::F1_SIGNAL_TARGET_ABORT data too large\n");
}
__inline void set_F1_STATUS_f1_received_target_abort(regF1_STATUS *reg, unsigned int f1_received_target_abort)
{
  reg->bitfields.F1_RECEIVED_TARGET_ABORT = f1_received_target_abort;
  if (reg->bitfields.F1_RECEIVED_TARGET_ABORT != f1_received_target_abort) HSLDPF(E_ERROR_MESSAGE,"F1_STATUS::F1_RECEIVED_TARGET_ABORT data too large\n");
}
__inline void set_F1_STATUS_f1_received_master_abort(regF1_STATUS *reg, unsigned int f1_received_master_abort)
{
  reg->bitfields.F1_RECEIVED_MASTER_ABORT = f1_received_master_abort;
  if (reg->bitfields.F1_RECEIVED_MASTER_ABORT != f1_received_master_abort) HSLDPF(E_ERROR_MESSAGE,"F1_STATUS::F1_RECEIVED_MASTER_ABORT data too large\n");
}
__inline void set_F1_STATUS_f1_parity_error_detected(regF1_STATUS *reg, unsigned int f1_parity_error_detected)
{
  reg->bitfields.F1_PARITY_ERROR_DETECTED = f1_parity_error_detected;
  if (reg->bitfields.F1_PARITY_ERROR_DETECTED != f1_parity_error_detected) HSLDPF(E_ERROR_MESSAGE,"F1_STATUS::F1_PARITY_ERROR_DETECTED data too large\n");
}
#else
#define set_F1_STATUS_f1_cap_list(reg, f1_cap_list) (reg)->bitfields.F1_CAP_LIST = f1_cap_list
#define set_F1_STATUS_f1_pci_66_en(reg, f1_pci_66_en) (reg)->bitfields.F1_PCI_66_EN = f1_pci_66_en
#define set_F1_STATUS_f1_udf_en(reg, f1_udf_en) (reg)->bitfields.F1_UDF_EN = f1_udf_en
#define set_F1_STATUS_f1_fast_back_capable(reg, f1_fast_back_capable) (reg)->bitfields.F1_FAST_BACK_CAPABLE = f1_fast_back_capable
#define set_F1_STATUS_f1_devsel_timing(reg, f1_devsel_timing) (reg)->bitfields.F1_DEVSEL_TIMING = f1_devsel_timing
#define set_F1_STATUS_f1_signal_target_abort(reg, f1_signal_target_abort) (reg)->bitfields.F1_SIGNAL_TARGET_ABORT = f1_signal_target_abort
#define set_F1_STATUS_f1_received_target_abort(reg, f1_received_target_abort) (reg)->bitfields.F1_RECEIVED_TARGET_ABORT = f1_received_target_abort
#define set_F1_STATUS_f1_received_master_abort(reg, f1_received_master_abort) (reg)->bitfields.F1_RECEIVED_MASTER_ABORT = f1_received_master_abort
#define set_F1_STATUS_f1_parity_error_detected(reg, f1_parity_error_detected) (reg)->bitfields.F1_PARITY_ERROR_DETECTED = f1_parity_error_detected

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_REVISION_ID regF1_REVISION_ID;

#ifdef DEBUG
__inline void set_F1_REVISION_ID_f1_minor_rev_id(regF1_REVISION_ID *reg, unsigned int f1_minor_rev_id)
{
  reg->bitfields.F1_MINOR_REV_ID = f1_minor_rev_id;
  if (reg->bitfields.F1_MINOR_REV_ID != f1_minor_rev_id) HSLDPF(E_ERROR_MESSAGE,"F1_REVISION_ID::F1_MINOR_REV_ID data too large\n");
}
__inline void set_F1_REVISION_ID_f1_major_rev_id(regF1_REVISION_ID *reg, unsigned int f1_major_rev_id)
{
  reg->bitfields.F1_MAJOR_REV_ID = f1_major_rev_id;
  if (reg->bitfields.F1_MAJOR_REV_ID != f1_major_rev_id) HSLDPF(E_ERROR_MESSAGE,"F1_REVISION_ID::F1_MAJOR_REV_ID data too large\n");
}
#else
#define set_F1_REVISION_ID_f1_minor_rev_id(reg, f1_minor_rev_id) (reg)->bitfields.F1_MINOR_REV_ID = f1_minor_rev_id
#define set_F1_REVISION_ID_f1_major_rev_id(reg, f1_major_rev_id) (reg)->bitfields.F1_MAJOR_REV_ID = f1_major_rev_id

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_REGPROG_INF regF1_REGPROG_INF;

#ifdef DEBUG
__inline void set_F1_REGPROG_INF_f1_reg_level_prog_inf(regF1_REGPROG_INF *reg, unsigned int f1_reg_level_prog_inf)
{
  reg->bitfields.F1_REG_LEVEL_PROG_INF = f1_reg_level_prog_inf;
  if (reg->bitfields.F1_REG_LEVEL_PROG_INF != f1_reg_level_prog_inf) HSLDPF(E_ERROR_MESSAGE,"F1_REGPROG_INF::F1_REG_LEVEL_PROG_INF data too large\n");
}
#else
#define set_F1_REGPROG_INF_f1_reg_level_prog_inf(reg, f1_reg_level_prog_inf) (reg)->bitfields.F1_REG_LEVEL_PROG_INF = f1_reg_level_prog_inf

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_SUB_CLASS regF1_SUB_CLASS;

#ifdef DEBUG
__inline void set_F1_SUB_CLASS_f1_sub_class_inf(regF1_SUB_CLASS *reg, unsigned int f1_sub_class_inf)
{
  reg->bitfields.F1_SUB_CLASS_INF = f1_sub_class_inf;
  if (reg->bitfields.F1_SUB_CLASS_INF != f1_sub_class_inf) HSLDPF(E_ERROR_MESSAGE,"F1_SUB_CLASS::F1_SUB_CLASS_INF data too large\n");
}
#else
#define set_F1_SUB_CLASS_f1_sub_class_inf(reg, f1_sub_class_inf) (reg)->bitfields.F1_SUB_CLASS_INF = f1_sub_class_inf

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_BASE_CODE regF1_BASE_CODE;

#ifdef DEBUG
__inline void set_F1_BASE_CODE_f1_base_class_code(regF1_BASE_CODE *reg, unsigned int f1_base_class_code)
{
  reg->bitfields.F1_BASE_CLASS_CODE = f1_base_class_code;
  if (reg->bitfields.F1_BASE_CLASS_CODE != f1_base_class_code) HSLDPF(E_ERROR_MESSAGE,"F1_BASE_CODE::F1_BASE_CLASS_CODE data too large\n");
}
#else
#define set_F1_BASE_CODE_f1_base_class_code(reg, f1_base_class_code) (reg)->bitfields.F1_BASE_CLASS_CODE = f1_base_class_code

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_CACHE_LINE regF1_CACHE_LINE;

#ifdef DEBUG
__inline void set_F1_CACHE_LINE_f1_cache_line_size(regF1_CACHE_LINE *reg, unsigned int f1_cache_line_size)
{
  reg->bitfields.F1_CACHE_LINE_SIZE = f1_cache_line_size;
  if (reg->bitfields.F1_CACHE_LINE_SIZE != f1_cache_line_size) HSLDPF(E_ERROR_MESSAGE,"F1_CACHE_LINE::F1_CACHE_LINE_SIZE data too large\n");
}
#else
#define set_F1_CACHE_LINE_f1_cache_line_size(reg, f1_cache_line_size) (reg)->bitfields.F1_CACHE_LINE_SIZE = f1_cache_line_size

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_LATENCY regF1_LATENCY;

#ifdef DEBUG
__inline void set_F1_LATENCY_f1_latency_timer(regF1_LATENCY *reg, unsigned int f1_latency_timer)
{
  reg->bitfields.F1_LATENCY_TIMER = f1_latency_timer;
  if (reg->bitfields.F1_LATENCY_TIMER != f1_latency_timer) HSLDPF(E_ERROR_MESSAGE,"F1_LATENCY::F1_LATENCY_TIMER data too large\n");
}
#else
#define set_F1_LATENCY_f1_latency_timer(reg, f1_latency_timer) (reg)->bitfields.F1_LATENCY_TIMER = f1_latency_timer

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_HEADER regF1_HEADER;

#ifdef DEBUG
__inline void set_F1_HEADER_f1_header_type(regF1_HEADER *reg, unsigned int f1_header_type)
{
  reg->bitfields.F1_HEADER_TYPE = f1_header_type;
  if (reg->bitfields.F1_HEADER_TYPE != f1_header_type) HSLDPF(E_ERROR_MESSAGE,"F1_HEADER::F1_HEADER_TYPE data too large\n");
}
__inline void set_F1_HEADER_f1_device_type(regF1_HEADER *reg, unsigned int f1_device_type)
{
  reg->bitfields.F1_DEVICE_TYPE = f1_device_type;
  if (reg->bitfields.F1_DEVICE_TYPE != f1_device_type) HSLDPF(E_ERROR_MESSAGE,"F1_HEADER::F1_DEVICE_TYPE data too large\n");
}
#else
#define set_F1_HEADER_f1_header_type(reg, f1_header_type) (reg)->bitfields.F1_HEADER_TYPE = f1_header_type
#define set_F1_HEADER_f1_device_type(reg, f1_device_type) (reg)->bitfields.F1_DEVICE_TYPE = f1_device_type

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_BIST regF1_BIST;

#ifdef DEBUG
__inline void set_F1_BIST_f1_bist_comp(regF1_BIST *reg, unsigned int f1_bist_comp)
{
  reg->bitfields.F1_BIST_COMP = f1_bist_comp;
  if (reg->bitfields.F1_BIST_COMP != f1_bist_comp) HSLDPF(E_ERROR_MESSAGE,"F1_BIST::F1_BIST_COMP data too large\n");
}
__inline void set_F1_BIST_f1_bist_strt(regF1_BIST *reg, unsigned int f1_bist_strt)
{
  reg->bitfields.F1_BIST_STRT = f1_bist_strt;
  if (reg->bitfields.F1_BIST_STRT != f1_bist_strt) HSLDPF(E_ERROR_MESSAGE,"F1_BIST::F1_BIST_STRT data too large\n");
}
__inline void set_F1_BIST_f1_bist_cap(regF1_BIST *reg, unsigned int f1_bist_cap)
{
  reg->bitfields.F1_BIST_CAP = f1_bist_cap;
  if (reg->bitfields.F1_BIST_CAP != f1_bist_cap) HSLDPF(E_ERROR_MESSAGE,"F1_BIST::F1_BIST_CAP data too large\n");
}
#else
#define set_F1_BIST_f1_bist_comp(reg, f1_bist_comp) (reg)->bitfields.F1_BIST_COMP = f1_bist_comp
#define set_F1_BIST_f1_bist_strt(reg, f1_bist_strt) (reg)->bitfields.F1_BIST_STRT = f1_bist_strt
#define set_F1_BIST_f1_bist_cap(reg, f1_bist_cap) (reg)->bitfields.F1_BIST_CAP = f1_bist_cap

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_MEM_BASE regF1_MEM_BASE;

#ifdef DEBUG
__inline void set_F1_MEM_BASE_f1_prefetch_en(regF1_MEM_BASE *reg, unsigned int f1_prefetch_en)
{
  reg->bitfields.F1_PREFETCH_EN = f1_prefetch_en;
  if (reg->bitfields.F1_PREFETCH_EN != f1_prefetch_en) HSLDPF(E_ERROR_MESSAGE,"F1_MEM_BASE::F1_PREFETCH_EN data too large\n");
}
__inline void set_F1_MEM_BASE_f1_mem_base(regF1_MEM_BASE *reg, unsigned int f1_mem_base)
{
  reg->bitfields.F1_MEM_BASE = f1_mem_base;
  if (reg->bitfields.F1_MEM_BASE != f1_mem_base) HSLDPF(E_ERROR_MESSAGE,"F1_MEM_BASE::F1_MEM_BASE data too large\n");
}
#else
#define set_F1_MEM_BASE_f1_prefetch_en(reg, f1_prefetch_en) (reg)->bitfields.F1_PREFETCH_EN = f1_prefetch_en
#define set_F1_MEM_BASE_f1_mem_base(reg, f1_mem_base) (reg)->bitfields.F1_MEM_BASE = f1_mem_base

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_REG_BASE regF1_REG_BASE;

#ifdef DEBUG
__inline void set_F1_REG_BASE_f1_reg_base(regF1_REG_BASE *reg, unsigned int f1_reg_base)
{
  reg->bitfields.F1_REG_BASE = f1_reg_base;
  if (reg->bitfields.F1_REG_BASE != f1_reg_base) HSLDPF(E_ERROR_MESSAGE,"F1_REG_BASE::F1_REG_BASE data too large\n");
}
#else
#define set_F1_REG_BASE_f1_reg_base(reg, f1_reg_base) (reg)->bitfields.F1_REG_BASE = f1_reg_base

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_ADAPTER_ID regF1_ADAPTER_ID;

#ifdef DEBUG
__inline void set_F1_ADAPTER_ID_f1_subsystem_vendor_id(regF1_ADAPTER_ID *reg, unsigned int f1_subsystem_vendor_id)
{
  reg->bitfields.F1_SUBSYSTEM_VENDOR_ID = f1_subsystem_vendor_id;
  if (reg->bitfields.F1_SUBSYSTEM_VENDOR_ID != f1_subsystem_vendor_id) HSLDPF(E_ERROR_MESSAGE,"F1_ADAPTER_ID::F1_SUBSYSTEM_VENDOR_ID data too large\n");
}
__inline void set_F1_ADAPTER_ID_f1_subsystem_id(regF1_ADAPTER_ID *reg, unsigned int f1_subsystem_id)
{
  reg->bitfields.F1_SUBSYSTEM_ID = f1_subsystem_id;
  if (reg->bitfields.F1_SUBSYSTEM_ID != f1_subsystem_id) HSLDPF(E_ERROR_MESSAGE,"F1_ADAPTER_ID::F1_SUBSYSTEM_ID data too large\n");
}
#else
#define set_F1_ADAPTER_ID_f1_subsystem_vendor_id(reg, f1_subsystem_vendor_id) (reg)->bitfields.F1_SUBSYSTEM_VENDOR_ID = f1_subsystem_vendor_id
#define set_F1_ADAPTER_ID_f1_subsystem_id(reg, f1_subsystem_id) (reg)->bitfields.F1_SUBSYSTEM_ID = f1_subsystem_id

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_CAPABILITIES_PTR regF1_CAPABILITIES_PTR;

#ifdef DEBUG
__inline void set_F1_CAPABILITIES_PTR_f1_cap_ptr(regF1_CAPABILITIES_PTR *reg, unsigned int f1_cap_ptr)
{
  reg->bitfields.F1_CAP_PTR = f1_cap_ptr;
  if (reg->bitfields.F1_CAP_PTR != f1_cap_ptr) HSLDPF(E_ERROR_MESSAGE,"F1_CAPABILITIES_PTR::F1_CAP_PTR data too large\n");
}
#else
#define set_F1_CAPABILITIES_PTR_f1_cap_ptr(reg, f1_cap_ptr) (reg)->bitfields.F1_CAP_PTR = f1_cap_ptr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_INTERRUPT_LINE regF1_INTERRUPT_LINE;

#ifdef DEBUG
__inline void set_F1_INTERRUPT_LINE_f1_interrupt_line(regF1_INTERRUPT_LINE *reg, unsigned int f1_interrupt_line)
{
  reg->bitfields.F1_INTERRUPT_LINE = f1_interrupt_line;
  if (reg->bitfields.F1_INTERRUPT_LINE != f1_interrupt_line) HSLDPF(E_ERROR_MESSAGE,"F1_INTERRUPT_LINE::F1_INTERRUPT_LINE data too large\n");
}
#else
#define set_F1_INTERRUPT_LINE_f1_interrupt_line(reg, f1_interrupt_line) (reg)->bitfields.F1_INTERRUPT_LINE = f1_interrupt_line

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_INTERRUPT_PIN regF1_INTERRUPT_PIN;

#ifdef DEBUG
__inline void set_F1_INTERRUPT_PIN_f1_interrupt_pin(regF1_INTERRUPT_PIN *reg, unsigned int f1_interrupt_pin)
{
  reg->bitfields.F1_INTERRUPT_PIN = f1_interrupt_pin;
  if (reg->bitfields.F1_INTERRUPT_PIN != f1_interrupt_pin) HSLDPF(E_ERROR_MESSAGE,"F1_INTERRUPT_PIN::F1_INTERRUPT_PIN data too large\n");
}
#else
#define set_F1_INTERRUPT_PIN_f1_interrupt_pin(reg, f1_interrupt_pin) (reg)->bitfields.F1_INTERRUPT_PIN = f1_interrupt_pin

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_MIN_GRANT regF1_MIN_GRANT;

#ifdef DEBUG
__inline void set_F1_MIN_GRANT_f1_min_gnt(regF1_MIN_GRANT *reg, unsigned int f1_min_gnt)
{
  reg->bitfields.F1_MIN_GNT = f1_min_gnt;
  if (reg->bitfields.F1_MIN_GNT != f1_min_gnt) HSLDPF(E_ERROR_MESSAGE,"F1_MIN_GRANT::F1_MIN_GNT data too large\n");
}
#else
#define set_F1_MIN_GRANT_f1_min_gnt(reg, f1_min_gnt) (reg)->bitfields.F1_MIN_GNT = f1_min_gnt

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_MAX_LATENCY regF1_MAX_LATENCY;

#ifdef DEBUG
__inline void set_F1_MAX_LATENCY_f1_max_lat(regF1_MAX_LATENCY *reg, unsigned int f1_max_lat)
{
  reg->bitfields.F1_MAX_LAT = f1_max_lat;
  if (reg->bitfields.F1_MAX_LAT != f1_max_lat) HSLDPF(E_ERROR_MESSAGE,"F1_MAX_LATENCY::F1_MAX_LAT data too large\n");
}
#else
#define set_F1_MAX_LATENCY_f1_max_lat(reg, f1_max_lat) (reg)->bitfields.F1_MAX_LAT = f1_max_lat

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_PMI_CAP_ID regF1_PMI_CAP_ID;

#ifdef DEBUG
__inline void set_F1_PMI_CAP_ID_f1_pmi_cap_id(regF1_PMI_CAP_ID *reg, unsigned int f1_pmi_cap_id)
{
  reg->bitfields.F1_PMI_CAP_ID = f1_pmi_cap_id;
  if (reg->bitfields.F1_PMI_CAP_ID != f1_pmi_cap_id) HSLDPF(E_ERROR_MESSAGE,"F1_PMI_CAP_ID::F1_PMI_CAP_ID data too large\n");
}
#else
#define set_F1_PMI_CAP_ID_f1_pmi_cap_id(reg, f1_pmi_cap_id) (reg)->bitfields.F1_PMI_CAP_ID = f1_pmi_cap_id

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_PMI_NXT_CAP_PTR regF1_PMI_NXT_CAP_PTR;

#ifdef DEBUG
__inline void set_F1_PMI_NXT_CAP_PTR_f1_pmi_nxt_cap_ptr(regF1_PMI_NXT_CAP_PTR *reg, unsigned int f1_pmi_nxt_cap_ptr)
{
  reg->bitfields.F1_PMI_NXT_CAP_PTR = f1_pmi_nxt_cap_ptr;
  if (reg->bitfields.F1_PMI_NXT_CAP_PTR != f1_pmi_nxt_cap_ptr) HSLDPF(E_ERROR_MESSAGE,"F1_PMI_NXT_CAP_PTR::F1_PMI_NXT_CAP_PTR data too large\n");
}
#else
#define set_F1_PMI_NXT_CAP_PTR_f1_pmi_nxt_cap_ptr(reg, f1_pmi_nxt_cap_ptr) (reg)->bitfields.F1_PMI_NXT_CAP_PTR = f1_pmi_nxt_cap_ptr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_PMI_PMC_REG regF1_PMI_PMC_REG;

#ifdef DEBUG
__inline void set_F1_PMI_PMC_REG_f1_pmi_version(regF1_PMI_PMC_REG *reg, unsigned int f1_pmi_version)
{
  reg->bitfields.F1_PMI_VERSION = f1_pmi_version;
  if (reg->bitfields.F1_PMI_VERSION != f1_pmi_version) HSLDPF(E_ERROR_MESSAGE,"F1_PMI_PMC_REG::F1_PMI_VERSION data too large\n");
}
__inline void set_F1_PMI_PMC_REG_f1_pmi_pme_clock(regF1_PMI_PMC_REG *reg, unsigned int f1_pmi_pme_clock)
{
  reg->bitfields.F1_PMI_PME_CLOCK = f1_pmi_pme_clock;
  if (reg->bitfields.F1_PMI_PME_CLOCK != f1_pmi_pme_clock) HSLDPF(E_ERROR_MESSAGE,"F1_PMI_PMC_REG::F1_PMI_PME_CLOCK data too large\n");
}
__inline void set_F1_PMI_PMC_REG_f1_pmi_dev_specific_init(regF1_PMI_PMC_REG *reg, unsigned int f1_pmi_dev_specific_init)
{
  reg->bitfields.F1_PMI_DEV_SPECIFIC_INIT = f1_pmi_dev_specific_init;
  if (reg->bitfields.F1_PMI_DEV_SPECIFIC_INIT != f1_pmi_dev_specific_init) HSLDPF(E_ERROR_MESSAGE,"F1_PMI_PMC_REG::F1_PMI_DEV_SPECIFIC_INIT data too large\n");
}
__inline void set_F1_PMI_PMC_REG_f1_pmi_d1_support(regF1_PMI_PMC_REG *reg, unsigned int f1_pmi_d1_support)
{
  reg->bitfields.F1_PMI_D1_SUPPORT = f1_pmi_d1_support;
  if (reg->bitfields.F1_PMI_D1_SUPPORT != f1_pmi_d1_support) HSLDPF(E_ERROR_MESSAGE,"F1_PMI_PMC_REG::F1_PMI_D1_SUPPORT data too large\n");
}
__inline void set_F1_PMI_PMC_REG_f1_pmi_d2_support(regF1_PMI_PMC_REG *reg, unsigned int f1_pmi_d2_support)
{
  reg->bitfields.F1_PMI_D2_SUPPORT = f1_pmi_d2_support;
  if (reg->bitfields.F1_PMI_D2_SUPPORT != f1_pmi_d2_support) HSLDPF(E_ERROR_MESSAGE,"F1_PMI_PMC_REG::F1_PMI_D2_SUPPORT data too large\n");
}
__inline void set_F1_PMI_PMC_REG_f1_pmi_pme_support(regF1_PMI_PMC_REG *reg, unsigned int f1_pmi_pme_support)
{
  reg->bitfields.F1_PMI_PME_SUPPORT = f1_pmi_pme_support;
  if (reg->bitfields.F1_PMI_PME_SUPPORT != f1_pmi_pme_support) HSLDPF(E_ERROR_MESSAGE,"F1_PMI_PMC_REG::F1_PMI_PME_SUPPORT data too large\n");
}
#else
#define set_F1_PMI_PMC_REG_f1_pmi_version(reg, f1_pmi_version) (reg)->bitfields.F1_PMI_VERSION = f1_pmi_version
#define set_F1_PMI_PMC_REG_f1_pmi_pme_clock(reg, f1_pmi_pme_clock) (reg)->bitfields.F1_PMI_PME_CLOCK = f1_pmi_pme_clock
#define set_F1_PMI_PMC_REG_f1_pmi_dev_specific_init(reg, f1_pmi_dev_specific_init) (reg)->bitfields.F1_PMI_DEV_SPECIFIC_INIT = f1_pmi_dev_specific_init
#define set_F1_PMI_PMC_REG_f1_pmi_d1_support(reg, f1_pmi_d1_support) (reg)->bitfields.F1_PMI_D1_SUPPORT = f1_pmi_d1_support
#define set_F1_PMI_PMC_REG_f1_pmi_d2_support(reg, f1_pmi_d2_support) (reg)->bitfields.F1_PMI_D2_SUPPORT = f1_pmi_d2_support
#define set_F1_PMI_PMC_REG_f1_pmi_pme_support(reg, f1_pmi_pme_support) (reg)->bitfields.F1_PMI_PME_SUPPORT = f1_pmi_pme_support

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_PM_STATUS regF1_PM_STATUS;

#ifdef DEBUG
__inline void set_F1_PM_STATUS_f1_pmi_power_state(regF1_PM_STATUS *reg, unsigned int f1_pmi_power_state)
{
  reg->bitfields.F1_PMI_POWER_STATE = f1_pmi_power_state;
  if (reg->bitfields.F1_PMI_POWER_STATE != f1_pmi_power_state) HSLDPF(E_ERROR_MESSAGE,"F1_PM_STATUS::F1_PMI_POWER_STATE data too large\n");
}
__inline void set_F1_PM_STATUS_f1_pmi_pme_en(regF1_PM_STATUS *reg, unsigned int f1_pmi_pme_en)
{
  reg->bitfields.F1_PMI_PME_EN = f1_pmi_pme_en;
  if (reg->bitfields.F1_PMI_PME_EN != f1_pmi_pme_en) HSLDPF(E_ERROR_MESSAGE,"F1_PM_STATUS::F1_PMI_PME_EN data too large\n");
}
__inline void set_F1_PM_STATUS_f1_pmi_data_select(regF1_PM_STATUS *reg, unsigned int f1_pmi_data_select)
{
  reg->bitfields.F1_PMI_DATA_SELECT = f1_pmi_data_select;
  if (reg->bitfields.F1_PMI_DATA_SELECT != f1_pmi_data_select) HSLDPF(E_ERROR_MESSAGE,"F1_PM_STATUS::F1_PMI_DATA_SELECT data too large\n");
}
__inline void set_F1_PM_STATUS_f1_pmi_data_scale(regF1_PM_STATUS *reg, unsigned int f1_pmi_data_scale)
{
  reg->bitfields.F1_PMI_DATA_SCALE = f1_pmi_data_scale;
  if (reg->bitfields.F1_PMI_DATA_SCALE != f1_pmi_data_scale) HSLDPF(E_ERROR_MESSAGE,"F1_PM_STATUS::F1_PMI_DATA_SCALE data too large\n");
}
__inline void set_F1_PM_STATUS_f1_pmi_pme_status(regF1_PM_STATUS *reg, unsigned int f1_pmi_pme_status)
{
  reg->bitfields.F1_PMI_PME_STATUS = f1_pmi_pme_status;
  if (reg->bitfields.F1_PMI_PME_STATUS != f1_pmi_pme_status) HSLDPF(E_ERROR_MESSAGE,"F1_PM_STATUS::F1_PMI_PME_STATUS data too large\n");
}
#else
#define set_F1_PM_STATUS_f1_pmi_power_state(reg, f1_pmi_power_state) (reg)->bitfields.F1_PMI_POWER_STATE = f1_pmi_power_state
#define set_F1_PM_STATUS_f1_pmi_pme_en(reg, f1_pmi_pme_en) (reg)->bitfields.F1_PMI_PME_EN = f1_pmi_pme_en
#define set_F1_PM_STATUS_f1_pmi_data_select(reg, f1_pmi_data_select) (reg)->bitfields.F1_PMI_DATA_SELECT = f1_pmi_data_select
#define set_F1_PM_STATUS_f1_pmi_data_scale(reg, f1_pmi_data_scale) (reg)->bitfields.F1_PMI_DATA_SCALE = f1_pmi_data_scale
#define set_F1_PM_STATUS_f1_pmi_pme_status(reg, f1_pmi_pme_status) (reg)->bitfields.F1_PMI_PME_STATUS = f1_pmi_pme_status

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_PMI_DATA regF1_PMI_DATA;

#ifdef DEBUG
__inline void set_F1_PMI_DATA_f1_pmi_data(regF1_PMI_DATA *reg, unsigned int f1_pmi_data)
{
  reg->bitfields.F1_PMI_DATA = f1_pmi_data;
  if (reg->bitfields.F1_PMI_DATA != f1_pmi_data) HSLDPF(E_ERROR_MESSAGE,"F1_PMI_DATA::F1_PMI_DATA data too large\n");
}
#else
#define set_F1_PMI_DATA_f1_pmi_data(reg, f1_pmi_data) (reg)->bitfields.F1_PMI_DATA = f1_pmi_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_AGP_CAP_ID regF1_AGP_CAP_ID;

#ifdef DEBUG
__inline void set_F1_AGP_CAP_ID_f1_cap_id(regF1_AGP_CAP_ID *reg, unsigned int f1_cap_id)
{
  reg->bitfields.F1_CAP_ID = f1_cap_id;
  if (reg->bitfields.F1_CAP_ID != f1_cap_id) HSLDPF(E_ERROR_MESSAGE,"F1_AGP_CAP_ID::F1_CAP_ID data too large\n");
}
__inline void set_F1_AGP_CAP_ID_f1_next_ptr(regF1_AGP_CAP_ID *reg, unsigned int f1_next_ptr)
{
  reg->bitfields.F1_NEXT_PTR = f1_next_ptr;
  if (reg->bitfields.F1_NEXT_PTR != f1_next_ptr) HSLDPF(E_ERROR_MESSAGE,"F1_AGP_CAP_ID::F1_NEXT_PTR data too large\n");
}
__inline void set_F1_AGP_CAP_ID_f1_agp_minor(regF1_AGP_CAP_ID *reg, unsigned int f1_agp_minor)
{
  reg->bitfields.F1_AGP_MINOR = f1_agp_minor;
  if (reg->bitfields.F1_AGP_MINOR != f1_agp_minor) HSLDPF(E_ERROR_MESSAGE,"F1_AGP_CAP_ID::F1_AGP_MINOR data too large\n");
}
__inline void set_F1_AGP_CAP_ID_f1_agp_major(regF1_AGP_CAP_ID *reg, unsigned int f1_agp_major)
{
  reg->bitfields.F1_AGP_MAJOR = f1_agp_major;
  if (reg->bitfields.F1_AGP_MAJOR != f1_agp_major) HSLDPF(E_ERROR_MESSAGE,"F1_AGP_CAP_ID::F1_AGP_MAJOR data too large\n");
}
#else
#define set_F1_AGP_CAP_ID_f1_cap_id(reg, f1_cap_id) (reg)->bitfields.F1_CAP_ID = f1_cap_id
#define set_F1_AGP_CAP_ID_f1_next_ptr(reg, f1_next_ptr) (reg)->bitfields.F1_NEXT_PTR = f1_next_ptr
#define set_F1_AGP_CAP_ID_f1_agp_minor(reg, f1_agp_minor) (reg)->bitfields.F1_AGP_MINOR = f1_agp_minor
#define set_F1_AGP_CAP_ID_f1_agp_major(reg, f1_agp_major) (reg)->bitfields.F1_AGP_MAJOR = f1_agp_major

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_AGP_STATUS regF1_AGP_STATUS;

#ifdef DEBUG
__inline void set_F1_AGP_STATUS_f1_rate1x(regF1_AGP_STATUS *reg, unsigned int f1_rate1x)
{
  reg->bitfields.F1_RATE1X = f1_rate1x;
  if (reg->bitfields.F1_RATE1X != f1_rate1x) HSLDPF(E_ERROR_MESSAGE,"F1_AGP_STATUS::F1_RATE1X data too large\n");
}
__inline void set_F1_AGP_STATUS_f1_rate2x(regF1_AGP_STATUS *reg, unsigned int f1_rate2x)
{
  reg->bitfields.F1_RATE2X = f1_rate2x;
  if (reg->bitfields.F1_RATE2X != f1_rate2x) HSLDPF(E_ERROR_MESSAGE,"F1_AGP_STATUS::F1_RATE2X data too large\n");
}
__inline void set_F1_AGP_STATUS_f1_rate4x(regF1_AGP_STATUS *reg, unsigned int f1_rate4x)
{
  reg->bitfields.F1_RATE4X = f1_rate4x;
  if (reg->bitfields.F1_RATE4X != f1_rate4x) HSLDPF(E_ERROR_MESSAGE,"F1_AGP_STATUS::F1_RATE4X data too large\n");
}
__inline void set_F1_AGP_STATUS_f1_fw(regF1_AGP_STATUS *reg, unsigned int f1_fw)
{
  reg->bitfields.F1_FW = f1_fw;
  if (reg->bitfields.F1_FW != f1_fw) HSLDPF(E_ERROR_MESSAGE,"F1_AGP_STATUS::F1_FW data too large\n");
}
__inline void set_F1_AGP_STATUS_f1_mode_4g(regF1_AGP_STATUS *reg, unsigned int f1_mode_4g)
{
  reg->bitfields.F1_MODE_4G = f1_mode_4g;
  if (reg->bitfields.F1_MODE_4G != f1_mode_4g) HSLDPF(E_ERROR_MESSAGE,"F1_AGP_STATUS::F1_MODE_4G data too large\n");
}
__inline void set_F1_AGP_STATUS_f1_sba(regF1_AGP_STATUS *reg, unsigned int f1_sba)
{
  reg->bitfields.F1_SBA = f1_sba;
  if (reg->bitfields.F1_SBA != f1_sba) HSLDPF(E_ERROR_MESSAGE,"F1_AGP_STATUS::F1_SBA data too large\n");
}
__inline void set_F1_AGP_STATUS_f1_rq(regF1_AGP_STATUS *reg, unsigned int f1_rq)
{
  reg->bitfields.F1_RQ = f1_rq;
  if (reg->bitfields.F1_RQ != f1_rq) HSLDPF(E_ERROR_MESSAGE,"F1_AGP_STATUS::F1_RQ data too large\n");
}
#else
#define set_F1_AGP_STATUS_f1_rate1x(reg, f1_rate1x) (reg)->bitfields.F1_RATE1X = f1_rate1x
#define set_F1_AGP_STATUS_f1_rate2x(reg, f1_rate2x) (reg)->bitfields.F1_RATE2X = f1_rate2x
#define set_F1_AGP_STATUS_f1_rate4x(reg, f1_rate4x) (reg)->bitfields.F1_RATE4X = f1_rate4x
#define set_F1_AGP_STATUS_f1_fw(reg, f1_fw) (reg)->bitfields.F1_FW = f1_fw
#define set_F1_AGP_STATUS_f1_mode_4g(reg, f1_mode_4g) (reg)->bitfields.F1_MODE_4G = f1_mode_4g
#define set_F1_AGP_STATUS_f1_sba(reg, f1_sba) (reg)->bitfields.F1_SBA = f1_sba
#define set_F1_AGP_STATUS_f1_rq(reg, f1_rq) (reg)->bitfields.F1_RQ = f1_rq

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union F1_AGP_COMMAND regF1_AGP_COMMAND;

#ifdef DEBUG
__inline void set_F1_AGP_COMMAND_f1_data_rate(regF1_AGP_COMMAND *reg, unsigned int f1_data_rate)
{
  reg->bitfields.F1_DATA_RATE = f1_data_rate;
  if (reg->bitfields.F1_DATA_RATE != f1_data_rate) HSLDPF(E_ERROR_MESSAGE,"F1_AGP_COMMAND::F1_DATA_RATE data too large\n");
}
__inline void set_F1_AGP_COMMAND_f1_fw_en(regF1_AGP_COMMAND *reg, unsigned int f1_fw_en)
{
  reg->bitfields.F1_FW_EN = f1_fw_en;
  if (reg->bitfields.F1_FW_EN != f1_fw_en) HSLDPF(E_ERROR_MESSAGE,"F1_AGP_COMMAND::F1_FW_EN data too large\n");
}
__inline void set_F1_AGP_COMMAND_f1_mode_4g_en(regF1_AGP_COMMAND *reg, unsigned int f1_mode_4g_en)
{
  reg->bitfields.F1_MODE_4G_EN = f1_mode_4g_en;
  if (reg->bitfields.F1_MODE_4G_EN != f1_mode_4g_en) HSLDPF(E_ERROR_MESSAGE,"F1_AGP_COMMAND::F1_MODE_4G_EN data too large\n");
}
__inline void set_F1_AGP_COMMAND_f1_agp_en(regF1_AGP_COMMAND *reg, unsigned int f1_agp_en)
{
  reg->bitfields.F1_AGP_EN = f1_agp_en;
  if (reg->bitfields.F1_AGP_EN != f1_agp_en) HSLDPF(E_ERROR_MESSAGE,"F1_AGP_COMMAND::F1_AGP_EN data too large\n");
}
__inline void set_F1_AGP_COMMAND_f1_sba_en(regF1_AGP_COMMAND *reg, unsigned int f1_sba_en)
{
  reg->bitfields.F1_SBA_EN = f1_sba_en;
  if (reg->bitfields.F1_SBA_EN != f1_sba_en) HSLDPF(E_ERROR_MESSAGE,"F1_AGP_COMMAND::F1_SBA_EN data too large\n");
}
__inline void set_F1_AGP_COMMAND_f1_rq_depth(regF1_AGP_COMMAND *reg, unsigned int f1_rq_depth)
{
  reg->bitfields.F1_RQ_DEPTH = f1_rq_depth;
  if (reg->bitfields.F1_RQ_DEPTH != f1_rq_depth) HSLDPF(E_ERROR_MESSAGE,"F1_AGP_COMMAND::F1_RQ_DEPTH data too large\n");
}
#else
#define set_F1_AGP_COMMAND_f1_data_rate(reg, f1_data_rate) (reg)->bitfields.F1_DATA_RATE = f1_data_rate
#define set_F1_AGP_COMMAND_f1_fw_en(reg, f1_fw_en) (reg)->bitfields.F1_FW_EN = f1_fw_en
#define set_F1_AGP_COMMAND_f1_mode_4g_en(reg, f1_mode_4g_en) (reg)->bitfields.F1_MODE_4G_EN = f1_mode_4g_en
#define set_F1_AGP_COMMAND_f1_agp_en(reg, f1_agp_en) (reg)->bitfields.F1_AGP_EN = f1_agp_en
#define set_F1_AGP_COMMAND_f1_sba_en(reg, f1_sba_en) (reg)->bitfields.F1_SBA_EN = f1_sba_en
#define set_F1_AGP_COMMAND_f1_rq_depth(reg, f1_rq_depth) (reg)->bitfields.F1_RQ_DEPTH = f1_rq_depth

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union AIC_CTRL regAIC_CTRL;

#ifdef DEBUG
__inline void set_AIC_CTRL_translate_en(regAIC_CTRL *reg, unsigned int translate_en)
{
  reg->bitfields.TRANSLATE_EN = translate_en;
  if (reg->bitfields.TRANSLATE_EN != translate_en) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::TRANSLATE_EN data too large\n");
}
__inline void set_AIC_CTRL_dis_out_of_pci_gart_access(regAIC_CTRL *reg, unsigned int dis_out_of_pci_gart_access)
{
  reg->bitfields.DIS_OUT_OF_PCI_GART_ACCESS = dis_out_of_pci_gart_access;
  if (reg->bitfields.DIS_OUT_OF_PCI_GART_ACCESS != dis_out_of_pci_gart_access) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::DIS_OUT_OF_PCI_GART_ACCESS data too large\n");
}
__inline void set_AIC_CTRL_hw_1_debug(regAIC_CTRL *reg, unsigned int hw_1_debug)
{
  reg->bitfields.HW_1_DEBUG = hw_1_debug;
  if (reg->bitfields.HW_1_DEBUG != hw_1_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_1_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_2_debug(regAIC_CTRL *reg, unsigned int hw_2_debug)
{
  reg->bitfields.HW_2_DEBUG = hw_2_debug;
  if (reg->bitfields.HW_2_DEBUG != hw_2_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_2_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_3_debug(regAIC_CTRL *reg, unsigned int hw_3_debug)
{
  reg->bitfields.HW_3_DEBUG = hw_3_debug;
  if (reg->bitfields.HW_3_DEBUG != hw_3_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_3_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_4_debug(regAIC_CTRL *reg, unsigned int hw_4_debug)
{
  reg->bitfields.HW_4_DEBUG = hw_4_debug;
  if (reg->bitfields.HW_4_DEBUG != hw_4_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_4_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_5_debug(regAIC_CTRL *reg, unsigned int hw_5_debug)
{
  reg->bitfields.HW_5_DEBUG = hw_5_debug;
  if (reg->bitfields.HW_5_DEBUG != hw_5_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_5_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_6_debug(regAIC_CTRL *reg, unsigned int hw_6_debug)
{
  reg->bitfields.HW_6_DEBUG = hw_6_debug;
  if (reg->bitfields.HW_6_DEBUG != hw_6_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_6_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_7_debug(regAIC_CTRL *reg, unsigned int hw_7_debug)
{
  reg->bitfields.HW_7_DEBUG = hw_7_debug;
  if (reg->bitfields.HW_7_DEBUG != hw_7_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_7_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_8_debug(regAIC_CTRL *reg, unsigned int hw_8_debug)
{
  reg->bitfields.HW_8_DEBUG = hw_8_debug;
  if (reg->bitfields.HW_8_DEBUG != hw_8_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_8_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_9_debug(regAIC_CTRL *reg, unsigned int hw_9_debug)
{
  reg->bitfields.HW_9_DEBUG = hw_9_debug;
  if (reg->bitfields.HW_9_DEBUG != hw_9_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_9_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_a_debug(regAIC_CTRL *reg, unsigned int hw_a_debug)
{
  reg->bitfields.HW_A_DEBUG = hw_a_debug;
  if (reg->bitfields.HW_A_DEBUG != hw_a_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_A_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_b_debug(regAIC_CTRL *reg, unsigned int hw_b_debug)
{
  reg->bitfields.HW_B_DEBUG = hw_b_debug;
  if (reg->bitfields.HW_B_DEBUG != hw_b_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_B_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_c_debug(regAIC_CTRL *reg, unsigned int hw_c_debug)
{
  reg->bitfields.HW_C_DEBUG = hw_c_debug;
  if (reg->bitfields.HW_C_DEBUG != hw_c_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_C_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_d_debug(regAIC_CTRL *reg, unsigned int hw_d_debug)
{
  reg->bitfields.HW_D_DEBUG = hw_d_debug;
  if (reg->bitfields.HW_D_DEBUG != hw_d_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_D_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_e_debug(regAIC_CTRL *reg, unsigned int hw_e_debug)
{
  reg->bitfields.HW_E_DEBUG = hw_e_debug;
  if (reg->bitfields.HW_E_DEBUG != hw_e_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_E_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_f_debug(regAIC_CTRL *reg, unsigned int hw_f_debug)
{
  reg->bitfields.HW_F_DEBUG = hw_f_debug;
  if (reg->bitfields.HW_F_DEBUG != hw_f_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_F_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_10_debug(regAIC_CTRL *reg, unsigned int hw_10_debug)
{
  reg->bitfields.HW_10_DEBUG = hw_10_debug;
  if (reg->bitfields.HW_10_DEBUG != hw_10_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_10_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_11_debug(regAIC_CTRL *reg, unsigned int hw_11_debug)
{
  reg->bitfields.HW_11_DEBUG = hw_11_debug;
  if (reg->bitfields.HW_11_DEBUG != hw_11_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_11_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_12_debug(regAIC_CTRL *reg, unsigned int hw_12_debug)
{
  reg->bitfields.HW_12_DEBUG = hw_12_debug;
  if (reg->bitfields.HW_12_DEBUG != hw_12_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_12_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_13_debug(regAIC_CTRL *reg, unsigned int hw_13_debug)
{
  reg->bitfields.HW_13_DEBUG = hw_13_debug;
  if (reg->bitfields.HW_13_DEBUG != hw_13_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_13_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_14_debug(regAIC_CTRL *reg, unsigned int hw_14_debug)
{
  reg->bitfields.HW_14_DEBUG = hw_14_debug;
  if (reg->bitfields.HW_14_DEBUG != hw_14_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_14_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_15_debug(regAIC_CTRL *reg, unsigned int hw_15_debug)
{
  reg->bitfields.HW_15_DEBUG = hw_15_debug;
  if (reg->bitfields.HW_15_DEBUG != hw_15_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_15_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_16_debug(regAIC_CTRL *reg, unsigned int hw_16_debug)
{
  reg->bitfields.HW_16_DEBUG = hw_16_debug;
  if (reg->bitfields.HW_16_DEBUG != hw_16_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_16_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_17_debug(regAIC_CTRL *reg, unsigned int hw_17_debug)
{
  reg->bitfields.HW_17_DEBUG = hw_17_debug;
  if (reg->bitfields.HW_17_DEBUG != hw_17_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_17_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_18_debug(regAIC_CTRL *reg, unsigned int hw_18_debug)
{
  reg->bitfields.HW_18_DEBUG = hw_18_debug;
  if (reg->bitfields.HW_18_DEBUG != hw_18_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_18_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_19_debug(regAIC_CTRL *reg, unsigned int hw_19_debug)
{
  reg->bitfields.HW_19_DEBUG = hw_19_debug;
  if (reg->bitfields.HW_19_DEBUG != hw_19_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_19_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_1a_debug(regAIC_CTRL *reg, unsigned int hw_1a_debug)
{
  reg->bitfields.HW_1A_DEBUG = hw_1a_debug;
  if (reg->bitfields.HW_1A_DEBUG != hw_1a_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_1A_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_1b_debug(regAIC_CTRL *reg, unsigned int hw_1b_debug)
{
  reg->bitfields.HW_1B_DEBUG = hw_1b_debug;
  if (reg->bitfields.HW_1B_DEBUG != hw_1b_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_1B_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_1c_debug(regAIC_CTRL *reg, unsigned int hw_1c_debug)
{
  reg->bitfields.HW_1C_DEBUG = hw_1c_debug;
  if (reg->bitfields.HW_1C_DEBUG != hw_1c_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_1C_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_1d_debug(regAIC_CTRL *reg, unsigned int hw_1d_debug)
{
  reg->bitfields.HW_1D_DEBUG = hw_1d_debug;
  if (reg->bitfields.HW_1D_DEBUG != hw_1d_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_1D_DEBUG data too large\n");
}
__inline void set_AIC_CTRL_hw_1e_debug(regAIC_CTRL *reg, unsigned int hw_1e_debug)
{
  reg->bitfields.HW_1E_DEBUG = hw_1e_debug;
  if (reg->bitfields.HW_1E_DEBUG != hw_1e_debug) HSLDPF(E_ERROR_MESSAGE,"AIC_CTRL::HW_1E_DEBUG data too large\n");
}
#else
#define set_AIC_CTRL_translate_en(reg, translate_en) (reg)->bitfields.TRANSLATE_EN = translate_en
#define set_AIC_CTRL_dis_out_of_pci_gart_access(reg, dis_out_of_pci_gart_access) (reg)->bitfields.DIS_OUT_OF_PCI_GART_ACCESS = dis_out_of_pci_gart_access
#define set_AIC_CTRL_hw_1_debug(reg, hw_1_debug) (reg)->bitfields.HW_1_DEBUG = hw_1_debug
#define set_AIC_CTRL_hw_2_debug(reg, hw_2_debug) (reg)->bitfields.HW_2_DEBUG = hw_2_debug
#define set_AIC_CTRL_hw_3_debug(reg, hw_3_debug) (reg)->bitfields.HW_3_DEBUG = hw_3_debug
#define set_AIC_CTRL_hw_4_debug(reg, hw_4_debug) (reg)->bitfields.HW_4_DEBUG = hw_4_debug
#define set_AIC_CTRL_hw_5_debug(reg, hw_5_debug) (reg)->bitfields.HW_5_DEBUG = hw_5_debug
#define set_AIC_CTRL_hw_6_debug(reg, hw_6_debug) (reg)->bitfields.HW_6_DEBUG = hw_6_debug
#define set_AIC_CTRL_hw_7_debug(reg, hw_7_debug) (reg)->bitfields.HW_7_DEBUG = hw_7_debug
#define set_AIC_CTRL_hw_8_debug(reg, hw_8_debug) (reg)->bitfields.HW_8_DEBUG = hw_8_debug
#define set_AIC_CTRL_hw_9_debug(reg, hw_9_debug) (reg)->bitfields.HW_9_DEBUG = hw_9_debug
#define set_AIC_CTRL_hw_a_debug(reg, hw_a_debug) (reg)->bitfields.HW_A_DEBUG = hw_a_debug
#define set_AIC_CTRL_hw_b_debug(reg, hw_b_debug) (reg)->bitfields.HW_B_DEBUG = hw_b_debug
#define set_AIC_CTRL_hw_c_debug(reg, hw_c_debug) (reg)->bitfields.HW_C_DEBUG = hw_c_debug
#define set_AIC_CTRL_hw_d_debug(reg, hw_d_debug) (reg)->bitfields.HW_D_DEBUG = hw_d_debug
#define set_AIC_CTRL_hw_e_debug(reg, hw_e_debug) (reg)->bitfields.HW_E_DEBUG = hw_e_debug
#define set_AIC_CTRL_hw_f_debug(reg, hw_f_debug) (reg)->bitfields.HW_F_DEBUG = hw_f_debug
#define set_AIC_CTRL_hw_10_debug(reg, hw_10_debug) (reg)->bitfields.HW_10_DEBUG = hw_10_debug
#define set_AIC_CTRL_hw_11_debug(reg, hw_11_debug) (reg)->bitfields.HW_11_DEBUG = hw_11_debug
#define set_AIC_CTRL_hw_12_debug(reg, hw_12_debug) (reg)->bitfields.HW_12_DEBUG = hw_12_debug
#define set_AIC_CTRL_hw_13_debug(reg, hw_13_debug) (reg)->bitfields.HW_13_DEBUG = hw_13_debug
#define set_AIC_CTRL_hw_14_debug(reg, hw_14_debug) (reg)->bitfields.HW_14_DEBUG = hw_14_debug
#define set_AIC_CTRL_hw_15_debug(reg, hw_15_debug) (reg)->bitfields.HW_15_DEBUG = hw_15_debug
#define set_AIC_CTRL_hw_16_debug(reg, hw_16_debug) (reg)->bitfields.HW_16_DEBUG = hw_16_debug
#define set_AIC_CTRL_hw_17_debug(reg, hw_17_debug) (reg)->bitfields.HW_17_DEBUG = hw_17_debug
#define set_AIC_CTRL_hw_18_debug(reg, hw_18_debug) (reg)->bitfields.HW_18_DEBUG = hw_18_debug
#define set_AIC_CTRL_hw_19_debug(reg, hw_19_debug) (reg)->bitfields.HW_19_DEBUG = hw_19_debug
#define set_AIC_CTRL_hw_1a_debug(reg, hw_1a_debug) (reg)->bitfields.HW_1A_DEBUG = hw_1a_debug
#define set_AIC_CTRL_hw_1b_debug(reg, hw_1b_debug) (reg)->bitfields.HW_1B_DEBUG = hw_1b_debug
#define set_AIC_CTRL_hw_1c_debug(reg, hw_1c_debug) (reg)->bitfields.HW_1C_DEBUG = hw_1c_debug
#define set_AIC_CTRL_hw_1d_debug(reg, hw_1d_debug) (reg)->bitfields.HW_1D_DEBUG = hw_1d_debug
#define set_AIC_CTRL_hw_1e_debug(reg, hw_1e_debug) (reg)->bitfields.HW_1E_DEBUG = hw_1e_debug

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union AIC_STAT regAIC_STAT;

#ifdef DEBUG
__inline void set_AIC_STAT_aic_tlb_vld(regAIC_STAT *reg, unsigned int aic_tlb_vld)
{
  reg->bitfields.AIC_TLB_VLD = aic_tlb_vld;
  if (reg->bitfields.AIC_TLB_VLD != aic_tlb_vld) HSLDPF(E_ERROR_MESSAGE,"AIC_STAT::AIC_TLB_VLD data too large\n");
}
__inline void set_AIC_STAT_aic_stat1(regAIC_STAT *reg, unsigned int aic_stat1)
{
  reg->bitfields.AIC_STAT1 = aic_stat1;
  if (reg->bitfields.AIC_STAT1 != aic_stat1) HSLDPF(E_ERROR_MESSAGE,"AIC_STAT::AIC_STAT1 data too large\n");
}
__inline void set_AIC_STAT_aic_stat0(regAIC_STAT *reg, unsigned int aic_stat0)
{
  reg->bitfields.AIC_STAT0 = aic_stat0;
  if (reg->bitfields.AIC_STAT0 != aic_stat0) HSLDPF(E_ERROR_MESSAGE,"AIC_STAT::AIC_STAT0 data too large\n");
}
#else
#define set_AIC_STAT_aic_tlb_vld(reg, aic_tlb_vld) (reg)->bitfields.AIC_TLB_VLD = aic_tlb_vld
#define set_AIC_STAT_aic_stat1(reg, aic_stat1) (reg)->bitfields.AIC_STAT1 = aic_stat1
#define set_AIC_STAT_aic_stat0(reg, aic_stat0) (reg)->bitfields.AIC_STAT0 = aic_stat0

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union AIC_PT_BASE regAIC_PT_BASE;

#ifdef DEBUG
__inline void set_AIC_PT_BASE_aic_pt_base(regAIC_PT_BASE *reg, unsigned int aic_pt_base)
{
  reg->bitfields.AIC_PT_BASE = aic_pt_base;
  if (reg->bitfields.AIC_PT_BASE != aic_pt_base) HSLDPF(E_ERROR_MESSAGE,"AIC_PT_BASE::AIC_PT_BASE data too large\n");
}
#else
#define set_AIC_PT_BASE_aic_pt_base(reg, aic_pt_base) (reg)->bitfields.AIC_PT_BASE = aic_pt_base

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union AIC_LO_ADDR regAIC_LO_ADDR;

#ifdef DEBUG
__inline void set_AIC_LO_ADDR_aic_lo_addr(regAIC_LO_ADDR *reg, unsigned int aic_lo_addr)
{
  reg->bitfields.AIC_LO_ADDR = aic_lo_addr;
  if (reg->bitfields.AIC_LO_ADDR != aic_lo_addr) HSLDPF(E_ERROR_MESSAGE,"AIC_LO_ADDR::AIC_LO_ADDR data too large\n");
}
#else
#define set_AIC_LO_ADDR_aic_lo_addr(reg, aic_lo_addr) (reg)->bitfields.AIC_LO_ADDR = aic_lo_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union AIC_HI_ADDR regAIC_HI_ADDR;

#ifdef DEBUG
__inline void set_AIC_HI_ADDR_aic_hi_addr(regAIC_HI_ADDR *reg, unsigned int aic_hi_addr)
{
  reg->bitfields.AIC_HI_ADDR = aic_hi_addr;
  if (reg->bitfields.AIC_HI_ADDR != aic_hi_addr) HSLDPF(E_ERROR_MESSAGE,"AIC_HI_ADDR::AIC_HI_ADDR data too large\n");
}
#else
#define set_AIC_HI_ADDR_aic_hi_addr(reg, aic_hi_addr) (reg)->bitfields.AIC_HI_ADDR = aic_hi_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union AIC_TLB_ADDR regAIC_TLB_ADDR;

#ifdef DEBUG
__inline void set_AIC_TLB_ADDR_aic_tlb_addr(regAIC_TLB_ADDR *reg, unsigned int aic_tlb_addr)
{
  reg->bitfields.AIC_TLB_ADDR = aic_tlb_addr;
  if (reg->bitfields.AIC_TLB_ADDR != aic_tlb_addr) HSLDPF(E_ERROR_MESSAGE,"AIC_TLB_ADDR::AIC_TLB_ADDR data too large\n");
}
#else
#define set_AIC_TLB_ADDR_aic_tlb_addr(reg, aic_tlb_addr) (reg)->bitfields.AIC_TLB_ADDR = aic_tlb_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union AIC_TLB_DATA regAIC_TLB_DATA;

#ifdef DEBUG
__inline void set_AIC_TLB_DATA_aic_tlb_data(regAIC_TLB_DATA *reg, unsigned int aic_tlb_data)
{
  reg->bitfields.AIC_TLB_DATA = aic_tlb_data;
  if (reg->bitfields.AIC_TLB_DATA != aic_tlb_data) HSLDPF(E_ERROR_MESSAGE,"AIC_TLB_DATA::AIC_TLB_DATA data too large\n");
}
#else
#define set_AIC_TLB_DATA_aic_tlb_data(reg, aic_tlb_data) (reg)->bitfields.AIC_TLB_DATA = aic_tlb_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GENMO_WT regGENMO_WT;

#ifdef DEBUG
__inline void set_GENMO_WT_genmo_mono_address_b(regGENMO_WT *reg, unsigned int genmo_mono_address_b)
{
  reg->bitfields.GENMO_MONO_ADDRESS_B = genmo_mono_address_b;
  if (reg->bitfields.GENMO_MONO_ADDRESS_B != genmo_mono_address_b) HSLDPF(E_ERROR_MESSAGE,"GENMO_WT::GENMO_MONO_ADDRESS_B data too large\n");
}
__inline void set_GENMO_WT_vga_ram_en(regGENMO_WT *reg, unsigned int vga_ram_en)
{
  reg->bitfields.VGA_RAM_EN = vga_ram_en;
  if (reg->bitfields.VGA_RAM_EN != vga_ram_en) HSLDPF(E_ERROR_MESSAGE,"GENMO_WT::VGA_RAM_EN data too large\n");
}
__inline void set_GENMO_WT_vga_cksel(regGENMO_WT *reg, unsigned int vga_cksel)
{
  reg->bitfields.VGA_CKSEL = vga_cksel;
  if (reg->bitfields.VGA_CKSEL != vga_cksel) HSLDPF(E_ERROR_MESSAGE,"GENMO_WT::VGA_CKSEL data too large\n");
}
__inline void set_GENMO_WT_odd_even_md_pgsel(regGENMO_WT *reg, unsigned int odd_even_md_pgsel)
{
  reg->bitfields.ODD_EVEN_MD_PGSEL = odd_even_md_pgsel;
  if (reg->bitfields.ODD_EVEN_MD_PGSEL != odd_even_md_pgsel) HSLDPF(E_ERROR_MESSAGE,"GENMO_WT::ODD_EVEN_MD_PGSEL data too large\n");
}
__inline void set_GENMO_WT_vga_hsync_pol(regGENMO_WT *reg, unsigned int vga_hsync_pol)
{
  reg->bitfields.VGA_HSYNC_POL = vga_hsync_pol;
  if (reg->bitfields.VGA_HSYNC_POL != vga_hsync_pol) HSLDPF(E_ERROR_MESSAGE,"GENMO_WT::VGA_HSYNC_POL data too large\n");
}
__inline void set_GENMO_WT_vga_vsync_pol(regGENMO_WT *reg, unsigned int vga_vsync_pol)
{
  reg->bitfields.VGA_VSYNC_POL = vga_vsync_pol;
  if (reg->bitfields.VGA_VSYNC_POL != vga_vsync_pol) HSLDPF(E_ERROR_MESSAGE,"GENMO_WT::VGA_VSYNC_POL data too large\n");
}
#else
#define set_GENMO_WT_genmo_mono_address_b(reg, genmo_mono_address_b) (reg)->bitfields.GENMO_MONO_ADDRESS_B = genmo_mono_address_b
#define set_GENMO_WT_vga_ram_en(reg, vga_ram_en) (reg)->bitfields.VGA_RAM_EN = vga_ram_en
#define set_GENMO_WT_vga_cksel(reg, vga_cksel) (reg)->bitfields.VGA_CKSEL = vga_cksel
#define set_GENMO_WT_odd_even_md_pgsel(reg, odd_even_md_pgsel) (reg)->bitfields.ODD_EVEN_MD_PGSEL = odd_even_md_pgsel
#define set_GENMO_WT_vga_hsync_pol(reg, vga_hsync_pol) (reg)->bitfields.VGA_HSYNC_POL = vga_hsync_pol
#define set_GENMO_WT_vga_vsync_pol(reg, vga_vsync_pol) (reg)->bitfields.VGA_VSYNC_POL = vga_vsync_pol

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GENMO_RD regGENMO_RD;

#ifdef DEBUG
__inline void set_GENMO_RD_genmo_mono_address_b(regGENMO_RD *reg, unsigned int genmo_mono_address_b)
{
  reg->bitfields.GENMO_MONO_ADDRESS_B = genmo_mono_address_b;
  if (reg->bitfields.GENMO_MONO_ADDRESS_B != genmo_mono_address_b) HSLDPF(E_ERROR_MESSAGE,"GENMO_RD::GENMO_MONO_ADDRESS_B data too large\n");
}
__inline void set_GENMO_RD_vga_ram_en(regGENMO_RD *reg, unsigned int vga_ram_en)
{
  reg->bitfields.VGA_RAM_EN = vga_ram_en;
  if (reg->bitfields.VGA_RAM_EN != vga_ram_en) HSLDPF(E_ERROR_MESSAGE,"GENMO_RD::VGA_RAM_EN data too large\n");
}
__inline void set_GENMO_RD_vga_cksel(regGENMO_RD *reg, unsigned int vga_cksel)
{
  reg->bitfields.VGA_CKSEL = vga_cksel;
  if (reg->bitfields.VGA_CKSEL != vga_cksel) HSLDPF(E_ERROR_MESSAGE,"GENMO_RD::VGA_CKSEL data too large\n");
}
__inline void set_GENMO_RD_odd_even_md_pgsel(regGENMO_RD *reg, unsigned int odd_even_md_pgsel)
{
  reg->bitfields.ODD_EVEN_MD_PGSEL = odd_even_md_pgsel;
  if (reg->bitfields.ODD_EVEN_MD_PGSEL != odd_even_md_pgsel) HSLDPF(E_ERROR_MESSAGE,"GENMO_RD::ODD_EVEN_MD_PGSEL data too large\n");
}
__inline void set_GENMO_RD_vga_hsync_pol(regGENMO_RD *reg, unsigned int vga_hsync_pol)
{
  reg->bitfields.VGA_HSYNC_POL = vga_hsync_pol;
  if (reg->bitfields.VGA_HSYNC_POL != vga_hsync_pol) HSLDPF(E_ERROR_MESSAGE,"GENMO_RD::VGA_HSYNC_POL data too large\n");
}
__inline void set_GENMO_RD_vga_vsync_pol(regGENMO_RD *reg, unsigned int vga_vsync_pol)
{
  reg->bitfields.VGA_VSYNC_POL = vga_vsync_pol;
  if (reg->bitfields.VGA_VSYNC_POL != vga_vsync_pol) HSLDPF(E_ERROR_MESSAGE,"GENMO_RD::VGA_VSYNC_POL data too large\n");
}
#else
#define set_GENMO_RD_genmo_mono_address_b(reg, genmo_mono_address_b) (reg)->bitfields.GENMO_MONO_ADDRESS_B = genmo_mono_address_b
#define set_GENMO_RD_vga_ram_en(reg, vga_ram_en) (reg)->bitfields.VGA_RAM_EN = vga_ram_en
#define set_GENMO_RD_vga_cksel(reg, vga_cksel) (reg)->bitfields.VGA_CKSEL = vga_cksel
#define set_GENMO_RD_odd_even_md_pgsel(reg, odd_even_md_pgsel) (reg)->bitfields.ODD_EVEN_MD_PGSEL = odd_even_md_pgsel
#define set_GENMO_RD_vga_hsync_pol(reg, vga_hsync_pol) (reg)->bitfields.VGA_HSYNC_POL = vga_hsync_pol
#define set_GENMO_RD_vga_vsync_pol(reg, vga_vsync_pol) (reg)->bitfields.VGA_VSYNC_POL = vga_vsync_pol

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250DAC_CNTL regrv250DAC_CNTL;

#ifdef DEBUG
__inline void set_rv250DAC_CNTL_dac_range_cntl(regrv250DAC_CNTL *reg, unsigned int dac_range_cntl)
{
  reg->bitfields.DAC_RANGE_CNTL = dac_range_cntl;
  if (reg->bitfields.DAC_RANGE_CNTL != dac_range_cntl) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL::DAC_RANGE_CNTL data too large\n");
}
__inline void set_rv250DAC_CNTL_dac_blanking(regrv250DAC_CNTL *reg, unsigned int dac_blanking)
{
  reg->bitfields.DAC_BLANKING = dac_blanking;
  if (reg->bitfields.DAC_BLANKING != dac_blanking) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL::DAC_BLANKING data too large\n");
}
__inline void set_rv250DAC_CNTL_dac_cmp_en(regrv250DAC_CNTL *reg, unsigned int dac_cmp_en)
{
  reg->bitfields.DAC_CMP_EN = dac_cmp_en;
  if (reg->bitfields.DAC_CMP_EN != dac_cmp_en) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL::DAC_CMP_EN data too large\n");
}
__inline void set_rv250DAC_CNTL_dac_cmp_out_r(regrv250DAC_CNTL *reg, unsigned int dac_cmp_out_r)
{
  reg->bitfields.DAC_CMP_OUT_R = dac_cmp_out_r;
  if (reg->bitfields.DAC_CMP_OUT_R != dac_cmp_out_r) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL::DAC_CMP_OUT_R data too large\n");
}
__inline void set_rv250DAC_CNTL_dac_cmp_out_g(regrv250DAC_CNTL *reg, unsigned int dac_cmp_out_g)
{
  reg->bitfields.DAC_CMP_OUT_G = dac_cmp_out_g;
  if (reg->bitfields.DAC_CMP_OUT_G != dac_cmp_out_g) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL::DAC_CMP_OUT_G data too large\n");
}
__inline void set_rv250DAC_CNTL_dac_cmp_out_b(regrv250DAC_CNTL *reg, unsigned int dac_cmp_out_b)
{
  reg->bitfields.DAC_CMP_OUT_B = dac_cmp_out_b;
  if (reg->bitfields.DAC_CMP_OUT_B != dac_cmp_out_b) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL::DAC_CMP_OUT_B data too large\n");
}
__inline void set_rv250DAC_CNTL_dac_cmp_output(regrv250DAC_CNTL *reg, unsigned int dac_cmp_output)
{
  reg->bitfields.DAC_CMP_OUTPUT = dac_cmp_output;
  if (reg->bitfields.DAC_CMP_OUTPUT != dac_cmp_output) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL::DAC_CMP_OUTPUT data too large\n");
}
__inline void set_rv250DAC_CNTL_dac_8bit_en(regrv250DAC_CNTL *reg, unsigned int dac_8bit_en)
{
  reg->bitfields.DAC_8BIT_EN = dac_8bit_en;
  if (reg->bitfields.DAC_8BIT_EN != dac_8bit_en) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL::DAC_8BIT_EN data too large\n");
}
__inline void set_rv250DAC_CNTL_dac_4bpp_pix_order(regrv250DAC_CNTL *reg, unsigned int dac_4bpp_pix_order)
{
  reg->bitfields.DAC_4BPP_PIX_ORDER = dac_4bpp_pix_order;
  if (reg->bitfields.DAC_4BPP_PIX_ORDER != dac_4bpp_pix_order) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL::DAC_4BPP_PIX_ORDER data too large\n");
}
__inline void set_rv250DAC_CNTL_dac_vga_adr_en(regrv250DAC_CNTL *reg, unsigned int dac_vga_adr_en)
{
  reg->bitfields.DAC_VGA_ADR_EN = dac_vga_adr_en;
  if (reg->bitfields.DAC_VGA_ADR_EN != dac_vga_adr_en) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL::DAC_VGA_ADR_EN data too large\n");
}
__inline void set_rv250DAC_CNTL_dac_expand_mode(regrv250DAC_CNTL *reg, unsigned int dac_expand_mode)
{
  reg->bitfields.DAC_EXPAND_MODE = dac_expand_mode;
  if (reg->bitfields.DAC_EXPAND_MODE != dac_expand_mode) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL::DAC_EXPAND_MODE data too large\n");
}
__inline void set_rv250DAC_CNTL_dac_pdwn(regrv250DAC_CNTL *reg, unsigned int dac_pdwn)
{
  reg->bitfields.DAC_PDWN = dac_pdwn;
  if (reg->bitfields.DAC_PDWN != dac_pdwn) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL::DAC_PDWN data too large\n");
}
__inline void set_rv250DAC_CNTL_crt_sense(regrv250DAC_CNTL *reg, unsigned int crt_sense)
{
  reg->bitfields.CRT_SENSE = crt_sense;
  if (reg->bitfields.CRT_SENSE != crt_sense) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL::CRT_SENSE data too large\n");
}
__inline void set_rv250DAC_CNTL_crt_detection_on(regrv250DAC_CNTL *reg, unsigned int crt_detection_on)
{
  reg->bitfields.CRT_DETECTION_ON = crt_detection_on;
  if (reg->bitfields.CRT_DETECTION_ON != crt_detection_on) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL::CRT_DETECTION_ON data too large\n");
}
__inline void set_rv250DAC_CNTL_dac_crc_cont_en(regrv250DAC_CNTL *reg, unsigned int dac_crc_cont_en)
{
  reg->bitfields.DAC_CRC_CONT_EN = dac_crc_cont_en;
  if (reg->bitfields.DAC_CRC_CONT_EN != dac_crc_cont_en) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL::DAC_CRC_CONT_EN data too large\n");
}
__inline void set_rv250DAC_CNTL_dac_crc_en(regrv250DAC_CNTL *reg, unsigned int dac_crc_en)
{
  reg->bitfields.DAC_CRC_EN = dac_crc_en;
  if (reg->bitfields.DAC_CRC_EN != dac_crc_en) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL::DAC_CRC_EN data too large\n");
}
__inline void set_rv250DAC_CNTL_dac_crc_field(regrv250DAC_CNTL *reg, unsigned int dac_crc_field)
{
  reg->bitfields.DAC_CRC_FIELD = dac_crc_field;
  if (reg->bitfields.DAC_CRC_FIELD != dac_crc_field) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL::DAC_CRC_FIELD data too large\n");
}
__inline void set_rv250DAC_CNTL_dac_lut_counter_limit(regrv250DAC_CNTL *reg, unsigned int dac_lut_counter_limit)
{
  reg->bitfields.DAC_LUT_COUNTER_LIMIT = dac_lut_counter_limit;
  if (reg->bitfields.DAC_LUT_COUNTER_LIMIT != dac_lut_counter_limit) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL::DAC_LUT_COUNTER_LIMIT data too large\n");
}
__inline void set_rv250DAC_CNTL_dac_lut_read_sel(regrv250DAC_CNTL *reg, unsigned int dac_lut_read_sel)
{
  reg->bitfields.DAC_LUT_READ_SEL = dac_lut_read_sel;
  if (reg->bitfields.DAC_LUT_READ_SEL != dac_lut_read_sel) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL::DAC_LUT_READ_SEL data too large\n");
}
__inline void set_rv250DAC_CNTL_dac_mask(regrv250DAC_CNTL *reg, unsigned int dac_mask)
{
  reg->bitfields.DAC_MASK = dac_mask;
  if (reg->bitfields.DAC_MASK != dac_mask) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL::DAC_MASK data too large\n");
}
#else
#define set_rv250DAC_CNTL_dac_range_cntl(reg, dac_range_cntl) (reg)->bitfields.DAC_RANGE_CNTL = dac_range_cntl
#define set_rv250DAC_CNTL_dac_blanking(reg, dac_blanking) (reg)->bitfields.DAC_BLANKING = dac_blanking
#define set_rv250DAC_CNTL_dac_cmp_en(reg, dac_cmp_en) (reg)->bitfields.DAC_CMP_EN = dac_cmp_en
#define set_rv250DAC_CNTL_dac_cmp_out_r(reg, dac_cmp_out_r) (reg)->bitfields.DAC_CMP_OUT_R = dac_cmp_out_r
#define set_rv250DAC_CNTL_dac_cmp_out_g(reg, dac_cmp_out_g) (reg)->bitfields.DAC_CMP_OUT_G = dac_cmp_out_g
#define set_rv250DAC_CNTL_dac_cmp_out_b(reg, dac_cmp_out_b) (reg)->bitfields.DAC_CMP_OUT_B = dac_cmp_out_b
#define set_rv250DAC_CNTL_dac_cmp_output(reg, dac_cmp_output) (reg)->bitfields.DAC_CMP_OUTPUT = dac_cmp_output
#define set_rv250DAC_CNTL_dac_8bit_en(reg, dac_8bit_en) (reg)->bitfields.DAC_8BIT_EN = dac_8bit_en
#define set_rv250DAC_CNTL_dac_4bpp_pix_order(reg, dac_4bpp_pix_order) (reg)->bitfields.DAC_4BPP_PIX_ORDER = dac_4bpp_pix_order
#define set_rv250DAC_CNTL_dac_vga_adr_en(reg, dac_vga_adr_en) (reg)->bitfields.DAC_VGA_ADR_EN = dac_vga_adr_en
#define set_rv250DAC_CNTL_dac_expand_mode(reg, dac_expand_mode) (reg)->bitfields.DAC_EXPAND_MODE = dac_expand_mode
#define set_rv250DAC_CNTL_dac_pdwn(reg, dac_pdwn) (reg)->bitfields.DAC_PDWN = dac_pdwn
#define set_rv250DAC_CNTL_crt_sense(reg, crt_sense) (reg)->bitfields.CRT_SENSE = crt_sense
#define set_rv250DAC_CNTL_crt_detection_on(reg, crt_detection_on) (reg)->bitfields.CRT_DETECTION_ON = crt_detection_on
#define set_rv250DAC_CNTL_dac_crc_cont_en(reg, dac_crc_cont_en) (reg)->bitfields.DAC_CRC_CONT_EN = dac_crc_cont_en
#define set_rv250DAC_CNTL_dac_crc_en(reg, dac_crc_en) (reg)->bitfields.DAC_CRC_EN = dac_crc_en
#define set_rv250DAC_CNTL_dac_crc_field(reg, dac_crc_field) (reg)->bitfields.DAC_CRC_FIELD = dac_crc_field
#define set_rv250DAC_CNTL_dac_lut_counter_limit(reg, dac_lut_counter_limit) (reg)->bitfields.DAC_LUT_COUNTER_LIMIT = dac_lut_counter_limit
#define set_rv250DAC_CNTL_dac_lut_read_sel(reg, dac_lut_read_sel) (reg)->bitfields.DAC_LUT_READ_SEL = dac_lut_read_sel
#define set_rv250DAC_CNTL_dac_mask(reg, dac_mask) (reg)->bitfields.DAC_MASK = dac_mask

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250CRTC_GEN_CNTL regrv250CRTC_GEN_CNTL;

#ifdef DEBUG
__inline void set_rv250CRTC_GEN_CNTL_crtc_dbl_scan_en(regrv250CRTC_GEN_CNTL *reg, unsigned int crtc_dbl_scan_en)
{
  reg->bitfields.CRTC_DBL_SCAN_EN = crtc_dbl_scan_en;
  if (reg->bitfields.CRTC_DBL_SCAN_EN != crtc_dbl_scan_en) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC_GEN_CNTL::CRTC_DBL_SCAN_EN data too large\n");
}
__inline void set_rv250CRTC_GEN_CNTL_crtc_interlace_en(regrv250CRTC_GEN_CNTL *reg, unsigned int crtc_interlace_en)
{
  reg->bitfields.CRTC_INTERLACE_EN = crtc_interlace_en;
  if (reg->bitfields.CRTC_INTERLACE_EN != crtc_interlace_en) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC_GEN_CNTL::CRTC_INTERLACE_EN data too large\n");
}
__inline void set_rv250CRTC_GEN_CNTL_crtc_c_sync_en(regrv250CRTC_GEN_CNTL *reg, unsigned int crtc_c_sync_en)
{
  reg->bitfields.CRTC_C_SYNC_EN = crtc_c_sync_en;
  if (reg->bitfields.CRTC_C_SYNC_EN != crtc_c_sync_en) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC_GEN_CNTL::CRTC_C_SYNC_EN data too large\n");
}
__inline void set_rv250CRTC_GEN_CNTL_crtc_pix_width(regrv250CRTC_GEN_CNTL *reg, unsigned int crtc_pix_width)
{
  reg->bitfields.CRTC_PIX_WIDTH = crtc_pix_width;
  if (reg->bitfields.CRTC_PIX_WIDTH != crtc_pix_width) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC_GEN_CNTL::CRTC_PIX_WIDTH data too large\n");
}
__inline void set_rv250CRTC_GEN_CNTL_crtc_mode9_color_order(regrv250CRTC_GEN_CNTL *reg, unsigned int crtc_mode9_color_order)
{
  reg->bitfields.CRTC_MODE9_COLOR_ORDER = crtc_mode9_color_order;
  if (reg->bitfields.CRTC_MODE9_COLOR_ORDER != crtc_mode9_color_order) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC_GEN_CNTL::CRTC_MODE9_COLOR_ORDER data too large\n");
}
__inline void set_rv250CRTC_GEN_CNTL_crtc_bypass_lut_en(regrv250CRTC_GEN_CNTL *reg, unsigned int crtc_bypass_lut_en)
{
  reg->bitfields.CRTC_BYPASS_LUT_EN = crtc_bypass_lut_en;
  if (reg->bitfields.CRTC_BYPASS_LUT_EN != crtc_bypass_lut_en) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC_GEN_CNTL::CRTC_BYPASS_LUT_EN data too large\n");
}
__inline void set_rv250CRTC_GEN_CNTL_crtc_icon_en(regrv250CRTC_GEN_CNTL *reg, unsigned int crtc_icon_en)
{
  reg->bitfields.CRTC_ICON_EN = crtc_icon_en;
  if (reg->bitfields.CRTC_ICON_EN != crtc_icon_en) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC_GEN_CNTL::CRTC_ICON_EN data too large\n");
}
__inline void set_rv250CRTC_GEN_CNTL_crtc_cur_en(regrv250CRTC_GEN_CNTL *reg, unsigned int crtc_cur_en)
{
  reg->bitfields.CRTC_CUR_EN = crtc_cur_en;
  if (reg->bitfields.CRTC_CUR_EN != crtc_cur_en) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC_GEN_CNTL::CRTC_CUR_EN data too large\n");
}
__inline void set_rv250CRTC_GEN_CNTL_crtc_vstat_mode(regrv250CRTC_GEN_CNTL *reg, unsigned int crtc_vstat_mode)
{
  reg->bitfields.CRTC_VSTAT_MODE = crtc_vstat_mode;
  if (reg->bitfields.CRTC_VSTAT_MODE != crtc_vstat_mode) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC_GEN_CNTL::CRTC_VSTAT_MODE data too large\n");
}
__inline void set_rv250CRTC_GEN_CNTL_crtc_cur_mode(regrv250CRTC_GEN_CNTL *reg, unsigned int crtc_cur_mode)
{
  reg->bitfields.CRTC_CUR_MODE = crtc_cur_mode;
  if (reg->bitfields.CRTC_CUR_MODE != crtc_cur_mode) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC_GEN_CNTL::CRTC_CUR_MODE data too large\n");
}
__inline void set_rv250CRTC_GEN_CNTL_crtc_ext_disp_en(regrv250CRTC_GEN_CNTL *reg, unsigned int crtc_ext_disp_en)
{
  reg->bitfields.CRTC_EXT_DISP_EN = crtc_ext_disp_en;
  if (reg->bitfields.CRTC_EXT_DISP_EN != crtc_ext_disp_en) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC_GEN_CNTL::CRTC_EXT_DISP_EN data too large\n");
}
__inline void set_rv250CRTC_GEN_CNTL_crtc_en(regrv250CRTC_GEN_CNTL *reg, unsigned int crtc_en)
{
  reg->bitfields.CRTC_EN = crtc_en;
  if (reg->bitfields.CRTC_EN != crtc_en) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC_GEN_CNTL::CRTC_EN data too large\n");
}
__inline void set_rv250CRTC_GEN_CNTL_crtc_disp_req_en_b(regrv250CRTC_GEN_CNTL *reg, unsigned int crtc_disp_req_en_b)
{
  reg->bitfields.CRTC_DISP_REQ_EN_B = crtc_disp_req_en_b;
  if (reg->bitfields.CRTC_DISP_REQ_EN_B != crtc_disp_req_en_b) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC_GEN_CNTL::CRTC_DISP_REQ_EN_B data too large\n");
}
#else
#define set_rv250CRTC_GEN_CNTL_crtc_dbl_scan_en(reg, crtc_dbl_scan_en) (reg)->bitfields.CRTC_DBL_SCAN_EN = crtc_dbl_scan_en
#define set_rv250CRTC_GEN_CNTL_crtc_interlace_en(reg, crtc_interlace_en) (reg)->bitfields.CRTC_INTERLACE_EN = crtc_interlace_en
#define set_rv250CRTC_GEN_CNTL_crtc_c_sync_en(reg, crtc_c_sync_en) (reg)->bitfields.CRTC_C_SYNC_EN = crtc_c_sync_en
#define set_rv250CRTC_GEN_CNTL_crtc_pix_width(reg, crtc_pix_width) (reg)->bitfields.CRTC_PIX_WIDTH = crtc_pix_width
#define set_rv250CRTC_GEN_CNTL_crtc_mode9_color_order(reg, crtc_mode9_color_order) (reg)->bitfields.CRTC_MODE9_COLOR_ORDER = crtc_mode9_color_order
#define set_rv250CRTC_GEN_CNTL_crtc_bypass_lut_en(reg, crtc_bypass_lut_en) (reg)->bitfields.CRTC_BYPASS_LUT_EN = crtc_bypass_lut_en
#define set_rv250CRTC_GEN_CNTL_crtc_icon_en(reg, crtc_icon_en) (reg)->bitfields.CRTC_ICON_EN = crtc_icon_en
#define set_rv250CRTC_GEN_CNTL_crtc_cur_en(reg, crtc_cur_en) (reg)->bitfields.CRTC_CUR_EN = crtc_cur_en
#define set_rv250CRTC_GEN_CNTL_crtc_vstat_mode(reg, crtc_vstat_mode) (reg)->bitfields.CRTC_VSTAT_MODE = crtc_vstat_mode
#define set_rv250CRTC_GEN_CNTL_crtc_cur_mode(reg, crtc_cur_mode) (reg)->bitfields.CRTC_CUR_MODE = crtc_cur_mode
#define set_rv250CRTC_GEN_CNTL_crtc_ext_disp_en(reg, crtc_ext_disp_en) (reg)->bitfields.CRTC_EXT_DISP_EN = crtc_ext_disp_en
#define set_rv250CRTC_GEN_CNTL_crtc_en(reg, crtc_en) (reg)->bitfields.CRTC_EN = crtc_en
#define set_rv250CRTC_GEN_CNTL_crtc_disp_req_en_b(reg, crtc_disp_req_en_b) (reg)->bitfields.CRTC_DISP_REQ_EN_B = crtc_disp_req_en_b

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MEM_TIMING_CNTL regMEM_TIMING_CNTL;

#ifdef DEBUG
__inline void set_MEM_TIMING_CNTL_mem_trcd(regMEM_TIMING_CNTL *reg, unsigned int mem_trcd)
{
  reg->bitfields.MEM_TRCD = mem_trcd;
  if (reg->bitfields.MEM_TRCD != mem_trcd) HSLDPF(E_ERROR_MESSAGE,"MEM_TIMING_CNTL::MEM_TRCD data too large\n");
}
__inline void set_MEM_TIMING_CNTL_mem_trcdw(regMEM_TIMING_CNTL *reg, unsigned int mem_trcdw)
{
  reg->bitfields.MEM_TRCDW = mem_trcdw;
  if (reg->bitfields.MEM_TRCDW != mem_trcdw) HSLDPF(E_ERROR_MESSAGE,"MEM_TIMING_CNTL::MEM_TRCDW data too large\n");
}
__inline void set_MEM_TIMING_CNTL_mem_trp(regMEM_TIMING_CNTL *reg, unsigned int mem_trp)
{
  reg->bitfields.MEM_TRP = mem_trp;
  if (reg->bitfields.MEM_TRP != mem_trp) HSLDPF(E_ERROR_MESSAGE,"MEM_TIMING_CNTL::MEM_TRP data too large\n");
}
__inline void set_MEM_TIMING_CNTL_mem_tras(regMEM_TIMING_CNTL *reg, unsigned int mem_tras)
{
  reg->bitfields.MEM_TRAS = mem_tras;
  if (reg->bitfields.MEM_TRAS != mem_tras) HSLDPF(E_ERROR_MESSAGE,"MEM_TIMING_CNTL::MEM_TRAS data too large\n");
}
__inline void set_MEM_TIMING_CNTL_mem_trrd(regMEM_TIMING_CNTL *reg, unsigned int mem_trrd)
{
  reg->bitfields.MEM_TRRD = mem_trrd;
  if (reg->bitfields.MEM_TRRD != mem_trrd) HSLDPF(E_ERROR_MESSAGE,"MEM_TIMING_CNTL::MEM_TRRD data too large\n");
}
__inline void set_MEM_TIMING_CNTL_mem_tr2w(regMEM_TIMING_CNTL *reg, unsigned int mem_tr2w)
{
  reg->bitfields.MEM_TR2W = mem_tr2w;
  if (reg->bitfields.MEM_TR2W != mem_tr2w) HSLDPF(E_ERROR_MESSAGE,"MEM_TIMING_CNTL::MEM_TR2W data too large\n");
}
__inline void set_MEM_TIMING_CNTL_mem_twr(regMEM_TIMING_CNTL *reg, unsigned int mem_twr)
{
  reg->bitfields.MEM_TWR = mem_twr;
  if (reg->bitfields.MEM_TWR != mem_twr) HSLDPF(E_ERROR_MESSAGE,"MEM_TIMING_CNTL::MEM_TWR data too large\n");
}
__inline void set_MEM_TIMING_CNTL_mem_tw2r(regMEM_TIMING_CNTL *reg, unsigned int mem_tw2r)
{
  reg->bitfields.MEM_TW2R = mem_tw2r;
  if (reg->bitfields.MEM_TW2R != mem_tw2r) HSLDPF(E_ERROR_MESSAGE,"MEM_TIMING_CNTL::MEM_TW2R data too large\n");
}
__inline void set_MEM_TIMING_CNTL_mem_tw2r_same_bank(regMEM_TIMING_CNTL *reg, unsigned int mem_tw2r_same_bank)
{
  reg->bitfields.MEM_TW2R_SAME_BANK = mem_tw2r_same_bank;
  if (reg->bitfields.MEM_TW2R_SAME_BANK != mem_tw2r_same_bank) HSLDPF(E_ERROR_MESSAGE,"MEM_TIMING_CNTL::MEM_TW2R_SAME_BANK data too large\n");
}
__inline void set_MEM_TIMING_CNTL_mem_tr2r(regMEM_TIMING_CNTL *reg, unsigned int mem_tr2r)
{
  reg->bitfields.MEM_TR2R = mem_tr2r;
  if (reg->bitfields.MEM_TR2R != mem_tr2r) HSLDPF(E_ERROR_MESSAGE,"MEM_TIMING_CNTL::MEM_TR2R data too large\n");
}
#else
#define set_MEM_TIMING_CNTL_mem_trcd(reg, mem_trcd) (reg)->bitfields.MEM_TRCD = mem_trcd
#define set_MEM_TIMING_CNTL_mem_trcdw(reg, mem_trcdw) (reg)->bitfields.MEM_TRCDW = mem_trcdw
#define set_MEM_TIMING_CNTL_mem_trp(reg, mem_trp) (reg)->bitfields.MEM_TRP = mem_trp
#define set_MEM_TIMING_CNTL_mem_tras(reg, mem_tras) (reg)->bitfields.MEM_TRAS = mem_tras
#define set_MEM_TIMING_CNTL_mem_trrd(reg, mem_trrd) (reg)->bitfields.MEM_TRRD = mem_trrd
#define set_MEM_TIMING_CNTL_mem_tr2w(reg, mem_tr2w) (reg)->bitfields.MEM_TR2W = mem_tr2w
#define set_MEM_TIMING_CNTL_mem_twr(reg, mem_twr) (reg)->bitfields.MEM_TWR = mem_twr
#define set_MEM_TIMING_CNTL_mem_tw2r(reg, mem_tw2r) (reg)->bitfields.MEM_TW2R = mem_tw2r
#define set_MEM_TIMING_CNTL_mem_tw2r_same_bank(reg, mem_tw2r_same_bank) (reg)->bitfields.MEM_TW2R_SAME_BANK = mem_tw2r_same_bank
#define set_MEM_TIMING_CNTL_mem_tr2r(reg, mem_tr2r) (reg)->bitfields.MEM_TR2R = mem_tr2r

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_AGP_LOCATION regMC_AGP_LOCATION;

#ifdef DEBUG
__inline void set_MC_AGP_LOCATION_mc_agp_start(regMC_AGP_LOCATION *reg, unsigned int mc_agp_start)
{
  reg->bitfields.MC_AGP_START = mc_agp_start;
  if (reg->bitfields.MC_AGP_START != mc_agp_start) HSLDPF(E_ERROR_MESSAGE,"MC_AGP_LOCATION::MC_AGP_START data too large\n");
}
__inline void set_MC_AGP_LOCATION_mc_agp_top(regMC_AGP_LOCATION *reg, unsigned int mc_agp_top)
{
  reg->bitfields.MC_AGP_TOP = mc_agp_top;
  if (reg->bitfields.MC_AGP_TOP != mc_agp_top) HSLDPF(E_ERROR_MESSAGE,"MC_AGP_LOCATION::MC_AGP_TOP data too large\n");
}
#else
#define set_MC_AGP_LOCATION_mc_agp_start(reg, mc_agp_start) (reg)->bitfields.MC_AGP_START = mc_agp_start
#define set_MC_AGP_LOCATION_mc_agp_top(reg, mc_agp_top) (reg)->bitfields.MC_AGP_TOP = mc_agp_top

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MEM_REFRESH_CNTL regMEM_REFRESH_CNTL;

#ifdef DEBUG
__inline void set_MEM_REFRESH_CNTL_mem_refresh_rate(regMEM_REFRESH_CNTL *reg, unsigned int mem_refresh_rate)
{
  reg->bitfields.MEM_REFRESH_RATE = mem_refresh_rate;
  if (reg->bitfields.MEM_REFRESH_RATE != mem_refresh_rate) HSLDPF(E_ERROR_MESSAGE,"MEM_REFRESH_CNTL::MEM_REFRESH_RATE data too large\n");
}
__inline void set_MEM_REFRESH_CNTL_mem_refresh_dis(regMEM_REFRESH_CNTL *reg, unsigned int mem_refresh_dis)
{
  reg->bitfields.MEM_REFRESH_DIS = mem_refresh_dis;
  if (reg->bitfields.MEM_REFRESH_DIS != mem_refresh_dis) HSLDPF(E_ERROR_MESSAGE,"MEM_REFRESH_CNTL::MEM_REFRESH_DIS data too large\n");
}
__inline void set_MEM_REFRESH_CNTL_mem_dynamic_cke(regMEM_REFRESH_CNTL *reg, unsigned int mem_dynamic_cke)
{
  reg->bitfields.MEM_DYNAMIC_CKE = mem_dynamic_cke;
  if (reg->bitfields.MEM_DYNAMIC_CKE != mem_dynamic_cke) HSLDPF(E_ERROR_MESSAGE,"MEM_REFRESH_CNTL::MEM_DYNAMIC_CKE data too large\n");
}
__inline void set_MEM_REFRESH_CNTL_mem_trfc(regMEM_REFRESH_CNTL *reg, unsigned int mem_trfc)
{
  reg->bitfields.MEM_TRFC = mem_trfc;
  if (reg->bitfields.MEM_TRFC != mem_trfc) HSLDPF(E_ERROR_MESSAGE,"MEM_REFRESH_CNTL::MEM_TRFC data too large\n");
}
__inline void set_MEM_REFRESH_CNTL_mem_clka0_enable(regMEM_REFRESH_CNTL *reg, unsigned int mem_clka0_enable)
{
  reg->bitfields.MEM_CLKA0_ENABLE = mem_clka0_enable;
  if (reg->bitfields.MEM_CLKA0_ENABLE != mem_clka0_enable) HSLDPF(E_ERROR_MESSAGE,"MEM_REFRESH_CNTL::MEM_CLKA0_ENABLE data too large\n");
}
__inline void set_MEM_REFRESH_CNTL_mem_clka0b_enable(regMEM_REFRESH_CNTL *reg, unsigned int mem_clka0b_enable)
{
  reg->bitfields.MEM_CLKA0b_ENABLE = mem_clka0b_enable;
  if (reg->bitfields.MEM_CLKA0b_ENABLE != mem_clka0b_enable) HSLDPF(E_ERROR_MESSAGE,"MEM_REFRESH_CNTL::MEM_CLKA0b_ENABLE data too large\n");
}
__inline void set_MEM_REFRESH_CNTL_mem_clka1_enable(regMEM_REFRESH_CNTL *reg, unsigned int mem_clka1_enable)
{
  reg->bitfields.MEM_CLKA1_ENABLE = mem_clka1_enable;
  if (reg->bitfields.MEM_CLKA1_ENABLE != mem_clka1_enable) HSLDPF(E_ERROR_MESSAGE,"MEM_REFRESH_CNTL::MEM_CLKA1_ENABLE data too large\n");
}
__inline void set_MEM_REFRESH_CNTL_mem_clka1b_enable(regMEM_REFRESH_CNTL *reg, unsigned int mem_clka1b_enable)
{
  reg->bitfields.MEM_CLKA1b_ENABLE = mem_clka1b_enable;
  if (reg->bitfields.MEM_CLKA1b_ENABLE != mem_clka1b_enable) HSLDPF(E_ERROR_MESSAGE,"MEM_REFRESH_CNTL::MEM_CLKA1b_ENABLE data too large\n");
}
__inline void set_MEM_REFRESH_CNTL_mem_clkafb_enable(regMEM_REFRESH_CNTL *reg, unsigned int mem_clkafb_enable)
{
  reg->bitfields.MEM_CLKAFB_ENABLE = mem_clkafb_enable;
  if (reg->bitfields.MEM_CLKAFB_ENABLE != mem_clkafb_enable) HSLDPF(E_ERROR_MESSAGE,"MEM_REFRESH_CNTL::MEM_CLKAFB_ENABLE data too large\n");
}
__inline void set_MEM_REFRESH_CNTL_dll_fb_slct_cka(regMEM_REFRESH_CNTL *reg, unsigned int dll_fb_slct_cka)
{
  reg->bitfields.DLL_FB_SLCT_CKA = dll_fb_slct_cka;
  if (reg->bitfields.DLL_FB_SLCT_CKA != dll_fb_slct_cka) HSLDPF(E_ERROR_MESSAGE,"MEM_REFRESH_CNTL::DLL_FB_SLCT_CKA data too large\n");
}
__inline void set_MEM_REFRESH_CNTL_mem_clkb0_enable(regMEM_REFRESH_CNTL *reg, unsigned int mem_clkb0_enable)
{
  reg->bitfields.MEM_CLKB0_ENABLE = mem_clkb0_enable;
  if (reg->bitfields.MEM_CLKB0_ENABLE != mem_clkb0_enable) HSLDPF(E_ERROR_MESSAGE,"MEM_REFRESH_CNTL::MEM_CLKB0_ENABLE data too large\n");
}
__inline void set_MEM_REFRESH_CNTL_mem_clkb0b_enable(regMEM_REFRESH_CNTL *reg, unsigned int mem_clkb0b_enable)
{
  reg->bitfields.MEM_CLKB0b_ENABLE = mem_clkb0b_enable;
  if (reg->bitfields.MEM_CLKB0b_ENABLE != mem_clkb0b_enable) HSLDPF(E_ERROR_MESSAGE,"MEM_REFRESH_CNTL::MEM_CLKB0b_ENABLE data too large\n");
}
__inline void set_MEM_REFRESH_CNTL_mem_clkb1_enable(regMEM_REFRESH_CNTL *reg, unsigned int mem_clkb1_enable)
{
  reg->bitfields.MEM_CLKB1_ENABLE = mem_clkb1_enable;
  if (reg->bitfields.MEM_CLKB1_ENABLE != mem_clkb1_enable) HSLDPF(E_ERROR_MESSAGE,"MEM_REFRESH_CNTL::MEM_CLKB1_ENABLE data too large\n");
}
__inline void set_MEM_REFRESH_CNTL_mem_clkb1b_enable(regMEM_REFRESH_CNTL *reg, unsigned int mem_clkb1b_enable)
{
  reg->bitfields.MEM_CLKB1b_ENABLE = mem_clkb1b_enable;
  if (reg->bitfields.MEM_CLKB1b_ENABLE != mem_clkb1b_enable) HSLDPF(E_ERROR_MESSAGE,"MEM_REFRESH_CNTL::MEM_CLKB1b_ENABLE data too large\n");
}
__inline void set_MEM_REFRESH_CNTL_mem_clkbfb_enable(regMEM_REFRESH_CNTL *reg, unsigned int mem_clkbfb_enable)
{
  reg->bitfields.MEM_CLKBFB_ENABLE = mem_clkbfb_enable;
  if (reg->bitfields.MEM_CLKBFB_ENABLE != mem_clkbfb_enable) HSLDPF(E_ERROR_MESSAGE,"MEM_REFRESH_CNTL::MEM_CLKBFB_ENABLE data too large\n");
}
__inline void set_MEM_REFRESH_CNTL_dll_fb_slct_ckb(regMEM_REFRESH_CNTL *reg, unsigned int dll_fb_slct_ckb)
{
  reg->bitfields.DLL_FB_SLCT_CKB = dll_fb_slct_ckb;
  if (reg->bitfields.DLL_FB_SLCT_CKB != dll_fb_slct_ckb) HSLDPF(E_ERROR_MESSAGE,"MEM_REFRESH_CNTL::DLL_FB_SLCT_CKB data too large\n");
}
#else
#define set_MEM_REFRESH_CNTL_mem_refresh_rate(reg, mem_refresh_rate) (reg)->bitfields.MEM_REFRESH_RATE = mem_refresh_rate
#define set_MEM_REFRESH_CNTL_mem_refresh_dis(reg, mem_refresh_dis) (reg)->bitfields.MEM_REFRESH_DIS = mem_refresh_dis
#define set_MEM_REFRESH_CNTL_mem_dynamic_cke(reg, mem_dynamic_cke) (reg)->bitfields.MEM_DYNAMIC_CKE = mem_dynamic_cke
#define set_MEM_REFRESH_CNTL_mem_trfc(reg, mem_trfc) (reg)->bitfields.MEM_TRFC = mem_trfc
#define set_MEM_REFRESH_CNTL_mem_clka0_enable(reg, mem_clka0_enable) (reg)->bitfields.MEM_CLKA0_ENABLE = mem_clka0_enable
#define set_MEM_REFRESH_CNTL_mem_clka0b_enable(reg, mem_clka0b_enable) (reg)->bitfields.MEM_CLKA0b_ENABLE = mem_clka0b_enable
#define set_MEM_REFRESH_CNTL_mem_clka1_enable(reg, mem_clka1_enable) (reg)->bitfields.MEM_CLKA1_ENABLE = mem_clka1_enable
#define set_MEM_REFRESH_CNTL_mem_clka1b_enable(reg, mem_clka1b_enable) (reg)->bitfields.MEM_CLKA1b_ENABLE = mem_clka1b_enable
#define set_MEM_REFRESH_CNTL_mem_clkafb_enable(reg, mem_clkafb_enable) (reg)->bitfields.MEM_CLKAFB_ENABLE = mem_clkafb_enable
#define set_MEM_REFRESH_CNTL_dll_fb_slct_cka(reg, dll_fb_slct_cka) (reg)->bitfields.DLL_FB_SLCT_CKA = dll_fb_slct_cka
#define set_MEM_REFRESH_CNTL_mem_clkb0_enable(reg, mem_clkb0_enable) (reg)->bitfields.MEM_CLKB0_ENABLE = mem_clkb0_enable
#define set_MEM_REFRESH_CNTL_mem_clkb0b_enable(reg, mem_clkb0b_enable) (reg)->bitfields.MEM_CLKB0b_ENABLE = mem_clkb0b_enable
#define set_MEM_REFRESH_CNTL_mem_clkb1_enable(reg, mem_clkb1_enable) (reg)->bitfields.MEM_CLKB1_ENABLE = mem_clkb1_enable
#define set_MEM_REFRESH_CNTL_mem_clkb1b_enable(reg, mem_clkb1b_enable) (reg)->bitfields.MEM_CLKB1b_ENABLE = mem_clkb1b_enable
#define set_MEM_REFRESH_CNTL_mem_clkbfb_enable(reg, mem_clkbfb_enable) (reg)->bitfields.MEM_CLKBFB_ENABLE = mem_clkbfb_enable
#define set_MEM_REFRESH_CNTL_dll_fb_slct_ckb(reg, dll_fb_slct_ckb) (reg)->bitfields.DLL_FB_SLCT_CKB = dll_fb_slct_ckb

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MEM_INIT_LATENCY_TIMER regMEM_INIT_LATENCY_TIMER;

#ifdef DEBUG
__inline void set_MEM_INIT_LATENCY_TIMER_mem_rb0r_init_lat(regMEM_INIT_LATENCY_TIMER *reg, unsigned int mem_rb0r_init_lat)
{
  reg->bitfields.MEM_RB0R_INIT_LAT = mem_rb0r_init_lat;
  if (reg->bitfields.MEM_RB0R_INIT_LAT != mem_rb0r_init_lat) HSLDPF(E_ERROR_MESSAGE,"MEM_INIT_LATENCY_TIMER::MEM_RB0R_INIT_LAT data too large\n");
}
__inline void set_MEM_INIT_LATENCY_TIMER_mem_rb1r_init_lat(regMEM_INIT_LATENCY_TIMER *reg, unsigned int mem_rb1r_init_lat)
{
  reg->bitfields.MEM_RB1R_INIT_LAT = mem_rb1r_init_lat;
  if (reg->bitfields.MEM_RB1R_INIT_LAT != mem_rb1r_init_lat) HSLDPF(E_ERROR_MESSAGE,"MEM_INIT_LATENCY_TIMER::MEM_RB1R_INIT_LAT data too large\n");
}
__inline void set_MEM_INIT_LATENCY_TIMER_mem_ppr_init_lat(regMEM_INIT_LATENCY_TIMER *reg, unsigned int mem_ppr_init_lat)
{
  reg->bitfields.MEM_PPR_INIT_LAT = mem_ppr_init_lat;
  if (reg->bitfields.MEM_PPR_INIT_LAT != mem_ppr_init_lat) HSLDPF(E_ERROR_MESSAGE,"MEM_INIT_LATENCY_TIMER::MEM_PPR_INIT_LAT data too large\n");
}
__inline void set_MEM_INIT_LATENCY_TIMER_mem_dispr_init_lat(regMEM_INIT_LATENCY_TIMER *reg, unsigned int mem_dispr_init_lat)
{
  reg->bitfields.MEM_DISPR_INIT_LAT = mem_dispr_init_lat;
  if (reg->bitfields.MEM_DISPR_INIT_LAT != mem_dispr_init_lat) HSLDPF(E_ERROR_MESSAGE,"MEM_INIT_LATENCY_TIMER::MEM_DISPR_INIT_LAT data too large\n");
}
__inline void set_MEM_INIT_LATENCY_TIMER_mem_rb0w_init_lat(regMEM_INIT_LATENCY_TIMER *reg, unsigned int mem_rb0w_init_lat)
{
  reg->bitfields.MEM_RB0W_INIT_LAT = mem_rb0w_init_lat;
  if (reg->bitfields.MEM_RB0W_INIT_LAT != mem_rb0w_init_lat) HSLDPF(E_ERROR_MESSAGE,"MEM_INIT_LATENCY_TIMER::MEM_RB0W_INIT_LAT data too large\n");
}
__inline void set_MEM_INIT_LATENCY_TIMER_mem_rb1w_init_lat(regMEM_INIT_LATENCY_TIMER *reg, unsigned int mem_rb1w_init_lat)
{
  reg->bitfields.MEM_RB1W_INIT_LAT = mem_rb1w_init_lat;
  if (reg->bitfields.MEM_RB1W_INIT_LAT != mem_rb1w_init_lat) HSLDPF(E_ERROR_MESSAGE,"MEM_INIT_LATENCY_TIMER::MEM_RB1W_INIT_LAT data too large\n");
}
__inline void set_MEM_INIT_LATENCY_TIMER_mem_fixed_init_lat(regMEM_INIT_LATENCY_TIMER *reg, unsigned int mem_fixed_init_lat)
{
  reg->bitfields.MEM_FIXED_INIT_LAT = mem_fixed_init_lat;
  if (reg->bitfields.MEM_FIXED_INIT_LAT != mem_fixed_init_lat) HSLDPF(E_ERROR_MESSAGE,"MEM_INIT_LATENCY_TIMER::MEM_FIXED_INIT_LAT data too large\n");
}
__inline void set_MEM_INIT_LATENCY_TIMER_same_page_prio(regMEM_INIT_LATENCY_TIMER *reg, unsigned int same_page_prio)
{
  reg->bitfields.SAME_PAGE_PRIO = same_page_prio;
  if (reg->bitfields.SAME_PAGE_PRIO != same_page_prio) HSLDPF(E_ERROR_MESSAGE,"MEM_INIT_LATENCY_TIMER::SAME_PAGE_PRIO data too large\n");
}
#else
#define set_MEM_INIT_LATENCY_TIMER_mem_rb0r_init_lat(reg, mem_rb0r_init_lat) (reg)->bitfields.MEM_RB0R_INIT_LAT = mem_rb0r_init_lat
#define set_MEM_INIT_LATENCY_TIMER_mem_rb1r_init_lat(reg, mem_rb1r_init_lat) (reg)->bitfields.MEM_RB1R_INIT_LAT = mem_rb1r_init_lat
#define set_MEM_INIT_LATENCY_TIMER_mem_ppr_init_lat(reg, mem_ppr_init_lat) (reg)->bitfields.MEM_PPR_INIT_LAT = mem_ppr_init_lat
#define set_MEM_INIT_LATENCY_TIMER_mem_dispr_init_lat(reg, mem_dispr_init_lat) (reg)->bitfields.MEM_DISPR_INIT_LAT = mem_dispr_init_lat
#define set_MEM_INIT_LATENCY_TIMER_mem_rb0w_init_lat(reg, mem_rb0w_init_lat) (reg)->bitfields.MEM_RB0W_INIT_LAT = mem_rb0w_init_lat
#define set_MEM_INIT_LATENCY_TIMER_mem_rb1w_init_lat(reg, mem_rb1w_init_lat) (reg)->bitfields.MEM_RB1W_INIT_LAT = mem_rb1w_init_lat
#define set_MEM_INIT_LATENCY_TIMER_mem_fixed_init_lat(reg, mem_fixed_init_lat) (reg)->bitfields.MEM_FIXED_INIT_LAT = mem_fixed_init_lat
#define set_MEM_INIT_LATENCY_TIMER_same_page_prio(reg, same_page_prio) (reg)->bitfields.SAME_PAGE_PRIO = same_page_prio

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MEM_SDRAM_MODE_REG regMEM_SDRAM_MODE_REG;

#ifdef DEBUG
__inline void set_MEM_SDRAM_MODE_REG_mem_mode_reg(regMEM_SDRAM_MODE_REG *reg, unsigned int mem_mode_reg)
{
  reg->bitfields.MEM_MODE_REG = mem_mode_reg;
  if (reg->bitfields.MEM_MODE_REG != mem_mode_reg) HSLDPF(E_ERROR_MESSAGE,"MEM_SDRAM_MODE_REG::MEM_MODE_REG data too large\n");
}
__inline void set_MEM_SDRAM_MODE_REG_mem_wr_latency(regMEM_SDRAM_MODE_REG *reg, unsigned int mem_wr_latency)
{
  reg->bitfields.MEM_WR_LATENCY = mem_wr_latency;
  if (reg->bitfields.MEM_WR_LATENCY != mem_wr_latency) HSLDPF(E_ERROR_MESSAGE,"MEM_SDRAM_MODE_REG::MEM_WR_LATENCY data too large\n");
}
__inline void set_MEM_SDRAM_MODE_REG_mem_cas_latency(regMEM_SDRAM_MODE_REG *reg, unsigned int mem_cas_latency)
{
  reg->bitfields.MEM_CAS_LATENCY = mem_cas_latency;
  if (reg->bitfields.MEM_CAS_LATENCY != mem_cas_latency) HSLDPF(E_ERROR_MESSAGE,"MEM_SDRAM_MODE_REG::MEM_CAS_LATENCY data too large\n");
}
__inline void set_MEM_SDRAM_MODE_REG_mem_cmd_latency(regMEM_SDRAM_MODE_REG *reg, unsigned int mem_cmd_latency)
{
  reg->bitfields.MEM_CMD_LATENCY = mem_cmd_latency;
  if (reg->bitfields.MEM_CMD_LATENCY != mem_cmd_latency) HSLDPF(E_ERROR_MESSAGE,"MEM_SDRAM_MODE_REG::MEM_CMD_LATENCY data too large\n");
}
__inline void set_MEM_SDRAM_MODE_REG_mem_str_latency(regMEM_SDRAM_MODE_REG *reg, unsigned int mem_str_latency)
{
  reg->bitfields.MEM_STR_LATENCY = mem_str_latency;
  if (reg->bitfields.MEM_STR_LATENCY != mem_str_latency) HSLDPF(E_ERROR_MESSAGE,"MEM_SDRAM_MODE_REG::MEM_STR_LATENCY data too large\n");
}
__inline void set_MEM_SDRAM_MODE_REG_mem_fall_out_cmd(regMEM_SDRAM_MODE_REG *reg, unsigned int mem_fall_out_cmd)
{
  reg->bitfields.MEM_FALL_OUT_CMD = mem_fall_out_cmd;
  if (reg->bitfields.MEM_FALL_OUT_CMD != mem_fall_out_cmd) HSLDPF(E_ERROR_MESSAGE,"MEM_SDRAM_MODE_REG::MEM_FALL_OUT_CMD data too large\n");
}
__inline void set_MEM_SDRAM_MODE_REG_mem_fall_out_data(regMEM_SDRAM_MODE_REG *reg, unsigned int mem_fall_out_data)
{
  reg->bitfields.MEM_FALL_OUT_DATA = mem_fall_out_data;
  if (reg->bitfields.MEM_FALL_OUT_DATA != mem_fall_out_data) HSLDPF(E_ERROR_MESSAGE,"MEM_SDRAM_MODE_REG::MEM_FALL_OUT_DATA data too large\n");
}
__inline void set_MEM_SDRAM_MODE_REG_mem_fall_out_str(regMEM_SDRAM_MODE_REG *reg, unsigned int mem_fall_out_str)
{
  reg->bitfields.MEM_FALL_OUT_STR = mem_fall_out_str;
  if (reg->bitfields.MEM_FALL_OUT_STR != mem_fall_out_str) HSLDPF(E_ERROR_MESSAGE,"MEM_SDRAM_MODE_REG::MEM_FALL_OUT_STR data too large\n");
}
__inline void set_MEM_SDRAM_MODE_REG_mc_init_complete(regMEM_SDRAM_MODE_REG *reg, unsigned int mc_init_complete)
{
  reg->bitfields.MC_INIT_COMPLETE = mc_init_complete;
  if (reg->bitfields.MC_INIT_COMPLETE != mc_init_complete) HSLDPF(E_ERROR_MESSAGE,"MEM_SDRAM_MODE_REG::MC_INIT_COMPLETE data too large\n");
}
__inline void set_MEM_SDRAM_MODE_REG_mem_ddr_dll(regMEM_SDRAM_MODE_REG *reg, unsigned int mem_ddr_dll)
{
  reg->bitfields.MEM_DDR_DLL = mem_ddr_dll;
  if (reg->bitfields.MEM_DDR_DLL != mem_ddr_dll) HSLDPF(E_ERROR_MESSAGE,"MEM_SDRAM_MODE_REG::MEM_DDR_DLL data too large\n");
}
__inline void set_MEM_SDRAM_MODE_REG_mem_cfg_type(regMEM_SDRAM_MODE_REG *reg, unsigned int mem_cfg_type)
{
  reg->bitfields.MEM_CFG_TYPE = mem_cfg_type;
  if (reg->bitfields.MEM_CFG_TYPE != mem_cfg_type) HSLDPF(E_ERROR_MESSAGE,"MEM_SDRAM_MODE_REG::MEM_CFG_TYPE data too large\n");
}
__inline void set_MEM_SDRAM_MODE_REG_mem_sdram_reset(regMEM_SDRAM_MODE_REG *reg, unsigned int mem_sdram_reset)
{
  reg->bitfields.MEM_SDRAM_RESET = mem_sdram_reset;
  if (reg->bitfields.MEM_SDRAM_RESET != mem_sdram_reset) HSLDPF(E_ERROR_MESSAGE,"MEM_SDRAM_MODE_REG::MEM_SDRAM_RESET data too large\n");
}
#else
#define set_MEM_SDRAM_MODE_REG_mem_mode_reg(reg, mem_mode_reg) (reg)->bitfields.MEM_MODE_REG = mem_mode_reg
#define set_MEM_SDRAM_MODE_REG_mem_wr_latency(reg, mem_wr_latency) (reg)->bitfields.MEM_WR_LATENCY = mem_wr_latency
#define set_MEM_SDRAM_MODE_REG_mem_cas_latency(reg, mem_cas_latency) (reg)->bitfields.MEM_CAS_LATENCY = mem_cas_latency
#define set_MEM_SDRAM_MODE_REG_mem_cmd_latency(reg, mem_cmd_latency) (reg)->bitfields.MEM_CMD_LATENCY = mem_cmd_latency
#define set_MEM_SDRAM_MODE_REG_mem_str_latency(reg, mem_str_latency) (reg)->bitfields.MEM_STR_LATENCY = mem_str_latency
#define set_MEM_SDRAM_MODE_REG_mem_fall_out_cmd(reg, mem_fall_out_cmd) (reg)->bitfields.MEM_FALL_OUT_CMD = mem_fall_out_cmd
#define set_MEM_SDRAM_MODE_REG_mem_fall_out_data(reg, mem_fall_out_data) (reg)->bitfields.MEM_FALL_OUT_DATA = mem_fall_out_data
#define set_MEM_SDRAM_MODE_REG_mem_fall_out_str(reg, mem_fall_out_str) (reg)->bitfields.MEM_FALL_OUT_STR = mem_fall_out_str
#define set_MEM_SDRAM_MODE_REG_mc_init_complete(reg, mc_init_complete) (reg)->bitfields.MC_INIT_COMPLETE = mc_init_complete
#define set_MEM_SDRAM_MODE_REG_mem_ddr_dll(reg, mem_ddr_dll) (reg)->bitfields.MEM_DDR_DLL = mem_ddr_dll
#define set_MEM_SDRAM_MODE_REG_mem_cfg_type(reg, mem_cfg_type) (reg)->bitfields.MEM_CFG_TYPE = mem_cfg_type
#define set_MEM_SDRAM_MODE_REG_mem_sdram_reset(reg, mem_sdram_reset) (reg)->bitfields.MEM_SDRAM_RESET = mem_sdram_reset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union AGP_BASE regAGP_BASE;

#ifdef DEBUG
__inline void set_AGP_BASE_agp_base_addr(regAGP_BASE *reg, unsigned int agp_base_addr)
{
  reg->bitfields.AGP_BASE_ADDR = agp_base_addr;
  if (reg->bitfields.AGP_BASE_ADDR != agp_base_addr) HSLDPF(E_ERROR_MESSAGE,"AGP_BASE::AGP_BASE_ADDR data too large\n");
}
#else
#define set_AGP_BASE_agp_base_addr(reg, agp_base_addr) (reg)->bitfields.AGP_BASE_ADDR = agp_base_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MEM_READ_CNTL regMEM_READ_CNTL;

#ifdef DEBUG
__inline void set_MEM_READ_CNTL_mem_rbs_position_a(regMEM_READ_CNTL *reg, unsigned int mem_rbs_position_a)
{
  reg->bitfields.MEM_RBS_POSITION_A = mem_rbs_position_a;
  if (reg->bitfields.MEM_RBS_POSITION_A != mem_rbs_position_a) HSLDPF(E_ERROR_MESSAGE,"MEM_READ_CNTL::MEM_RBS_POSITION_A data too large\n");
}
__inline void set_MEM_READ_CNTL_mem_str_sel_a(regMEM_READ_CNTL *reg, unsigned int mem_str_sel_a)
{
  reg->bitfields.MEM_STR_SEL_A = mem_str_sel_a;
  if (reg->bitfields.MEM_STR_SEL_A != mem_str_sel_a) HSLDPF(E_ERROR_MESSAGE,"MEM_READ_CNTL::MEM_STR_SEL_A data too large\n");
}
__inline void set_MEM_READ_CNTL_mem_erst_position_a(regMEM_READ_CNTL *reg, unsigned int mem_erst_position_a)
{
  reg->bitfields.MEM_ERST_POSITION_A = mem_erst_position_a;
  if (reg->bitfields.MEM_ERST_POSITION_A != mem_erst_position_a) HSLDPF(E_ERROR_MESSAGE,"MEM_READ_CNTL::MEM_ERST_POSITION_A data too large\n");
}
__inline void set_MEM_READ_CNTL_mem_erst_extend_a(regMEM_READ_CNTL *reg, unsigned int mem_erst_extend_a)
{
  reg->bitfields.MEM_ERST_EXTEND_A = mem_erst_extend_a;
  if (reg->bitfields.MEM_ERST_EXTEND_A != mem_erst_extend_a) HSLDPF(E_ERROR_MESSAGE,"MEM_READ_CNTL::MEM_ERST_EXTEND_A data too large\n");
}
__inline void set_MEM_READ_CNTL_mem_qsrec_position_a(regMEM_READ_CNTL *reg, unsigned int mem_qsrec_position_a)
{
  reg->bitfields.MEM_QSREC_POSITION_A = mem_qsrec_position_a;
  if (reg->bitfields.MEM_QSREC_POSITION_A != mem_qsrec_position_a) HSLDPF(E_ERROR_MESSAGE,"MEM_READ_CNTL::MEM_QSREC_POSITION_A data too large\n");
}
__inline void set_MEM_READ_CNTL_mem_qsrec_extend_a(regMEM_READ_CNTL *reg, unsigned int mem_qsrec_extend_a)
{
  reg->bitfields.MEM_QSREC_EXTEND_A = mem_qsrec_extend_a;
  if (reg->bitfields.MEM_QSREC_EXTEND_A != mem_qsrec_extend_a) HSLDPF(E_ERROR_MESSAGE,"MEM_READ_CNTL::MEM_QSREC_EXTEND_A data too large\n");
}
__inline void set_MEM_READ_CNTL_mem_erst_sync_a(regMEM_READ_CNTL *reg, unsigned int mem_erst_sync_a)
{
  reg->bitfields.MEM_ERST_SYNC_A = mem_erst_sync_a;
  if (reg->bitfields.MEM_ERST_SYNC_A != mem_erst_sync_a) HSLDPF(E_ERROR_MESSAGE,"MEM_READ_CNTL::MEM_ERST_SYNC_A data too large\n");
}
__inline void set_MEM_READ_CNTL_mem_qsrec_sync_a(regMEM_READ_CNTL *reg, unsigned int mem_qsrec_sync_a)
{
  reg->bitfields.MEM_QSREC_SYNC_A = mem_qsrec_sync_a;
  if (reg->bitfields.MEM_QSREC_SYNC_A != mem_qsrec_sync_a) HSLDPF(E_ERROR_MESSAGE,"MEM_READ_CNTL::MEM_QSREC_SYNC_A data too large\n");
}
__inline void set_MEM_READ_CNTL_mem_read_str_fall_a(regMEM_READ_CNTL *reg, unsigned int mem_read_str_fall_a)
{
  reg->bitfields.MEM_READ_STR_FALL_A = mem_read_str_fall_a;
  if (reg->bitfields.MEM_READ_STR_FALL_A != mem_read_str_fall_a) HSLDPF(E_ERROR_MESSAGE,"MEM_READ_CNTL::MEM_READ_STR_FALL_A data too large\n");
}
__inline void set_MEM_READ_CNTL_mem_rbs_position_b(regMEM_READ_CNTL *reg, unsigned int mem_rbs_position_b)
{
  reg->bitfields.MEM_RBS_POSITION_B = mem_rbs_position_b;
  if (reg->bitfields.MEM_RBS_POSITION_B != mem_rbs_position_b) HSLDPF(E_ERROR_MESSAGE,"MEM_READ_CNTL::MEM_RBS_POSITION_B data too large\n");
}
__inline void set_MEM_READ_CNTL_mem_str_sel_b(regMEM_READ_CNTL *reg, unsigned int mem_str_sel_b)
{
  reg->bitfields.MEM_STR_SEL_B = mem_str_sel_b;
  if (reg->bitfields.MEM_STR_SEL_B != mem_str_sel_b) HSLDPF(E_ERROR_MESSAGE,"MEM_READ_CNTL::MEM_STR_SEL_B data too large\n");
}
__inline void set_MEM_READ_CNTL_mem_erst_position_b(regMEM_READ_CNTL *reg, unsigned int mem_erst_position_b)
{
  reg->bitfields.MEM_ERST_POSITION_B = mem_erst_position_b;
  if (reg->bitfields.MEM_ERST_POSITION_B != mem_erst_position_b) HSLDPF(E_ERROR_MESSAGE,"MEM_READ_CNTL::MEM_ERST_POSITION_B data too large\n");
}
__inline void set_MEM_READ_CNTL_mem_erst_extend_b(regMEM_READ_CNTL *reg, unsigned int mem_erst_extend_b)
{
  reg->bitfields.MEM_ERST_EXTEND_B = mem_erst_extend_b;
  if (reg->bitfields.MEM_ERST_EXTEND_B != mem_erst_extend_b) HSLDPF(E_ERROR_MESSAGE,"MEM_READ_CNTL::MEM_ERST_EXTEND_B data too large\n");
}
__inline void set_MEM_READ_CNTL_mem_qsrec_position_b(regMEM_READ_CNTL *reg, unsigned int mem_qsrec_position_b)
{
  reg->bitfields.MEM_QSREC_POSITION_B = mem_qsrec_position_b;
  if (reg->bitfields.MEM_QSREC_POSITION_B != mem_qsrec_position_b) HSLDPF(E_ERROR_MESSAGE,"MEM_READ_CNTL::MEM_QSREC_POSITION_B data too large\n");
}
__inline void set_MEM_READ_CNTL_mem_qsrec_extend_b(regMEM_READ_CNTL *reg, unsigned int mem_qsrec_extend_b)
{
  reg->bitfields.MEM_QSREC_EXTEND_B = mem_qsrec_extend_b;
  if (reg->bitfields.MEM_QSREC_EXTEND_B != mem_qsrec_extend_b) HSLDPF(E_ERROR_MESSAGE,"MEM_READ_CNTL::MEM_QSREC_EXTEND_B data too large\n");
}
__inline void set_MEM_READ_CNTL_mem_erst_sync_b(regMEM_READ_CNTL *reg, unsigned int mem_erst_sync_b)
{
  reg->bitfields.MEM_ERST_SYNC_B = mem_erst_sync_b;
  if (reg->bitfields.MEM_ERST_SYNC_B != mem_erst_sync_b) HSLDPF(E_ERROR_MESSAGE,"MEM_READ_CNTL::MEM_ERST_SYNC_B data too large\n");
}
__inline void set_MEM_READ_CNTL_mem_qsrec_sync_b(regMEM_READ_CNTL *reg, unsigned int mem_qsrec_sync_b)
{
  reg->bitfields.MEM_QSREC_SYNC_B = mem_qsrec_sync_b;
  if (reg->bitfields.MEM_QSREC_SYNC_B != mem_qsrec_sync_b) HSLDPF(E_ERROR_MESSAGE,"MEM_READ_CNTL::MEM_QSREC_SYNC_B data too large\n");
}
__inline void set_MEM_READ_CNTL_mem_read_str_fall_b(regMEM_READ_CNTL *reg, unsigned int mem_read_str_fall_b)
{
  reg->bitfields.MEM_READ_STR_FALL_B = mem_read_str_fall_b;
  if (reg->bitfields.MEM_READ_STR_FALL_B != mem_read_str_fall_b) HSLDPF(E_ERROR_MESSAGE,"MEM_READ_CNTL::MEM_READ_STR_FALL_B data too large\n");
}
#else
#define set_MEM_READ_CNTL_mem_rbs_position_a(reg, mem_rbs_position_a) (reg)->bitfields.MEM_RBS_POSITION_A = mem_rbs_position_a
#define set_MEM_READ_CNTL_mem_str_sel_a(reg, mem_str_sel_a) (reg)->bitfields.MEM_STR_SEL_A = mem_str_sel_a
#define set_MEM_READ_CNTL_mem_erst_position_a(reg, mem_erst_position_a) (reg)->bitfields.MEM_ERST_POSITION_A = mem_erst_position_a
#define set_MEM_READ_CNTL_mem_erst_extend_a(reg, mem_erst_extend_a) (reg)->bitfields.MEM_ERST_EXTEND_A = mem_erst_extend_a
#define set_MEM_READ_CNTL_mem_qsrec_position_a(reg, mem_qsrec_position_a) (reg)->bitfields.MEM_QSREC_POSITION_A = mem_qsrec_position_a
#define set_MEM_READ_CNTL_mem_qsrec_extend_a(reg, mem_qsrec_extend_a) (reg)->bitfields.MEM_QSREC_EXTEND_A = mem_qsrec_extend_a
#define set_MEM_READ_CNTL_mem_erst_sync_a(reg, mem_erst_sync_a) (reg)->bitfields.MEM_ERST_SYNC_A = mem_erst_sync_a
#define set_MEM_READ_CNTL_mem_qsrec_sync_a(reg, mem_qsrec_sync_a) (reg)->bitfields.MEM_QSREC_SYNC_A = mem_qsrec_sync_a
#define set_MEM_READ_CNTL_mem_read_str_fall_a(reg, mem_read_str_fall_a) (reg)->bitfields.MEM_READ_STR_FALL_A = mem_read_str_fall_a
#define set_MEM_READ_CNTL_mem_rbs_position_b(reg, mem_rbs_position_b) (reg)->bitfields.MEM_RBS_POSITION_B = mem_rbs_position_b
#define set_MEM_READ_CNTL_mem_str_sel_b(reg, mem_str_sel_b) (reg)->bitfields.MEM_STR_SEL_B = mem_str_sel_b
#define set_MEM_READ_CNTL_mem_erst_position_b(reg, mem_erst_position_b) (reg)->bitfields.MEM_ERST_POSITION_B = mem_erst_position_b
#define set_MEM_READ_CNTL_mem_erst_extend_b(reg, mem_erst_extend_b) (reg)->bitfields.MEM_ERST_EXTEND_B = mem_erst_extend_b
#define set_MEM_READ_CNTL_mem_qsrec_position_b(reg, mem_qsrec_position_b) (reg)->bitfields.MEM_QSREC_POSITION_B = mem_qsrec_position_b
#define set_MEM_READ_CNTL_mem_qsrec_extend_b(reg, mem_qsrec_extend_b) (reg)->bitfields.MEM_QSREC_EXTEND_B = mem_qsrec_extend_b
#define set_MEM_READ_CNTL_mem_erst_sync_b(reg, mem_erst_sync_b) (reg)->bitfields.MEM_ERST_SYNC_B = mem_erst_sync_b
#define set_MEM_READ_CNTL_mem_qsrec_sync_b(reg, mem_qsrec_sync_b) (reg)->bitfields.MEM_QSREC_SYNC_B = mem_qsrec_sync_b
#define set_MEM_READ_CNTL_mem_read_str_fall_b(reg, mem_read_str_fall_b) (reg)->bitfields.MEM_READ_STR_FALL_B = mem_read_str_fall_b

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250MC_DEBUG regrv250MC_DEBUG;

#ifdef DEBUG
__inline void set_rv250MC_DEBUG_ignore_rw_penalty_rb0r(regrv250MC_DEBUG *reg, unsigned int ignore_rw_penalty_rb0r)
{
  reg->bitfields.IGNORE_RW_PENALTY_RB0R = ignore_rw_penalty_rb0r;
  if (reg->bitfields.IGNORE_RW_PENALTY_RB0R != ignore_rw_penalty_rb0r) HSLDPF(E_ERROR_MESSAGE,"rv250MC_DEBUG::IGNORE_RW_PENALTY_RB0R data too large\n");
}
__inline void set_rv250MC_DEBUG_ignore_rw_penalty_rb1r(regrv250MC_DEBUG *reg, unsigned int ignore_rw_penalty_rb1r)
{
  reg->bitfields.IGNORE_RW_PENALTY_RB1R = ignore_rw_penalty_rb1r;
  if (reg->bitfields.IGNORE_RW_PENALTY_RB1R != ignore_rw_penalty_rb1r) HSLDPF(E_ERROR_MESSAGE,"rv250MC_DEBUG::IGNORE_RW_PENALTY_RB1R data too large\n");
}
__inline void set_rv250MC_DEBUG_ignore_rw_penalty_rb0w(regrv250MC_DEBUG *reg, unsigned int ignore_rw_penalty_rb0w)
{
  reg->bitfields.IGNORE_RW_PENALTY_RB0W = ignore_rw_penalty_rb0w;
  if (reg->bitfields.IGNORE_RW_PENALTY_RB0W != ignore_rw_penalty_rb0w) HSLDPF(E_ERROR_MESSAGE,"rv250MC_DEBUG::IGNORE_RW_PENALTY_RB0W data too large\n");
}
__inline void set_rv250MC_DEBUG_ignore_rw_penalty_rb1w(regrv250MC_DEBUG *reg, unsigned int ignore_rw_penalty_rb1w)
{
  reg->bitfields.IGNORE_RW_PENALTY_RB1W = ignore_rw_penalty_rb1w;
  if (reg->bitfields.IGNORE_RW_PENALTY_RB1W != ignore_rw_penalty_rb1w) HSLDPF(E_ERROR_MESSAGE,"rv250MC_DEBUG::IGNORE_RW_PENALTY_RB1W data too large\n");
}
__inline void set_rv250MC_DEBUG_ignore_rw_penalty_dispr(regrv250MC_DEBUG *reg, unsigned int ignore_rw_penalty_dispr)
{
  reg->bitfields.IGNORE_RW_PENALTY_DISPR = ignore_rw_penalty_dispr;
  if (reg->bitfields.IGNORE_RW_PENALTY_DISPR != ignore_rw_penalty_dispr) HSLDPF(E_ERROR_MESSAGE,"rv250MC_DEBUG::IGNORE_RW_PENALTY_DISPR data too large\n");
}
__inline void set_rv250MC_DEBUG_ignore_rw_penalty_ppr(regrv250MC_DEBUG *reg, unsigned int ignore_rw_penalty_ppr)
{
  reg->bitfields.IGNORE_RW_PENALTY_PPR = ignore_rw_penalty_ppr;
  if (reg->bitfields.IGNORE_RW_PENALTY_PPR != ignore_rw_penalty_ppr) HSLDPF(E_ERROR_MESSAGE,"rv250MC_DEBUG::IGNORE_RW_PENALTY_PPR data too large\n");
}
__inline void set_rv250MC_DEBUG_ignore_rw_penalty_fixed(regrv250MC_DEBUG *reg, unsigned int ignore_rw_penalty_fixed)
{
  reg->bitfields.IGNORE_RW_PENALTY_FIXED = ignore_rw_penalty_fixed;
  if (reg->bitfields.IGNORE_RW_PENALTY_FIXED != ignore_rw_penalty_fixed) HSLDPF(E_ERROR_MESSAGE,"rv250MC_DEBUG::IGNORE_RW_PENALTY_FIXED data too large\n");
}
__inline void set_rv250MC_DEBUG_mem_vipw_priority(regrv250MC_DEBUG *reg, unsigned int mem_vipw_priority)
{
  reg->bitfields.MEM_VIPW_PRIORITY = mem_vipw_priority;
  if (reg->bitfields.MEM_VIPW_PRIORITY != mem_vipw_priority) HSLDPF(E_ERROR_MESSAGE,"rv250MC_DEBUG::MEM_VIPW_PRIORITY data too large\n");
}
__inline void set_rv250MC_DEBUG_en_aic_idle_det(regrv250MC_DEBUG *reg, unsigned int en_aic_idle_det)
{
  reg->bitfields.EN_AIC_IDLE_DET = en_aic_idle_det;
  if (reg->bitfields.EN_AIC_IDLE_DET != en_aic_idle_det) HSLDPF(E_ERROR_MESSAGE,"rv250MC_DEBUG::EN_AIC_IDLE_DET data too large\n");
}
__inline void set_rv250MC_DEBUG_mem_mc_blackout(regrv250MC_DEBUG *reg, unsigned int mem_mc_blackout)
{
  reg->bitfields.MEM_MC_BLACKOUT = mem_mc_blackout;
  if (reg->bitfields.MEM_MC_BLACKOUT != mem_mc_blackout) HSLDPF(E_ERROR_MESSAGE,"rv250MC_DEBUG::MEM_MC_BLACKOUT data too large\n");
}
__inline void set_rv250MC_DEBUG_disable_tee_sm_changes(regrv250MC_DEBUG *reg, unsigned int disable_tee_sm_changes)
{
  reg->bitfields.DISABLE_TEE_SM_CHANGES = disable_tee_sm_changes;
  if (reg->bitfields.DISABLE_TEE_SM_CHANGES != disable_tee_sm_changes) HSLDPF(E_ERROR_MESSAGE,"rv250MC_DEBUG::DISABLE_TEE_SM_CHANGES data too large\n");
}
__inline void set_rv250MC_DEBUG_imp_n_value_dqs_r_back(regrv250MC_DEBUG *reg, unsigned int imp_n_value_dqs_r_back)
{
  reg->bitfields.IMP_N_VALUE_DQS_R_BACK = imp_n_value_dqs_r_back;
  if (reg->bitfields.IMP_N_VALUE_DQS_R_BACK != imp_n_value_dqs_r_back) HSLDPF(E_ERROR_MESSAGE,"rv250MC_DEBUG::IMP_N_VALUE_DQS_R_BACK data too large\n");
}
__inline void set_rv250MC_DEBUG_imp_p_value_dqs_r_back(regrv250MC_DEBUG *reg, unsigned int imp_p_value_dqs_r_back)
{
  reg->bitfields.IMP_P_VALUE_DQS_R_BACK = imp_p_value_dqs_r_back;
  if (reg->bitfields.IMP_P_VALUE_DQS_R_BACK != imp_p_value_dqs_r_back) HSLDPF(E_ERROR_MESSAGE,"rv250MC_DEBUG::IMP_P_VALUE_DQS_R_BACK data too large\n");
}
__inline void set_rv250MC_DEBUG_mc_bist_en(regrv250MC_DEBUG *reg, unsigned int mc_bist_en)
{
  reg->bitfields.MC_BIST_EN = mc_bist_en;
  if (reg->bitfields.MC_BIST_EN != mc_bist_en) HSLDPF(E_ERROR_MESSAGE,"rv250MC_DEBUG::MC_BIST_EN data too large\n");
}
__inline void set_rv250MC_DEBUG_mc_debug(regrv250MC_DEBUG *reg, unsigned int mc_debug)
{
  reg->bitfields.MC_DEBUG = mc_debug;
  if (reg->bitfields.MC_DEBUG != mc_debug) HSLDPF(E_ERROR_MESSAGE,"rv250MC_DEBUG::MC_DEBUG data too large\n");
}
#else
#define set_rv250MC_DEBUG_ignore_rw_penalty_rb0r(reg, ignore_rw_penalty_rb0r) (reg)->bitfields.IGNORE_RW_PENALTY_RB0R = ignore_rw_penalty_rb0r
#define set_rv250MC_DEBUG_ignore_rw_penalty_rb1r(reg, ignore_rw_penalty_rb1r) (reg)->bitfields.IGNORE_RW_PENALTY_RB1R = ignore_rw_penalty_rb1r
#define set_rv250MC_DEBUG_ignore_rw_penalty_rb0w(reg, ignore_rw_penalty_rb0w) (reg)->bitfields.IGNORE_RW_PENALTY_RB0W = ignore_rw_penalty_rb0w
#define set_rv250MC_DEBUG_ignore_rw_penalty_rb1w(reg, ignore_rw_penalty_rb1w) (reg)->bitfields.IGNORE_RW_PENALTY_RB1W = ignore_rw_penalty_rb1w
#define set_rv250MC_DEBUG_ignore_rw_penalty_dispr(reg, ignore_rw_penalty_dispr) (reg)->bitfields.IGNORE_RW_PENALTY_DISPR = ignore_rw_penalty_dispr
#define set_rv250MC_DEBUG_ignore_rw_penalty_ppr(reg, ignore_rw_penalty_ppr) (reg)->bitfields.IGNORE_RW_PENALTY_PPR = ignore_rw_penalty_ppr
#define set_rv250MC_DEBUG_ignore_rw_penalty_fixed(reg, ignore_rw_penalty_fixed) (reg)->bitfields.IGNORE_RW_PENALTY_FIXED = ignore_rw_penalty_fixed
#define set_rv250MC_DEBUG_mem_vipw_priority(reg, mem_vipw_priority) (reg)->bitfields.MEM_VIPW_PRIORITY = mem_vipw_priority
#define set_rv250MC_DEBUG_en_aic_idle_det(reg, en_aic_idle_det) (reg)->bitfields.EN_AIC_IDLE_DET = en_aic_idle_det
#define set_rv250MC_DEBUG_mem_mc_blackout(reg, mem_mc_blackout) (reg)->bitfields.MEM_MC_BLACKOUT = mem_mc_blackout
#define set_rv250MC_DEBUG_disable_tee_sm_changes(reg, disable_tee_sm_changes) (reg)->bitfields.DISABLE_TEE_SM_CHANGES = disable_tee_sm_changes
#define set_rv250MC_DEBUG_imp_n_value_dqs_r_back(reg, imp_n_value_dqs_r_back) (reg)->bitfields.IMP_N_VALUE_DQS_R_BACK = imp_n_value_dqs_r_back
#define set_rv250MC_DEBUG_imp_p_value_dqs_r_back(reg, imp_p_value_dqs_r_back) (reg)->bitfields.IMP_P_VALUE_DQS_R_BACK = imp_p_value_dqs_r_back
#define set_rv250MC_DEBUG_mc_bist_en(reg, mc_bist_en) (reg)->bitfields.MC_BIST_EN = mc_bist_en
#define set_rv250MC_DEBUG_mc_debug(reg, mc_debug) (reg)->bitfields.MC_DEBUG = mc_debug

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_STATUS regMC_STATUS;

#ifdef DEBUG
__inline void set_MC_STATUS_mem_pwrup_compl_a(regMC_STATUS *reg, unsigned int mem_pwrup_compl_a)
{
  reg->bitfields.MEM_PWRUP_COMPL_A = mem_pwrup_compl_a;
  if (reg->bitfields.MEM_PWRUP_COMPL_A != mem_pwrup_compl_a) HSLDPF(E_ERROR_MESSAGE,"MC_STATUS::MEM_PWRUP_COMPL_A data too large\n");
}
__inline void set_MC_STATUS_mem_pwrup_compl_b(regMC_STATUS *reg, unsigned int mem_pwrup_compl_b)
{
  reg->bitfields.MEM_PWRUP_COMPL_B = mem_pwrup_compl_b;
  if (reg->bitfields.MEM_PWRUP_COMPL_B != mem_pwrup_compl_b) HSLDPF(E_ERROR_MESSAGE,"MC_STATUS::MEM_PWRUP_COMPL_B data too large\n");
}
__inline void set_MC_STATUS_mc_idle(regMC_STATUS *reg, unsigned int mc_idle)
{
  reg->bitfields.MC_IDLE = mc_idle;
  if (reg->bitfields.MC_IDLE != mc_idle) HSLDPF(E_ERROR_MESSAGE,"MC_STATUS::MC_IDLE data too large\n");
}
__inline void set_MC_STATUS_imp_n_value_r_back(regMC_STATUS *reg, unsigned int imp_n_value_r_back)
{
  reg->bitfields.IMP_N_VALUE_R_BACK = imp_n_value_r_back;
  if (reg->bitfields.IMP_N_VALUE_R_BACK != imp_n_value_r_back) HSLDPF(E_ERROR_MESSAGE,"MC_STATUS::IMP_N_VALUE_R_BACK data too large\n");
}
__inline void set_MC_STATUS_imp_p_value_r_back(regMC_STATUS *reg, unsigned int imp_p_value_r_back)
{
  reg->bitfields.IMP_P_VALUE_R_BACK = imp_p_value_r_back;
  if (reg->bitfields.IMP_P_VALUE_R_BACK != imp_p_value_r_back) HSLDPF(E_ERROR_MESSAGE,"MC_STATUS::IMP_P_VALUE_R_BACK data too large\n");
}
__inline void set_MC_STATUS_test_out_r_back(regMC_STATUS *reg, unsigned int test_out_r_back)
{
  reg->bitfields.TEST_OUT_R_BACK = test_out_r_back;
  if (reg->bitfields.TEST_OUT_R_BACK != test_out_r_back) HSLDPF(E_ERROR_MESSAGE,"MC_STATUS::TEST_OUT_R_BACK data too large\n");
}
__inline void set_MC_STATUS_dummy_out_r_back(regMC_STATUS *reg, unsigned int dummy_out_r_back)
{
  reg->bitfields.DUMMY_OUT_R_BACK = dummy_out_r_back;
  if (reg->bitfields.DUMMY_OUT_R_BACK != dummy_out_r_back) HSLDPF(E_ERROR_MESSAGE,"MC_STATUS::DUMMY_OUT_R_BACK data too large\n");
}
__inline void set_MC_STATUS_imp_n_value_a_r_back(regMC_STATUS *reg, unsigned int imp_n_value_a_r_back)
{
  reg->bitfields.IMP_N_VALUE_A_R_BACK = imp_n_value_a_r_back;
  if (reg->bitfields.IMP_N_VALUE_A_R_BACK != imp_n_value_a_r_back) HSLDPF(E_ERROR_MESSAGE,"MC_STATUS::IMP_N_VALUE_A_R_BACK data too large\n");
}
__inline void set_MC_STATUS_imp_p_value_a_r_back(regMC_STATUS *reg, unsigned int imp_p_value_a_r_back)
{
  reg->bitfields.IMP_P_VALUE_A_R_BACK = imp_p_value_a_r_back;
  if (reg->bitfields.IMP_P_VALUE_A_R_BACK != imp_p_value_a_r_back) HSLDPF(E_ERROR_MESSAGE,"MC_STATUS::IMP_P_VALUE_A_R_BACK data too large\n");
}
__inline void set_MC_STATUS_imp_n_value_ck_r_back(regMC_STATUS *reg, unsigned int imp_n_value_ck_r_back)
{
  reg->bitfields.IMP_N_VALUE_CK_R_BACK = imp_n_value_ck_r_back;
  if (reg->bitfields.IMP_N_VALUE_CK_R_BACK != imp_n_value_ck_r_back) HSLDPF(E_ERROR_MESSAGE,"MC_STATUS::IMP_N_VALUE_CK_R_BACK data too large\n");
}
__inline void set_MC_STATUS_imp_p_value_ck_r_back(regMC_STATUS *reg, unsigned int imp_p_value_ck_r_back)
{
  reg->bitfields.IMP_P_VALUE_CK_R_BACK = imp_p_value_ck_r_back;
  if (reg->bitfields.IMP_P_VALUE_CK_R_BACK != imp_p_value_ck_r_back) HSLDPF(E_ERROR_MESSAGE,"MC_STATUS::IMP_P_VALUE_CK_R_BACK data too large\n");
}
#else
#define set_MC_STATUS_mem_pwrup_compl_a(reg, mem_pwrup_compl_a) (reg)->bitfields.MEM_PWRUP_COMPL_A = mem_pwrup_compl_a
#define set_MC_STATUS_mem_pwrup_compl_b(reg, mem_pwrup_compl_b) (reg)->bitfields.MEM_PWRUP_COMPL_B = mem_pwrup_compl_b
#define set_MC_STATUS_mc_idle(reg, mc_idle) (reg)->bitfields.MC_IDLE = mc_idle
#define set_MC_STATUS_imp_n_value_r_back(reg, imp_n_value_r_back) (reg)->bitfields.IMP_N_VALUE_R_BACK = imp_n_value_r_back
#define set_MC_STATUS_imp_p_value_r_back(reg, imp_p_value_r_back) (reg)->bitfields.IMP_P_VALUE_R_BACK = imp_p_value_r_back
#define set_MC_STATUS_test_out_r_back(reg, test_out_r_back) (reg)->bitfields.TEST_OUT_R_BACK = test_out_r_back
#define set_MC_STATUS_dummy_out_r_back(reg, dummy_out_r_back) (reg)->bitfields.DUMMY_OUT_R_BACK = dummy_out_r_back
#define set_MC_STATUS_imp_n_value_a_r_back(reg, imp_n_value_a_r_back) (reg)->bitfields.IMP_N_VALUE_A_R_BACK = imp_n_value_a_r_back
#define set_MC_STATUS_imp_p_value_a_r_back(reg, imp_p_value_a_r_back) (reg)->bitfields.IMP_P_VALUE_A_R_BACK = imp_p_value_a_r_back
#define set_MC_STATUS_imp_n_value_ck_r_back(reg, imp_n_value_ck_r_back) (reg)->bitfields.IMP_N_VALUE_CK_R_BACK = imp_n_value_ck_r_back
#define set_MC_STATUS_imp_p_value_ck_r_back(reg, imp_p_value_ck_r_back) (reg)->bitfields.IMP_P_VALUE_CK_R_BACK = imp_p_value_ck_r_back

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_CHP_IO_OE_CNTL regMC_CHP_IO_OE_CNTL;

#ifdef DEBUG
__inline void set_MC_CHP_IO_OE_CNTL_dq_oe_position_a(regMC_CHP_IO_OE_CNTL *reg, unsigned int dq_oe_position_a)
{
  reg->bitfields.DQ_OE_POSITION_A = dq_oe_position_a;
  if (reg->bitfields.DQ_OE_POSITION_A != dq_oe_position_a) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::DQ_OE_POSITION_A data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_qs_oe_position_a(regMC_CHP_IO_OE_CNTL *reg, unsigned int qs_oe_position_a)
{
  reg->bitfields.QS_OE_POSITION_A = qs_oe_position_a;
  if (reg->bitfields.QS_OE_POSITION_A != qs_oe_position_a) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::QS_OE_POSITION_A data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_dq_oe_extend_a(regMC_CHP_IO_OE_CNTL *reg, unsigned int dq_oe_extend_a)
{
  reg->bitfields.DQ_OE_EXTEND_A = dq_oe_extend_a;
  if (reg->bitfields.DQ_OE_EXTEND_A != dq_oe_extend_a) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::DQ_OE_EXTEND_A data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_qs_oe_extend_a(regMC_CHP_IO_OE_CNTL *reg, unsigned int qs_oe_extend_a)
{
  reg->bitfields.QS_OE_EXTEND_A = qs_oe_extend_a;
  if (reg->bitfields.QS_OE_EXTEND_A != qs_oe_extend_a) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::QS_OE_EXTEND_A data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_dq_oe_advance_a(regMC_CHP_IO_OE_CNTL *reg, unsigned int dq_oe_advance_a)
{
  reg->bitfields.DQ_OE_ADVANCE_A = dq_oe_advance_a;
  if (reg->bitfields.DQ_OE_ADVANCE_A != dq_oe_advance_a) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::DQ_OE_ADVANCE_A data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_qs_oe_advance_a(regMC_CHP_IO_OE_CNTL *reg, unsigned int qs_oe_advance_a)
{
  reg->bitfields.QS_OE_ADVANCE_A = qs_oe_advance_a;
  if (reg->bitfields.QS_OE_ADVANCE_A != qs_oe_advance_a) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::QS_OE_ADVANCE_A data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_dqs_driver_slct_a0(regMC_CHP_IO_OE_CNTL *reg, unsigned int dqs_driver_slct_a0)
{
  reg->bitfields.DQS_DRIVER_SLCT_A0 = dqs_driver_slct_a0;
  if (reg->bitfields.DQS_DRIVER_SLCT_A0 != dqs_driver_slct_a0) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::DQS_DRIVER_SLCT_A0 data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_dqs_driver_slct_a1(regMC_CHP_IO_OE_CNTL *reg, unsigned int dqs_driver_slct_a1)
{
  reg->bitfields.DQS_DRIVER_SLCT_A1 = dqs_driver_slct_a1;
  if (reg->bitfields.DQS_DRIVER_SLCT_A1 != dqs_driver_slct_a1) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::DQS_DRIVER_SLCT_A1 data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_dqs_driver_slct_a2(regMC_CHP_IO_OE_CNTL *reg, unsigned int dqs_driver_slct_a2)
{
  reg->bitfields.DQS_DRIVER_SLCT_A2 = dqs_driver_slct_a2;
  if (reg->bitfields.DQS_DRIVER_SLCT_A2 != dqs_driver_slct_a2) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::DQS_DRIVER_SLCT_A2 data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_dqs_driver_slct_a3(regMC_CHP_IO_OE_CNTL *reg, unsigned int dqs_driver_slct_a3)
{
  reg->bitfields.DQS_DRIVER_SLCT_A3 = dqs_driver_slct_a3;
  if (reg->bitfields.DQS_DRIVER_SLCT_A3 != dqs_driver_slct_a3) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::DQS_DRIVER_SLCT_A3 data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_mem_sdr_strobe_a(regMC_CHP_IO_OE_CNTL *reg, unsigned int mem_sdr_strobe_a)
{
  reg->bitfields.MEM_SDR_STROBE_A = mem_sdr_strobe_a;
  if (reg->bitfields.MEM_SDR_STROBE_A != mem_sdr_strobe_a) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::MEM_SDR_STROBE_A data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_dq_oe_position_b(regMC_CHP_IO_OE_CNTL *reg, unsigned int dq_oe_position_b)
{
  reg->bitfields.DQ_OE_POSITION_B = dq_oe_position_b;
  if (reg->bitfields.DQ_OE_POSITION_B != dq_oe_position_b) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::DQ_OE_POSITION_B data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_qs_oe_position_b(regMC_CHP_IO_OE_CNTL *reg, unsigned int qs_oe_position_b)
{
  reg->bitfields.QS_OE_POSITION_B = qs_oe_position_b;
  if (reg->bitfields.QS_OE_POSITION_B != qs_oe_position_b) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::QS_OE_POSITION_B data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_dq_oe_extend_b(regMC_CHP_IO_OE_CNTL *reg, unsigned int dq_oe_extend_b)
{
  reg->bitfields.DQ_OE_EXTEND_B = dq_oe_extend_b;
  if (reg->bitfields.DQ_OE_EXTEND_B != dq_oe_extend_b) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::DQ_OE_EXTEND_B data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_qs_oe_extend_b(regMC_CHP_IO_OE_CNTL *reg, unsigned int qs_oe_extend_b)
{
  reg->bitfields.QS_OE_EXTEND_B = qs_oe_extend_b;
  if (reg->bitfields.QS_OE_EXTEND_B != qs_oe_extend_b) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::QS_OE_EXTEND_B data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_dq_oe_advance_b(regMC_CHP_IO_OE_CNTL *reg, unsigned int dq_oe_advance_b)
{
  reg->bitfields.DQ_OE_ADVANCE_B = dq_oe_advance_b;
  if (reg->bitfields.DQ_OE_ADVANCE_B != dq_oe_advance_b) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::DQ_OE_ADVANCE_B data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_qs_oe_advance_b(regMC_CHP_IO_OE_CNTL *reg, unsigned int qs_oe_advance_b)
{
  reg->bitfields.QS_OE_ADVANCE_B = qs_oe_advance_b;
  if (reg->bitfields.QS_OE_ADVANCE_B != qs_oe_advance_b) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::QS_OE_ADVANCE_B data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_dqs_driver_slct_b0(regMC_CHP_IO_OE_CNTL *reg, unsigned int dqs_driver_slct_b0)
{
  reg->bitfields.DQS_DRIVER_SLCT_B0 = dqs_driver_slct_b0;
  if (reg->bitfields.DQS_DRIVER_SLCT_B0 != dqs_driver_slct_b0) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::DQS_DRIVER_SLCT_B0 data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_dqs_driver_slct_b1(regMC_CHP_IO_OE_CNTL *reg, unsigned int dqs_driver_slct_b1)
{
  reg->bitfields.DQS_DRIVER_SLCT_B1 = dqs_driver_slct_b1;
  if (reg->bitfields.DQS_DRIVER_SLCT_B1 != dqs_driver_slct_b1) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::DQS_DRIVER_SLCT_B1 data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_dqs_driver_slct_b2(regMC_CHP_IO_OE_CNTL *reg, unsigned int dqs_driver_slct_b2)
{
  reg->bitfields.DQS_DRIVER_SLCT_B2 = dqs_driver_slct_b2;
  if (reg->bitfields.DQS_DRIVER_SLCT_B2 != dqs_driver_slct_b2) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::DQS_DRIVER_SLCT_B2 data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_dqs_driver_slct_b3(regMC_CHP_IO_OE_CNTL *reg, unsigned int dqs_driver_slct_b3)
{
  reg->bitfields.DQS_DRIVER_SLCT_B3 = dqs_driver_slct_b3;
  if (reg->bitfields.DQS_DRIVER_SLCT_B3 != dqs_driver_slct_b3) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::DQS_DRIVER_SLCT_B3 data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_mem_sdr_strobe_b(regMC_CHP_IO_OE_CNTL *reg, unsigned int mem_sdr_strobe_b)
{
  reg->bitfields.MEM_SDR_STROBE_B = mem_sdr_strobe_b;
  if (reg->bitfields.MEM_SDR_STROBE_B != mem_sdr_strobe_b) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::MEM_SDR_STROBE_B data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_mem_pm_sdram_tri_en(regMC_CHP_IO_OE_CNTL *reg, unsigned int mem_pm_sdram_tri_en)
{
  reg->bitfields.MEM_PM_SDRAM_TRI_EN = mem_pm_sdram_tri_en;
  if (reg->bitfields.MEM_PM_SDRAM_TRI_EN != mem_pm_sdram_tri_en) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::MEM_PM_SDRAM_TRI_EN data too large\n");
}
__inline void set_MC_CHP_IO_OE_CNTL_mem_io_tristate(regMC_CHP_IO_OE_CNTL *reg, unsigned int mem_io_tristate)
{
  reg->bitfields.MEM_IO_TRISTATE = mem_io_tristate;
  if (reg->bitfields.MEM_IO_TRISTATE != mem_io_tristate) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_OE_CNTL::MEM_IO_TRISTATE data too large\n");
}
#else
#define set_MC_CHP_IO_OE_CNTL_dq_oe_position_a(reg, dq_oe_position_a) (reg)->bitfields.DQ_OE_POSITION_A = dq_oe_position_a
#define set_MC_CHP_IO_OE_CNTL_qs_oe_position_a(reg, qs_oe_position_a) (reg)->bitfields.QS_OE_POSITION_A = qs_oe_position_a
#define set_MC_CHP_IO_OE_CNTL_dq_oe_extend_a(reg, dq_oe_extend_a) (reg)->bitfields.DQ_OE_EXTEND_A = dq_oe_extend_a
#define set_MC_CHP_IO_OE_CNTL_qs_oe_extend_a(reg, qs_oe_extend_a) (reg)->bitfields.QS_OE_EXTEND_A = qs_oe_extend_a
#define set_MC_CHP_IO_OE_CNTL_dq_oe_advance_a(reg, dq_oe_advance_a) (reg)->bitfields.DQ_OE_ADVANCE_A = dq_oe_advance_a
#define set_MC_CHP_IO_OE_CNTL_qs_oe_advance_a(reg, qs_oe_advance_a) (reg)->bitfields.QS_OE_ADVANCE_A = qs_oe_advance_a
#define set_MC_CHP_IO_OE_CNTL_dqs_driver_slct_a0(reg, dqs_driver_slct_a0) (reg)->bitfields.DQS_DRIVER_SLCT_A0 = dqs_driver_slct_a0
#define set_MC_CHP_IO_OE_CNTL_dqs_driver_slct_a1(reg, dqs_driver_slct_a1) (reg)->bitfields.DQS_DRIVER_SLCT_A1 = dqs_driver_slct_a1
#define set_MC_CHP_IO_OE_CNTL_dqs_driver_slct_a2(reg, dqs_driver_slct_a2) (reg)->bitfields.DQS_DRIVER_SLCT_A2 = dqs_driver_slct_a2
#define set_MC_CHP_IO_OE_CNTL_dqs_driver_slct_a3(reg, dqs_driver_slct_a3) (reg)->bitfields.DQS_DRIVER_SLCT_A3 = dqs_driver_slct_a3
#define set_MC_CHP_IO_OE_CNTL_mem_sdr_strobe_a(reg, mem_sdr_strobe_a) (reg)->bitfields.MEM_SDR_STROBE_A = mem_sdr_strobe_a
#define set_MC_CHP_IO_OE_CNTL_dq_oe_position_b(reg, dq_oe_position_b) (reg)->bitfields.DQ_OE_POSITION_B = dq_oe_position_b
#define set_MC_CHP_IO_OE_CNTL_qs_oe_position_b(reg, qs_oe_position_b) (reg)->bitfields.QS_OE_POSITION_B = qs_oe_position_b
#define set_MC_CHP_IO_OE_CNTL_dq_oe_extend_b(reg, dq_oe_extend_b) (reg)->bitfields.DQ_OE_EXTEND_B = dq_oe_extend_b
#define set_MC_CHP_IO_OE_CNTL_qs_oe_extend_b(reg, qs_oe_extend_b) (reg)->bitfields.QS_OE_EXTEND_B = qs_oe_extend_b
#define set_MC_CHP_IO_OE_CNTL_dq_oe_advance_b(reg, dq_oe_advance_b) (reg)->bitfields.DQ_OE_ADVANCE_B = dq_oe_advance_b
#define set_MC_CHP_IO_OE_CNTL_qs_oe_advance_b(reg, qs_oe_advance_b) (reg)->bitfields.QS_OE_ADVANCE_B = qs_oe_advance_b
#define set_MC_CHP_IO_OE_CNTL_dqs_driver_slct_b0(reg, dqs_driver_slct_b0) (reg)->bitfields.DQS_DRIVER_SLCT_B0 = dqs_driver_slct_b0
#define set_MC_CHP_IO_OE_CNTL_dqs_driver_slct_b1(reg, dqs_driver_slct_b1) (reg)->bitfields.DQS_DRIVER_SLCT_B1 = dqs_driver_slct_b1
#define set_MC_CHP_IO_OE_CNTL_dqs_driver_slct_b2(reg, dqs_driver_slct_b2) (reg)->bitfields.DQS_DRIVER_SLCT_B2 = dqs_driver_slct_b2
#define set_MC_CHP_IO_OE_CNTL_dqs_driver_slct_b3(reg, dqs_driver_slct_b3) (reg)->bitfields.DQS_DRIVER_SLCT_B3 = dqs_driver_slct_b3
#define set_MC_CHP_IO_OE_CNTL_mem_sdr_strobe_b(reg, mem_sdr_strobe_b) (reg)->bitfields.MEM_SDR_STROBE_B = mem_sdr_strobe_b
#define set_MC_CHP_IO_OE_CNTL_mem_pm_sdram_tri_en(reg, mem_pm_sdram_tri_en) (reg)->bitfields.MEM_PM_SDRAM_TRI_EN = mem_pm_sdram_tri_en
#define set_MC_CHP_IO_OE_CNTL_mem_io_tristate(reg, mem_io_tristate) (reg)->bitfields.MEM_IO_TRISTATE = mem_io_tristate

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union AGP_BASE_2 regAGP_BASE_2;

#ifdef DEBUG
__inline void set_AGP_BASE_2_agp_base_addr_2(regAGP_BASE_2 *reg, unsigned int agp_base_addr_2)
{
  reg->bitfields.AGP_BASE_ADDR_2 = agp_base_addr_2;
  if (reg->bitfields.AGP_BASE_ADDR_2 != agp_base_addr_2) HSLDPF(E_ERROR_MESSAGE,"AGP_BASE_2::AGP_BASE_ADDR_2 data too large\n");
}
#else
#define set_AGP_BASE_2_agp_base_addr_2(reg, agp_base_addr_2) (reg)->bitfields.AGP_BASE_ADDR_2 = agp_base_addr_2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250MC_IND_INDEX regrv250MC_IND_INDEX;

#ifdef DEBUG
__inline void set_rv250MC_IND_INDEX_mc_ind_addr(regrv250MC_IND_INDEX *reg, unsigned int mc_ind_addr)
{
  reg->bitfields.MC_IND_ADDR = mc_ind_addr;
  if (reg->bitfields.MC_IND_ADDR != mc_ind_addr) HSLDPF(E_ERROR_MESSAGE,"rv250MC_IND_INDEX::MC_IND_ADDR data too large\n");
}
__inline void set_rv250MC_IND_INDEX_mc_ind_wr_en(regrv250MC_IND_INDEX *reg, unsigned int mc_ind_wr_en)
{
  reg->bitfields.MC_IND_WR_EN = mc_ind_wr_en;
  if (reg->bitfields.MC_IND_WR_EN != mc_ind_wr_en) HSLDPF(E_ERROR_MESSAGE,"rv250MC_IND_INDEX::MC_IND_WR_EN data too large\n");
}
#else
#define set_rv250MC_IND_INDEX_mc_ind_addr(reg, mc_ind_addr) (reg)->bitfields.MC_IND_ADDR = mc_ind_addr
#define set_rv250MC_IND_INDEX_mc_ind_wr_en(reg, mc_ind_wr_en) (reg)->bitfields.MC_IND_WR_EN = mc_ind_wr_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_IND_DATA regMC_IND_DATA;

#ifdef DEBUG
__inline void set_MC_IND_DATA_mc_ind_data(regMC_IND_DATA *reg, unsigned int mc_ind_data)
{
  reg->bitfields.MC_IND_DATA = mc_ind_data;
  if (reg->bitfields.MC_IND_DATA != mc_ind_data) HSLDPF(E_ERROR_MESSAGE,"MC_IND_DATA::MC_IND_DATA data too large\n");
}
#else
#define set_MC_IND_DATA_mc_ind_data(reg, mc_ind_data) (reg)->bitfields.MC_IND_DATA = mc_ind_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_PERF_CNTL regMC_PERF_CNTL;

#ifdef DEBUG
__inline void set_MC_PERF_CNTL_monitor_period(regMC_PERF_CNTL *reg, unsigned int monitor_period)
{
  reg->bitfields.MONITOR_PERIOD = monitor_period;
  if (reg->bitfields.MONITOR_PERIOD != monitor_period) HSLDPF(E_ERROR_MESSAGE,"MC_PERF_CNTL::MONITOR_PERIOD data too large\n");
}
__inline void set_MC_PERF_CNTL_clr_perf(regMC_PERF_CNTL *reg, unsigned int clr_perf)
{
  reg->bitfields.CLR_PERF = clr_perf;
  if (reg->bitfields.CLR_PERF != clr_perf) HSLDPF(E_ERROR_MESSAGE,"MC_PERF_CNTL::CLR_PERF data too large\n");
}
__inline void set_MC_PERF_CNTL_en_perf(regMC_PERF_CNTL *reg, unsigned int en_perf)
{
  reg->bitfields.EN_PERF = en_perf;
  if (reg->bitfields.EN_PERF != en_perf) HSLDPF(E_ERROR_MESSAGE,"MC_PERF_CNTL::EN_PERF data too large\n");
}
#else
#define set_MC_PERF_CNTL_monitor_period(reg, monitor_period) (reg)->bitfields.MONITOR_PERIOD = monitor_period
#define set_MC_PERF_CNTL_clr_perf(reg, clr_perf) (reg)->bitfields.CLR_PERF = clr_perf
#define set_MC_PERF_CNTL_en_perf(reg, en_perf) (reg)->bitfields.EN_PERF = en_perf

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_PERF_SEL regMC_PERF_SEL;

#ifdef DEBUG
__inline void set_MC_PERF_SEL_perfsel0(regMC_PERF_SEL *reg, unsigned int perfsel0)
{
  reg->bitfields.PERFSEL0 = perfsel0;
  if (reg->bitfields.PERFSEL0 != perfsel0) HSLDPF(E_ERROR_MESSAGE,"MC_PERF_SEL::PERFSEL0 data too large\n");
}
__inline void set_MC_PERF_SEL_perfsel1(regMC_PERF_SEL *reg, unsigned int perfsel1)
{
  reg->bitfields.PERFSEL1 = perfsel1;
  if (reg->bitfields.PERFSEL1 != perfsel1) HSLDPF(E_ERROR_MESSAGE,"MC_PERF_SEL::PERFSEL1 data too large\n");
}
__inline void set_MC_PERF_SEL_perfsel2(regMC_PERF_SEL *reg, unsigned int perfsel2)
{
  reg->bitfields.PERFSEL2 = perfsel2;
  if (reg->bitfields.PERFSEL2 != perfsel2) HSLDPF(E_ERROR_MESSAGE,"MC_PERF_SEL::PERFSEL2 data too large\n");
}
__inline void set_MC_PERF_SEL_perfsel3(regMC_PERF_SEL *reg, unsigned int perfsel3)
{
  reg->bitfields.PERFSEL3 = perfsel3;
  if (reg->bitfields.PERFSEL3 != perfsel3) HSLDPF(E_ERROR_MESSAGE,"MC_PERF_SEL::PERFSEL3 data too large\n");
}
__inline void set_MC_PERF_SEL_memch_a_sel(regMC_PERF_SEL *reg, unsigned int memch_a_sel)
{
  reg->bitfields.MEMCH_A_SEL = memch_a_sel;
  if (reg->bitfields.MEMCH_A_SEL != memch_a_sel) HSLDPF(E_ERROR_MESSAGE,"MC_PERF_SEL::MEMCH_A_SEL data too large\n");
}
__inline void set_MC_PERF_SEL_memch_b_sel(regMC_PERF_SEL *reg, unsigned int memch_b_sel)
{
  reg->bitfields.MEMCH_B_SEL = memch_b_sel;
  if (reg->bitfields.MEMCH_B_SEL != memch_b_sel) HSLDPF(E_ERROR_MESSAGE,"MC_PERF_SEL::MEMCH_B_SEL data too large\n");
}
#else
#define set_MC_PERF_SEL_perfsel0(reg, perfsel0) (reg)->bitfields.PERFSEL0 = perfsel0
#define set_MC_PERF_SEL_perfsel1(reg, perfsel1) (reg)->bitfields.PERFSEL1 = perfsel1
#define set_MC_PERF_SEL_perfsel2(reg, perfsel2) (reg)->bitfields.PERFSEL2 = perfsel2
#define set_MC_PERF_SEL_perfsel3(reg, perfsel3) (reg)->bitfields.PERFSEL3 = perfsel3
#define set_MC_PERF_SEL_memch_a_sel(reg, memch_a_sel) (reg)->bitfields.MEMCH_A_SEL = memch_a_sel
#define set_MC_PERF_SEL_memch_b_sel(reg, memch_b_sel) (reg)->bitfields.MEMCH_B_SEL = memch_b_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_PERF_REGION_0 regMC_PERF_REGION_0;

#ifdef DEBUG
__inline void set_MC_PERF_REGION_0_size(regMC_PERF_REGION_0 *reg, unsigned int size)
{
  reg->bitfields.SIZE = size;
  if (reg->bitfields.SIZE != size) HSLDPF(E_ERROR_MESSAGE,"MC_PERF_REGION_0::SIZE data too large\n");
}
__inline void set_MC_PERF_REGION_0_address(regMC_PERF_REGION_0 *reg, unsigned int address)
{
  reg->bitfields.ADDRESS = address;
  if (reg->bitfields.ADDRESS != address) HSLDPF(E_ERROR_MESSAGE,"MC_PERF_REGION_0::ADDRESS data too large\n");
}
#else
#define set_MC_PERF_REGION_0_size(reg, size) (reg)->bitfields.SIZE = size
#define set_MC_PERF_REGION_0_address(reg, address) (reg)->bitfields.ADDRESS = address

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_PERF_REGION_1 regMC_PERF_REGION_1;

#ifdef DEBUG
__inline void set_MC_PERF_REGION_1_size(regMC_PERF_REGION_1 *reg, unsigned int size)
{
  reg->bitfields.SIZE = size;
  if (reg->bitfields.SIZE != size) HSLDPF(E_ERROR_MESSAGE,"MC_PERF_REGION_1::SIZE data too large\n");
}
__inline void set_MC_PERF_REGION_1_address(regMC_PERF_REGION_1 *reg, unsigned int address)
{
  reg->bitfields.ADDRESS = address;
  if (reg->bitfields.ADDRESS != address) HSLDPF(E_ERROR_MESSAGE,"MC_PERF_REGION_1::ADDRESS data too large\n");
}
#else
#define set_MC_PERF_REGION_1_size(reg, size) (reg)->bitfields.SIZE = size
#define set_MC_PERF_REGION_1_address(reg, address) (reg)->bitfields.ADDRESS = address

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_PERF_COUNT_0 regMC_PERF_COUNT_0;

#ifdef DEBUG
__inline void set_MC_PERF_COUNT_0_perf_count(regMC_PERF_COUNT_0 *reg, unsigned int perf_count)
{
  reg->bitfields.PERF_COUNT = perf_count;
  if (reg->bitfields.PERF_COUNT != perf_count) HSLDPF(E_ERROR_MESSAGE,"MC_PERF_COUNT_0::PERF_COUNT data too large\n");
}
#else
#define set_MC_PERF_COUNT_0_perf_count(reg, perf_count) (reg)->bitfields.PERF_COUNT = perf_count

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_PERF_COUNT_1 regMC_PERF_COUNT_1;

#ifdef DEBUG
__inline void set_MC_PERF_COUNT_1_perf_count(regMC_PERF_COUNT_1 *reg, unsigned int perf_count)
{
  reg->bitfields.PERF_COUNT = perf_count;
  if (reg->bitfields.PERF_COUNT != perf_count) HSLDPF(E_ERROR_MESSAGE,"MC_PERF_COUNT_1::PERF_COUNT data too large\n");
}
#else
#define set_MC_PERF_COUNT_1_perf_count(reg, perf_count) (reg)->bitfields.PERF_COUNT = perf_count

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_PERF_COUNT_2 regMC_PERF_COUNT_2;

#ifdef DEBUG
__inline void set_MC_PERF_COUNT_2_perf_count(regMC_PERF_COUNT_2 *reg, unsigned int perf_count)
{
  reg->bitfields.PERF_COUNT = perf_count;
  if (reg->bitfields.PERF_COUNT != perf_count) HSLDPF(E_ERROR_MESSAGE,"MC_PERF_COUNT_2::PERF_COUNT data too large\n");
}
#else
#define set_MC_PERF_COUNT_2_perf_count(reg, perf_count) (reg)->bitfields.PERF_COUNT = perf_count

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_PERF_COUNT_3 regMC_PERF_COUNT_3;

#ifdef DEBUG
__inline void set_MC_PERF_COUNT_3_perf_count(regMC_PERF_COUNT_3 *reg, unsigned int perf_count)
{
  reg->bitfields.PERF_COUNT = perf_count;
  if (reg->bitfields.PERF_COUNT != perf_count) HSLDPF(E_ERROR_MESSAGE,"MC_PERF_COUNT_3::PERF_COUNT data too large\n");
}
#else
#define set_MC_PERF_COUNT_3_perf_count(reg, perf_count) (reg)->bitfields.PERF_COUNT = perf_count

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_PERF_COUNT_MEMCH_A regMC_PERF_COUNT_MEMCH_A;

#ifdef DEBUG
__inline void set_MC_PERF_COUNT_MEMCH_A_perf_count_mem_ch_a(regMC_PERF_COUNT_MEMCH_A *reg, unsigned int perf_count_mem_ch_a)
{
  reg->bitfields.PERF_COUNT_MEM_CH_A = perf_count_mem_ch_a;
  if (reg->bitfields.PERF_COUNT_MEM_CH_A != perf_count_mem_ch_a) HSLDPF(E_ERROR_MESSAGE,"MC_PERF_COUNT_MEMCH_A::PERF_COUNT_MEM_CH_A data too large\n");
}
#else
#define set_MC_PERF_COUNT_MEMCH_A_perf_count_mem_ch_a(reg, perf_count_mem_ch_a) (reg)->bitfields.PERF_COUNT_MEM_CH_A = perf_count_mem_ch_a

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_PERF_COUNT_MEMCH_B regMC_PERF_COUNT_MEMCH_B;

#ifdef DEBUG
__inline void set_MC_PERF_COUNT_MEMCH_B_perf_count_mem_ch_b(regMC_PERF_COUNT_MEMCH_B *reg, unsigned int perf_count_mem_ch_b)
{
  reg->bitfields.PERF_COUNT_MEM_CH_B = perf_count_mem_ch_b;
  if (reg->bitfields.PERF_COUNT_MEM_CH_B != perf_count_mem_ch_b) HSLDPF(E_ERROR_MESSAGE,"MC_PERF_COUNT_MEMCH_B::PERF_COUNT_MEM_CH_B data too large\n");
}
#else
#define set_MC_PERF_COUNT_MEMCH_B_perf_count_mem_ch_b(reg, perf_count_mem_ch_b) (reg)->bitfields.PERF_COUNT_MEM_CH_B = perf_count_mem_ch_b

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_IMP_CNTL regMC_IMP_CNTL;

#ifdef DEBUG
__inline void set_MC_IMP_CNTL_mem_io_update_rate(regMC_IMP_CNTL *reg, unsigned int mem_io_update_rate)
{
  reg->bitfields.MEM_IO_UPDATE_RATE = mem_io_update_rate;
  if (reg->bitfields.MEM_IO_UPDATE_RATE != mem_io_update_rate) HSLDPF(E_ERROR_MESSAGE,"MC_IMP_CNTL::MEM_IO_UPDATE_RATE data too large\n");
}
__inline void set_MC_IMP_CNTL_mem_io_sample_delay(regMC_IMP_CNTL *reg, unsigned int mem_io_sample_delay)
{
  reg->bitfields.MEM_IO_SAMPLE_DELAY = mem_io_sample_delay;
  if (reg->bitfields.MEM_IO_SAMPLE_DELAY != mem_io_sample_delay) HSLDPF(E_ERROR_MESSAGE,"MC_IMP_CNTL::MEM_IO_SAMPLE_DELAY data too large\n");
}
__inline void set_MC_IMP_CNTL_mem_io_inc_threshold(regMC_IMP_CNTL *reg, unsigned int mem_io_inc_threshold)
{
  reg->bitfields.MEM_IO_INC_THRESHOLD = mem_io_inc_threshold;
  if (reg->bitfields.MEM_IO_INC_THRESHOLD != mem_io_inc_threshold) HSLDPF(E_ERROR_MESSAGE,"MC_IMP_CNTL::MEM_IO_INC_THRESHOLD data too large\n");
}
__inline void set_MC_IMP_CNTL_mem_io_dec_threshold(regMC_IMP_CNTL *reg, unsigned int mem_io_dec_threshold)
{
  reg->bitfields.MEM_IO_DEC_THRESHOLD = mem_io_dec_threshold;
  if (reg->bitfields.MEM_IO_DEC_THRESHOLD != mem_io_dec_threshold) HSLDPF(E_ERROR_MESSAGE,"MC_IMP_CNTL::MEM_IO_DEC_THRESHOLD data too large\n");
}
__inline void set_MC_IMP_CNTL_mem_io_manual_override_ck(regMC_IMP_CNTL *reg, unsigned int mem_io_manual_override_ck)
{
  reg->bitfields.MEM_IO_MANUAL_OVERRIDE_CK = mem_io_manual_override_ck;
  if (reg->bitfields.MEM_IO_MANUAL_OVERRIDE_CK != mem_io_manual_override_ck) HSLDPF(E_ERROR_MESSAGE,"MC_IMP_CNTL::MEM_IO_MANUAL_OVERRIDE_CK data too large\n");
}
__inline void set_MC_IMP_CNTL_mem_io_manual_override_a(regMC_IMP_CNTL *reg, unsigned int mem_io_manual_override_a)
{
  reg->bitfields.MEM_IO_MANUAL_OVERRIDE_A = mem_io_manual_override_a;
  if (reg->bitfields.MEM_IO_MANUAL_OVERRIDE_A != mem_io_manual_override_a) HSLDPF(E_ERROR_MESSAGE,"MC_IMP_CNTL::MEM_IO_MANUAL_OVERRIDE_A data too large\n");
}
__inline void set_MC_IMP_CNTL_mem_io_manual_override_dqm(regMC_IMP_CNTL *reg, unsigned int mem_io_manual_override_dqm)
{
  reg->bitfields.MEM_IO_MANUAL_OVERRIDE_DQM = mem_io_manual_override_dqm;
  if (reg->bitfields.MEM_IO_MANUAL_OVERRIDE_DQM != mem_io_manual_override_dqm) HSLDPF(E_ERROR_MESSAGE,"MC_IMP_CNTL::MEM_IO_MANUAL_OVERRIDE_DQM data too large\n");
}
__inline void set_MC_IMP_CNTL_mem_io_manual_override_dqs(regMC_IMP_CNTL *reg, unsigned int mem_io_manual_override_dqs)
{
  reg->bitfields.MEM_IO_MANUAL_OVERRIDE_DQS = mem_io_manual_override_dqs;
  if (reg->bitfields.MEM_IO_MANUAL_OVERRIDE_DQS != mem_io_manual_override_dqs) HSLDPF(E_ERROR_MESSAGE,"MC_IMP_CNTL::MEM_IO_MANUAL_OVERRIDE_DQS data too large\n");
}
__inline void set_MC_IMP_CNTL_mem_io_slewn(regMC_IMP_CNTL *reg, unsigned int mem_io_slewn)
{
  reg->bitfields.MEM_IO_SLEWN = mem_io_slewn;
  if (reg->bitfields.MEM_IO_SLEWN != mem_io_slewn) HSLDPF(E_ERROR_MESSAGE,"MC_IMP_CNTL::MEM_IO_SLEWN data too large\n");
}
__inline void set_MC_IMP_CNTL_mem_io_slewp(regMC_IMP_CNTL *reg, unsigned int mem_io_slewp)
{
  reg->bitfields.MEM_IO_SLEWP = mem_io_slewp;
  if (reg->bitfields.MEM_IO_SLEWP != mem_io_slewp) HSLDPF(E_ERROR_MESSAGE,"MC_IMP_CNTL::MEM_IO_SLEWP data too large\n");
}
#else
#define set_MC_IMP_CNTL_mem_io_update_rate(reg, mem_io_update_rate) (reg)->bitfields.MEM_IO_UPDATE_RATE = mem_io_update_rate
#define set_MC_IMP_CNTL_mem_io_sample_delay(reg, mem_io_sample_delay) (reg)->bitfields.MEM_IO_SAMPLE_DELAY = mem_io_sample_delay
#define set_MC_IMP_CNTL_mem_io_inc_threshold(reg, mem_io_inc_threshold) (reg)->bitfields.MEM_IO_INC_THRESHOLD = mem_io_inc_threshold
#define set_MC_IMP_CNTL_mem_io_dec_threshold(reg, mem_io_dec_threshold) (reg)->bitfields.MEM_IO_DEC_THRESHOLD = mem_io_dec_threshold
#define set_MC_IMP_CNTL_mem_io_manual_override_ck(reg, mem_io_manual_override_ck) (reg)->bitfields.MEM_IO_MANUAL_OVERRIDE_CK = mem_io_manual_override_ck
#define set_MC_IMP_CNTL_mem_io_manual_override_a(reg, mem_io_manual_override_a) (reg)->bitfields.MEM_IO_MANUAL_OVERRIDE_A = mem_io_manual_override_a
#define set_MC_IMP_CNTL_mem_io_manual_override_dqm(reg, mem_io_manual_override_dqm) (reg)->bitfields.MEM_IO_MANUAL_OVERRIDE_DQM = mem_io_manual_override_dqm
#define set_MC_IMP_CNTL_mem_io_manual_override_dqs(reg, mem_io_manual_override_dqs) (reg)->bitfields.MEM_IO_MANUAL_OVERRIDE_DQS = mem_io_manual_override_dqs
#define set_MC_IMP_CNTL_mem_io_slewn(reg, mem_io_slewn) (reg)->bitfields.MEM_IO_SLEWN = mem_io_slewn
#define set_MC_IMP_CNTL_mem_io_slewp(reg, mem_io_slewp) (reg)->bitfields.MEM_IO_SLEWP = mem_io_slewp

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_CHP_IO_CNTL_A0 regMC_CHP_IO_CNTL_A0;

#ifdef DEBUG
__inline void set_MC_CHP_IO_CNTL_A0_mem_n_cka(regMC_CHP_IO_CNTL_A0 *reg, unsigned int mem_n_cka)
{
  reg->bitfields.MEM_N_CKA = mem_n_cka;
  if (reg->bitfields.MEM_N_CKA != mem_n_cka) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A0::MEM_N_CKA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A0_mem_n_aa(regMC_CHP_IO_CNTL_A0 *reg, unsigned int mem_n_aa)
{
  reg->bitfields.MEM_N_AA = mem_n_aa;
  if (reg->bitfields.MEM_N_AA != mem_n_aa) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A0::MEM_N_AA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A0_mem_n_dqma(regMC_CHP_IO_CNTL_A0 *reg, unsigned int mem_n_dqma)
{
  reg->bitfields.MEM_N_DQMA = mem_n_dqma;
  if (reg->bitfields.MEM_N_DQMA != mem_n_dqma) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A0::MEM_N_DQMA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A0_mem_n_dqsa(regMC_CHP_IO_CNTL_A0 *reg, unsigned int mem_n_dqsa)
{
  reg->bitfields.MEM_N_DQSA = mem_n_dqsa;
  if (reg->bitfields.MEM_N_DQSA != mem_n_dqsa) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A0::MEM_N_DQSA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A0_mem_p_cka(regMC_CHP_IO_CNTL_A0 *reg, unsigned int mem_p_cka)
{
  reg->bitfields.MEM_P_CKA = mem_p_cka;
  if (reg->bitfields.MEM_P_CKA != mem_p_cka) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A0::MEM_P_CKA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A0_mem_p_aa(regMC_CHP_IO_CNTL_A0 *reg, unsigned int mem_p_aa)
{
  reg->bitfields.MEM_P_AA = mem_p_aa;
  if (reg->bitfields.MEM_P_AA != mem_p_aa) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A0::MEM_P_AA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A0_mem_p_dqma(regMC_CHP_IO_CNTL_A0 *reg, unsigned int mem_p_dqma)
{
  reg->bitfields.MEM_P_DQMA = mem_p_dqma;
  if (reg->bitfields.MEM_P_DQMA != mem_p_dqma) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A0::MEM_P_DQMA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A0_mem_p_dqsa(regMC_CHP_IO_CNTL_A0 *reg, unsigned int mem_p_dqsa)
{
  reg->bitfields.MEM_P_DQSA = mem_p_dqsa;
  if (reg->bitfields.MEM_P_DQSA != mem_p_dqsa) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A0::MEM_P_DQSA data too large\n");
}
#else
#define set_MC_CHP_IO_CNTL_A0_mem_n_cka(reg, mem_n_cka) (reg)->bitfields.MEM_N_CKA = mem_n_cka
#define set_MC_CHP_IO_CNTL_A0_mem_n_aa(reg, mem_n_aa) (reg)->bitfields.MEM_N_AA = mem_n_aa
#define set_MC_CHP_IO_CNTL_A0_mem_n_dqma(reg, mem_n_dqma) (reg)->bitfields.MEM_N_DQMA = mem_n_dqma
#define set_MC_CHP_IO_CNTL_A0_mem_n_dqsa(reg, mem_n_dqsa) (reg)->bitfields.MEM_N_DQSA = mem_n_dqsa
#define set_MC_CHP_IO_CNTL_A0_mem_p_cka(reg, mem_p_cka) (reg)->bitfields.MEM_P_CKA = mem_p_cka
#define set_MC_CHP_IO_CNTL_A0_mem_p_aa(reg, mem_p_aa) (reg)->bitfields.MEM_P_AA = mem_p_aa
#define set_MC_CHP_IO_CNTL_A0_mem_p_dqma(reg, mem_p_dqma) (reg)->bitfields.MEM_P_DQMA = mem_p_dqma
#define set_MC_CHP_IO_CNTL_A0_mem_p_dqsa(reg, mem_p_dqsa) (reg)->bitfields.MEM_P_DQSA = mem_p_dqsa

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_CHP_IO_CNTL_A1 regMC_CHP_IO_CNTL_A1;

#ifdef DEBUG
__inline void set_MC_CHP_IO_CNTL_A1_mem_slewn_cka(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_slewn_cka)
{
  reg->bitfields.MEM_SLEWN_CKA = mem_slewn_cka;
  if (reg->bitfields.MEM_SLEWN_CKA != mem_slewn_cka) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_SLEWN_CKA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A1_mem_slewn_aa(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_slewn_aa)
{
  reg->bitfields.MEM_SLEWN_AA = mem_slewn_aa;
  if (reg->bitfields.MEM_SLEWN_AA != mem_slewn_aa) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_SLEWN_AA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A1_mem_slewn_dqma(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_slewn_dqma)
{
  reg->bitfields.MEM_SLEWN_DQMA = mem_slewn_dqma;
  if (reg->bitfields.MEM_SLEWN_DQMA != mem_slewn_dqma) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_SLEWN_DQMA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A1_mem_slewn_dqsa(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_slewn_dqsa)
{
  reg->bitfields.MEM_SLEWN_DQSA = mem_slewn_dqsa;
  if (reg->bitfields.MEM_SLEWN_DQSA != mem_slewn_dqsa) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_SLEWN_DQSA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A1_mem_slewp_cka(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_slewp_cka)
{
  reg->bitfields.MEM_SLEWP_CKA = mem_slewp_cka;
  if (reg->bitfields.MEM_SLEWP_CKA != mem_slewp_cka) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_SLEWP_CKA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A1_mem_slewp_aa(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_slewp_aa)
{
  reg->bitfields.MEM_SLEWP_AA = mem_slewp_aa;
  if (reg->bitfields.MEM_SLEWP_AA != mem_slewp_aa) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_SLEWP_AA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A1_mem_slewp_dqma(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_slewp_dqma)
{
  reg->bitfields.MEM_SLEWP_DQMA = mem_slewp_dqma;
  if (reg->bitfields.MEM_SLEWP_DQMA != mem_slewp_dqma) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_SLEWP_DQMA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A1_mem_slewp_dqsa(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_slewp_dqsa)
{
  reg->bitfields.MEM_SLEWP_DQSA = mem_slewp_dqsa;
  if (reg->bitfields.MEM_SLEWP_DQSA != mem_slewp_dqsa) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_SLEWP_DQSA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A1_mem_preamp_aa(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_preamp_aa)
{
  reg->bitfields.MEM_PREAMP_AA = mem_preamp_aa;
  if (reg->bitfields.MEM_PREAMP_AA != mem_preamp_aa) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_PREAMP_AA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A1_mem_preamp_dqma(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_preamp_dqma)
{
  reg->bitfields.MEM_PREAMP_DQMA = mem_preamp_dqma;
  if (reg->bitfields.MEM_PREAMP_DQMA != mem_preamp_dqma) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_PREAMP_DQMA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A1_mem_preamp_dqsa(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_preamp_dqsa)
{
  reg->bitfields.MEM_PREAMP_DQSA = mem_preamp_dqsa;
  if (reg->bitfields.MEM_PREAMP_DQSA != mem_preamp_dqsa) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_PREAMP_DQSA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A1_mem_io_modea(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_io_modea)
{
  reg->bitfields.MEM_IO_MODEA = mem_io_modea;
  if (reg->bitfields.MEM_IO_MODEA != mem_io_modea) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_IO_MODEA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A1_mem_rec_cka(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_rec_cka)
{
  reg->bitfields.MEM_REC_CKA = mem_rec_cka;
  if (reg->bitfields.MEM_REC_CKA != mem_rec_cka) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_REC_CKA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A1_mem_rec_aa(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_rec_aa)
{
  reg->bitfields.MEM_REC_AA = mem_rec_aa;
  if (reg->bitfields.MEM_REC_AA != mem_rec_aa) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_REC_AA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A1_mem_rec_dqma(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_rec_dqma)
{
  reg->bitfields.MEM_REC_DQMA = mem_rec_dqma;
  if (reg->bitfields.MEM_REC_DQMA != mem_rec_dqma) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_REC_DQMA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A1_mem_rec_dqsa(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_rec_dqsa)
{
  reg->bitfields.MEM_REC_DQSA = mem_rec_dqsa;
  if (reg->bitfields.MEM_REC_DQSA != mem_rec_dqsa) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_REC_DQSA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A1_mem_sync_phasea(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_sync_phasea)
{
  reg->bitfields.MEM_SYNC_PHASEA = mem_sync_phasea;
  if (reg->bitfields.MEM_SYNC_PHASEA != mem_sync_phasea) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_SYNC_PHASEA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A1_mem_sync_centera(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_sync_centera)
{
  reg->bitfields.MEM_SYNC_CENTERA = mem_sync_centera;
  if (reg->bitfields.MEM_SYNC_CENTERA != mem_sync_centera) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_SYNC_CENTERA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A1_mem_sync_ena(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_sync_ena)
{
  reg->bitfields.MEM_SYNC_ENA = mem_sync_ena;
  if (reg->bitfields.MEM_SYNC_ENA != mem_sync_ena) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_SYNC_ENA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A1_mem_clk_sela(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_clk_sela)
{
  reg->bitfields.MEM_CLK_SELA = mem_clk_sela;
  if (reg->bitfields.MEM_CLK_SELA != mem_clk_sela) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_CLK_SELA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A1_mem_clk_inva(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_clk_inva)
{
  reg->bitfields.MEM_CLK_INVA = mem_clk_inva;
  if (reg->bitfields.MEM_CLK_INVA != mem_clk_inva) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_CLK_INVA data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A1_mem_data_enimp_a(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_data_enimp_a)
{
  reg->bitfields.MEM_DATA_ENIMP_A = mem_data_enimp_a;
  if (reg->bitfields.MEM_DATA_ENIMP_A != mem_data_enimp_a) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_DATA_ENIMP_A data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_A1_mem_cntl_enimp_a(regMC_CHP_IO_CNTL_A1 *reg, unsigned int mem_cntl_enimp_a)
{
  reg->bitfields.MEM_CNTL_ENIMP_A = mem_cntl_enimp_a;
  if (reg->bitfields.MEM_CNTL_ENIMP_A != mem_cntl_enimp_a) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_A1::MEM_CNTL_ENIMP_A data too large\n");
}
#else
#define set_MC_CHP_IO_CNTL_A1_mem_slewn_cka(reg, mem_slewn_cka) (reg)->bitfields.MEM_SLEWN_CKA = mem_slewn_cka
#define set_MC_CHP_IO_CNTL_A1_mem_slewn_aa(reg, mem_slewn_aa) (reg)->bitfields.MEM_SLEWN_AA = mem_slewn_aa
#define set_MC_CHP_IO_CNTL_A1_mem_slewn_dqma(reg, mem_slewn_dqma) (reg)->bitfields.MEM_SLEWN_DQMA = mem_slewn_dqma
#define set_MC_CHP_IO_CNTL_A1_mem_slewn_dqsa(reg, mem_slewn_dqsa) (reg)->bitfields.MEM_SLEWN_DQSA = mem_slewn_dqsa
#define set_MC_CHP_IO_CNTL_A1_mem_slewp_cka(reg, mem_slewp_cka) (reg)->bitfields.MEM_SLEWP_CKA = mem_slewp_cka
#define set_MC_CHP_IO_CNTL_A1_mem_slewp_aa(reg, mem_slewp_aa) (reg)->bitfields.MEM_SLEWP_AA = mem_slewp_aa
#define set_MC_CHP_IO_CNTL_A1_mem_slewp_dqma(reg, mem_slewp_dqma) (reg)->bitfields.MEM_SLEWP_DQMA = mem_slewp_dqma
#define set_MC_CHP_IO_CNTL_A1_mem_slewp_dqsa(reg, mem_slewp_dqsa) (reg)->bitfields.MEM_SLEWP_DQSA = mem_slewp_dqsa
#define set_MC_CHP_IO_CNTL_A1_mem_preamp_aa(reg, mem_preamp_aa) (reg)->bitfields.MEM_PREAMP_AA = mem_preamp_aa
#define set_MC_CHP_IO_CNTL_A1_mem_preamp_dqma(reg, mem_preamp_dqma) (reg)->bitfields.MEM_PREAMP_DQMA = mem_preamp_dqma
#define set_MC_CHP_IO_CNTL_A1_mem_preamp_dqsa(reg, mem_preamp_dqsa) (reg)->bitfields.MEM_PREAMP_DQSA = mem_preamp_dqsa
#define set_MC_CHP_IO_CNTL_A1_mem_io_modea(reg, mem_io_modea) (reg)->bitfields.MEM_IO_MODEA = mem_io_modea
#define set_MC_CHP_IO_CNTL_A1_mem_rec_cka(reg, mem_rec_cka) (reg)->bitfields.MEM_REC_CKA = mem_rec_cka
#define set_MC_CHP_IO_CNTL_A1_mem_rec_aa(reg, mem_rec_aa) (reg)->bitfields.MEM_REC_AA = mem_rec_aa
#define set_MC_CHP_IO_CNTL_A1_mem_rec_dqma(reg, mem_rec_dqma) (reg)->bitfields.MEM_REC_DQMA = mem_rec_dqma
#define set_MC_CHP_IO_CNTL_A1_mem_rec_dqsa(reg, mem_rec_dqsa) (reg)->bitfields.MEM_REC_DQSA = mem_rec_dqsa
#define set_MC_CHP_IO_CNTL_A1_mem_sync_phasea(reg, mem_sync_phasea) (reg)->bitfields.MEM_SYNC_PHASEA = mem_sync_phasea
#define set_MC_CHP_IO_CNTL_A1_mem_sync_centera(reg, mem_sync_centera) (reg)->bitfields.MEM_SYNC_CENTERA = mem_sync_centera
#define set_MC_CHP_IO_CNTL_A1_mem_sync_ena(reg, mem_sync_ena) (reg)->bitfields.MEM_SYNC_ENA = mem_sync_ena
#define set_MC_CHP_IO_CNTL_A1_mem_clk_sela(reg, mem_clk_sela) (reg)->bitfields.MEM_CLK_SELA = mem_clk_sela
#define set_MC_CHP_IO_CNTL_A1_mem_clk_inva(reg, mem_clk_inva) (reg)->bitfields.MEM_CLK_INVA = mem_clk_inva
#define set_MC_CHP_IO_CNTL_A1_mem_data_enimp_a(reg, mem_data_enimp_a) (reg)->bitfields.MEM_DATA_ENIMP_A = mem_data_enimp_a
#define set_MC_CHP_IO_CNTL_A1_mem_cntl_enimp_a(reg, mem_cntl_enimp_a) (reg)->bitfields.MEM_CNTL_ENIMP_A = mem_cntl_enimp_a

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_CHP_IO_CNTL_B0 regMC_CHP_IO_CNTL_B0;

#ifdef DEBUG
__inline void set_MC_CHP_IO_CNTL_B0_mem_n_ckb(regMC_CHP_IO_CNTL_B0 *reg, unsigned int mem_n_ckb)
{
  reg->bitfields.MEM_N_CKB = mem_n_ckb;
  if (reg->bitfields.MEM_N_CKB != mem_n_ckb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B0::MEM_N_CKB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B0_mem_n_ab(regMC_CHP_IO_CNTL_B0 *reg, unsigned int mem_n_ab)
{
  reg->bitfields.MEM_N_AB = mem_n_ab;
  if (reg->bitfields.MEM_N_AB != mem_n_ab) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B0::MEM_N_AB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B0_mem_n_dqmb(regMC_CHP_IO_CNTL_B0 *reg, unsigned int mem_n_dqmb)
{
  reg->bitfields.MEM_N_DQMB = mem_n_dqmb;
  if (reg->bitfields.MEM_N_DQMB != mem_n_dqmb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B0::MEM_N_DQMB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B0_mem_n_dqsb(regMC_CHP_IO_CNTL_B0 *reg, unsigned int mem_n_dqsb)
{
  reg->bitfields.MEM_N_DQSB = mem_n_dqsb;
  if (reg->bitfields.MEM_N_DQSB != mem_n_dqsb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B0::MEM_N_DQSB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B0_mem_p_ckb(regMC_CHP_IO_CNTL_B0 *reg, unsigned int mem_p_ckb)
{
  reg->bitfields.MEM_P_CKB = mem_p_ckb;
  if (reg->bitfields.MEM_P_CKB != mem_p_ckb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B0::MEM_P_CKB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B0_mem_p_ab(regMC_CHP_IO_CNTL_B0 *reg, unsigned int mem_p_ab)
{
  reg->bitfields.MEM_P_AB = mem_p_ab;
  if (reg->bitfields.MEM_P_AB != mem_p_ab) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B0::MEM_P_AB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B0_mem_p_dqmb(regMC_CHP_IO_CNTL_B0 *reg, unsigned int mem_p_dqmb)
{
  reg->bitfields.MEM_P_DQMB = mem_p_dqmb;
  if (reg->bitfields.MEM_P_DQMB != mem_p_dqmb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B0::MEM_P_DQMB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B0_mem_p_dqsb(regMC_CHP_IO_CNTL_B0 *reg, unsigned int mem_p_dqsb)
{
  reg->bitfields.MEM_P_DQSB = mem_p_dqsb;
  if (reg->bitfields.MEM_P_DQSB != mem_p_dqsb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B0::MEM_P_DQSB data too large\n");
}
#else
#define set_MC_CHP_IO_CNTL_B0_mem_n_ckb(reg, mem_n_ckb) (reg)->bitfields.MEM_N_CKB = mem_n_ckb
#define set_MC_CHP_IO_CNTL_B0_mem_n_ab(reg, mem_n_ab) (reg)->bitfields.MEM_N_AB = mem_n_ab
#define set_MC_CHP_IO_CNTL_B0_mem_n_dqmb(reg, mem_n_dqmb) (reg)->bitfields.MEM_N_DQMB = mem_n_dqmb
#define set_MC_CHP_IO_CNTL_B0_mem_n_dqsb(reg, mem_n_dqsb) (reg)->bitfields.MEM_N_DQSB = mem_n_dqsb
#define set_MC_CHP_IO_CNTL_B0_mem_p_ckb(reg, mem_p_ckb) (reg)->bitfields.MEM_P_CKB = mem_p_ckb
#define set_MC_CHP_IO_CNTL_B0_mem_p_ab(reg, mem_p_ab) (reg)->bitfields.MEM_P_AB = mem_p_ab
#define set_MC_CHP_IO_CNTL_B0_mem_p_dqmb(reg, mem_p_dqmb) (reg)->bitfields.MEM_P_DQMB = mem_p_dqmb
#define set_MC_CHP_IO_CNTL_B0_mem_p_dqsb(reg, mem_p_dqsb) (reg)->bitfields.MEM_P_DQSB = mem_p_dqsb

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_CHP_IO_CNTL_B1 regMC_CHP_IO_CNTL_B1;

#ifdef DEBUG
__inline void set_MC_CHP_IO_CNTL_B1_mem_slewn_ckb(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_slewn_ckb)
{
  reg->bitfields.MEM_SLEWN_CKB = mem_slewn_ckb;
  if (reg->bitfields.MEM_SLEWN_CKB != mem_slewn_ckb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_SLEWN_CKB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B1_mem_slewn_ab(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_slewn_ab)
{
  reg->bitfields.MEM_SLEWN_AB = mem_slewn_ab;
  if (reg->bitfields.MEM_SLEWN_AB != mem_slewn_ab) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_SLEWN_AB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B1_mem_slewn_dqmb(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_slewn_dqmb)
{
  reg->bitfields.MEM_SLEWN_DQMB = mem_slewn_dqmb;
  if (reg->bitfields.MEM_SLEWN_DQMB != mem_slewn_dqmb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_SLEWN_DQMB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B1_mem_slewn_dqsb(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_slewn_dqsb)
{
  reg->bitfields.MEM_SLEWN_DQSB = mem_slewn_dqsb;
  if (reg->bitfields.MEM_SLEWN_DQSB != mem_slewn_dqsb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_SLEWN_DQSB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B1_mem_slewp_ckb(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_slewp_ckb)
{
  reg->bitfields.MEM_SLEWP_CKB = mem_slewp_ckb;
  if (reg->bitfields.MEM_SLEWP_CKB != mem_slewp_ckb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_SLEWP_CKB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B1_mem_slewp_ab(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_slewp_ab)
{
  reg->bitfields.MEM_SLEWP_AB = mem_slewp_ab;
  if (reg->bitfields.MEM_SLEWP_AB != mem_slewp_ab) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_SLEWP_AB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B1_mem_slewp_dqmb(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_slewp_dqmb)
{
  reg->bitfields.MEM_SLEWP_DQMB = mem_slewp_dqmb;
  if (reg->bitfields.MEM_SLEWP_DQMB != mem_slewp_dqmb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_SLEWP_DQMB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B1_mem_slewp_dqsb(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_slewp_dqsb)
{
  reg->bitfields.MEM_SLEWP_DQSB = mem_slewp_dqsb;
  if (reg->bitfields.MEM_SLEWP_DQSB != mem_slewp_dqsb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_SLEWP_DQSB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B1_mem_preamp_ab(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_preamp_ab)
{
  reg->bitfields.MEM_PREAMP_AB = mem_preamp_ab;
  if (reg->bitfields.MEM_PREAMP_AB != mem_preamp_ab) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_PREAMP_AB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B1_mem_preamp_dqmb(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_preamp_dqmb)
{
  reg->bitfields.MEM_PREAMP_DQMB = mem_preamp_dqmb;
  if (reg->bitfields.MEM_PREAMP_DQMB != mem_preamp_dqmb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_PREAMP_DQMB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B1_mem_preamp_dqsb(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_preamp_dqsb)
{
  reg->bitfields.MEM_PREAMP_DQSB = mem_preamp_dqsb;
  if (reg->bitfields.MEM_PREAMP_DQSB != mem_preamp_dqsb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_PREAMP_DQSB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B1_mem_io_modeb(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_io_modeb)
{
  reg->bitfields.MEM_IO_MODEB = mem_io_modeb;
  if (reg->bitfields.MEM_IO_MODEB != mem_io_modeb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_IO_MODEB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B1_mem_rec_ckb(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_rec_ckb)
{
  reg->bitfields.MEM_REC_CKB = mem_rec_ckb;
  if (reg->bitfields.MEM_REC_CKB != mem_rec_ckb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_REC_CKB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B1_mem_rec_ab(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_rec_ab)
{
  reg->bitfields.MEM_REC_AB = mem_rec_ab;
  if (reg->bitfields.MEM_REC_AB != mem_rec_ab) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_REC_AB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B1_mem_rec_dqmb(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_rec_dqmb)
{
  reg->bitfields.MEM_REC_DQMB = mem_rec_dqmb;
  if (reg->bitfields.MEM_REC_DQMB != mem_rec_dqmb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_REC_DQMB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B1_mem_rec_dqsb(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_rec_dqsb)
{
  reg->bitfields.MEM_REC_DQSB = mem_rec_dqsb;
  if (reg->bitfields.MEM_REC_DQSB != mem_rec_dqsb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_REC_DQSB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B1_mem_sync_phaseb(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_sync_phaseb)
{
  reg->bitfields.MEM_SYNC_PHASEB = mem_sync_phaseb;
  if (reg->bitfields.MEM_SYNC_PHASEB != mem_sync_phaseb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_SYNC_PHASEB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B1_mem_sync_centerb(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_sync_centerb)
{
  reg->bitfields.MEM_SYNC_CENTERB = mem_sync_centerb;
  if (reg->bitfields.MEM_SYNC_CENTERB != mem_sync_centerb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_SYNC_CENTERB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B1_mem_sync_enb(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_sync_enb)
{
  reg->bitfields.MEM_SYNC_ENB = mem_sync_enb;
  if (reg->bitfields.MEM_SYNC_ENB != mem_sync_enb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_SYNC_ENB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B1_mem_clk_selb(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_clk_selb)
{
  reg->bitfields.MEM_CLK_SELB = mem_clk_selb;
  if (reg->bitfields.MEM_CLK_SELB != mem_clk_selb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_CLK_SELB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B1_mem_clk_invb(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_clk_invb)
{
  reg->bitfields.MEM_CLK_INVB = mem_clk_invb;
  if (reg->bitfields.MEM_CLK_INVB != mem_clk_invb) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_CLK_INVB data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B1_mem_data_enimp_b(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_data_enimp_b)
{
  reg->bitfields.MEM_DATA_ENIMP_B = mem_data_enimp_b;
  if (reg->bitfields.MEM_DATA_ENIMP_B != mem_data_enimp_b) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_DATA_ENIMP_B data too large\n");
}
__inline void set_MC_CHP_IO_CNTL_B1_mem_cntl_enimp_b(regMC_CHP_IO_CNTL_B1 *reg, unsigned int mem_cntl_enimp_b)
{
  reg->bitfields.MEM_CNTL_ENIMP_B = mem_cntl_enimp_b;
  if (reg->bitfields.MEM_CNTL_ENIMP_B != mem_cntl_enimp_b) HSLDPF(E_ERROR_MESSAGE,"MC_CHP_IO_CNTL_B1::MEM_CNTL_ENIMP_B data too large\n");
}
#else
#define set_MC_CHP_IO_CNTL_B1_mem_slewn_ckb(reg, mem_slewn_ckb) (reg)->bitfields.MEM_SLEWN_CKB = mem_slewn_ckb
#define set_MC_CHP_IO_CNTL_B1_mem_slewn_ab(reg, mem_slewn_ab) (reg)->bitfields.MEM_SLEWN_AB = mem_slewn_ab
#define set_MC_CHP_IO_CNTL_B1_mem_slewn_dqmb(reg, mem_slewn_dqmb) (reg)->bitfields.MEM_SLEWN_DQMB = mem_slewn_dqmb
#define set_MC_CHP_IO_CNTL_B1_mem_slewn_dqsb(reg, mem_slewn_dqsb) (reg)->bitfields.MEM_SLEWN_DQSB = mem_slewn_dqsb
#define set_MC_CHP_IO_CNTL_B1_mem_slewp_ckb(reg, mem_slewp_ckb) (reg)->bitfields.MEM_SLEWP_CKB = mem_slewp_ckb
#define set_MC_CHP_IO_CNTL_B1_mem_slewp_ab(reg, mem_slewp_ab) (reg)->bitfields.MEM_SLEWP_AB = mem_slewp_ab
#define set_MC_CHP_IO_CNTL_B1_mem_slewp_dqmb(reg, mem_slewp_dqmb) (reg)->bitfields.MEM_SLEWP_DQMB = mem_slewp_dqmb
#define set_MC_CHP_IO_CNTL_B1_mem_slewp_dqsb(reg, mem_slewp_dqsb) (reg)->bitfields.MEM_SLEWP_DQSB = mem_slewp_dqsb
#define set_MC_CHP_IO_CNTL_B1_mem_preamp_ab(reg, mem_preamp_ab) (reg)->bitfields.MEM_PREAMP_AB = mem_preamp_ab
#define set_MC_CHP_IO_CNTL_B1_mem_preamp_dqmb(reg, mem_preamp_dqmb) (reg)->bitfields.MEM_PREAMP_DQMB = mem_preamp_dqmb
#define set_MC_CHP_IO_CNTL_B1_mem_preamp_dqsb(reg, mem_preamp_dqsb) (reg)->bitfields.MEM_PREAMP_DQSB = mem_preamp_dqsb
#define set_MC_CHP_IO_CNTL_B1_mem_io_modeb(reg, mem_io_modeb) (reg)->bitfields.MEM_IO_MODEB = mem_io_modeb
#define set_MC_CHP_IO_CNTL_B1_mem_rec_ckb(reg, mem_rec_ckb) (reg)->bitfields.MEM_REC_CKB = mem_rec_ckb
#define set_MC_CHP_IO_CNTL_B1_mem_rec_ab(reg, mem_rec_ab) (reg)->bitfields.MEM_REC_AB = mem_rec_ab
#define set_MC_CHP_IO_CNTL_B1_mem_rec_dqmb(reg, mem_rec_dqmb) (reg)->bitfields.MEM_REC_DQMB = mem_rec_dqmb
#define set_MC_CHP_IO_CNTL_B1_mem_rec_dqsb(reg, mem_rec_dqsb) (reg)->bitfields.MEM_REC_DQSB = mem_rec_dqsb
#define set_MC_CHP_IO_CNTL_B1_mem_sync_phaseb(reg, mem_sync_phaseb) (reg)->bitfields.MEM_SYNC_PHASEB = mem_sync_phaseb
#define set_MC_CHP_IO_CNTL_B1_mem_sync_centerb(reg, mem_sync_centerb) (reg)->bitfields.MEM_SYNC_CENTERB = mem_sync_centerb
#define set_MC_CHP_IO_CNTL_B1_mem_sync_enb(reg, mem_sync_enb) (reg)->bitfields.MEM_SYNC_ENB = mem_sync_enb
#define set_MC_CHP_IO_CNTL_B1_mem_clk_selb(reg, mem_clk_selb) (reg)->bitfields.MEM_CLK_SELB = mem_clk_selb
#define set_MC_CHP_IO_CNTL_B1_mem_clk_invb(reg, mem_clk_invb) (reg)->bitfields.MEM_CLK_INVB = mem_clk_invb
#define set_MC_CHP_IO_CNTL_B1_mem_data_enimp_b(reg, mem_data_enimp_b) (reg)->bitfields.MEM_DATA_ENIMP_B = mem_data_enimp_b
#define set_MC_CHP_IO_CNTL_B1_mem_cntl_enimp_b(reg, mem_cntl_enimp_b) (reg)->bitfields.MEM_CNTL_ENIMP_B = mem_cntl_enimp_b

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_IMP_CNTL_0 regMC_IMP_CNTL_0;

#ifdef DEBUG
__inline void set_MC_IMP_CNTL_0_mem_step_n_a(regMC_IMP_CNTL_0 *reg, unsigned int mem_step_n_a)
{
  reg->bitfields.MEM_STEP_N_A = mem_step_n_a;
  if (reg->bitfields.MEM_STEP_N_A != mem_step_n_a) HSLDPF(E_ERROR_MESSAGE,"MC_IMP_CNTL_0::MEM_STEP_N_A data too large\n");
}
__inline void set_MC_IMP_CNTL_0_mem_step_n_ck(regMC_IMP_CNTL_0 *reg, unsigned int mem_step_n_ck)
{
  reg->bitfields.MEM_STEP_N_CK = mem_step_n_ck;
  if (reg->bitfields.MEM_STEP_N_CK != mem_step_n_ck) HSLDPF(E_ERROR_MESSAGE,"MC_IMP_CNTL_0::MEM_STEP_N_CK data too large\n");
}
__inline void set_MC_IMP_CNTL_0_mem_step_n_dqs(regMC_IMP_CNTL_0 *reg, unsigned int mem_step_n_dqs)
{
  reg->bitfields.MEM_STEP_N_DQS = mem_step_n_dqs;
  if (reg->bitfields.MEM_STEP_N_DQS != mem_step_n_dqs) HSLDPF(E_ERROR_MESSAGE,"MC_IMP_CNTL_0::MEM_STEP_N_DQS data too large\n");
}
__inline void set_MC_IMP_CNTL_0_mem_step_p_a(regMC_IMP_CNTL_0 *reg, unsigned int mem_step_p_a)
{
  reg->bitfields.MEM_STEP_P_A = mem_step_p_a;
  if (reg->bitfields.MEM_STEP_P_A != mem_step_p_a) HSLDPF(E_ERROR_MESSAGE,"MC_IMP_CNTL_0::MEM_STEP_P_A data too large\n");
}
__inline void set_MC_IMP_CNTL_0_mem_step_p_ck(regMC_IMP_CNTL_0 *reg, unsigned int mem_step_p_ck)
{
  reg->bitfields.MEM_STEP_P_CK = mem_step_p_ck;
  if (reg->bitfields.MEM_STEP_P_CK != mem_step_p_ck) HSLDPF(E_ERROR_MESSAGE,"MC_IMP_CNTL_0::MEM_STEP_P_CK data too large\n");
}
__inline void set_MC_IMP_CNTL_0_mem_step_p_dqs(regMC_IMP_CNTL_0 *reg, unsigned int mem_step_p_dqs)
{
  reg->bitfields.MEM_STEP_P_DQS = mem_step_p_dqs;
  if (reg->bitfields.MEM_STEP_P_DQS != mem_step_p_dqs) HSLDPF(E_ERROR_MESSAGE,"MC_IMP_CNTL_0::MEM_STEP_P_DQS data too large\n");
}
#else
#define set_MC_IMP_CNTL_0_mem_step_n_a(reg, mem_step_n_a) (reg)->bitfields.MEM_STEP_N_A = mem_step_n_a
#define set_MC_IMP_CNTL_0_mem_step_n_ck(reg, mem_step_n_ck) (reg)->bitfields.MEM_STEP_N_CK = mem_step_n_ck
#define set_MC_IMP_CNTL_0_mem_step_n_dqs(reg, mem_step_n_dqs) (reg)->bitfields.MEM_STEP_N_DQS = mem_step_n_dqs
#define set_MC_IMP_CNTL_0_mem_step_p_a(reg, mem_step_p_a) (reg)->bitfields.MEM_STEP_P_A = mem_step_p_a
#define set_MC_IMP_CNTL_0_mem_step_p_ck(reg, mem_step_p_ck) (reg)->bitfields.MEM_STEP_P_CK = mem_step_p_ck
#define set_MC_IMP_CNTL_0_mem_step_p_dqs(reg, mem_step_p_dqs) (reg)->bitfields.MEM_STEP_P_DQS = mem_step_p_dqs

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TC_MISMATCH_1 regTC_MISMATCH_1;

#ifdef DEBUG
__inline void set_TC_MISMATCH_1_tc_mismatch_1(regTC_MISMATCH_1 *reg, unsigned int tc_mismatch_1)
{
  reg->bitfields.TC_MISMATCH_1 = tc_mismatch_1;
  if (reg->bitfields.TC_MISMATCH_1 != tc_mismatch_1) HSLDPF(E_ERROR_MESSAGE,"TC_MISMATCH_1::TC_MISMATCH_1 data too large\n");
}
#else
#define set_TC_MISMATCH_1_tc_mismatch_1(reg, tc_mismatch_1) (reg)->bitfields.TC_MISMATCH_1 = tc_mismatch_1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TC_MISMATCH_2 regTC_MISMATCH_2;

#ifdef DEBUG
__inline void set_TC_MISMATCH_2_tc_mismatch_2(regTC_MISMATCH_2 *reg, unsigned int tc_mismatch_2)
{
  reg->bitfields.TC_MISMATCH_2 = tc_mismatch_2;
  if (reg->bitfields.TC_MISMATCH_2 != tc_mismatch_2) HSLDPF(E_ERROR_MESSAGE,"TC_MISMATCH_2::TC_MISMATCH_2 data too large\n");
}
#else
#define set_TC_MISMATCH_2_tc_mismatch_2(reg, tc_mismatch_2) (reg)->bitfields.TC_MISMATCH_2 = tc_mismatch_2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_BIST_CTRL regMC_BIST_CTRL;

#ifdef DEBUG
__inline void set_MC_BIST_CTRL_mc_bist_ctrl(regMC_BIST_CTRL *reg, unsigned int mc_bist_ctrl)
{
  reg->bitfields.MC_BIST_CTRL = mc_bist_ctrl;
  if (reg->bitfields.MC_BIST_CTRL != mc_bist_ctrl) HSLDPF(E_ERROR_MESSAGE,"MC_BIST_CTRL::MC_BIST_CTRL data too large\n");
}
#else
#define set_MC_BIST_CTRL_mc_bist_ctrl(reg, mc_bist_ctrl) (reg)->bitfields.MC_BIST_CTRL = mc_bist_ctrl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union REG_COLLAR_WRITE regREG_COLLAR_WRITE;

#ifdef DEBUG
__inline void set_REG_COLLAR_WRITE_reg_collar_write(regREG_COLLAR_WRITE *reg, unsigned int reg_collar_write)
{
  reg->bitfields.REG_COLLAR_WRITE = reg_collar_write;
  if (reg->bitfields.REG_COLLAR_WRITE != reg_collar_write) HSLDPF(E_ERROR_MESSAGE,"REG_COLLAR_WRITE::REG_COLLAR_WRITE data too large\n");
}
#else
#define set_REG_COLLAR_WRITE_reg_collar_write(reg, reg_collar_write) (reg)->bitfields.REG_COLLAR_WRITE = reg_collar_write

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union REG_COLLAR_READ regREG_COLLAR_READ;

#ifdef DEBUG
__inline void set_REG_COLLAR_READ_reg_collar_read(regREG_COLLAR_READ *reg, unsigned int reg_collar_read)
{
  reg->bitfields.REG_COLLAR_READ = reg_collar_read;
  if (reg->bitfields.REG_COLLAR_READ != reg_collar_read) HSLDPF(E_ERROR_MESSAGE,"REG_COLLAR_READ::REG_COLLAR_READ data too large\n");
}
#else
#define set_REG_COLLAR_READ_reg_collar_read(reg, reg_collar_read) (reg)->bitfields.REG_COLLAR_READ = reg_collar_read

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_FB_LOCATION regMC_FB_LOCATION;

#ifdef DEBUG
__inline void set_MC_FB_LOCATION_mc_fb_start(regMC_FB_LOCATION *reg, unsigned int mc_fb_start)
{
  reg->bitfields.MC_FB_START = mc_fb_start;
  if (reg->bitfields.MC_FB_START != mc_fb_start) HSLDPF(E_ERROR_MESSAGE,"MC_FB_LOCATION::MC_FB_START data too large\n");
}
__inline void set_MC_FB_LOCATION_mc_fb_top(regMC_FB_LOCATION *reg, unsigned int mc_fb_top)
{
  reg->bitfields.MC_FB_TOP = mc_fb_top;
  if (reg->bitfields.MC_FB_TOP != mc_fb_top) HSLDPF(E_ERROR_MESSAGE,"MC_FB_LOCATION::MC_FB_TOP data too large\n");
}
#else
#define set_MC_FB_LOCATION_mc_fb_start(reg, mc_fb_start) (reg)->bitfields.MC_FB_START = mc_fb_start
#define set_MC_FB_LOCATION_mc_fb_top(reg, mc_fb_top) (reg)->bitfields.MC_FB_TOP = mc_fb_top

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GRA00 regGRA00;

#ifdef DEBUG
__inline void set_GRA00_grph_set_reset0(regGRA00 *reg, unsigned int grph_set_reset0)
{
  reg->bitfields.GRPH_SET_RESET0 = grph_set_reset0;
  if (reg->bitfields.GRPH_SET_RESET0 != grph_set_reset0) HSLDPF(E_ERROR_MESSAGE,"GRA00::GRPH_SET_RESET0 data too large\n");
}
__inline void set_GRA00_grph_set_reset1(regGRA00 *reg, unsigned int grph_set_reset1)
{
  reg->bitfields.GRPH_SET_RESET1 = grph_set_reset1;
  if (reg->bitfields.GRPH_SET_RESET1 != grph_set_reset1) HSLDPF(E_ERROR_MESSAGE,"GRA00::GRPH_SET_RESET1 data too large\n");
}
__inline void set_GRA00_grph_set_reset2(regGRA00 *reg, unsigned int grph_set_reset2)
{
  reg->bitfields.GRPH_SET_RESET2 = grph_set_reset2;
  if (reg->bitfields.GRPH_SET_RESET2 != grph_set_reset2) HSLDPF(E_ERROR_MESSAGE,"GRA00::GRPH_SET_RESET2 data too large\n");
}
__inline void set_GRA00_grph_set_reset3(regGRA00 *reg, unsigned int grph_set_reset3)
{
  reg->bitfields.GRPH_SET_RESET3 = grph_set_reset3;
  if (reg->bitfields.GRPH_SET_RESET3 != grph_set_reset3) HSLDPF(E_ERROR_MESSAGE,"GRA00::GRPH_SET_RESET3 data too large\n");
}
#else
#define set_GRA00_grph_set_reset0(reg, grph_set_reset0) (reg)->bitfields.GRPH_SET_RESET0 = grph_set_reset0
#define set_GRA00_grph_set_reset1(reg, grph_set_reset1) (reg)->bitfields.GRPH_SET_RESET1 = grph_set_reset1
#define set_GRA00_grph_set_reset2(reg, grph_set_reset2) (reg)->bitfields.GRPH_SET_RESET2 = grph_set_reset2
#define set_GRA00_grph_set_reset3(reg, grph_set_reset3) (reg)->bitfields.GRPH_SET_RESET3 = grph_set_reset3

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GRA01 regGRA01;

#ifdef DEBUG
__inline void set_GRA01_grph_set_reset_ena0(regGRA01 *reg, unsigned int grph_set_reset_ena0)
{
  reg->bitfields.GRPH_SET_RESET_ENA0 = grph_set_reset_ena0;
  if (reg->bitfields.GRPH_SET_RESET_ENA0 != grph_set_reset_ena0) HSLDPF(E_ERROR_MESSAGE,"GRA01::GRPH_SET_RESET_ENA0 data too large\n");
}
__inline void set_GRA01_grph_set_reset_ena1(regGRA01 *reg, unsigned int grph_set_reset_ena1)
{
  reg->bitfields.GRPH_SET_RESET_ENA1 = grph_set_reset_ena1;
  if (reg->bitfields.GRPH_SET_RESET_ENA1 != grph_set_reset_ena1) HSLDPF(E_ERROR_MESSAGE,"GRA01::GRPH_SET_RESET_ENA1 data too large\n");
}
__inline void set_GRA01_grph_set_reset_ena2(regGRA01 *reg, unsigned int grph_set_reset_ena2)
{
  reg->bitfields.GRPH_SET_RESET_ENA2 = grph_set_reset_ena2;
  if (reg->bitfields.GRPH_SET_RESET_ENA2 != grph_set_reset_ena2) HSLDPF(E_ERROR_MESSAGE,"GRA01::GRPH_SET_RESET_ENA2 data too large\n");
}
__inline void set_GRA01_grph_set_reset_ena3(regGRA01 *reg, unsigned int grph_set_reset_ena3)
{
  reg->bitfields.GRPH_SET_RESET_ENA3 = grph_set_reset_ena3;
  if (reg->bitfields.GRPH_SET_RESET_ENA3 != grph_set_reset_ena3) HSLDPF(E_ERROR_MESSAGE,"GRA01::GRPH_SET_RESET_ENA3 data too large\n");
}
#else
#define set_GRA01_grph_set_reset_ena0(reg, grph_set_reset_ena0) (reg)->bitfields.GRPH_SET_RESET_ENA0 = grph_set_reset_ena0
#define set_GRA01_grph_set_reset_ena1(reg, grph_set_reset_ena1) (reg)->bitfields.GRPH_SET_RESET_ENA1 = grph_set_reset_ena1
#define set_GRA01_grph_set_reset_ena2(reg, grph_set_reset_ena2) (reg)->bitfields.GRPH_SET_RESET_ENA2 = grph_set_reset_ena2
#define set_GRA01_grph_set_reset_ena3(reg, grph_set_reset_ena3) (reg)->bitfields.GRPH_SET_RESET_ENA3 = grph_set_reset_ena3

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GRA02 regGRA02;

#ifdef DEBUG
__inline void set_GRA02_grph_ccomp(regGRA02 *reg, unsigned int grph_ccomp)
{
  reg->bitfields.GRPH_CCOMP = grph_ccomp;
  if (reg->bitfields.GRPH_CCOMP != grph_ccomp) HSLDPF(E_ERROR_MESSAGE,"GRA02::GRPH_CCOMP data too large\n");
}
#else
#define set_GRA02_grph_ccomp(reg, grph_ccomp) (reg)->bitfields.GRPH_CCOMP = grph_ccomp

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GRA03 regGRA03;

#ifdef DEBUG
__inline void set_GRA03_grph_rotate(regGRA03 *reg, unsigned int grph_rotate)
{
  reg->bitfields.GRPH_ROTATE = grph_rotate;
  if (reg->bitfields.GRPH_ROTATE != grph_rotate) HSLDPF(E_ERROR_MESSAGE,"GRA03::GRPH_ROTATE data too large\n");
}
__inline void set_GRA03_grph_fn_sel(regGRA03 *reg, unsigned int grph_fn_sel)
{
  reg->bitfields.GRPH_FN_SEL = grph_fn_sel;
  if (reg->bitfields.GRPH_FN_SEL != grph_fn_sel) HSLDPF(E_ERROR_MESSAGE,"GRA03::GRPH_FN_SEL data too large\n");
}
#else
#define set_GRA03_grph_rotate(reg, grph_rotate) (reg)->bitfields.GRPH_ROTATE = grph_rotate
#define set_GRA03_grph_fn_sel(reg, grph_fn_sel) (reg)->bitfields.GRPH_FN_SEL = grph_fn_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GRA04 regGRA04;

#ifdef DEBUG
__inline void set_GRA04_grph_rmap(regGRA04 *reg, unsigned int grph_rmap)
{
  reg->bitfields.GRPH_RMAP = grph_rmap;
  if (reg->bitfields.GRPH_RMAP != grph_rmap) HSLDPF(E_ERROR_MESSAGE,"GRA04::GRPH_RMAP data too large\n");
}
#else
#define set_GRA04_grph_rmap(reg, grph_rmap) (reg)->bitfields.GRPH_RMAP = grph_rmap

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GRA06 regGRA06;

#ifdef DEBUG
__inline void set_GRA06_grph_graphics(regGRA06 *reg, unsigned int grph_graphics)
{
  reg->bitfields.GRPH_GRAPHICS = grph_graphics;
  if (reg->bitfields.GRPH_GRAPHICS != grph_graphics) HSLDPF(E_ERROR_MESSAGE,"GRA06::GRPH_GRAPHICS data too large\n");
}
__inline void set_GRA06_grph_oddeven(regGRA06 *reg, unsigned int grph_oddeven)
{
  reg->bitfields.GRPH_ODDEVEN = grph_oddeven;
  if (reg->bitfields.GRPH_ODDEVEN != grph_oddeven) HSLDPF(E_ERROR_MESSAGE,"GRA06::GRPH_ODDEVEN data too large\n");
}
__inline void set_GRA06_grph_adrsel(regGRA06 *reg, unsigned int grph_adrsel)
{
  reg->bitfields.GRPH_ADRSEL = grph_adrsel;
  if (reg->bitfields.GRPH_ADRSEL != grph_adrsel) HSLDPF(E_ERROR_MESSAGE,"GRA06::GRPH_ADRSEL data too large\n");
}
#else
#define set_GRA06_grph_graphics(reg, grph_graphics) (reg)->bitfields.GRPH_GRAPHICS = grph_graphics
#define set_GRA06_grph_oddeven(reg, grph_oddeven) (reg)->bitfields.GRPH_ODDEVEN = grph_oddeven
#define set_GRA06_grph_adrsel(reg, grph_adrsel) (reg)->bitfields.GRPH_ADRSEL = grph_adrsel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GRA07 regGRA07;

#ifdef DEBUG
__inline void set_GRA07_grph_xcare0(regGRA07 *reg, unsigned int grph_xcare0)
{
  reg->bitfields.GRPH_XCARE0 = grph_xcare0;
  if (reg->bitfields.GRPH_XCARE0 != grph_xcare0) HSLDPF(E_ERROR_MESSAGE,"GRA07::GRPH_XCARE0 data too large\n");
}
__inline void set_GRA07_grph_xcare1(regGRA07 *reg, unsigned int grph_xcare1)
{
  reg->bitfields.GRPH_XCARE1 = grph_xcare1;
  if (reg->bitfields.GRPH_XCARE1 != grph_xcare1) HSLDPF(E_ERROR_MESSAGE,"GRA07::GRPH_XCARE1 data too large\n");
}
__inline void set_GRA07_grph_xcare2(regGRA07 *reg, unsigned int grph_xcare2)
{
  reg->bitfields.GRPH_XCARE2 = grph_xcare2;
  if (reg->bitfields.GRPH_XCARE2 != grph_xcare2) HSLDPF(E_ERROR_MESSAGE,"GRA07::GRPH_XCARE2 data too large\n");
}
__inline void set_GRA07_grph_xcare3(regGRA07 *reg, unsigned int grph_xcare3)
{
  reg->bitfields.GRPH_XCARE3 = grph_xcare3;
  if (reg->bitfields.GRPH_XCARE3 != grph_xcare3) HSLDPF(E_ERROR_MESSAGE,"GRA07::GRPH_XCARE3 data too large\n");
}
#else
#define set_GRA07_grph_xcare0(reg, grph_xcare0) (reg)->bitfields.GRPH_XCARE0 = grph_xcare0
#define set_GRA07_grph_xcare1(reg, grph_xcare1) (reg)->bitfields.GRPH_XCARE1 = grph_xcare1
#define set_GRA07_grph_xcare2(reg, grph_xcare2) (reg)->bitfields.GRPH_XCARE2 = grph_xcare2
#define set_GRA07_grph_xcare3(reg, grph_xcare3) (reg)->bitfields.GRPH_XCARE3 = grph_xcare3

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GRA08 regGRA08;

#ifdef DEBUG
__inline void set_GRA08_grph_bmsk(regGRA08 *reg, unsigned int grph_bmsk)
{
  reg->bitfields.GRPH_BMSK = grph_bmsk;
  if (reg->bitfields.GRPH_BMSK != grph_bmsk) HSLDPF(E_ERROR_MESSAGE,"GRA08::GRPH_BMSK data too large\n");
}
#else
#define set_GRA08_grph_bmsk(reg, grph_bmsk) (reg)->bitfields.GRPH_BMSK = grph_bmsk

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SEQ02 regSEQ02;

#ifdef DEBUG
__inline void set_SEQ02_seq_map0_en(regSEQ02 *reg, unsigned int seq_map0_en)
{
  reg->bitfields.SEQ_MAP0_EN = seq_map0_en;
  if (reg->bitfields.SEQ_MAP0_EN != seq_map0_en) HSLDPF(E_ERROR_MESSAGE,"SEQ02::SEQ_MAP0_EN data too large\n");
}
__inline void set_SEQ02_seq_map1_en(regSEQ02 *reg, unsigned int seq_map1_en)
{
  reg->bitfields.SEQ_MAP1_EN = seq_map1_en;
  if (reg->bitfields.SEQ_MAP1_EN != seq_map1_en) HSLDPF(E_ERROR_MESSAGE,"SEQ02::SEQ_MAP1_EN data too large\n");
}
__inline void set_SEQ02_seq_map2_en(regSEQ02 *reg, unsigned int seq_map2_en)
{
  reg->bitfields.SEQ_MAP2_EN = seq_map2_en;
  if (reg->bitfields.SEQ_MAP2_EN != seq_map2_en) HSLDPF(E_ERROR_MESSAGE,"SEQ02::SEQ_MAP2_EN data too large\n");
}
__inline void set_SEQ02_seq_map3_en(regSEQ02 *reg, unsigned int seq_map3_en)
{
  reg->bitfields.SEQ_MAP3_EN = seq_map3_en;
  if (reg->bitfields.SEQ_MAP3_EN != seq_map3_en) HSLDPF(E_ERROR_MESSAGE,"SEQ02::SEQ_MAP3_EN data too large\n");
}
#else
#define set_SEQ02_seq_map0_en(reg, seq_map0_en) (reg)->bitfields.SEQ_MAP0_EN = seq_map0_en
#define set_SEQ02_seq_map1_en(reg, seq_map1_en) (reg)->bitfields.SEQ_MAP1_EN = seq_map1_en
#define set_SEQ02_seq_map2_en(reg, seq_map2_en) (reg)->bitfields.SEQ_MAP2_EN = seq_map2_en
#define set_SEQ02_seq_map3_en(reg, seq_map3_en) (reg)->bitfields.SEQ_MAP3_EN = seq_map3_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SEQ04 regSEQ04;

#ifdef DEBUG
__inline void set_SEQ04_seq_256k(regSEQ04 *reg, unsigned int seq_256k)
{
  reg->bitfields.SEQ_256K = seq_256k;
  if (reg->bitfields.SEQ_256K != seq_256k) HSLDPF(E_ERROR_MESSAGE,"SEQ04::SEQ_256K data too large\n");
}
__inline void set_SEQ04_seq_oddeven(regSEQ04 *reg, unsigned int seq_oddeven)
{
  reg->bitfields.SEQ_ODDEVEN = seq_oddeven;
  if (reg->bitfields.SEQ_ODDEVEN != seq_oddeven) HSLDPF(E_ERROR_MESSAGE,"SEQ04::SEQ_ODDEVEN data too large\n");
}
__inline void set_SEQ04_seq_chain(regSEQ04 *reg, unsigned int seq_chain)
{
  reg->bitfields.SEQ_CHAIN = seq_chain;
  if (reg->bitfields.SEQ_CHAIN != seq_chain) HSLDPF(E_ERROR_MESSAGE,"SEQ04::SEQ_CHAIN data too large\n");
}
#else
#define set_SEQ04_seq_256k(reg, seq_256k) (reg)->bitfields.SEQ_256K = seq_256k
#define set_SEQ04_seq_oddeven(reg, seq_oddeven) (reg)->bitfields.SEQ_ODDEVEN = seq_oddeven
#define set_SEQ04_seq_chain(reg, seq_chain) (reg)->bitfields.SEQ_CHAIN = seq_chain

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT1E regCRT1E;

#ifdef DEBUG
__inline void set_CRT1E_grph_dec_rd1(regCRT1E *reg, unsigned int grph_dec_rd1)
{
  reg->bitfields.GRPH_DEC_RD1 = grph_dec_rd1;
  if (reg->bitfields.GRPH_DEC_RD1 != grph_dec_rd1) HSLDPF(E_ERROR_MESSAGE,"CRT1E::GRPH_DEC_RD1 data too large\n");
}
#else
#define set_CRT1E_grph_dec_rd1(reg, grph_dec_rd1) (reg)->bitfields.GRPH_DEC_RD1 = grph_dec_rd1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT1F regCRT1F;

#ifdef DEBUG
__inline void set_CRT1F_grph_dec_rd0(regCRT1F *reg, unsigned int grph_dec_rd0)
{
  reg->bitfields.GRPH_DEC_RD0 = grph_dec_rd0;
  if (reg->bitfields.GRPH_DEC_RD0 != grph_dec_rd0) HSLDPF(E_ERROR_MESSAGE,"CRT1F::GRPH_DEC_RD0 data too large\n");
}
#else
#define set_CRT1F_grph_dec_rd0(reg, grph_dec_rd0) (reg)->bitfields.GRPH_DEC_RD0 = grph_dec_rd0

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT22 regCRT22;

#ifdef DEBUG
__inline void set_CRT22_grph_latch_data(regCRT22 *reg, unsigned int grph_latch_data)
{
  reg->bitfields.GRPH_LATCH_DATA = grph_latch_data;
  if (reg->bitfields.GRPH_LATCH_DATA != grph_latch_data) HSLDPF(E_ERROR_MESSAGE,"CRT22::GRPH_LATCH_DATA data too large\n");
}
#else
#define set_CRT22_grph_latch_data(reg, grph_latch_data) (reg)->bitfields.GRPH_LATCH_DATA = grph_latch_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT1E_S regCRT1E_S;

#ifdef DEBUG
__inline void set_CRT1E_S_grph_dec_rd1_m(regCRT1E_S *reg, unsigned int grph_dec_rd1_m)
{
  reg->bitfields.GRPH_DEC_RD1_M = grph_dec_rd1_m;
  if (reg->bitfields.GRPH_DEC_RD1_M != grph_dec_rd1_m) HSLDPF(E_ERROR_MESSAGE,"CRT1E_S::GRPH_DEC_RD1_M data too large\n");
}
#else
#define set_CRT1E_S_grph_dec_rd1_m(reg, grph_dec_rd1_m) (reg)->bitfields.GRPH_DEC_RD1_M = grph_dec_rd1_m

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT1F_S regCRT1F_S;

#ifdef DEBUG
__inline void set_CRT1F_S_grph_dec_rd0_m(regCRT1F_S *reg, unsigned int grph_dec_rd0_m)
{
  reg->bitfields.GRPH_DEC_RD0_M = grph_dec_rd0_m;
  if (reg->bitfields.GRPH_DEC_RD0_M != grph_dec_rd0_m) HSLDPF(E_ERROR_MESSAGE,"CRT1F_S::GRPH_DEC_RD0_M data too large\n");
}
#else
#define set_CRT1F_S_grph_dec_rd0_m(reg, grph_dec_rd0_m) (reg)->bitfields.GRPH_DEC_RD0_M = grph_dec_rd0_m

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT22_S regCRT22_S;

#ifdef DEBUG
__inline void set_CRT22_S_grph_latch_data_m(regCRT22_S *reg, unsigned int grph_latch_data_m)
{
  reg->bitfields.GRPH_LATCH_DATA_M = grph_latch_data_m;
  if (reg->bitfields.GRPH_LATCH_DATA_M != grph_latch_data_m) HSLDPF(E_ERROR_MESSAGE,"CRT22_S::GRPH_LATCH_DATA_M data too large\n");
}
#else
#define set_CRT22_S_grph_latch_data_m(reg, grph_latch_data_m) (reg)->bitfields.GRPH_LATCH_DATA_M = grph_latch_data_m

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union HOST_PATH_CNTL regHOST_PATH_CNTL;

#ifdef DEBUG
__inline void set_HOST_PATH_CNTL_hdp_write_through_cache_dis(regHOST_PATH_CNTL *reg, unsigned int hdp_write_through_cache_dis)
{
  reg->bitfields.HDP_WRITE_THROUGH_CACHE_DIS = hdp_write_through_cache_dis;
  if (reg->bitfields.HDP_WRITE_THROUGH_CACHE_DIS != hdp_write_through_cache_dis) HSLDPF(E_ERROR_MESSAGE,"HOST_PATH_CNTL::HDP_WRITE_THROUGH_CACHE_DIS data too large\n");
}
__inline void set_HOST_PATH_CNTL_hdp_aper_cntl(regHOST_PATH_CNTL *reg, unsigned int hdp_aper_cntl)
{
  reg->bitfields.HDP_APER_CNTL = hdp_aper_cntl;
  if (reg->bitfields.HDP_APER_CNTL != hdp_aper_cntl) HSLDPF(E_ERROR_MESSAGE,"HOST_PATH_CNTL::HDP_APER_CNTL data too large\n");
}
__inline void set_HOST_PATH_CNTL_hp_lin_rd_cache_dis(regHOST_PATH_CNTL *reg, unsigned int hp_lin_rd_cache_dis)
{
  reg->bitfields.HP_LIN_RD_CACHE_DIS = hp_lin_rd_cache_dis;
  if (reg->bitfields.HP_LIN_RD_CACHE_DIS != hp_lin_rd_cache_dis) HSLDPF(E_ERROR_MESSAGE,"HOST_PATH_CNTL::HP_LIN_RD_CACHE_DIS data too large\n");
}
__inline void set_HOST_PATH_CNTL_hp_rbbm_lock_dis(regHOST_PATH_CNTL *reg, unsigned int hp_rbbm_lock_dis)
{
  reg->bitfields.HP_RBBM_LOCK_DIS = hp_rbbm_lock_dis;
  if (reg->bitfields.HP_RBBM_LOCK_DIS != hp_rbbm_lock_dis) HSLDPF(E_ERROR_MESSAGE,"HOST_PATH_CNTL::HP_RBBM_LOCK_DIS data too large\n");
}
__inline void set_HOST_PATH_CNTL_hdp_soft_reset(regHOST_PATH_CNTL *reg, unsigned int hdp_soft_reset)
{
  reg->bitfields.HDP_SOFT_RESET = hdp_soft_reset;
  if (reg->bitfields.HDP_SOFT_RESET != hdp_soft_reset) HSLDPF(E_ERROR_MESSAGE,"HOST_PATH_CNTL::HDP_SOFT_RESET data too large\n");
}
__inline void set_HOST_PATH_CNTL_hdp_read_buffer_invalidate(regHOST_PATH_CNTL *reg, unsigned int hdp_read_buffer_invalidate)
{
  reg->bitfields.HDP_READ_BUFFER_INVALIDATE = hdp_read_buffer_invalidate;
  if (reg->bitfields.HDP_READ_BUFFER_INVALIDATE != hdp_read_buffer_invalidate) HSLDPF(E_ERROR_MESSAGE,"HOST_PATH_CNTL::HDP_READ_BUFFER_INVALIDATE data too large\n");
}
__inline void set_HOST_PATH_CNTL_hdp_write_combiner_timeout(regHOST_PATH_CNTL *reg, unsigned int hdp_write_combiner_timeout)
{
  reg->bitfields.HDP_WRITE_COMBINER_TIMEOUT = hdp_write_combiner_timeout;
  if (reg->bitfields.HDP_WRITE_COMBINER_TIMEOUT != hdp_write_combiner_timeout) HSLDPF(E_ERROR_MESSAGE,"HOST_PATH_CNTL::HDP_WRITE_COMBINER_TIMEOUT data too large\n");
}
__inline void set_HOST_PATH_CNTL_hp_test_rst_cntl(regHOST_PATH_CNTL *reg, unsigned int hp_test_rst_cntl)
{
  reg->bitfields.HP_TEST_RST_CNTL = hp_test_rst_cntl;
  if (reg->bitfields.HP_TEST_RST_CNTL != hp_test_rst_cntl) HSLDPF(E_ERROR_MESSAGE,"HOST_PATH_CNTL::HP_TEST_RST_CNTL data too large\n");
}
#else
#define set_HOST_PATH_CNTL_hdp_write_through_cache_dis(reg, hdp_write_through_cache_dis) (reg)->bitfields.HDP_WRITE_THROUGH_CACHE_DIS = hdp_write_through_cache_dis
#define set_HOST_PATH_CNTL_hdp_aper_cntl(reg, hdp_aper_cntl) (reg)->bitfields.HDP_APER_CNTL = hdp_aper_cntl
#define set_HOST_PATH_CNTL_hp_lin_rd_cache_dis(reg, hp_lin_rd_cache_dis) (reg)->bitfields.HP_LIN_RD_CACHE_DIS = hp_lin_rd_cache_dis
#define set_HOST_PATH_CNTL_hp_rbbm_lock_dis(reg, hp_rbbm_lock_dis) (reg)->bitfields.HP_RBBM_LOCK_DIS = hp_rbbm_lock_dis
#define set_HOST_PATH_CNTL_hdp_soft_reset(reg, hdp_soft_reset) (reg)->bitfields.HDP_SOFT_RESET = hdp_soft_reset
#define set_HOST_PATH_CNTL_hdp_read_buffer_invalidate(reg, hdp_read_buffer_invalidate) (reg)->bitfields.HDP_READ_BUFFER_INVALIDATE = hdp_read_buffer_invalidate
#define set_HOST_PATH_CNTL_hdp_write_combiner_timeout(reg, hdp_write_combiner_timeout) (reg)->bitfields.HDP_WRITE_COMBINER_TIMEOUT = hdp_write_combiner_timeout
#define set_HOST_PATH_CNTL_hp_test_rst_cntl(reg, hp_test_rst_cntl) (reg)->bitfields.HP_TEST_RST_CNTL = hp_test_rst_cntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MEM_VGA_WP_SEL regMEM_VGA_WP_SEL;

#ifdef DEBUG
__inline void set_MEM_VGA_WP_SEL_mem_vga_wps0(regMEM_VGA_WP_SEL *reg, unsigned int mem_vga_wps0)
{
  reg->bitfields.MEM_VGA_WPS0 = mem_vga_wps0;
  if (reg->bitfields.MEM_VGA_WPS0 != mem_vga_wps0) HSLDPF(E_ERROR_MESSAGE,"MEM_VGA_WP_SEL::MEM_VGA_WPS0 data too large\n");
}
__inline void set_MEM_VGA_WP_SEL_mem_vga_wps1(regMEM_VGA_WP_SEL *reg, unsigned int mem_vga_wps1)
{
  reg->bitfields.MEM_VGA_WPS1 = mem_vga_wps1;
  if (reg->bitfields.MEM_VGA_WPS1 != mem_vga_wps1) HSLDPF(E_ERROR_MESSAGE,"MEM_VGA_WP_SEL::MEM_VGA_WPS1 data too large\n");
}
#else
#define set_MEM_VGA_WP_SEL_mem_vga_wps0(reg, mem_vga_wps0) (reg)->bitfields.MEM_VGA_WPS0 = mem_vga_wps0
#define set_MEM_VGA_WP_SEL_mem_vga_wps1(reg, mem_vga_wps1) (reg)->bitfields.MEM_VGA_WPS1 = mem_vga_wps1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MEM_VGA_RP_SEL regMEM_VGA_RP_SEL;

#ifdef DEBUG
__inline void set_MEM_VGA_RP_SEL_mem_vga_rps0(regMEM_VGA_RP_SEL *reg, unsigned int mem_vga_rps0)
{
  reg->bitfields.MEM_VGA_RPS0 = mem_vga_rps0;
  if (reg->bitfields.MEM_VGA_RPS0 != mem_vga_rps0) HSLDPF(E_ERROR_MESSAGE,"MEM_VGA_RP_SEL::MEM_VGA_RPS0 data too large\n");
}
__inline void set_MEM_VGA_RP_SEL_mem_vga_rps1(regMEM_VGA_RP_SEL *reg, unsigned int mem_vga_rps1)
{
  reg->bitfields.MEM_VGA_RPS1 = mem_vga_rps1;
  if (reg->bitfields.MEM_VGA_RPS1 != mem_vga_rps1) HSLDPF(E_ERROR_MESSAGE,"MEM_VGA_RP_SEL::MEM_VGA_RPS1 data too large\n");
}
#else
#define set_MEM_VGA_RP_SEL_mem_vga_rps0(reg, mem_vga_rps0) (reg)->bitfields.MEM_VGA_RPS0 = mem_vga_rps0
#define set_MEM_VGA_RP_SEL_mem_vga_rps1(reg, mem_vga_rps1) (reg)->bitfields.MEM_VGA_RPS1 = mem_vga_rps1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union HDP_DEBUG regHDP_DEBUG;

#ifdef DEBUG
__inline void set_HDP_DEBUG_hdp_0_debug(regHDP_DEBUG *reg, unsigned int hdp_0_debug)
{
  reg->bitfields.HDP_0_DEBUG = hdp_0_debug;
  if (reg->bitfields.HDP_0_DEBUG != hdp_0_debug) HSLDPF(E_ERROR_MESSAGE,"HDP_DEBUG::HDP_0_DEBUG data too large\n");
}
__inline void set_HDP_DEBUG_hdp_1_debug(regHDP_DEBUG *reg, unsigned int hdp_1_debug)
{
  reg->bitfields.HDP_1_DEBUG = hdp_1_debug;
  if (reg->bitfields.HDP_1_DEBUG != hdp_1_debug) HSLDPF(E_ERROR_MESSAGE,"HDP_DEBUG::HDP_1_DEBUG data too large\n");
}
__inline void set_HDP_DEBUG_hdp_2_debug(regHDP_DEBUG *reg, unsigned int hdp_2_debug)
{
  reg->bitfields.HDP_2_DEBUG = hdp_2_debug;
  if (reg->bitfields.HDP_2_DEBUG != hdp_2_debug) HSLDPF(E_ERROR_MESSAGE,"HDP_DEBUG::HDP_2_DEBUG data too large\n");
}
__inline void set_HDP_DEBUG_hdp_3_debug(regHDP_DEBUG *reg, unsigned int hdp_3_debug)
{
  reg->bitfields.HDP_3_DEBUG = hdp_3_debug;
  if (reg->bitfields.HDP_3_DEBUG != hdp_3_debug) HSLDPF(E_ERROR_MESSAGE,"HDP_DEBUG::HDP_3_DEBUG data too large\n");
}
__inline void set_HDP_DEBUG_hdp_4_debug(regHDP_DEBUG *reg, unsigned int hdp_4_debug)
{
  reg->bitfields.HDP_4_DEBUG = hdp_4_debug;
  if (reg->bitfields.HDP_4_DEBUG != hdp_4_debug) HSLDPF(E_ERROR_MESSAGE,"HDP_DEBUG::HDP_4_DEBUG data too large\n");
}
__inline void set_HDP_DEBUG_hdp_5_debug(regHDP_DEBUG *reg, unsigned int hdp_5_debug)
{
  reg->bitfields.HDP_5_DEBUG = hdp_5_debug;
  if (reg->bitfields.HDP_5_DEBUG != hdp_5_debug) HSLDPF(E_ERROR_MESSAGE,"HDP_DEBUG::HDP_5_DEBUG data too large\n");
}
__inline void set_HDP_DEBUG_hdp_6_debug(regHDP_DEBUG *reg, unsigned int hdp_6_debug)
{
  reg->bitfields.HDP_6_DEBUG = hdp_6_debug;
  if (reg->bitfields.HDP_6_DEBUG != hdp_6_debug) HSLDPF(E_ERROR_MESSAGE,"HDP_DEBUG::HDP_6_DEBUG data too large\n");
}
__inline void set_HDP_DEBUG_hdp_7_debug(regHDP_DEBUG *reg, unsigned int hdp_7_debug)
{
  reg->bitfields.HDP_7_DEBUG = hdp_7_debug;
  if (reg->bitfields.HDP_7_DEBUG != hdp_7_debug) HSLDPF(E_ERROR_MESSAGE,"HDP_DEBUG::HDP_7_DEBUG data too large\n");
}
#else
#define set_HDP_DEBUG_hdp_0_debug(reg, hdp_0_debug) (reg)->bitfields.HDP_0_DEBUG = hdp_0_debug
#define set_HDP_DEBUG_hdp_1_debug(reg, hdp_1_debug) (reg)->bitfields.HDP_1_DEBUG = hdp_1_debug
#define set_HDP_DEBUG_hdp_2_debug(reg, hdp_2_debug) (reg)->bitfields.HDP_2_DEBUG = hdp_2_debug
#define set_HDP_DEBUG_hdp_3_debug(reg, hdp_3_debug) (reg)->bitfields.HDP_3_DEBUG = hdp_3_debug
#define set_HDP_DEBUG_hdp_4_debug(reg, hdp_4_debug) (reg)->bitfields.HDP_4_DEBUG = hdp_4_debug
#define set_HDP_DEBUG_hdp_5_debug(reg, hdp_5_debug) (reg)->bitfields.HDP_5_DEBUG = hdp_5_debug
#define set_HDP_DEBUG_hdp_6_debug(reg, hdp_6_debug) (reg)->bitfields.HDP_6_DEBUG = hdp_6_debug
#define set_HDP_DEBUG_hdp_7_debug(reg, hdp_7_debug) (reg)->bitfields.HDP_7_DEBUG = hdp_7_debug

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SW_SEMAPHORE regSW_SEMAPHORE;

#ifdef DEBUG
__inline void set_SW_SEMAPHORE_sw_semaphore(regSW_SEMAPHORE *reg, unsigned int sw_semaphore)
{
  reg->bitfields.SW_SEMAPHORE = sw_semaphore;
  if (reg->bitfields.SW_SEMAPHORE != sw_semaphore) HSLDPF(E_ERROR_MESSAGE,"SW_SEMAPHORE::SW_SEMAPHORE data too large\n");
}
#else
#define set_SW_SEMAPHORE_sw_semaphore(reg, sw_semaphore) (reg)->bitfields.SW_SEMAPHORE = sw_semaphore

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE_CNTL regSURFACE_CNTL;

#ifdef DEBUG
__inline void set_SURFACE_CNTL_surf_translation_dis(regSURFACE_CNTL *reg, unsigned int surf_translation_dis)
{
  reg->bitfields.SURF_TRANSLATION_DIS = surf_translation_dis;
  if (reg->bitfields.SURF_TRANSLATION_DIS != surf_translation_dis) HSLDPF(E_ERROR_MESSAGE,"SURFACE_CNTL::SURF_TRANSLATION_DIS data too large\n");
}
__inline void set_SURFACE_CNTL_nonsurf_ap0_swp(regSURFACE_CNTL *reg, unsigned int nonsurf_ap0_swp)
{
  reg->bitfields.NONSURF_AP0_SWP = nonsurf_ap0_swp;
  if (reg->bitfields.NONSURF_AP0_SWP != nonsurf_ap0_swp) HSLDPF(E_ERROR_MESSAGE,"SURFACE_CNTL::NONSURF_AP0_SWP data too large\n");
}
__inline void set_SURFACE_CNTL_nonsurf_ap1_swp(regSURFACE_CNTL *reg, unsigned int nonsurf_ap1_swp)
{
  reg->bitfields.NONSURF_AP1_SWP = nonsurf_ap1_swp;
  if (reg->bitfields.NONSURF_AP1_SWP != nonsurf_ap1_swp) HSLDPF(E_ERROR_MESSAGE,"SURFACE_CNTL::NONSURF_AP1_SWP data too large\n");
}
#else
#define set_SURFACE_CNTL_surf_translation_dis(reg, surf_translation_dis) (reg)->bitfields.SURF_TRANSLATION_DIS = surf_translation_dis
#define set_SURFACE_CNTL_nonsurf_ap0_swp(reg, nonsurf_ap0_swp) (reg)->bitfields.NONSURF_AP0_SWP = nonsurf_ap0_swp
#define set_SURFACE_CNTL_nonsurf_ap1_swp(reg, nonsurf_ap1_swp) (reg)->bitfields.NONSURF_AP1_SWP = nonsurf_ap1_swp

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE0_LOWER_BOUND regSURFACE0_LOWER_BOUND;

#ifdef DEBUG
__inline void set_SURFACE0_LOWER_BOUND_surf_lower(regSURFACE0_LOWER_BOUND *reg, unsigned int surf_lower)
{
  reg->bitfields.SURF_LOWER = surf_lower;
  if (reg->bitfields.SURF_LOWER != surf_lower) HSLDPF(E_ERROR_MESSAGE,"SURFACE0_LOWER_BOUND::SURF_LOWER data too large\n");
}
#else
#define set_SURFACE0_LOWER_BOUND_surf_lower(reg, surf_lower) (reg)->bitfields.SURF_LOWER = surf_lower

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE1_LOWER_BOUND regSURFACE1_LOWER_BOUND;

#ifdef DEBUG
__inline void set_SURFACE1_LOWER_BOUND_surf_lower(regSURFACE1_LOWER_BOUND *reg, unsigned int surf_lower)
{
  reg->bitfields.SURF_LOWER = surf_lower;
  if (reg->bitfields.SURF_LOWER != surf_lower) HSLDPF(E_ERROR_MESSAGE,"SURFACE1_LOWER_BOUND::SURF_LOWER data too large\n");
}
#else
#define set_SURFACE1_LOWER_BOUND_surf_lower(reg, surf_lower) (reg)->bitfields.SURF_LOWER = surf_lower

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE2_LOWER_BOUND regSURFACE2_LOWER_BOUND;

#ifdef DEBUG
__inline void set_SURFACE2_LOWER_BOUND_surf_lower(regSURFACE2_LOWER_BOUND *reg, unsigned int surf_lower)
{
  reg->bitfields.SURF_LOWER = surf_lower;
  if (reg->bitfields.SURF_LOWER != surf_lower) HSLDPF(E_ERROR_MESSAGE,"SURFACE2_LOWER_BOUND::SURF_LOWER data too large\n");
}
#else
#define set_SURFACE2_LOWER_BOUND_surf_lower(reg, surf_lower) (reg)->bitfields.SURF_LOWER = surf_lower

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE3_LOWER_BOUND regSURFACE3_LOWER_BOUND;

#ifdef DEBUG
__inline void set_SURFACE3_LOWER_BOUND_surf_lower(regSURFACE3_LOWER_BOUND *reg, unsigned int surf_lower)
{
  reg->bitfields.SURF_LOWER = surf_lower;
  if (reg->bitfields.SURF_LOWER != surf_lower) HSLDPF(E_ERROR_MESSAGE,"SURFACE3_LOWER_BOUND::SURF_LOWER data too large\n");
}
#else
#define set_SURFACE3_LOWER_BOUND_surf_lower(reg, surf_lower) (reg)->bitfields.SURF_LOWER = surf_lower

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE4_LOWER_BOUND regSURFACE4_LOWER_BOUND;

#ifdef DEBUG
__inline void set_SURFACE4_LOWER_BOUND_surf_lower(regSURFACE4_LOWER_BOUND *reg, unsigned int surf_lower)
{
  reg->bitfields.SURF_LOWER = surf_lower;
  if (reg->bitfields.SURF_LOWER != surf_lower) HSLDPF(E_ERROR_MESSAGE,"SURFACE4_LOWER_BOUND::SURF_LOWER data too large\n");
}
#else
#define set_SURFACE4_LOWER_BOUND_surf_lower(reg, surf_lower) (reg)->bitfields.SURF_LOWER = surf_lower

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE5_LOWER_BOUND regSURFACE5_LOWER_BOUND;

#ifdef DEBUG
__inline void set_SURFACE5_LOWER_BOUND_surf_lower(regSURFACE5_LOWER_BOUND *reg, unsigned int surf_lower)
{
  reg->bitfields.SURF_LOWER = surf_lower;
  if (reg->bitfields.SURF_LOWER != surf_lower) HSLDPF(E_ERROR_MESSAGE,"SURFACE5_LOWER_BOUND::SURF_LOWER data too large\n");
}
#else
#define set_SURFACE5_LOWER_BOUND_surf_lower(reg, surf_lower) (reg)->bitfields.SURF_LOWER = surf_lower

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE6_LOWER_BOUND regSURFACE6_LOWER_BOUND;

#ifdef DEBUG
__inline void set_SURFACE6_LOWER_BOUND_surf_lower(regSURFACE6_LOWER_BOUND *reg, unsigned int surf_lower)
{
  reg->bitfields.SURF_LOWER = surf_lower;
  if (reg->bitfields.SURF_LOWER != surf_lower) HSLDPF(E_ERROR_MESSAGE,"SURFACE6_LOWER_BOUND::SURF_LOWER data too large\n");
}
#else
#define set_SURFACE6_LOWER_BOUND_surf_lower(reg, surf_lower) (reg)->bitfields.SURF_LOWER = surf_lower

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE7_LOWER_BOUND regSURFACE7_LOWER_BOUND;

#ifdef DEBUG
__inline void set_SURFACE7_LOWER_BOUND_surf_lower(regSURFACE7_LOWER_BOUND *reg, unsigned int surf_lower)
{
  reg->bitfields.SURF_LOWER = surf_lower;
  if (reg->bitfields.SURF_LOWER != surf_lower) HSLDPF(E_ERROR_MESSAGE,"SURFACE7_LOWER_BOUND::SURF_LOWER data too large\n");
}
#else
#define set_SURFACE7_LOWER_BOUND_surf_lower(reg, surf_lower) (reg)->bitfields.SURF_LOWER = surf_lower

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE0_UPPER_BOUND regSURFACE0_UPPER_BOUND;

#ifdef DEBUG
__inline void set_SURFACE0_UPPER_BOUND_surf_upper(regSURFACE0_UPPER_BOUND *reg, unsigned int surf_upper)
{
  reg->bitfields.SURF_UPPER = surf_upper;
  if (reg->bitfields.SURF_UPPER != surf_upper) HSLDPF(E_ERROR_MESSAGE,"SURFACE0_UPPER_BOUND::SURF_UPPER data too large\n");
}
#else
#define set_SURFACE0_UPPER_BOUND_surf_upper(reg, surf_upper) (reg)->bitfields.SURF_UPPER = surf_upper

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE1_UPPER_BOUND regSURFACE1_UPPER_BOUND;

#ifdef DEBUG
__inline void set_SURFACE1_UPPER_BOUND_surf_upper(regSURFACE1_UPPER_BOUND *reg, unsigned int surf_upper)
{
  reg->bitfields.SURF_UPPER = surf_upper;
  if (reg->bitfields.SURF_UPPER != surf_upper) HSLDPF(E_ERROR_MESSAGE,"SURFACE1_UPPER_BOUND::SURF_UPPER data too large\n");
}
#else
#define set_SURFACE1_UPPER_BOUND_surf_upper(reg, surf_upper) (reg)->bitfields.SURF_UPPER = surf_upper

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE2_UPPER_BOUND regSURFACE2_UPPER_BOUND;

#ifdef DEBUG
__inline void set_SURFACE2_UPPER_BOUND_surf_upper(regSURFACE2_UPPER_BOUND *reg, unsigned int surf_upper)
{
  reg->bitfields.SURF_UPPER = surf_upper;
  if (reg->bitfields.SURF_UPPER != surf_upper) HSLDPF(E_ERROR_MESSAGE,"SURFACE2_UPPER_BOUND::SURF_UPPER data too large\n");
}
#else
#define set_SURFACE2_UPPER_BOUND_surf_upper(reg, surf_upper) (reg)->bitfields.SURF_UPPER = surf_upper

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE3_UPPER_BOUND regSURFACE3_UPPER_BOUND;

#ifdef DEBUG
__inline void set_SURFACE3_UPPER_BOUND_surf_upper(regSURFACE3_UPPER_BOUND *reg, unsigned int surf_upper)
{
  reg->bitfields.SURF_UPPER = surf_upper;
  if (reg->bitfields.SURF_UPPER != surf_upper) HSLDPF(E_ERROR_MESSAGE,"SURFACE3_UPPER_BOUND::SURF_UPPER data too large\n");
}
#else
#define set_SURFACE3_UPPER_BOUND_surf_upper(reg, surf_upper) (reg)->bitfields.SURF_UPPER = surf_upper

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE4_UPPER_BOUND regSURFACE4_UPPER_BOUND;

#ifdef DEBUG
__inline void set_SURFACE4_UPPER_BOUND_surf_upper(regSURFACE4_UPPER_BOUND *reg, unsigned int surf_upper)
{
  reg->bitfields.SURF_UPPER = surf_upper;
  if (reg->bitfields.SURF_UPPER != surf_upper) HSLDPF(E_ERROR_MESSAGE,"SURFACE4_UPPER_BOUND::SURF_UPPER data too large\n");
}
#else
#define set_SURFACE4_UPPER_BOUND_surf_upper(reg, surf_upper) (reg)->bitfields.SURF_UPPER = surf_upper

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE5_UPPER_BOUND regSURFACE5_UPPER_BOUND;

#ifdef DEBUG
__inline void set_SURFACE5_UPPER_BOUND_surf_upper(regSURFACE5_UPPER_BOUND *reg, unsigned int surf_upper)
{
  reg->bitfields.SURF_UPPER = surf_upper;
  if (reg->bitfields.SURF_UPPER != surf_upper) HSLDPF(E_ERROR_MESSAGE,"SURFACE5_UPPER_BOUND::SURF_UPPER data too large\n");
}
#else
#define set_SURFACE5_UPPER_BOUND_surf_upper(reg, surf_upper) (reg)->bitfields.SURF_UPPER = surf_upper

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE6_UPPER_BOUND regSURFACE6_UPPER_BOUND;

#ifdef DEBUG
__inline void set_SURFACE6_UPPER_BOUND_surf_upper(regSURFACE6_UPPER_BOUND *reg, unsigned int surf_upper)
{
  reg->bitfields.SURF_UPPER = surf_upper;
  if (reg->bitfields.SURF_UPPER != surf_upper) HSLDPF(E_ERROR_MESSAGE,"SURFACE6_UPPER_BOUND::SURF_UPPER data too large\n");
}
#else
#define set_SURFACE6_UPPER_BOUND_surf_upper(reg, surf_upper) (reg)->bitfields.SURF_UPPER = surf_upper

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE7_UPPER_BOUND regSURFACE7_UPPER_BOUND;

#ifdef DEBUG
__inline void set_SURFACE7_UPPER_BOUND_surf_upper(regSURFACE7_UPPER_BOUND *reg, unsigned int surf_upper)
{
  reg->bitfields.SURF_UPPER = surf_upper;
  if (reg->bitfields.SURF_UPPER != surf_upper) HSLDPF(E_ERROR_MESSAGE,"SURFACE7_UPPER_BOUND::SURF_UPPER data too large\n");
}
#else
#define set_SURFACE7_UPPER_BOUND_surf_upper(reg, surf_upper) (reg)->bitfields.SURF_UPPER = surf_upper

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE0_INFO regSURFACE0_INFO;

#ifdef DEBUG
__inline void set_SURFACE0_INFO_surf0_pitchsel(regSURFACE0_INFO *reg, unsigned int surf0_pitchsel)
{
  reg->bitfields.SURF0_PITCHSEL = surf0_pitchsel;
  if (reg->bitfields.SURF0_PITCHSEL != surf0_pitchsel) HSLDPF(E_ERROR_MESSAGE,"SURFACE0_INFO::SURF0_PITCHSEL data too large\n");
}
__inline void set_SURFACE0_INFO_surf0_tile_mode(regSURFACE0_INFO *reg, unsigned int surf0_tile_mode)
{
  reg->bitfields.SURF0_TILE_MODE = surf0_tile_mode;
  if (reg->bitfields.SURF0_TILE_MODE != surf0_tile_mode) HSLDPF(E_ERROR_MESSAGE,"SURFACE0_INFO::SURF0_TILE_MODE data too large\n");
}
__inline void set_SURFACE0_INFO_surf0_ap0_swp(regSURFACE0_INFO *reg, unsigned int surf0_ap0_swp)
{
  reg->bitfields.SURF0_AP0_SWP = surf0_ap0_swp;
  if (reg->bitfields.SURF0_AP0_SWP != surf0_ap0_swp) HSLDPF(E_ERROR_MESSAGE,"SURFACE0_INFO::SURF0_AP0_SWP data too large\n");
}
__inline void set_SURFACE0_INFO_surf0_ap1_swp(regSURFACE0_INFO *reg, unsigned int surf0_ap1_swp)
{
  reg->bitfields.SURF0_AP1_SWP = surf0_ap1_swp;
  if (reg->bitfields.SURF0_AP1_SWP != surf0_ap1_swp) HSLDPF(E_ERROR_MESSAGE,"SURFACE0_INFO::SURF0_AP1_SWP data too large\n");
}
__inline void set_SURFACE0_INFO_surf0_write_flag(regSURFACE0_INFO *reg, unsigned int surf0_write_flag)
{
  reg->bitfields.SURF0_WRITE_FLAG = surf0_write_flag;
  if (reg->bitfields.SURF0_WRITE_FLAG != surf0_write_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE0_INFO::SURF0_WRITE_FLAG data too large\n");
}
__inline void set_SURFACE0_INFO_surf0_read_flag(regSURFACE0_INFO *reg, unsigned int surf0_read_flag)
{
  reg->bitfields.SURF0_READ_FLAG = surf0_read_flag;
  if (reg->bitfields.SURF0_READ_FLAG != surf0_read_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE0_INFO::SURF0_READ_FLAG data too large\n");
}
#else
#define set_SURFACE0_INFO_surf0_pitchsel(reg, surf0_pitchsel) (reg)->bitfields.SURF0_PITCHSEL = surf0_pitchsel
#define set_SURFACE0_INFO_surf0_tile_mode(reg, surf0_tile_mode) (reg)->bitfields.SURF0_TILE_MODE = surf0_tile_mode
#define set_SURFACE0_INFO_surf0_ap0_swp(reg, surf0_ap0_swp) (reg)->bitfields.SURF0_AP0_SWP = surf0_ap0_swp
#define set_SURFACE0_INFO_surf0_ap1_swp(reg, surf0_ap1_swp) (reg)->bitfields.SURF0_AP1_SWP = surf0_ap1_swp
#define set_SURFACE0_INFO_surf0_write_flag(reg, surf0_write_flag) (reg)->bitfields.SURF0_WRITE_FLAG = surf0_write_flag
#define set_SURFACE0_INFO_surf0_read_flag(reg, surf0_read_flag) (reg)->bitfields.SURF0_READ_FLAG = surf0_read_flag

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE1_INFO regSURFACE1_INFO;

#ifdef DEBUG
__inline void set_SURFACE1_INFO_surf1_pitchsel(regSURFACE1_INFO *reg, unsigned int surf1_pitchsel)
{
  reg->bitfields.SURF1_PITCHSEL = surf1_pitchsel;
  if (reg->bitfields.SURF1_PITCHSEL != surf1_pitchsel) HSLDPF(E_ERROR_MESSAGE,"SURFACE1_INFO::SURF1_PITCHSEL data too large\n");
}
__inline void set_SURFACE1_INFO_surf1_tile_mode(regSURFACE1_INFO *reg, unsigned int surf1_tile_mode)
{
  reg->bitfields.SURF1_TILE_MODE = surf1_tile_mode;
  if (reg->bitfields.SURF1_TILE_MODE != surf1_tile_mode) HSLDPF(E_ERROR_MESSAGE,"SURFACE1_INFO::SURF1_TILE_MODE data too large\n");
}
__inline void set_SURFACE1_INFO_surf1_ap0_swp(regSURFACE1_INFO *reg, unsigned int surf1_ap0_swp)
{
  reg->bitfields.SURF1_AP0_SWP = surf1_ap0_swp;
  if (reg->bitfields.SURF1_AP0_SWP != surf1_ap0_swp) HSLDPF(E_ERROR_MESSAGE,"SURFACE1_INFO::SURF1_AP0_SWP data too large\n");
}
__inline void set_SURFACE1_INFO_surf1_ap1_swp(regSURFACE1_INFO *reg, unsigned int surf1_ap1_swp)
{
  reg->bitfields.SURF1_AP1_SWP = surf1_ap1_swp;
  if (reg->bitfields.SURF1_AP1_SWP != surf1_ap1_swp) HSLDPF(E_ERROR_MESSAGE,"SURFACE1_INFO::SURF1_AP1_SWP data too large\n");
}
__inline void set_SURFACE1_INFO_surf1_write_flag(regSURFACE1_INFO *reg, unsigned int surf1_write_flag)
{
  reg->bitfields.SURF1_WRITE_FLAG = surf1_write_flag;
  if (reg->bitfields.SURF1_WRITE_FLAG != surf1_write_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE1_INFO::SURF1_WRITE_FLAG data too large\n");
}
__inline void set_SURFACE1_INFO_surf1_read_flag(regSURFACE1_INFO *reg, unsigned int surf1_read_flag)
{
  reg->bitfields.SURF1_READ_FLAG = surf1_read_flag;
  if (reg->bitfields.SURF1_READ_FLAG != surf1_read_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE1_INFO::SURF1_READ_FLAG data too large\n");
}
#else
#define set_SURFACE1_INFO_surf1_pitchsel(reg, surf1_pitchsel) (reg)->bitfields.SURF1_PITCHSEL = surf1_pitchsel
#define set_SURFACE1_INFO_surf1_tile_mode(reg, surf1_tile_mode) (reg)->bitfields.SURF1_TILE_MODE = surf1_tile_mode
#define set_SURFACE1_INFO_surf1_ap0_swp(reg, surf1_ap0_swp) (reg)->bitfields.SURF1_AP0_SWP = surf1_ap0_swp
#define set_SURFACE1_INFO_surf1_ap1_swp(reg, surf1_ap1_swp) (reg)->bitfields.SURF1_AP1_SWP = surf1_ap1_swp
#define set_SURFACE1_INFO_surf1_write_flag(reg, surf1_write_flag) (reg)->bitfields.SURF1_WRITE_FLAG = surf1_write_flag
#define set_SURFACE1_INFO_surf1_read_flag(reg, surf1_read_flag) (reg)->bitfields.SURF1_READ_FLAG = surf1_read_flag

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE2_INFO regSURFACE2_INFO;

#ifdef DEBUG
__inline void set_SURFACE2_INFO_surf2_pitchsel(regSURFACE2_INFO *reg, unsigned int surf2_pitchsel)
{
  reg->bitfields.SURF2_PITCHSEL = surf2_pitchsel;
  if (reg->bitfields.SURF2_PITCHSEL != surf2_pitchsel) HSLDPF(E_ERROR_MESSAGE,"SURFACE2_INFO::SURF2_PITCHSEL data too large\n");
}
__inline void set_SURFACE2_INFO_surf2_tile_mode(regSURFACE2_INFO *reg, unsigned int surf2_tile_mode)
{
  reg->bitfields.SURF2_TILE_MODE = surf2_tile_mode;
  if (reg->bitfields.SURF2_TILE_MODE != surf2_tile_mode) HSLDPF(E_ERROR_MESSAGE,"SURFACE2_INFO::SURF2_TILE_MODE data too large\n");
}
__inline void set_SURFACE2_INFO_surf2_ap0_swp(regSURFACE2_INFO *reg, unsigned int surf2_ap0_swp)
{
  reg->bitfields.SURF2_AP0_SWP = surf2_ap0_swp;
  if (reg->bitfields.SURF2_AP0_SWP != surf2_ap0_swp) HSLDPF(E_ERROR_MESSAGE,"SURFACE2_INFO::SURF2_AP0_SWP data too large\n");
}
__inline void set_SURFACE2_INFO_surf2_ap1_swp(regSURFACE2_INFO *reg, unsigned int surf2_ap1_swp)
{
  reg->bitfields.SURF2_AP1_SWP = surf2_ap1_swp;
  if (reg->bitfields.SURF2_AP1_SWP != surf2_ap1_swp) HSLDPF(E_ERROR_MESSAGE,"SURFACE2_INFO::SURF2_AP1_SWP data too large\n");
}
__inline void set_SURFACE2_INFO_surf2_write_flag(regSURFACE2_INFO *reg, unsigned int surf2_write_flag)
{
  reg->bitfields.SURF2_WRITE_FLAG = surf2_write_flag;
  if (reg->bitfields.SURF2_WRITE_FLAG != surf2_write_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE2_INFO::SURF2_WRITE_FLAG data too large\n");
}
__inline void set_SURFACE2_INFO_surf2_read_flag(regSURFACE2_INFO *reg, unsigned int surf2_read_flag)
{
  reg->bitfields.SURF2_READ_FLAG = surf2_read_flag;
  if (reg->bitfields.SURF2_READ_FLAG != surf2_read_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE2_INFO::SURF2_READ_FLAG data too large\n");
}
#else
#define set_SURFACE2_INFO_surf2_pitchsel(reg, surf2_pitchsel) (reg)->bitfields.SURF2_PITCHSEL = surf2_pitchsel
#define set_SURFACE2_INFO_surf2_tile_mode(reg, surf2_tile_mode) (reg)->bitfields.SURF2_TILE_MODE = surf2_tile_mode
#define set_SURFACE2_INFO_surf2_ap0_swp(reg, surf2_ap0_swp) (reg)->bitfields.SURF2_AP0_SWP = surf2_ap0_swp
#define set_SURFACE2_INFO_surf2_ap1_swp(reg, surf2_ap1_swp) (reg)->bitfields.SURF2_AP1_SWP = surf2_ap1_swp
#define set_SURFACE2_INFO_surf2_write_flag(reg, surf2_write_flag) (reg)->bitfields.SURF2_WRITE_FLAG = surf2_write_flag
#define set_SURFACE2_INFO_surf2_read_flag(reg, surf2_read_flag) (reg)->bitfields.SURF2_READ_FLAG = surf2_read_flag

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE3_INFO regSURFACE3_INFO;

#ifdef DEBUG
__inline void set_SURFACE3_INFO_surf3_pitchsel(regSURFACE3_INFO *reg, unsigned int surf3_pitchsel)
{
  reg->bitfields.SURF3_PITCHSEL = surf3_pitchsel;
  if (reg->bitfields.SURF3_PITCHSEL != surf3_pitchsel) HSLDPF(E_ERROR_MESSAGE,"SURFACE3_INFO::SURF3_PITCHSEL data too large\n");
}
__inline void set_SURFACE3_INFO_surf3_tile_mode(regSURFACE3_INFO *reg, unsigned int surf3_tile_mode)
{
  reg->bitfields.SURF3_TILE_MODE = surf3_tile_mode;
  if (reg->bitfields.SURF3_TILE_MODE != surf3_tile_mode) HSLDPF(E_ERROR_MESSAGE,"SURFACE3_INFO::SURF3_TILE_MODE data too large\n");
}
__inline void set_SURFACE3_INFO_surf3_ap0_swp(regSURFACE3_INFO *reg, unsigned int surf3_ap0_swp)
{
  reg->bitfields.SURF3_AP0_SWP = surf3_ap0_swp;
  if (reg->bitfields.SURF3_AP0_SWP != surf3_ap0_swp) HSLDPF(E_ERROR_MESSAGE,"SURFACE3_INFO::SURF3_AP0_SWP data too large\n");
}
__inline void set_SURFACE3_INFO_surf3_ap1_swp(regSURFACE3_INFO *reg, unsigned int surf3_ap1_swp)
{
  reg->bitfields.SURF3_AP1_SWP = surf3_ap1_swp;
  if (reg->bitfields.SURF3_AP1_SWP != surf3_ap1_swp) HSLDPF(E_ERROR_MESSAGE,"SURFACE3_INFO::SURF3_AP1_SWP data too large\n");
}
__inline void set_SURFACE3_INFO_surf3_write_flag(regSURFACE3_INFO *reg, unsigned int surf3_write_flag)
{
  reg->bitfields.SURF3_WRITE_FLAG = surf3_write_flag;
  if (reg->bitfields.SURF3_WRITE_FLAG != surf3_write_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE3_INFO::SURF3_WRITE_FLAG data too large\n");
}
__inline void set_SURFACE3_INFO_surf3_read_flag(regSURFACE3_INFO *reg, unsigned int surf3_read_flag)
{
  reg->bitfields.SURF3_READ_FLAG = surf3_read_flag;
  if (reg->bitfields.SURF3_READ_FLAG != surf3_read_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE3_INFO::SURF3_READ_FLAG data too large\n");
}
#else
#define set_SURFACE3_INFO_surf3_pitchsel(reg, surf3_pitchsel) (reg)->bitfields.SURF3_PITCHSEL = surf3_pitchsel
#define set_SURFACE3_INFO_surf3_tile_mode(reg, surf3_tile_mode) (reg)->bitfields.SURF3_TILE_MODE = surf3_tile_mode
#define set_SURFACE3_INFO_surf3_ap0_swp(reg, surf3_ap0_swp) (reg)->bitfields.SURF3_AP0_SWP = surf3_ap0_swp
#define set_SURFACE3_INFO_surf3_ap1_swp(reg, surf3_ap1_swp) (reg)->bitfields.SURF3_AP1_SWP = surf3_ap1_swp
#define set_SURFACE3_INFO_surf3_write_flag(reg, surf3_write_flag) (reg)->bitfields.SURF3_WRITE_FLAG = surf3_write_flag
#define set_SURFACE3_INFO_surf3_read_flag(reg, surf3_read_flag) (reg)->bitfields.SURF3_READ_FLAG = surf3_read_flag

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE4_INFO regSURFACE4_INFO;

#ifdef DEBUG
__inline void set_SURFACE4_INFO_surf4_pitchsel(regSURFACE4_INFO *reg, unsigned int surf4_pitchsel)
{
  reg->bitfields.SURF4_PITCHSEL = surf4_pitchsel;
  if (reg->bitfields.SURF4_PITCHSEL != surf4_pitchsel) HSLDPF(E_ERROR_MESSAGE,"SURFACE4_INFO::SURF4_PITCHSEL data too large\n");
}
__inline void set_SURFACE4_INFO_surf4_tile_mode(regSURFACE4_INFO *reg, unsigned int surf4_tile_mode)
{
  reg->bitfields.SURF4_TILE_MODE = surf4_tile_mode;
  if (reg->bitfields.SURF4_TILE_MODE != surf4_tile_mode) HSLDPF(E_ERROR_MESSAGE,"SURFACE4_INFO::SURF4_TILE_MODE data too large\n");
}
__inline void set_SURFACE4_INFO_surf4_ap0_swp(regSURFACE4_INFO *reg, unsigned int surf4_ap0_swp)
{
  reg->bitfields.SURF4_AP0_SWP = surf4_ap0_swp;
  if (reg->bitfields.SURF4_AP0_SWP != surf4_ap0_swp) HSLDPF(E_ERROR_MESSAGE,"SURFACE4_INFO::SURF4_AP0_SWP data too large\n");
}
__inline void set_SURFACE4_INFO_surf4_ap1_swp(regSURFACE4_INFO *reg, unsigned int surf4_ap1_swp)
{
  reg->bitfields.SURF4_AP1_SWP = surf4_ap1_swp;
  if (reg->bitfields.SURF4_AP1_SWP != surf4_ap1_swp) HSLDPF(E_ERROR_MESSAGE,"SURFACE4_INFO::SURF4_AP1_SWP data too large\n");
}
__inline void set_SURFACE4_INFO_surf4_write_flag(regSURFACE4_INFO *reg, unsigned int surf4_write_flag)
{
  reg->bitfields.SURF4_WRITE_FLAG = surf4_write_flag;
  if (reg->bitfields.SURF4_WRITE_FLAG != surf4_write_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE4_INFO::SURF4_WRITE_FLAG data too large\n");
}
__inline void set_SURFACE4_INFO_surf4_read_flag(regSURFACE4_INFO *reg, unsigned int surf4_read_flag)
{
  reg->bitfields.SURF4_READ_FLAG = surf4_read_flag;
  if (reg->bitfields.SURF4_READ_FLAG != surf4_read_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE4_INFO::SURF4_READ_FLAG data too large\n");
}
#else
#define set_SURFACE4_INFO_surf4_pitchsel(reg, surf4_pitchsel) (reg)->bitfields.SURF4_PITCHSEL = surf4_pitchsel
#define set_SURFACE4_INFO_surf4_tile_mode(reg, surf4_tile_mode) (reg)->bitfields.SURF4_TILE_MODE = surf4_tile_mode
#define set_SURFACE4_INFO_surf4_ap0_swp(reg, surf4_ap0_swp) (reg)->bitfields.SURF4_AP0_SWP = surf4_ap0_swp
#define set_SURFACE4_INFO_surf4_ap1_swp(reg, surf4_ap1_swp) (reg)->bitfields.SURF4_AP1_SWP = surf4_ap1_swp
#define set_SURFACE4_INFO_surf4_write_flag(reg, surf4_write_flag) (reg)->bitfields.SURF4_WRITE_FLAG = surf4_write_flag
#define set_SURFACE4_INFO_surf4_read_flag(reg, surf4_read_flag) (reg)->bitfields.SURF4_READ_FLAG = surf4_read_flag

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE5_INFO regSURFACE5_INFO;

#ifdef DEBUG
__inline void set_SURFACE5_INFO_surf5_pitchsel(regSURFACE5_INFO *reg, unsigned int surf5_pitchsel)
{
  reg->bitfields.SURF5_PITCHSEL = surf5_pitchsel;
  if (reg->bitfields.SURF5_PITCHSEL != surf5_pitchsel) HSLDPF(E_ERROR_MESSAGE,"SURFACE5_INFO::SURF5_PITCHSEL data too large\n");
}
__inline void set_SURFACE5_INFO_surf5_tile_mode(regSURFACE5_INFO *reg, unsigned int surf5_tile_mode)
{
  reg->bitfields.SURF5_TILE_MODE = surf5_tile_mode;
  if (reg->bitfields.SURF5_TILE_MODE != surf5_tile_mode) HSLDPF(E_ERROR_MESSAGE,"SURFACE5_INFO::SURF5_TILE_MODE data too large\n");
}
__inline void set_SURFACE5_INFO_surf5_ap0_swp(regSURFACE5_INFO *reg, unsigned int surf5_ap0_swp)
{
  reg->bitfields.SURF5_AP0_SWP = surf5_ap0_swp;
  if (reg->bitfields.SURF5_AP0_SWP != surf5_ap0_swp) HSLDPF(E_ERROR_MESSAGE,"SURFACE5_INFO::SURF5_AP0_SWP data too large\n");
}
__inline void set_SURFACE5_INFO_surf5_ap1_swp(regSURFACE5_INFO *reg, unsigned int surf5_ap1_swp)
{
  reg->bitfields.SURF5_AP1_SWP = surf5_ap1_swp;
  if (reg->bitfields.SURF5_AP1_SWP != surf5_ap1_swp) HSLDPF(E_ERROR_MESSAGE,"SURFACE5_INFO::SURF5_AP1_SWP data too large\n");
}
__inline void set_SURFACE5_INFO_surf5_write_flag(regSURFACE5_INFO *reg, unsigned int surf5_write_flag)
{
  reg->bitfields.SURF5_WRITE_FLAG = surf5_write_flag;
  if (reg->bitfields.SURF5_WRITE_FLAG != surf5_write_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE5_INFO::SURF5_WRITE_FLAG data too large\n");
}
__inline void set_SURFACE5_INFO_surf5_read_flag(regSURFACE5_INFO *reg, unsigned int surf5_read_flag)
{
  reg->bitfields.SURF5_READ_FLAG = surf5_read_flag;
  if (reg->bitfields.SURF5_READ_FLAG != surf5_read_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE5_INFO::SURF5_READ_FLAG data too large\n");
}
#else
#define set_SURFACE5_INFO_surf5_pitchsel(reg, surf5_pitchsel) (reg)->bitfields.SURF5_PITCHSEL = surf5_pitchsel
#define set_SURFACE5_INFO_surf5_tile_mode(reg, surf5_tile_mode) (reg)->bitfields.SURF5_TILE_MODE = surf5_tile_mode
#define set_SURFACE5_INFO_surf5_ap0_swp(reg, surf5_ap0_swp) (reg)->bitfields.SURF5_AP0_SWP = surf5_ap0_swp
#define set_SURFACE5_INFO_surf5_ap1_swp(reg, surf5_ap1_swp) (reg)->bitfields.SURF5_AP1_SWP = surf5_ap1_swp
#define set_SURFACE5_INFO_surf5_write_flag(reg, surf5_write_flag) (reg)->bitfields.SURF5_WRITE_FLAG = surf5_write_flag
#define set_SURFACE5_INFO_surf5_read_flag(reg, surf5_read_flag) (reg)->bitfields.SURF5_READ_FLAG = surf5_read_flag

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE6_INFO regSURFACE6_INFO;

#ifdef DEBUG
__inline void set_SURFACE6_INFO_surf6_pitchsel(regSURFACE6_INFO *reg, unsigned int surf6_pitchsel)
{
  reg->bitfields.SURF6_PITCHSEL = surf6_pitchsel;
  if (reg->bitfields.SURF6_PITCHSEL != surf6_pitchsel) HSLDPF(E_ERROR_MESSAGE,"SURFACE6_INFO::SURF6_PITCHSEL data too large\n");
}
__inline void set_SURFACE6_INFO_surf6_tile_mode(regSURFACE6_INFO *reg, unsigned int surf6_tile_mode)
{
  reg->bitfields.SURF6_TILE_MODE = surf6_tile_mode;
  if (reg->bitfields.SURF6_TILE_MODE != surf6_tile_mode) HSLDPF(E_ERROR_MESSAGE,"SURFACE6_INFO::SURF6_TILE_MODE data too large\n");
}
__inline void set_SURFACE6_INFO_surf6_ap0_swp(regSURFACE6_INFO *reg, unsigned int surf6_ap0_swp)
{
  reg->bitfields.SURF6_AP0_SWP = surf6_ap0_swp;
  if (reg->bitfields.SURF6_AP0_SWP != surf6_ap0_swp) HSLDPF(E_ERROR_MESSAGE,"SURFACE6_INFO::SURF6_AP0_SWP data too large\n");
}
__inline void set_SURFACE6_INFO_surf6_ap1_swp(regSURFACE6_INFO *reg, unsigned int surf6_ap1_swp)
{
  reg->bitfields.SURF6_AP1_SWP = surf6_ap1_swp;
  if (reg->bitfields.SURF6_AP1_SWP != surf6_ap1_swp) HSLDPF(E_ERROR_MESSAGE,"SURFACE6_INFO::SURF6_AP1_SWP data too large\n");
}
__inline void set_SURFACE6_INFO_surf6_write_flag(regSURFACE6_INFO *reg, unsigned int surf6_write_flag)
{
  reg->bitfields.SURF6_WRITE_FLAG = surf6_write_flag;
  if (reg->bitfields.SURF6_WRITE_FLAG != surf6_write_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE6_INFO::SURF6_WRITE_FLAG data too large\n");
}
__inline void set_SURFACE6_INFO_surf6_read_flag(regSURFACE6_INFO *reg, unsigned int surf6_read_flag)
{
  reg->bitfields.SURF6_READ_FLAG = surf6_read_flag;
  if (reg->bitfields.SURF6_READ_FLAG != surf6_read_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE6_INFO::SURF6_READ_FLAG data too large\n");
}
#else
#define set_SURFACE6_INFO_surf6_pitchsel(reg, surf6_pitchsel) (reg)->bitfields.SURF6_PITCHSEL = surf6_pitchsel
#define set_SURFACE6_INFO_surf6_tile_mode(reg, surf6_tile_mode) (reg)->bitfields.SURF6_TILE_MODE = surf6_tile_mode
#define set_SURFACE6_INFO_surf6_ap0_swp(reg, surf6_ap0_swp) (reg)->bitfields.SURF6_AP0_SWP = surf6_ap0_swp
#define set_SURFACE6_INFO_surf6_ap1_swp(reg, surf6_ap1_swp) (reg)->bitfields.SURF6_AP1_SWP = surf6_ap1_swp
#define set_SURFACE6_INFO_surf6_write_flag(reg, surf6_write_flag) (reg)->bitfields.SURF6_WRITE_FLAG = surf6_write_flag
#define set_SURFACE6_INFO_surf6_read_flag(reg, surf6_read_flag) (reg)->bitfields.SURF6_READ_FLAG = surf6_read_flag

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE7_INFO regSURFACE7_INFO;

#ifdef DEBUG
__inline void set_SURFACE7_INFO_surf7_pitchsel(regSURFACE7_INFO *reg, unsigned int surf7_pitchsel)
{
  reg->bitfields.SURF7_PITCHSEL = surf7_pitchsel;
  if (reg->bitfields.SURF7_PITCHSEL != surf7_pitchsel) HSLDPF(E_ERROR_MESSAGE,"SURFACE7_INFO::SURF7_PITCHSEL data too large\n");
}
__inline void set_SURFACE7_INFO_surf7_tile_mode(regSURFACE7_INFO *reg, unsigned int surf7_tile_mode)
{
  reg->bitfields.SURF7_TILE_MODE = surf7_tile_mode;
  if (reg->bitfields.SURF7_TILE_MODE != surf7_tile_mode) HSLDPF(E_ERROR_MESSAGE,"SURFACE7_INFO::SURF7_TILE_MODE data too large\n");
}
__inline void set_SURFACE7_INFO_surf7_ap0_swp(regSURFACE7_INFO *reg, unsigned int surf7_ap0_swp)
{
  reg->bitfields.SURF7_AP0_SWP = surf7_ap0_swp;
  if (reg->bitfields.SURF7_AP0_SWP != surf7_ap0_swp) HSLDPF(E_ERROR_MESSAGE,"SURFACE7_INFO::SURF7_AP0_SWP data too large\n");
}
__inline void set_SURFACE7_INFO_surf7_ap1_swp(regSURFACE7_INFO *reg, unsigned int surf7_ap1_swp)
{
  reg->bitfields.SURF7_AP1_SWP = surf7_ap1_swp;
  if (reg->bitfields.SURF7_AP1_SWP != surf7_ap1_swp) HSLDPF(E_ERROR_MESSAGE,"SURFACE7_INFO::SURF7_AP1_SWP data too large\n");
}
__inline void set_SURFACE7_INFO_surf7_write_flag(regSURFACE7_INFO *reg, unsigned int surf7_write_flag)
{
  reg->bitfields.SURF7_WRITE_FLAG = surf7_write_flag;
  if (reg->bitfields.SURF7_WRITE_FLAG != surf7_write_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE7_INFO::SURF7_WRITE_FLAG data too large\n");
}
__inline void set_SURFACE7_INFO_surf7_read_flag(regSURFACE7_INFO *reg, unsigned int surf7_read_flag)
{
  reg->bitfields.SURF7_READ_FLAG = surf7_read_flag;
  if (reg->bitfields.SURF7_READ_FLAG != surf7_read_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE7_INFO::SURF7_READ_FLAG data too large\n");
}
#else
#define set_SURFACE7_INFO_surf7_pitchsel(reg, surf7_pitchsel) (reg)->bitfields.SURF7_PITCHSEL = surf7_pitchsel
#define set_SURFACE7_INFO_surf7_tile_mode(reg, surf7_tile_mode) (reg)->bitfields.SURF7_TILE_MODE = surf7_tile_mode
#define set_SURFACE7_INFO_surf7_ap0_swp(reg, surf7_ap0_swp) (reg)->bitfields.SURF7_AP0_SWP = surf7_ap0_swp
#define set_SURFACE7_INFO_surf7_ap1_swp(reg, surf7_ap1_swp) (reg)->bitfields.SURF7_AP1_SWP = surf7_ap1_swp
#define set_SURFACE7_INFO_surf7_write_flag(reg, surf7_write_flag) (reg)->bitfields.SURF7_WRITE_FLAG = surf7_write_flag
#define set_SURFACE7_INFO_surf7_read_flag(reg, surf7_read_flag) (reg)->bitfields.SURF7_READ_FLAG = surf7_read_flag

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE_ACCESS_FLAGS regSURFACE_ACCESS_FLAGS;

#ifdef DEBUG
__inline void set_SURFACE_ACCESS_FLAGS_surf0_write_flag(regSURFACE_ACCESS_FLAGS *reg, unsigned int surf0_write_flag)
{
  reg->bitfields.SURF0_WRITE_FLAG = surf0_write_flag;
  if (reg->bitfields.SURF0_WRITE_FLAG != surf0_write_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_FLAGS::SURF0_WRITE_FLAG data too large\n");
}
__inline void set_SURFACE_ACCESS_FLAGS_surf1_write_flag(regSURFACE_ACCESS_FLAGS *reg, unsigned int surf1_write_flag)
{
  reg->bitfields.SURF1_WRITE_FLAG = surf1_write_flag;
  if (reg->bitfields.SURF1_WRITE_FLAG != surf1_write_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_FLAGS::SURF1_WRITE_FLAG data too large\n");
}
__inline void set_SURFACE_ACCESS_FLAGS_surf2_write_flag(regSURFACE_ACCESS_FLAGS *reg, unsigned int surf2_write_flag)
{
  reg->bitfields.SURF2_WRITE_FLAG = surf2_write_flag;
  if (reg->bitfields.SURF2_WRITE_FLAG != surf2_write_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_FLAGS::SURF2_WRITE_FLAG data too large\n");
}
__inline void set_SURFACE_ACCESS_FLAGS_surf3_write_flag(regSURFACE_ACCESS_FLAGS *reg, unsigned int surf3_write_flag)
{
  reg->bitfields.SURF3_WRITE_FLAG = surf3_write_flag;
  if (reg->bitfields.SURF3_WRITE_FLAG != surf3_write_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_FLAGS::SURF3_WRITE_FLAG data too large\n");
}
__inline void set_SURFACE_ACCESS_FLAGS_surf4_write_flag(regSURFACE_ACCESS_FLAGS *reg, unsigned int surf4_write_flag)
{
  reg->bitfields.SURF4_WRITE_FLAG = surf4_write_flag;
  if (reg->bitfields.SURF4_WRITE_FLAG != surf4_write_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_FLAGS::SURF4_WRITE_FLAG data too large\n");
}
__inline void set_SURFACE_ACCESS_FLAGS_surf5_write_flag(regSURFACE_ACCESS_FLAGS *reg, unsigned int surf5_write_flag)
{
  reg->bitfields.SURF5_WRITE_FLAG = surf5_write_flag;
  if (reg->bitfields.SURF5_WRITE_FLAG != surf5_write_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_FLAGS::SURF5_WRITE_FLAG data too large\n");
}
__inline void set_SURFACE_ACCESS_FLAGS_surf6_write_flag(regSURFACE_ACCESS_FLAGS *reg, unsigned int surf6_write_flag)
{
  reg->bitfields.SURF6_WRITE_FLAG = surf6_write_flag;
  if (reg->bitfields.SURF6_WRITE_FLAG != surf6_write_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_FLAGS::SURF6_WRITE_FLAG data too large\n");
}
__inline void set_SURFACE_ACCESS_FLAGS_surf7_write_flag(regSURFACE_ACCESS_FLAGS *reg, unsigned int surf7_write_flag)
{
  reg->bitfields.SURF7_WRITE_FLAG = surf7_write_flag;
  if (reg->bitfields.SURF7_WRITE_FLAG != surf7_write_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_FLAGS::SURF7_WRITE_FLAG data too large\n");
}
__inline void set_SURFACE_ACCESS_FLAGS_nonsurf_write_flag(regSURFACE_ACCESS_FLAGS *reg, unsigned int nonsurf_write_flag)
{
  reg->bitfields.NONSURF_WRITE_FLAG = nonsurf_write_flag;
  if (reg->bitfields.NONSURF_WRITE_FLAG != nonsurf_write_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_FLAGS::NONSURF_WRITE_FLAG data too large\n");
}
__inline void set_SURFACE_ACCESS_FLAGS_linear_write_flag(regSURFACE_ACCESS_FLAGS *reg, unsigned int linear_write_flag)
{
  reg->bitfields.LINEAR_WRITE_FLAG = linear_write_flag;
  if (reg->bitfields.LINEAR_WRITE_FLAG != linear_write_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_FLAGS::LINEAR_WRITE_FLAG data too large\n");
}
__inline void set_SURFACE_ACCESS_FLAGS_vga_write_flag(regSURFACE_ACCESS_FLAGS *reg, unsigned int vga_write_flag)
{
  reg->bitfields.VGA_WRITE_FLAG = vga_write_flag;
  if (reg->bitfields.VGA_WRITE_FLAG != vga_write_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_FLAGS::VGA_WRITE_FLAG data too large\n");
}
__inline void set_SURFACE_ACCESS_FLAGS_surf0_read_flag(regSURFACE_ACCESS_FLAGS *reg, unsigned int surf0_read_flag)
{
  reg->bitfields.SURF0_READ_FLAG = surf0_read_flag;
  if (reg->bitfields.SURF0_READ_FLAG != surf0_read_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_FLAGS::SURF0_READ_FLAG data too large\n");
}
__inline void set_SURFACE_ACCESS_FLAGS_surf1_read_flag(regSURFACE_ACCESS_FLAGS *reg, unsigned int surf1_read_flag)
{
  reg->bitfields.SURF1_READ_FLAG = surf1_read_flag;
  if (reg->bitfields.SURF1_READ_FLAG != surf1_read_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_FLAGS::SURF1_READ_FLAG data too large\n");
}
__inline void set_SURFACE_ACCESS_FLAGS_surf2_read_flag(regSURFACE_ACCESS_FLAGS *reg, unsigned int surf2_read_flag)
{
  reg->bitfields.SURF2_READ_FLAG = surf2_read_flag;
  if (reg->bitfields.SURF2_READ_FLAG != surf2_read_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_FLAGS::SURF2_READ_FLAG data too large\n");
}
__inline void set_SURFACE_ACCESS_FLAGS_surf3_read_flag(regSURFACE_ACCESS_FLAGS *reg, unsigned int surf3_read_flag)
{
  reg->bitfields.SURF3_READ_FLAG = surf3_read_flag;
  if (reg->bitfields.SURF3_READ_FLAG != surf3_read_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_FLAGS::SURF3_READ_FLAG data too large\n");
}
__inline void set_SURFACE_ACCESS_FLAGS_surf4_read_flag(regSURFACE_ACCESS_FLAGS *reg, unsigned int surf4_read_flag)
{
  reg->bitfields.SURF4_READ_FLAG = surf4_read_flag;
  if (reg->bitfields.SURF4_READ_FLAG != surf4_read_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_FLAGS::SURF4_READ_FLAG data too large\n");
}
__inline void set_SURFACE_ACCESS_FLAGS_surf5_read_flag(regSURFACE_ACCESS_FLAGS *reg, unsigned int surf5_read_flag)
{
  reg->bitfields.SURF5_READ_FLAG = surf5_read_flag;
  if (reg->bitfields.SURF5_READ_FLAG != surf5_read_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_FLAGS::SURF5_READ_FLAG data too large\n");
}
__inline void set_SURFACE_ACCESS_FLAGS_surf6_read_flag(regSURFACE_ACCESS_FLAGS *reg, unsigned int surf6_read_flag)
{
  reg->bitfields.SURF6_READ_FLAG = surf6_read_flag;
  if (reg->bitfields.SURF6_READ_FLAG != surf6_read_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_FLAGS::SURF6_READ_FLAG data too large\n");
}
__inline void set_SURFACE_ACCESS_FLAGS_surf7_read_flag(regSURFACE_ACCESS_FLAGS *reg, unsigned int surf7_read_flag)
{
  reg->bitfields.SURF7_READ_FLAG = surf7_read_flag;
  if (reg->bitfields.SURF7_READ_FLAG != surf7_read_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_FLAGS::SURF7_READ_FLAG data too large\n");
}
__inline void set_SURFACE_ACCESS_FLAGS_nonsurf_read_flag(regSURFACE_ACCESS_FLAGS *reg, unsigned int nonsurf_read_flag)
{
  reg->bitfields.NONSURF_READ_FLAG = nonsurf_read_flag;
  if (reg->bitfields.NONSURF_READ_FLAG != nonsurf_read_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_FLAGS::NONSURF_READ_FLAG data too large\n");
}
__inline void set_SURFACE_ACCESS_FLAGS_linear_read_flag(regSURFACE_ACCESS_FLAGS *reg, unsigned int linear_read_flag)
{
  reg->bitfields.LINEAR_READ_FLAG = linear_read_flag;
  if (reg->bitfields.LINEAR_READ_FLAG != linear_read_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_FLAGS::LINEAR_READ_FLAG data too large\n");
}
__inline void set_SURFACE_ACCESS_FLAGS_vga_read_flag(regSURFACE_ACCESS_FLAGS *reg, unsigned int vga_read_flag)
{
  reg->bitfields.VGA_READ_FLAG = vga_read_flag;
  if (reg->bitfields.VGA_READ_FLAG != vga_read_flag) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_FLAGS::VGA_READ_FLAG data too large\n");
}
#else
#define set_SURFACE_ACCESS_FLAGS_surf0_write_flag(reg, surf0_write_flag) (reg)->bitfields.SURF0_WRITE_FLAG = surf0_write_flag
#define set_SURFACE_ACCESS_FLAGS_surf1_write_flag(reg, surf1_write_flag) (reg)->bitfields.SURF1_WRITE_FLAG = surf1_write_flag
#define set_SURFACE_ACCESS_FLAGS_surf2_write_flag(reg, surf2_write_flag) (reg)->bitfields.SURF2_WRITE_FLAG = surf2_write_flag
#define set_SURFACE_ACCESS_FLAGS_surf3_write_flag(reg, surf3_write_flag) (reg)->bitfields.SURF3_WRITE_FLAG = surf3_write_flag
#define set_SURFACE_ACCESS_FLAGS_surf4_write_flag(reg, surf4_write_flag) (reg)->bitfields.SURF4_WRITE_FLAG = surf4_write_flag
#define set_SURFACE_ACCESS_FLAGS_surf5_write_flag(reg, surf5_write_flag) (reg)->bitfields.SURF5_WRITE_FLAG = surf5_write_flag
#define set_SURFACE_ACCESS_FLAGS_surf6_write_flag(reg, surf6_write_flag) (reg)->bitfields.SURF6_WRITE_FLAG = surf6_write_flag
#define set_SURFACE_ACCESS_FLAGS_surf7_write_flag(reg, surf7_write_flag) (reg)->bitfields.SURF7_WRITE_FLAG = surf7_write_flag
#define set_SURFACE_ACCESS_FLAGS_nonsurf_write_flag(reg, nonsurf_write_flag) (reg)->bitfields.NONSURF_WRITE_FLAG = nonsurf_write_flag
#define set_SURFACE_ACCESS_FLAGS_linear_write_flag(reg, linear_write_flag) (reg)->bitfields.LINEAR_WRITE_FLAG = linear_write_flag
#define set_SURFACE_ACCESS_FLAGS_vga_write_flag(reg, vga_write_flag) (reg)->bitfields.VGA_WRITE_FLAG = vga_write_flag
#define set_SURFACE_ACCESS_FLAGS_surf0_read_flag(reg, surf0_read_flag) (reg)->bitfields.SURF0_READ_FLAG = surf0_read_flag
#define set_SURFACE_ACCESS_FLAGS_surf1_read_flag(reg, surf1_read_flag) (reg)->bitfields.SURF1_READ_FLAG = surf1_read_flag
#define set_SURFACE_ACCESS_FLAGS_surf2_read_flag(reg, surf2_read_flag) (reg)->bitfields.SURF2_READ_FLAG = surf2_read_flag
#define set_SURFACE_ACCESS_FLAGS_surf3_read_flag(reg, surf3_read_flag) (reg)->bitfields.SURF3_READ_FLAG = surf3_read_flag
#define set_SURFACE_ACCESS_FLAGS_surf4_read_flag(reg, surf4_read_flag) (reg)->bitfields.SURF4_READ_FLAG = surf4_read_flag
#define set_SURFACE_ACCESS_FLAGS_surf5_read_flag(reg, surf5_read_flag) (reg)->bitfields.SURF5_READ_FLAG = surf5_read_flag
#define set_SURFACE_ACCESS_FLAGS_surf6_read_flag(reg, surf6_read_flag) (reg)->bitfields.SURF6_READ_FLAG = surf6_read_flag
#define set_SURFACE_ACCESS_FLAGS_surf7_read_flag(reg, surf7_read_flag) (reg)->bitfields.SURF7_READ_FLAG = surf7_read_flag
#define set_SURFACE_ACCESS_FLAGS_nonsurf_read_flag(reg, nonsurf_read_flag) (reg)->bitfields.NONSURF_READ_FLAG = nonsurf_read_flag
#define set_SURFACE_ACCESS_FLAGS_linear_read_flag(reg, linear_read_flag) (reg)->bitfields.LINEAR_READ_FLAG = linear_read_flag
#define set_SURFACE_ACCESS_FLAGS_vga_read_flag(reg, vga_read_flag) (reg)->bitfields.VGA_READ_FLAG = vga_read_flag

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SURFACE_ACCESS_CLR regSURFACE_ACCESS_CLR;

#ifdef DEBUG
__inline void set_SURFACE_ACCESS_CLR_surf0_write_flag_clr(regSURFACE_ACCESS_CLR *reg, unsigned int surf0_write_flag_clr)
{
  reg->bitfields.SURF0_WRITE_FLAG_CLR = surf0_write_flag_clr;
  if (reg->bitfields.SURF0_WRITE_FLAG_CLR != surf0_write_flag_clr) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_CLR::SURF0_WRITE_FLAG_CLR data too large\n");
}
__inline void set_SURFACE_ACCESS_CLR_surf1_write_flag_clr(regSURFACE_ACCESS_CLR *reg, unsigned int surf1_write_flag_clr)
{
  reg->bitfields.SURF1_WRITE_FLAG_CLR = surf1_write_flag_clr;
  if (reg->bitfields.SURF1_WRITE_FLAG_CLR != surf1_write_flag_clr) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_CLR::SURF1_WRITE_FLAG_CLR data too large\n");
}
__inline void set_SURFACE_ACCESS_CLR_surf2_write_flag_clr(regSURFACE_ACCESS_CLR *reg, unsigned int surf2_write_flag_clr)
{
  reg->bitfields.SURF2_WRITE_FLAG_CLR = surf2_write_flag_clr;
  if (reg->bitfields.SURF2_WRITE_FLAG_CLR != surf2_write_flag_clr) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_CLR::SURF2_WRITE_FLAG_CLR data too large\n");
}
__inline void set_SURFACE_ACCESS_CLR_surf3_write_flag_clr(regSURFACE_ACCESS_CLR *reg, unsigned int surf3_write_flag_clr)
{
  reg->bitfields.SURF3_WRITE_FLAG_CLR = surf3_write_flag_clr;
  if (reg->bitfields.SURF3_WRITE_FLAG_CLR != surf3_write_flag_clr) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_CLR::SURF3_WRITE_FLAG_CLR data too large\n");
}
__inline void set_SURFACE_ACCESS_CLR_surf4_write_flag_clr(regSURFACE_ACCESS_CLR *reg, unsigned int surf4_write_flag_clr)
{
  reg->bitfields.SURF4_WRITE_FLAG_CLR = surf4_write_flag_clr;
  if (reg->bitfields.SURF4_WRITE_FLAG_CLR != surf4_write_flag_clr) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_CLR::SURF4_WRITE_FLAG_CLR data too large\n");
}
__inline void set_SURFACE_ACCESS_CLR_surf5_write_flag_clr(regSURFACE_ACCESS_CLR *reg, unsigned int surf5_write_flag_clr)
{
  reg->bitfields.SURF5_WRITE_FLAG_CLR = surf5_write_flag_clr;
  if (reg->bitfields.SURF5_WRITE_FLAG_CLR != surf5_write_flag_clr) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_CLR::SURF5_WRITE_FLAG_CLR data too large\n");
}
__inline void set_SURFACE_ACCESS_CLR_surf6_write_flag_clr(regSURFACE_ACCESS_CLR *reg, unsigned int surf6_write_flag_clr)
{
  reg->bitfields.SURF6_WRITE_FLAG_CLR = surf6_write_flag_clr;
  if (reg->bitfields.SURF6_WRITE_FLAG_CLR != surf6_write_flag_clr) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_CLR::SURF6_WRITE_FLAG_CLR data too large\n");
}
__inline void set_SURFACE_ACCESS_CLR_surf7_write_flag_clr(regSURFACE_ACCESS_CLR *reg, unsigned int surf7_write_flag_clr)
{
  reg->bitfields.SURF7_WRITE_FLAG_CLR = surf7_write_flag_clr;
  if (reg->bitfields.SURF7_WRITE_FLAG_CLR != surf7_write_flag_clr) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_CLR::SURF7_WRITE_FLAG_CLR data too large\n");
}
__inline void set_SURFACE_ACCESS_CLR_nonsurf_write_flag_clr(regSURFACE_ACCESS_CLR *reg, unsigned int nonsurf_write_flag_clr)
{
  reg->bitfields.NONSURF_WRITE_FLAG_CLR = nonsurf_write_flag_clr;
  if (reg->bitfields.NONSURF_WRITE_FLAG_CLR != nonsurf_write_flag_clr) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_CLR::NONSURF_WRITE_FLAG_CLR data too large\n");
}
__inline void set_SURFACE_ACCESS_CLR_linear_write_flag_clr(regSURFACE_ACCESS_CLR *reg, unsigned int linear_write_flag_clr)
{
  reg->bitfields.LINEAR_WRITE_FLAG_CLR = linear_write_flag_clr;
  if (reg->bitfields.LINEAR_WRITE_FLAG_CLR != linear_write_flag_clr) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_CLR::LINEAR_WRITE_FLAG_CLR data too large\n");
}
__inline void set_SURFACE_ACCESS_CLR_vga_write_flag_clr(regSURFACE_ACCESS_CLR *reg, unsigned int vga_write_flag_clr)
{
  reg->bitfields.VGA_WRITE_FLAG_CLR = vga_write_flag_clr;
  if (reg->bitfields.VGA_WRITE_FLAG_CLR != vga_write_flag_clr) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_CLR::VGA_WRITE_FLAG_CLR data too large\n");
}
__inline void set_SURFACE_ACCESS_CLR_surf0_read_flag_clr(regSURFACE_ACCESS_CLR *reg, unsigned int surf0_read_flag_clr)
{
  reg->bitfields.SURF0_READ_FLAG_CLR = surf0_read_flag_clr;
  if (reg->bitfields.SURF0_READ_FLAG_CLR != surf0_read_flag_clr) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_CLR::SURF0_READ_FLAG_CLR data too large\n");
}
__inline void set_SURFACE_ACCESS_CLR_surf1_read_flag_clr(regSURFACE_ACCESS_CLR *reg, unsigned int surf1_read_flag_clr)
{
  reg->bitfields.SURF1_READ_FLAG_CLR = surf1_read_flag_clr;
  if (reg->bitfields.SURF1_READ_FLAG_CLR != surf1_read_flag_clr) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_CLR::SURF1_READ_FLAG_CLR data too large\n");
}
__inline void set_SURFACE_ACCESS_CLR_surf2_read_flag_clr(regSURFACE_ACCESS_CLR *reg, unsigned int surf2_read_flag_clr)
{
  reg->bitfields.SURF2_READ_FLAG_CLR = surf2_read_flag_clr;
  if (reg->bitfields.SURF2_READ_FLAG_CLR != surf2_read_flag_clr) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_CLR::SURF2_READ_FLAG_CLR data too large\n");
}
__inline void set_SURFACE_ACCESS_CLR_surf3_read_flag_clr(regSURFACE_ACCESS_CLR *reg, unsigned int surf3_read_flag_clr)
{
  reg->bitfields.SURF3_READ_FLAG_CLR = surf3_read_flag_clr;
  if (reg->bitfields.SURF3_READ_FLAG_CLR != surf3_read_flag_clr) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_CLR::SURF3_READ_FLAG_CLR data too large\n");
}
__inline void set_SURFACE_ACCESS_CLR_surf4_read_flag_clr(regSURFACE_ACCESS_CLR *reg, unsigned int surf4_read_flag_clr)
{
  reg->bitfields.SURF4_READ_FLAG_CLR = surf4_read_flag_clr;
  if (reg->bitfields.SURF4_READ_FLAG_CLR != surf4_read_flag_clr) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_CLR::SURF4_READ_FLAG_CLR data too large\n");
}
__inline void set_SURFACE_ACCESS_CLR_surf5_read_flag_clr(regSURFACE_ACCESS_CLR *reg, unsigned int surf5_read_flag_clr)
{
  reg->bitfields.SURF5_READ_FLAG_CLR = surf5_read_flag_clr;
  if (reg->bitfields.SURF5_READ_FLAG_CLR != surf5_read_flag_clr) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_CLR::SURF5_READ_FLAG_CLR data too large\n");
}
__inline void set_SURFACE_ACCESS_CLR_surf6_read_flag_clr(regSURFACE_ACCESS_CLR *reg, unsigned int surf6_read_flag_clr)
{
  reg->bitfields.SURF6_READ_FLAG_CLR = surf6_read_flag_clr;
  if (reg->bitfields.SURF6_READ_FLAG_CLR != surf6_read_flag_clr) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_CLR::SURF6_READ_FLAG_CLR data too large\n");
}
__inline void set_SURFACE_ACCESS_CLR_surf7_read_flag_clr(regSURFACE_ACCESS_CLR *reg, unsigned int surf7_read_flag_clr)
{
  reg->bitfields.SURF7_READ_FLAG_CLR = surf7_read_flag_clr;
  if (reg->bitfields.SURF7_READ_FLAG_CLR != surf7_read_flag_clr) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_CLR::SURF7_READ_FLAG_CLR data too large\n");
}
__inline void set_SURFACE_ACCESS_CLR_nonsurf_read_flag_clr(regSURFACE_ACCESS_CLR *reg, unsigned int nonsurf_read_flag_clr)
{
  reg->bitfields.NONSURF_READ_FLAG_CLR = nonsurf_read_flag_clr;
  if (reg->bitfields.NONSURF_READ_FLAG_CLR != nonsurf_read_flag_clr) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_CLR::NONSURF_READ_FLAG_CLR data too large\n");
}
__inline void set_SURFACE_ACCESS_CLR_linear_read_flag_clr(regSURFACE_ACCESS_CLR *reg, unsigned int linear_read_flag_clr)
{
  reg->bitfields.LINEAR_READ_FLAG_CLR = linear_read_flag_clr;
  if (reg->bitfields.LINEAR_READ_FLAG_CLR != linear_read_flag_clr) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_CLR::LINEAR_READ_FLAG_CLR data too large\n");
}
__inline void set_SURFACE_ACCESS_CLR_vga_read_flag_clr(regSURFACE_ACCESS_CLR *reg, unsigned int vga_read_flag_clr)
{
  reg->bitfields.VGA_READ_FLAG_CLR = vga_read_flag_clr;
  if (reg->bitfields.VGA_READ_FLAG_CLR != vga_read_flag_clr) HSLDPF(E_ERROR_MESSAGE,"SURFACE_ACCESS_CLR::VGA_READ_FLAG_CLR data too large\n");
}
#else
#define set_SURFACE_ACCESS_CLR_surf0_write_flag_clr(reg, surf0_write_flag_clr) (reg)->bitfields.SURF0_WRITE_FLAG_CLR = surf0_write_flag_clr
#define set_SURFACE_ACCESS_CLR_surf1_write_flag_clr(reg, surf1_write_flag_clr) (reg)->bitfields.SURF1_WRITE_FLAG_CLR = surf1_write_flag_clr
#define set_SURFACE_ACCESS_CLR_surf2_write_flag_clr(reg, surf2_write_flag_clr) (reg)->bitfields.SURF2_WRITE_FLAG_CLR = surf2_write_flag_clr
#define set_SURFACE_ACCESS_CLR_surf3_write_flag_clr(reg, surf3_write_flag_clr) (reg)->bitfields.SURF3_WRITE_FLAG_CLR = surf3_write_flag_clr
#define set_SURFACE_ACCESS_CLR_surf4_write_flag_clr(reg, surf4_write_flag_clr) (reg)->bitfields.SURF4_WRITE_FLAG_CLR = surf4_write_flag_clr
#define set_SURFACE_ACCESS_CLR_surf5_write_flag_clr(reg, surf5_write_flag_clr) (reg)->bitfields.SURF5_WRITE_FLAG_CLR = surf5_write_flag_clr
#define set_SURFACE_ACCESS_CLR_surf6_write_flag_clr(reg, surf6_write_flag_clr) (reg)->bitfields.SURF6_WRITE_FLAG_CLR = surf6_write_flag_clr
#define set_SURFACE_ACCESS_CLR_surf7_write_flag_clr(reg, surf7_write_flag_clr) (reg)->bitfields.SURF7_WRITE_FLAG_CLR = surf7_write_flag_clr
#define set_SURFACE_ACCESS_CLR_nonsurf_write_flag_clr(reg, nonsurf_write_flag_clr) (reg)->bitfields.NONSURF_WRITE_FLAG_CLR = nonsurf_write_flag_clr
#define set_SURFACE_ACCESS_CLR_linear_write_flag_clr(reg, linear_write_flag_clr) (reg)->bitfields.LINEAR_WRITE_FLAG_CLR = linear_write_flag_clr
#define set_SURFACE_ACCESS_CLR_vga_write_flag_clr(reg, vga_write_flag_clr) (reg)->bitfields.VGA_WRITE_FLAG_CLR = vga_write_flag_clr
#define set_SURFACE_ACCESS_CLR_surf0_read_flag_clr(reg, surf0_read_flag_clr) (reg)->bitfields.SURF0_READ_FLAG_CLR = surf0_read_flag_clr
#define set_SURFACE_ACCESS_CLR_surf1_read_flag_clr(reg, surf1_read_flag_clr) (reg)->bitfields.SURF1_READ_FLAG_CLR = surf1_read_flag_clr
#define set_SURFACE_ACCESS_CLR_surf2_read_flag_clr(reg, surf2_read_flag_clr) (reg)->bitfields.SURF2_READ_FLAG_CLR = surf2_read_flag_clr
#define set_SURFACE_ACCESS_CLR_surf3_read_flag_clr(reg, surf3_read_flag_clr) (reg)->bitfields.SURF3_READ_FLAG_CLR = surf3_read_flag_clr
#define set_SURFACE_ACCESS_CLR_surf4_read_flag_clr(reg, surf4_read_flag_clr) (reg)->bitfields.SURF4_READ_FLAG_CLR = surf4_read_flag_clr
#define set_SURFACE_ACCESS_CLR_surf5_read_flag_clr(reg, surf5_read_flag_clr) (reg)->bitfields.SURF5_READ_FLAG_CLR = surf5_read_flag_clr
#define set_SURFACE_ACCESS_CLR_surf6_read_flag_clr(reg, surf6_read_flag_clr) (reg)->bitfields.SURF6_READ_FLAG_CLR = surf6_read_flag_clr
#define set_SURFACE_ACCESS_CLR_surf7_read_flag_clr(reg, surf7_read_flag_clr) (reg)->bitfields.SURF7_READ_FLAG_CLR = surf7_read_flag_clr
#define set_SURFACE_ACCESS_CLR_nonsurf_read_flag_clr(reg, nonsurf_read_flag_clr) (reg)->bitfields.NONSURF_READ_FLAG_CLR = nonsurf_read_flag_clr
#define set_SURFACE_ACCESS_CLR_linear_read_flag_clr(reg, linear_read_flag_clr) (reg)->bitfields.LINEAR_READ_FLAG_CLR = linear_read_flag_clr
#define set_SURFACE_ACCESS_CLR_vga_read_flag_clr(reg, vga_read_flag_clr) (reg)->bitfields.VGA_READ_FLAG_CLR = vga_read_flag_clr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GRPH8_IDX regGRPH8_IDX;

#ifdef DEBUG
__inline void set_GRPH8_IDX_grph_idx(regGRPH8_IDX *reg, unsigned int grph_idx)
{
  reg->bitfields.GRPH_IDX = grph_idx;
  if (reg->bitfields.GRPH_IDX != grph_idx) HSLDPF(E_ERROR_MESSAGE,"GRPH8_IDX::GRPH_IDX data too large\n");
}
#else
#define set_GRPH8_IDX_grph_idx(reg, grph_idx) (reg)->bitfields.GRPH_IDX = grph_idx

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GRPH8_DATA regGRPH8_DATA;

#ifdef DEBUG
__inline void set_GRPH8_DATA_grph_data(regGRPH8_DATA *reg, unsigned int grph_data)
{
  reg->bitfields.GRPH_DATA = grph_data;
  if (reg->bitfields.GRPH_DATA != grph_data) HSLDPF(E_ERROR_MESSAGE,"GRPH8_DATA::GRPH_DATA data too large\n");
}
#else
#define set_GRPH8_DATA_grph_data(reg, grph_data) (reg)->bitfields.GRPH_DATA = grph_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GRA05 regGRA05;

#ifdef DEBUG
__inline void set_GRA05_grph_write_mode(regGRA05 *reg, unsigned int grph_write_mode)
{
  reg->bitfields.GRPH_WRITE_MODE = grph_write_mode;
  if (reg->bitfields.GRPH_WRITE_MODE != grph_write_mode) HSLDPF(E_ERROR_MESSAGE,"GRA05::GRPH_WRITE_MODE data too large\n");
}
__inline void set_GRA05_grph_read1(regGRA05 *reg, unsigned int grph_read1)
{
  reg->bitfields.GRPH_READ1 = grph_read1;
  if (reg->bitfields.GRPH_READ1 != grph_read1) HSLDPF(E_ERROR_MESSAGE,"GRA05::GRPH_READ1 data too large\n");
}
__inline void set_GRA05_cga_oddeven(regGRA05 *reg, unsigned int cga_oddeven)
{
  reg->bitfields.CGA_ODDEVEN = cga_oddeven;
  if (reg->bitfields.CGA_ODDEVEN != cga_oddeven) HSLDPF(E_ERROR_MESSAGE,"GRA05::CGA_ODDEVEN data too large\n");
}
__inline void set_GRA05_grph_oes(regGRA05 *reg, unsigned int grph_oes)
{
  reg->bitfields.GRPH_OES = grph_oes;
  if (reg->bitfields.GRPH_OES != grph_oes) HSLDPF(E_ERROR_MESSAGE,"GRA05::GRPH_OES data too large\n");
}
__inline void set_GRA05_grph_pack(regGRA05 *reg, unsigned int grph_pack)
{
  reg->bitfields.GRPH_PACK = grph_pack;
  if (reg->bitfields.GRPH_PACK != grph_pack) HSLDPF(E_ERROR_MESSAGE,"GRA05::GRPH_PACK data too large\n");
}
#else
#define set_GRA05_grph_write_mode(reg, grph_write_mode) (reg)->bitfields.GRPH_WRITE_MODE = grph_write_mode
#define set_GRA05_grph_read1(reg, grph_read1) (reg)->bitfields.GRPH_READ1 = grph_read1
#define set_GRA05_cga_oddeven(reg, cga_oddeven) (reg)->bitfields.CGA_ODDEVEN = cga_oddeven
#define set_GRA05_grph_oes(reg, grph_oes) (reg)->bitfields.GRPH_OES = grph_oes
#define set_GRA05_grph_pack(reg, grph_pack) (reg)->bitfields.GRPH_PACK = grph_pack

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SEQ8_IDX regSEQ8_IDX;

#ifdef DEBUG
__inline void set_SEQ8_IDX_seq_idx(regSEQ8_IDX *reg, unsigned int seq_idx)
{
  reg->bitfields.SEQ_IDX = seq_idx;
  if (reg->bitfields.SEQ_IDX != seq_idx) HSLDPF(E_ERROR_MESSAGE,"SEQ8_IDX::SEQ_IDX data too large\n");
}
#else
#define set_SEQ8_IDX_seq_idx(reg, seq_idx) (reg)->bitfields.SEQ_IDX = seq_idx

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SEQ8_DATA regSEQ8_DATA;

#ifdef DEBUG
__inline void set_SEQ8_DATA_seq_data(regSEQ8_DATA *reg, unsigned int seq_data)
{
  reg->bitfields.SEQ_DATA = seq_data;
  if (reg->bitfields.SEQ_DATA != seq_data) HSLDPF(E_ERROR_MESSAGE,"SEQ8_DATA::SEQ_DATA data too large\n");
}
#else
#define set_SEQ8_DATA_seq_data(reg, seq_data) (reg)->bitfields.SEQ_DATA = seq_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC8_IDX regCRTC8_IDX;

#ifdef DEBUG
__inline void set_CRTC8_IDX_vcrtc_idx(regCRTC8_IDX *reg, unsigned int vcrtc_idx)
{
  reg->bitfields.VCRTC_IDX = vcrtc_idx;
  if (reg->bitfields.VCRTC_IDX != vcrtc_idx) HSLDPF(E_ERROR_MESSAGE,"CRTC8_IDX::VCRTC_IDX data too large\n");
}
#else
#define set_CRTC8_IDX_vcrtc_idx(reg, vcrtc_idx) (reg)->bitfields.VCRTC_IDX = vcrtc_idx

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC8_DATA regCRTC8_DATA;

#ifdef DEBUG
__inline void set_CRTC8_DATA_vcrtc_data(regCRTC8_DATA *reg, unsigned int vcrtc_data)
{
  reg->bitfields.VCRTC_DATA = vcrtc_data;
  if (reg->bitfields.VCRTC_DATA != vcrtc_data) HSLDPF(E_ERROR_MESSAGE,"CRTC8_DATA::VCRTC_DATA data too large\n");
}
#else
#define set_CRTC8_DATA_vcrtc_data(reg, vcrtc_data) (reg)->bitfields.VCRTC_DATA = vcrtc_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT14 regCRT14;

#ifdef DEBUG
__inline void set_CRT14_undrln_loc(regCRT14 *reg, unsigned int undrln_loc)
{
  reg->bitfields.UNDRLN_LOC = undrln_loc;
  if (reg->bitfields.UNDRLN_LOC != undrln_loc) HSLDPF(E_ERROR_MESSAGE,"CRT14::UNDRLN_LOC data too large\n");
}
__inline void set_CRT14_addr_cnt_by4(regCRT14 *reg, unsigned int addr_cnt_by4)
{
  reg->bitfields.ADDR_CNT_BY4 = addr_cnt_by4;
  if (reg->bitfields.ADDR_CNT_BY4 != addr_cnt_by4) HSLDPF(E_ERROR_MESSAGE,"CRT14::ADDR_CNT_BY4 data too large\n");
}
__inline void set_CRT14_double_word(regCRT14 *reg, unsigned int double_word)
{
  reg->bitfields.DOUBLE_WORD = double_word;
  if (reg->bitfields.DOUBLE_WORD != double_word) HSLDPF(E_ERROR_MESSAGE,"CRT14::DOUBLE_WORD data too large\n");
}
#else
#define set_CRT14_undrln_loc(reg, undrln_loc) (reg)->bitfields.UNDRLN_LOC = undrln_loc
#define set_CRT14_addr_cnt_by4(reg, addr_cnt_by4) (reg)->bitfields.ADDR_CNT_BY4 = addr_cnt_by4
#define set_CRT14_double_word(reg, double_word) (reg)->bitfields.DOUBLE_WORD = double_word

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT17 regCRT17;

#ifdef DEBUG
__inline void set_CRT17_ra0_as_a13b(regCRT17 *reg, unsigned int ra0_as_a13b)
{
  reg->bitfields.RA0_AS_A13B = ra0_as_a13b;
  if (reg->bitfields.RA0_AS_A13B != ra0_as_a13b) HSLDPF(E_ERROR_MESSAGE,"CRT17::RA0_AS_A13B data too large\n");
}
__inline void set_CRT17_ra1_as_a14b(regCRT17 *reg, unsigned int ra1_as_a14b)
{
  reg->bitfields.RA1_AS_A14B = ra1_as_a14b;
  if (reg->bitfields.RA1_AS_A14B != ra1_as_a14b) HSLDPF(E_ERROR_MESSAGE,"CRT17::RA1_AS_A14B data too large\n");
}
__inline void set_CRT17_vcount_by2(regCRT17 *reg, unsigned int vcount_by2)
{
  reg->bitfields.VCOUNT_BY2 = vcount_by2;
  if (reg->bitfields.VCOUNT_BY2 != vcount_by2) HSLDPF(E_ERROR_MESSAGE,"CRT17::VCOUNT_BY2 data too large\n");
}
__inline void set_CRT17_addr_cnt_by2(regCRT17 *reg, unsigned int addr_cnt_by2)
{
  reg->bitfields.ADDR_CNT_BY2 = addr_cnt_by2;
  if (reg->bitfields.ADDR_CNT_BY2 != addr_cnt_by2) HSLDPF(E_ERROR_MESSAGE,"CRT17::ADDR_CNT_BY2 data too large\n");
}
__inline void set_CRT17_wrap_a15toa0(regCRT17 *reg, unsigned int wrap_a15toa0)
{
  reg->bitfields.WRAP_A15TOA0 = wrap_a15toa0;
  if (reg->bitfields.WRAP_A15TOA0 != wrap_a15toa0) HSLDPF(E_ERROR_MESSAGE,"CRT17::WRAP_A15TOA0 data too large\n");
}
__inline void set_CRT17_byte_mode(regCRT17 *reg, unsigned int byte_mode)
{
  reg->bitfields.BYTE_MODE = byte_mode;
  if (reg->bitfields.BYTE_MODE != byte_mode) HSLDPF(E_ERROR_MESSAGE,"CRT17::BYTE_MODE data too large\n");
}
__inline void set_CRT17_crtc_sync_en(regCRT17 *reg, unsigned int crtc_sync_en)
{
  reg->bitfields.CRTC_SYNC_EN = crtc_sync_en;
  if (reg->bitfields.CRTC_SYNC_EN != crtc_sync_en) HSLDPF(E_ERROR_MESSAGE,"CRT17::CRTC_SYNC_EN data too large\n");
}
#else
#define set_CRT17_ra0_as_a13b(reg, ra0_as_a13b) (reg)->bitfields.RA0_AS_A13B = ra0_as_a13b
#define set_CRT17_ra1_as_a14b(reg, ra1_as_a14b) (reg)->bitfields.RA1_AS_A14B = ra1_as_a14b
#define set_CRT17_vcount_by2(reg, vcount_by2) (reg)->bitfields.VCOUNT_BY2 = vcount_by2
#define set_CRT17_addr_cnt_by2(reg, addr_cnt_by2) (reg)->bitfields.ADDR_CNT_BY2 = addr_cnt_by2
#define set_CRT17_wrap_a15toa0(reg, wrap_a15toa0) (reg)->bitfields.WRAP_A15TOA0 = wrap_a15toa0
#define set_CRT17_byte_mode(reg, byte_mode) (reg)->bitfields.BYTE_MODE = byte_mode
#define set_CRT17_crtc_sync_en(reg, crtc_sync_en) (reg)->bitfields.CRTC_SYNC_EN = crtc_sync_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT14_S regCRT14_S;

#ifdef DEBUG
__inline void set_CRT14_S_undrln_loc_s(regCRT14_S *reg, unsigned int undrln_loc_s)
{
  reg->bitfields.UNDRLN_LOC_S = undrln_loc_s;
  if (reg->bitfields.UNDRLN_LOC_S != undrln_loc_s) HSLDPF(E_ERROR_MESSAGE,"CRT14_S::UNDRLN_LOC_S data too large\n");
}
__inline void set_CRT14_S_addr_cnt_by4_m(regCRT14_S *reg, unsigned int addr_cnt_by4_m)
{
  reg->bitfields.ADDR_CNT_BY4_M = addr_cnt_by4_m;
  if (reg->bitfields.ADDR_CNT_BY4_M != addr_cnt_by4_m) HSLDPF(E_ERROR_MESSAGE,"CRT14_S::ADDR_CNT_BY4_M data too large\n");
}
__inline void set_CRT14_S_double_word_m(regCRT14_S *reg, unsigned int double_word_m)
{
  reg->bitfields.DOUBLE_WORD_M = double_word_m;
  if (reg->bitfields.DOUBLE_WORD_M != double_word_m) HSLDPF(E_ERROR_MESSAGE,"CRT14_S::DOUBLE_WORD_M data too large\n");
}
#else
#define set_CRT14_S_undrln_loc_s(reg, undrln_loc_s) (reg)->bitfields.UNDRLN_LOC_S = undrln_loc_s
#define set_CRT14_S_addr_cnt_by4_m(reg, addr_cnt_by4_m) (reg)->bitfields.ADDR_CNT_BY4_M = addr_cnt_by4_m
#define set_CRT14_S_double_word_m(reg, double_word_m) (reg)->bitfields.DOUBLE_WORD_M = double_word_m

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT17_S regCRT17_S;

#ifdef DEBUG
__inline void set_CRT17_S_ra0_as_a13b_m(regCRT17_S *reg, unsigned int ra0_as_a13b_m)
{
  reg->bitfields.RA0_AS_A13B_M = ra0_as_a13b_m;
  if (reg->bitfields.RA0_AS_A13B_M != ra0_as_a13b_m) HSLDPF(E_ERROR_MESSAGE,"CRT17_S::RA0_AS_A13B_M data too large\n");
}
__inline void set_CRT17_S_ra1_as_a14b_m(regCRT17_S *reg, unsigned int ra1_as_a14b_m)
{
  reg->bitfields.RA1_AS_A14B_M = ra1_as_a14b_m;
  if (reg->bitfields.RA1_AS_A14B_M != ra1_as_a14b_m) HSLDPF(E_ERROR_MESSAGE,"CRT17_S::RA1_AS_A14B_M data too large\n");
}
__inline void set_CRT17_S_vcount_by2_s(regCRT17_S *reg, unsigned int vcount_by2_s)
{
  reg->bitfields.VCOUNT_BY2_S = vcount_by2_s;
  if (reg->bitfields.VCOUNT_BY2_S != vcount_by2_s) HSLDPF(E_ERROR_MESSAGE,"CRT17_S::VCOUNT_BY2_S data too large\n");
}
__inline void set_CRT17_S_addr_cnt_by2_m(regCRT17_S *reg, unsigned int addr_cnt_by2_m)
{
  reg->bitfields.ADDR_CNT_BY2_M = addr_cnt_by2_m;
  if (reg->bitfields.ADDR_CNT_BY2_M != addr_cnt_by2_m) HSLDPF(E_ERROR_MESSAGE,"CRT17_S::ADDR_CNT_BY2_M data too large\n");
}
__inline void set_CRT17_S_wrap_a15toa0_m(regCRT17_S *reg, unsigned int wrap_a15toa0_m)
{
  reg->bitfields.WRAP_A15TOA0_M = wrap_a15toa0_m;
  if (reg->bitfields.WRAP_A15TOA0_M != wrap_a15toa0_m) HSLDPF(E_ERROR_MESSAGE,"CRT17_S::WRAP_A15TOA0_M data too large\n");
}
__inline void set_CRT17_S_byte_mode_m(regCRT17_S *reg, unsigned int byte_mode_m)
{
  reg->bitfields.BYTE_MODE_M = byte_mode_m;
  if (reg->bitfields.BYTE_MODE_M != byte_mode_m) HSLDPF(E_ERROR_MESSAGE,"CRT17_S::BYTE_MODE_M data too large\n");
}
__inline void set_CRT17_S_crtc_sync_en_m(regCRT17_S *reg, unsigned int crtc_sync_en_m)
{
  reg->bitfields.CRTC_SYNC_EN_M = crtc_sync_en_m;
  if (reg->bitfields.CRTC_SYNC_EN_M != crtc_sync_en_m) HSLDPF(E_ERROR_MESSAGE,"CRT17_S::CRTC_SYNC_EN_M data too large\n");
}
#else
#define set_CRT17_S_ra0_as_a13b_m(reg, ra0_as_a13b_m) (reg)->bitfields.RA0_AS_A13B_M = ra0_as_a13b_m
#define set_CRT17_S_ra1_as_a14b_m(reg, ra1_as_a14b_m) (reg)->bitfields.RA1_AS_A14B_M = ra1_as_a14b_m
#define set_CRT17_S_vcount_by2_s(reg, vcount_by2_s) (reg)->bitfields.VCOUNT_BY2_S = vcount_by2_s
#define set_CRT17_S_addr_cnt_by2_m(reg, addr_cnt_by2_m) (reg)->bitfields.ADDR_CNT_BY2_M = addr_cnt_by2_m
#define set_CRT17_S_wrap_a15toa0_m(reg, wrap_a15toa0_m) (reg)->bitfields.WRAP_A15TOA0_M = wrap_a15toa0_m
#define set_CRT17_S_byte_mode_m(reg, byte_mode_m) (reg)->bitfields.BYTE_MODE_M = byte_mode_m
#define set_CRT17_S_crtc_sync_en_m(reg, crtc_sync_en_m) (reg)->bitfields.CRTC_SYNC_EN_M = crtc_sync_en_m

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250GEN_INT_CNTL regrv250GEN_INT_CNTL;

#ifdef DEBUG
__inline void set_rv250GEN_INT_CNTL_crtc_vblank_mask(regrv250GEN_INT_CNTL *reg, unsigned int crtc_vblank_mask)
{
  reg->bitfields.CRTC_VBLANK_MASK = crtc_vblank_mask;
  if (reg->bitfields.CRTC_VBLANK_MASK != crtc_vblank_mask) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::CRTC_VBLANK_MASK data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_crtc_vline_mask(regrv250GEN_INT_CNTL *reg, unsigned int crtc_vline_mask)
{
  reg->bitfields.CRTC_VLINE_MASK = crtc_vline_mask;
  if (reg->bitfields.CRTC_VLINE_MASK != crtc_vline_mask) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::CRTC_VLINE_MASK data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_crtc_vsync_mask(regrv250GEN_INT_CNTL *reg, unsigned int crtc_vsync_mask)
{
  reg->bitfields.CRTC_VSYNC_MASK = crtc_vsync_mask;
  if (reg->bitfields.CRTC_VSYNC_MASK != crtc_vsync_mask) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::CRTC_VSYNC_MASK data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_snapshot_mask(regrv250GEN_INT_CNTL *reg, unsigned int snapshot_mask)
{
  reg->bitfields.SNAPSHOT_MASK = snapshot_mask;
  if (reg->bitfields.SNAPSHOT_MASK != snapshot_mask) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::SNAPSHOT_MASK data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_fp_detect_mask(regrv250GEN_INT_CNTL *reg, unsigned int fp_detect_mask)
{
  reg->bitfields.FP_DETECT_MASK = fp_detect_mask;
  if (reg->bitfields.FP_DETECT_MASK != fp_detect_mask) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::FP_DETECT_MASK data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_crtc2_vline_mask(regrv250GEN_INT_CNTL *reg, unsigned int crtc2_vline_mask)
{
  reg->bitfields.CRTC2_VLINE_MASK = crtc2_vline_mask;
  if (reg->bitfields.CRTC2_VLINE_MASK != crtc2_vline_mask) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::CRTC2_VLINE_MASK data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_crtc2_vsync_mask(regrv250GEN_INT_CNTL *reg, unsigned int crtc2_vsync_mask)
{
  reg->bitfields.CRTC2_VSYNC_MASK = crtc2_vsync_mask;
  if (reg->bitfields.CRTC2_VSYNC_MASK != crtc2_vsync_mask) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::CRTC2_VSYNC_MASK data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_snapshot2_mask(regrv250GEN_INT_CNTL *reg, unsigned int snapshot2_mask)
{
  reg->bitfields.SNAPSHOT2_MASK = snapshot2_mask;
  if (reg->bitfields.SNAPSHOT2_MASK != snapshot2_mask) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::SNAPSHOT2_MASK data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_crtc2_vblank_mask(regrv250GEN_INT_CNTL *reg, unsigned int crtc2_vblank_mask)
{
  reg->bitfields.CRTC2_VBLANK_MASK = crtc2_vblank_mask;
  if (reg->bitfields.CRTC2_VBLANK_MASK != crtc2_vblank_mask) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::CRTC2_VBLANK_MASK data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_fp2_detect_mask(regrv250GEN_INT_CNTL *reg, unsigned int fp2_detect_mask)
{
  reg->bitfields.FP2_DETECT_MASK = fp2_detect_mask;
  if (reg->bitfields.FP2_DETECT_MASK != fp2_detect_mask) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::FP2_DETECT_MASK data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_vsync_diff_over_limit_mask(regrv250GEN_INT_CNTL *reg, unsigned int vsync_diff_over_limit_mask)
{
  reg->bitfields.VSYNC_DIFF_OVER_LIMIT_MASK = vsync_diff_over_limit_mask;
  if (reg->bitfields.VSYNC_DIFF_OVER_LIMIT_MASK != vsync_diff_over_limit_mask) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::VSYNC_DIFF_OVER_LIMIT_MASK data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_dma_viph0_int_en(regrv250GEN_INT_CNTL *reg, unsigned int dma_viph0_int_en)
{
  reg->bitfields.DMA_VIPH0_INT_EN = dma_viph0_int_en;
  if (reg->bitfields.DMA_VIPH0_INT_EN != dma_viph0_int_en) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::DMA_VIPH0_INT_EN data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_dma_viph1_int_en(regrv250GEN_INT_CNTL *reg, unsigned int dma_viph1_int_en)
{
  reg->bitfields.DMA_VIPH1_INT_EN = dma_viph1_int_en;
  if (reg->bitfields.DMA_VIPH1_INT_EN != dma_viph1_int_en) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::DMA_VIPH1_INT_EN data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_dma_viph2_int_en(regrv250GEN_INT_CNTL *reg, unsigned int dma_viph2_int_en)
{
  reg->bitfields.DMA_VIPH2_INT_EN = dma_viph2_int_en;
  if (reg->bitfields.DMA_VIPH2_INT_EN != dma_viph2_int_en) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::DMA_VIPH2_INT_EN data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_dma_viph3_int_en(regrv250GEN_INT_CNTL *reg, unsigned int dma_viph3_int_en)
{
  reg->bitfields.DMA_VIPH3_INT_EN = dma_viph3_int_en;
  if (reg->bitfields.DMA_VIPH3_INT_EN != dma_viph3_int_en) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::DMA_VIPH3_INT_EN data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_i2c_int_en(regrv250GEN_INT_CNTL *reg, unsigned int i2c_int_en)
{
  reg->bitfields.I2C_INT_EN = i2c_int_en;
  if (reg->bitfields.I2C_INT_EN != i2c_int_en) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::I2C_INT_EN data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_gui_idle_mask(regrv250GEN_INT_CNTL *reg, unsigned int gui_idle_mask)
{
  reg->bitfields.GUI_IDLE_MASK = gui_idle_mask;
  if (reg->bitfields.GUI_IDLE_MASK != gui_idle_mask) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::GUI_IDLE_MASK data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_viph_int_en(regrv250GEN_INT_CNTL *reg, unsigned int viph_int_en)
{
  reg->bitfields.VIPH_INT_EN = viph_int_en;
  if (reg->bitfields.VIPH_INT_EN != viph_int_en) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::VIPH_INT_EN data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_sw_int_en(regrv250GEN_INT_CNTL *reg, unsigned int sw_int_en)
{
  reg->bitfields.SW_INT_EN = sw_int_en;
  if (reg->bitfields.SW_INT_EN != sw_int_en) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::SW_INT_EN data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_geyserville_mask(regrv250GEN_INT_CNTL *reg, unsigned int geyserville_mask)
{
  reg->bitfields.GEYSERVILLE_MASK = geyserville_mask;
  if (reg->bitfields.GEYSERVILLE_MASK != geyserville_mask) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::GEYSERVILLE_MASK data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_hdcp_authorized_int_mask(regrv250GEN_INT_CNTL *reg, unsigned int hdcp_authorized_int_mask)
{
  reg->bitfields.HDCP_AUTHORIZED_INT_MASK = hdcp_authorized_int_mask;
  if (reg->bitfields.HDCP_AUTHORIZED_INT_MASK != hdcp_authorized_int_mask) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::HDCP_AUTHORIZED_INT_MASK data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_dvi_i2c_int_mask(regrv250GEN_INT_CNTL *reg, unsigned int dvi_i2c_int_mask)
{
  reg->bitfields.DVI_I2C_INT_MASK = dvi_i2c_int_mask;
  if (reg->bitfields.DVI_I2C_INT_MASK != dvi_i2c_int_mask) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::DVI_I2C_INT_MASK data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_guidma_mask(regrv250GEN_INT_CNTL *reg, unsigned int guidma_mask)
{
  reg->bitfields.GUIDMA_MASK = guidma_mask;
  if (reg->bitfields.GUIDMA_MASK != guidma_mask) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::GUIDMA_MASK data too large\n");
}
__inline void set_rv250GEN_INT_CNTL_viddma_mask(regrv250GEN_INT_CNTL *reg, unsigned int viddma_mask)
{
  reg->bitfields.VIDDMA_MASK = viddma_mask;
  if (reg->bitfields.VIDDMA_MASK != viddma_mask) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_CNTL::VIDDMA_MASK data too large\n");
}
#else
#define set_rv250GEN_INT_CNTL_crtc_vblank_mask(reg, crtc_vblank_mask) (reg)->bitfields.CRTC_VBLANK_MASK = crtc_vblank_mask
#define set_rv250GEN_INT_CNTL_crtc_vline_mask(reg, crtc_vline_mask) (reg)->bitfields.CRTC_VLINE_MASK = crtc_vline_mask
#define set_rv250GEN_INT_CNTL_crtc_vsync_mask(reg, crtc_vsync_mask) (reg)->bitfields.CRTC_VSYNC_MASK = crtc_vsync_mask
#define set_rv250GEN_INT_CNTL_snapshot_mask(reg, snapshot_mask) (reg)->bitfields.SNAPSHOT_MASK = snapshot_mask
#define set_rv250GEN_INT_CNTL_fp_detect_mask(reg, fp_detect_mask) (reg)->bitfields.FP_DETECT_MASK = fp_detect_mask
#define set_rv250GEN_INT_CNTL_crtc2_vline_mask(reg, crtc2_vline_mask) (reg)->bitfields.CRTC2_VLINE_MASK = crtc2_vline_mask
#define set_rv250GEN_INT_CNTL_crtc2_vsync_mask(reg, crtc2_vsync_mask) (reg)->bitfields.CRTC2_VSYNC_MASK = crtc2_vsync_mask
#define set_rv250GEN_INT_CNTL_snapshot2_mask(reg, snapshot2_mask) (reg)->bitfields.SNAPSHOT2_MASK = snapshot2_mask
#define set_rv250GEN_INT_CNTL_crtc2_vblank_mask(reg, crtc2_vblank_mask) (reg)->bitfields.CRTC2_VBLANK_MASK = crtc2_vblank_mask
#define set_rv250GEN_INT_CNTL_fp2_detect_mask(reg, fp2_detect_mask) (reg)->bitfields.FP2_DETECT_MASK = fp2_detect_mask
#define set_rv250GEN_INT_CNTL_vsync_diff_over_limit_mask(reg, vsync_diff_over_limit_mask) (reg)->bitfields.VSYNC_DIFF_OVER_LIMIT_MASK = vsync_diff_over_limit_mask
#define set_rv250GEN_INT_CNTL_dma_viph0_int_en(reg, dma_viph0_int_en) (reg)->bitfields.DMA_VIPH0_INT_EN = dma_viph0_int_en
#define set_rv250GEN_INT_CNTL_dma_viph1_int_en(reg, dma_viph1_int_en) (reg)->bitfields.DMA_VIPH1_INT_EN = dma_viph1_int_en
#define set_rv250GEN_INT_CNTL_dma_viph2_int_en(reg, dma_viph2_int_en) (reg)->bitfields.DMA_VIPH2_INT_EN = dma_viph2_int_en
#define set_rv250GEN_INT_CNTL_dma_viph3_int_en(reg, dma_viph3_int_en) (reg)->bitfields.DMA_VIPH3_INT_EN = dma_viph3_int_en
#define set_rv250GEN_INT_CNTL_i2c_int_en(reg, i2c_int_en) (reg)->bitfields.I2C_INT_EN = i2c_int_en
#define set_rv250GEN_INT_CNTL_gui_idle_mask(reg, gui_idle_mask) (reg)->bitfields.GUI_IDLE_MASK = gui_idle_mask
#define set_rv250GEN_INT_CNTL_viph_int_en(reg, viph_int_en) (reg)->bitfields.VIPH_INT_EN = viph_int_en
#define set_rv250GEN_INT_CNTL_sw_int_en(reg, sw_int_en) (reg)->bitfields.SW_INT_EN = sw_int_en
#define set_rv250GEN_INT_CNTL_geyserville_mask(reg, geyserville_mask) (reg)->bitfields.GEYSERVILLE_MASK = geyserville_mask
#define set_rv250GEN_INT_CNTL_hdcp_authorized_int_mask(reg, hdcp_authorized_int_mask) (reg)->bitfields.HDCP_AUTHORIZED_INT_MASK = hdcp_authorized_int_mask
#define set_rv250GEN_INT_CNTL_dvi_i2c_int_mask(reg, dvi_i2c_int_mask) (reg)->bitfields.DVI_I2C_INT_MASK = dvi_i2c_int_mask
#define set_rv250GEN_INT_CNTL_guidma_mask(reg, guidma_mask) (reg)->bitfields.GUIDMA_MASK = guidma_mask
#define set_rv250GEN_INT_CNTL_viddma_mask(reg, viddma_mask) (reg)->bitfields.VIDDMA_MASK = viddma_mask

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250GEN_INT_STATUS regrv250GEN_INT_STATUS;

#ifdef DEBUG
__inline void set_rv250GEN_INT_STATUS_crtc_vblank_stat(regrv250GEN_INT_STATUS *reg, unsigned int crtc_vblank_stat)
{
  reg->bitfields.CRTC_VBLANK_STAT = crtc_vblank_stat;
  if (reg->bitfields.CRTC_VBLANK_STAT != crtc_vblank_stat) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::CRTC_VBLANK_STAT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_crtc_vline_stat(regrv250GEN_INT_STATUS *reg, unsigned int crtc_vline_stat)
{
  reg->bitfields.CRTC_VLINE_STAT = crtc_vline_stat;
  if (reg->bitfields.CRTC_VLINE_STAT != crtc_vline_stat) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::CRTC_VLINE_STAT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_crtc_vsync_stat(regrv250GEN_INT_STATUS *reg, unsigned int crtc_vsync_stat)
{
  reg->bitfields.CRTC_VSYNC_STAT = crtc_vsync_stat;
  if (reg->bitfields.CRTC_VSYNC_STAT != crtc_vsync_stat) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::CRTC_VSYNC_STAT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_snapshot_stat(regrv250GEN_INT_STATUS *reg, unsigned int snapshot_stat)
{
  reg->bitfields.SNAPSHOT_STAT = snapshot_stat;
  if (reg->bitfields.SNAPSHOT_STAT != snapshot_stat) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::SNAPSHOT_STAT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_fp_detect_stat(regrv250GEN_INT_STATUS *reg, unsigned int fp_detect_stat)
{
  reg->bitfields.FP_DETECT_STAT = fp_detect_stat;
  if (reg->bitfields.FP_DETECT_STAT != fp_detect_stat) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::FP_DETECT_STAT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_crtc2_vline_stat(regrv250GEN_INT_STATUS *reg, unsigned int crtc2_vline_stat)
{
  reg->bitfields.CRTC2_VLINE_STAT = crtc2_vline_stat;
  if (reg->bitfields.CRTC2_VLINE_STAT != crtc2_vline_stat) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::CRTC2_VLINE_STAT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_crtc2_vsync_stat(regrv250GEN_INT_STATUS *reg, unsigned int crtc2_vsync_stat)
{
  reg->bitfields.CRTC2_VSYNC_STAT = crtc2_vsync_stat;
  if (reg->bitfields.CRTC2_VSYNC_STAT != crtc2_vsync_stat) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::CRTC2_VSYNC_STAT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_snapshot2_stat(regrv250GEN_INT_STATUS *reg, unsigned int snapshot2_stat)
{
  reg->bitfields.SNAPSHOT2_STAT = snapshot2_stat;
  if (reg->bitfields.SNAPSHOT2_STAT != snapshot2_stat) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::SNAPSHOT2_STAT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_cap0_int_active(regrv250GEN_INT_STATUS *reg, unsigned int cap0_int_active)
{
  reg->bitfields.CAP0_INT_ACTIVE = cap0_int_active;
  if (reg->bitfields.CAP0_INT_ACTIVE != cap0_int_active) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::CAP0_INT_ACTIVE data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_crtc2_vblank_stat(regrv250GEN_INT_STATUS *reg, unsigned int crtc2_vblank_stat)
{
  reg->bitfields.CRTC2_VBLANK_STAT = crtc2_vblank_stat;
  if (reg->bitfields.CRTC2_VBLANK_STAT != crtc2_vblank_stat) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::CRTC2_VBLANK_STAT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_fp2_detect_stat(regrv250GEN_INT_STATUS *reg, unsigned int fp2_detect_stat)
{
  reg->bitfields.FP2_DETECT_STAT = fp2_detect_stat;
  if (reg->bitfields.FP2_DETECT_STAT != fp2_detect_stat) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::FP2_DETECT_STAT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_vsync_diff_over_limit_stat(regrv250GEN_INT_STATUS *reg, unsigned int vsync_diff_over_limit_stat)
{
  reg->bitfields.VSYNC_DIFF_OVER_LIMIT_STAT = vsync_diff_over_limit_stat;
  if (reg->bitfields.VSYNC_DIFF_OVER_LIMIT_STAT != vsync_diff_over_limit_stat) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::VSYNC_DIFF_OVER_LIMIT_STAT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_dma_viph0_int(regrv250GEN_INT_STATUS *reg, unsigned int dma_viph0_int)
{
  reg->bitfields.DMA_VIPH0_INT = dma_viph0_int;
  if (reg->bitfields.DMA_VIPH0_INT != dma_viph0_int) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::DMA_VIPH0_INT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_dma_viph1_int(regrv250GEN_INT_STATUS *reg, unsigned int dma_viph1_int)
{
  reg->bitfields.DMA_VIPH1_INT = dma_viph1_int;
  if (reg->bitfields.DMA_VIPH1_INT != dma_viph1_int) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::DMA_VIPH1_INT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_dma_viph2_int(regrv250GEN_INT_STATUS *reg, unsigned int dma_viph2_int)
{
  reg->bitfields.DMA_VIPH2_INT = dma_viph2_int;
  if (reg->bitfields.DMA_VIPH2_INT != dma_viph2_int) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::DMA_VIPH2_INT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_dma_viph3_int(regrv250GEN_INT_STATUS *reg, unsigned int dma_viph3_int)
{
  reg->bitfields.DMA_VIPH3_INT = dma_viph3_int;
  if (reg->bitfields.DMA_VIPH3_INT != dma_viph3_int) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::DMA_VIPH3_INT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_i2c_int(regrv250GEN_INT_STATUS *reg, unsigned int i2c_int)
{
  reg->bitfields.I2C_INT = i2c_int;
  if (reg->bitfields.I2C_INT != i2c_int) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::I2C_INT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_gui_idle_stat(regrv250GEN_INT_STATUS *reg, unsigned int gui_idle_stat)
{
  reg->bitfields.GUI_IDLE_STAT = gui_idle_stat;
  if (reg->bitfields.GUI_IDLE_STAT != gui_idle_stat) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::GUI_IDLE_STAT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_viph_int(regrv250GEN_INT_STATUS *reg, unsigned int viph_int)
{
  reg->bitfields.VIPH_INT = viph_int;
  if (reg->bitfields.VIPH_INT != viph_int) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::VIPH_INT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_sw_int(regrv250GEN_INT_STATUS *reg, unsigned int sw_int)
{
  reg->bitfields.SW_INT = sw_int;
  if (reg->bitfields.SW_INT != sw_int) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::SW_INT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_sw_int_set(regrv250GEN_INT_STATUS *reg, unsigned int sw_int_set)
{
  reg->bitfields.SW_INT_SET = sw_int_set;
  if (reg->bitfields.SW_INT_SET != sw_int_set) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::SW_INT_SET data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_geyserville_stat(regrv250GEN_INT_STATUS *reg, unsigned int geyserville_stat)
{
  reg->bitfields.GEYSERVILLE_STAT = geyserville_stat;
  if (reg->bitfields.GEYSERVILLE_STAT != geyserville_stat) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::GEYSERVILLE_STAT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_hdcp_authorized_int_stat(regrv250GEN_INT_STATUS *reg, unsigned int hdcp_authorized_int_stat)
{
  reg->bitfields.HDCP_AUTHORIZED_INT_STAT = hdcp_authorized_int_stat;
  if (reg->bitfields.HDCP_AUTHORIZED_INT_STAT != hdcp_authorized_int_stat) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::HDCP_AUTHORIZED_INT_STAT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_dvi_i2c_int_stat(regrv250GEN_INT_STATUS *reg, unsigned int dvi_i2c_int_stat)
{
  reg->bitfields.DVI_I2C_INT_STAT = dvi_i2c_int_stat;
  if (reg->bitfields.DVI_I2C_INT_STAT != dvi_i2c_int_stat) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::DVI_I2C_INT_STAT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_guidma_stat(regrv250GEN_INT_STATUS *reg, unsigned int guidma_stat)
{
  reg->bitfields.GUIDMA_STAT = guidma_stat;
  if (reg->bitfields.GUIDMA_STAT != guidma_stat) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::GUIDMA_STAT data too large\n");
}
__inline void set_rv250GEN_INT_STATUS_viddma_stat(regrv250GEN_INT_STATUS *reg, unsigned int viddma_stat)
{
  reg->bitfields.VIDDMA_STAT = viddma_stat;
  if (reg->bitfields.VIDDMA_STAT != viddma_stat) HSLDPF(E_ERROR_MESSAGE,"rv250GEN_INT_STATUS::VIDDMA_STAT data too large\n");
}
#else
#define set_rv250GEN_INT_STATUS_crtc_vblank_stat(reg, crtc_vblank_stat) (reg)->bitfields.CRTC_VBLANK_STAT = crtc_vblank_stat
#define set_rv250GEN_INT_STATUS_crtc_vline_stat(reg, crtc_vline_stat) (reg)->bitfields.CRTC_VLINE_STAT = crtc_vline_stat
#define set_rv250GEN_INT_STATUS_crtc_vsync_stat(reg, crtc_vsync_stat) (reg)->bitfields.CRTC_VSYNC_STAT = crtc_vsync_stat
#define set_rv250GEN_INT_STATUS_snapshot_stat(reg, snapshot_stat) (reg)->bitfields.SNAPSHOT_STAT = snapshot_stat
#define set_rv250GEN_INT_STATUS_fp_detect_stat(reg, fp_detect_stat) (reg)->bitfields.FP_DETECT_STAT = fp_detect_stat
#define set_rv250GEN_INT_STATUS_crtc2_vline_stat(reg, crtc2_vline_stat) (reg)->bitfields.CRTC2_VLINE_STAT = crtc2_vline_stat
#define set_rv250GEN_INT_STATUS_crtc2_vsync_stat(reg, crtc2_vsync_stat) (reg)->bitfields.CRTC2_VSYNC_STAT = crtc2_vsync_stat
#define set_rv250GEN_INT_STATUS_snapshot2_stat(reg, snapshot2_stat) (reg)->bitfields.SNAPSHOT2_STAT = snapshot2_stat
#define set_rv250GEN_INT_STATUS_cap0_int_active(reg, cap0_int_active) (reg)->bitfields.CAP0_INT_ACTIVE = cap0_int_active
#define set_rv250GEN_INT_STATUS_crtc2_vblank_stat(reg, crtc2_vblank_stat) (reg)->bitfields.CRTC2_VBLANK_STAT = crtc2_vblank_stat
#define set_rv250GEN_INT_STATUS_fp2_detect_stat(reg, fp2_detect_stat) (reg)->bitfields.FP2_DETECT_STAT = fp2_detect_stat
#define set_rv250GEN_INT_STATUS_vsync_diff_over_limit_stat(reg, vsync_diff_over_limit_stat) (reg)->bitfields.VSYNC_DIFF_OVER_LIMIT_STAT = vsync_diff_over_limit_stat
#define set_rv250GEN_INT_STATUS_dma_viph0_int(reg, dma_viph0_int) (reg)->bitfields.DMA_VIPH0_INT = dma_viph0_int
#define set_rv250GEN_INT_STATUS_dma_viph1_int(reg, dma_viph1_int) (reg)->bitfields.DMA_VIPH1_INT = dma_viph1_int
#define set_rv250GEN_INT_STATUS_dma_viph2_int(reg, dma_viph2_int) (reg)->bitfields.DMA_VIPH2_INT = dma_viph2_int
#define set_rv250GEN_INT_STATUS_dma_viph3_int(reg, dma_viph3_int) (reg)->bitfields.DMA_VIPH3_INT = dma_viph3_int
#define set_rv250GEN_INT_STATUS_i2c_int(reg, i2c_int) (reg)->bitfields.I2C_INT = i2c_int
#define set_rv250GEN_INT_STATUS_gui_idle_stat(reg, gui_idle_stat) (reg)->bitfields.GUI_IDLE_STAT = gui_idle_stat
#define set_rv250GEN_INT_STATUS_viph_int(reg, viph_int) (reg)->bitfields.VIPH_INT = viph_int
#define set_rv250GEN_INT_STATUS_sw_int(reg, sw_int) (reg)->bitfields.SW_INT = sw_int
#define set_rv250GEN_INT_STATUS_sw_int_set(reg, sw_int_set) (reg)->bitfields.SW_INT_SET = sw_int_set
#define set_rv250GEN_INT_STATUS_geyserville_stat(reg, geyserville_stat) (reg)->bitfields.GEYSERVILLE_STAT = geyserville_stat
#define set_rv250GEN_INT_STATUS_hdcp_authorized_int_stat(reg, hdcp_authorized_int_stat) (reg)->bitfields.HDCP_AUTHORIZED_INT_STAT = hdcp_authorized_int_stat
#define set_rv250GEN_INT_STATUS_dvi_i2c_int_stat(reg, dvi_i2c_int_stat) (reg)->bitfields.DVI_I2C_INT_STAT = dvi_i2c_int_stat
#define set_rv250GEN_INT_STATUS_guidma_stat(reg, guidma_stat) (reg)->bitfields.GUIDMA_STAT = guidma_stat
#define set_rv250GEN_INT_STATUS_viddma_stat(reg, viddma_stat) (reg)->bitfields.VIDDMA_STAT = viddma_stat

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC_EXT_CNTL regCRTC_EXT_CNTL;

#ifdef DEBUG
__inline void set_CRTC_EXT_CNTL_crtc_vga_xoverscan(regCRTC_EXT_CNTL *reg, unsigned int crtc_vga_xoverscan)
{
  reg->bitfields.CRTC_VGA_XOVERSCAN = crtc_vga_xoverscan;
  if (reg->bitfields.CRTC_VGA_XOVERSCAN != crtc_vga_xoverscan) HSLDPF(E_ERROR_MESSAGE,"CRTC_EXT_CNTL::CRTC_VGA_XOVERSCAN data too large\n");
}
__inline void set_CRTC_EXT_CNTL_vga_blink_rate(regCRTC_EXT_CNTL *reg, unsigned int vga_blink_rate)
{
  reg->bitfields.VGA_BLINK_RATE = vga_blink_rate;
  if (reg->bitfields.VGA_BLINK_RATE != vga_blink_rate) HSLDPF(E_ERROR_MESSAGE,"CRTC_EXT_CNTL::VGA_BLINK_RATE data too large\n");
}
__inline void set_CRTC_EXT_CNTL_vga_ati_linear(regCRTC_EXT_CNTL *reg, unsigned int vga_ati_linear)
{
  reg->bitfields.VGA_ATI_LINEAR = vga_ati_linear;
  if (reg->bitfields.VGA_ATI_LINEAR != vga_ati_linear) HSLDPF(E_ERROR_MESSAGE,"CRTC_EXT_CNTL::VGA_ATI_LINEAR data too large\n");
}
__inline void set_CRTC_EXT_CNTL_vga_128kap_paging(regCRTC_EXT_CNTL *reg, unsigned int vga_128kap_paging)
{
  reg->bitfields.VGA_128KAP_PAGING = vga_128kap_paging;
  if (reg->bitfields.VGA_128KAP_PAGING != vga_128kap_paging) HSLDPF(E_ERROR_MESSAGE,"CRTC_EXT_CNTL::VGA_128KAP_PAGING data too large\n");
}
__inline void set_CRTC_EXT_CNTL_vga_text_132(regCRTC_EXT_CNTL *reg, unsigned int vga_text_132)
{
  reg->bitfields.VGA_TEXT_132 = vga_text_132;
  if (reg->bitfields.VGA_TEXT_132 != vga_text_132) HSLDPF(E_ERROR_MESSAGE,"CRTC_EXT_CNTL::VGA_TEXT_132 data too large\n");
}
__inline void set_CRTC_EXT_CNTL_vga_xcrt_cnt_en(regCRTC_EXT_CNTL *reg, unsigned int vga_xcrt_cnt_en)
{
  reg->bitfields.VGA_XCRT_CNT_EN = vga_xcrt_cnt_en;
  if (reg->bitfields.VGA_XCRT_CNT_EN != vga_xcrt_cnt_en) HSLDPF(E_ERROR_MESSAGE,"CRTC_EXT_CNTL::VGA_XCRT_CNT_EN data too large\n");
}
__inline void set_CRTC_EXT_CNTL_crtc_hsync_dis(regCRTC_EXT_CNTL *reg, unsigned int crtc_hsync_dis)
{
  reg->bitfields.CRTC_HSYNC_DIS = crtc_hsync_dis;
  if (reg->bitfields.CRTC_HSYNC_DIS != crtc_hsync_dis) HSLDPF(E_ERROR_MESSAGE,"CRTC_EXT_CNTL::CRTC_HSYNC_DIS data too large\n");
}
__inline void set_CRTC_EXT_CNTL_crtc_vsync_dis(regCRTC_EXT_CNTL *reg, unsigned int crtc_vsync_dis)
{
  reg->bitfields.CRTC_VSYNC_DIS = crtc_vsync_dis;
  if (reg->bitfields.CRTC_VSYNC_DIS != crtc_vsync_dis) HSLDPF(E_ERROR_MESSAGE,"CRTC_EXT_CNTL::CRTC_VSYNC_DIS data too large\n");
}
__inline void set_CRTC_EXT_CNTL_crtc_display_dis(regCRTC_EXT_CNTL *reg, unsigned int crtc_display_dis)
{
  reg->bitfields.CRTC_DISPLAY_DIS = crtc_display_dis;
  if (reg->bitfields.CRTC_DISPLAY_DIS != crtc_display_dis) HSLDPF(E_ERROR_MESSAGE,"CRTC_EXT_CNTL::CRTC_DISPLAY_DIS data too large\n");
}
__inline void set_CRTC_EXT_CNTL_crtc_sync_tristate(regCRTC_EXT_CNTL *reg, unsigned int crtc_sync_tristate)
{
  reg->bitfields.CRTC_SYNC_TRISTATE = crtc_sync_tristate;
  if (reg->bitfields.CRTC_SYNC_TRISTATE != crtc_sync_tristate) HSLDPF(E_ERROR_MESSAGE,"CRTC_EXT_CNTL::CRTC_SYNC_TRISTATE data too large\n");
}
__inline void set_CRTC_EXT_CNTL_crtc_hsync_tristate(regCRTC_EXT_CNTL *reg, unsigned int crtc_hsync_tristate)
{
  reg->bitfields.CRTC_HSYNC_TRISTATE = crtc_hsync_tristate;
  if (reg->bitfields.CRTC_HSYNC_TRISTATE != crtc_hsync_tristate) HSLDPF(E_ERROR_MESSAGE,"CRTC_EXT_CNTL::CRTC_HSYNC_TRISTATE data too large\n");
}
__inline void set_CRTC_EXT_CNTL_crtc_vsync_tristate(regCRTC_EXT_CNTL *reg, unsigned int crtc_vsync_tristate)
{
  reg->bitfields.CRTC_VSYNC_TRISTATE = crtc_vsync_tristate;
  if (reg->bitfields.CRTC_VSYNC_TRISTATE != crtc_vsync_tristate) HSLDPF(E_ERROR_MESSAGE,"CRTC_EXT_CNTL::CRTC_VSYNC_TRISTATE data too large\n");
}
__inline void set_CRTC_EXT_CNTL_crt_on(regCRTC_EXT_CNTL *reg, unsigned int crt_on)
{
  reg->bitfields.CRT_ON = crt_on;
  if (reg->bitfields.CRT_ON != crt_on) HSLDPF(E_ERROR_MESSAGE,"CRTC_EXT_CNTL::CRT_ON data too large\n");
}
__inline void set_CRTC_EXT_CNTL_vga_cur_b_test(regCRTC_EXT_CNTL *reg, unsigned int vga_cur_b_test)
{
  reg->bitfields.VGA_CUR_B_TEST = vga_cur_b_test;
  if (reg->bitfields.VGA_CUR_B_TEST != vga_cur_b_test) HSLDPF(E_ERROR_MESSAGE,"CRTC_EXT_CNTL::VGA_CUR_B_TEST data too large\n");
}
__inline void set_CRTC_EXT_CNTL_vga_pack_dis(regCRTC_EXT_CNTL *reg, unsigned int vga_pack_dis)
{
  reg->bitfields.VGA_PACK_DIS = vga_pack_dis;
  if (reg->bitfields.VGA_PACK_DIS != vga_pack_dis) HSLDPF(E_ERROR_MESSAGE,"CRTC_EXT_CNTL::VGA_PACK_DIS data too large\n");
}
__inline void set_CRTC_EXT_CNTL_vga_mem_ps_en(regCRTC_EXT_CNTL *reg, unsigned int vga_mem_ps_en)
{
  reg->bitfields.VGA_MEM_PS_EN = vga_mem_ps_en;
  if (reg->bitfields.VGA_MEM_PS_EN != vga_mem_ps_en) HSLDPF(E_ERROR_MESSAGE,"CRTC_EXT_CNTL::VGA_MEM_PS_EN data too large\n");
}
__inline void set_CRTC_EXT_CNTL_vcrtc_idx_master(regCRTC_EXT_CNTL *reg, unsigned int vcrtc_idx_master)
{
  reg->bitfields.VCRTC_IDX_MASTER = vcrtc_idx_master;
  if (reg->bitfields.VCRTC_IDX_MASTER != vcrtc_idx_master) HSLDPF(E_ERROR_MESSAGE,"CRTC_EXT_CNTL::VCRTC_IDX_MASTER data too large\n");
}
#else
#define set_CRTC_EXT_CNTL_crtc_vga_xoverscan(reg, crtc_vga_xoverscan) (reg)->bitfields.CRTC_VGA_XOVERSCAN = crtc_vga_xoverscan
#define set_CRTC_EXT_CNTL_vga_blink_rate(reg, vga_blink_rate) (reg)->bitfields.VGA_BLINK_RATE = vga_blink_rate
#define set_CRTC_EXT_CNTL_vga_ati_linear(reg, vga_ati_linear) (reg)->bitfields.VGA_ATI_LINEAR = vga_ati_linear
#define set_CRTC_EXT_CNTL_vga_128kap_paging(reg, vga_128kap_paging) (reg)->bitfields.VGA_128KAP_PAGING = vga_128kap_paging
#define set_CRTC_EXT_CNTL_vga_text_132(reg, vga_text_132) (reg)->bitfields.VGA_TEXT_132 = vga_text_132
#define set_CRTC_EXT_CNTL_vga_xcrt_cnt_en(reg, vga_xcrt_cnt_en) (reg)->bitfields.VGA_XCRT_CNT_EN = vga_xcrt_cnt_en
#define set_CRTC_EXT_CNTL_crtc_hsync_dis(reg, crtc_hsync_dis) (reg)->bitfields.CRTC_HSYNC_DIS = crtc_hsync_dis
#define set_CRTC_EXT_CNTL_crtc_vsync_dis(reg, crtc_vsync_dis) (reg)->bitfields.CRTC_VSYNC_DIS = crtc_vsync_dis
#define set_CRTC_EXT_CNTL_crtc_display_dis(reg, crtc_display_dis) (reg)->bitfields.CRTC_DISPLAY_DIS = crtc_display_dis
#define set_CRTC_EXT_CNTL_crtc_sync_tristate(reg, crtc_sync_tristate) (reg)->bitfields.CRTC_SYNC_TRISTATE = crtc_sync_tristate
#define set_CRTC_EXT_CNTL_crtc_hsync_tristate(reg, crtc_hsync_tristate) (reg)->bitfields.CRTC_HSYNC_TRISTATE = crtc_hsync_tristate
#define set_CRTC_EXT_CNTL_crtc_vsync_tristate(reg, crtc_vsync_tristate) (reg)->bitfields.CRTC_VSYNC_TRISTATE = crtc_vsync_tristate
#define set_CRTC_EXT_CNTL_crt_on(reg, crt_on) (reg)->bitfields.CRT_ON = crt_on
#define set_CRTC_EXT_CNTL_vga_cur_b_test(reg, vga_cur_b_test) (reg)->bitfields.VGA_CUR_B_TEST = vga_cur_b_test
#define set_CRTC_EXT_CNTL_vga_pack_dis(reg, vga_pack_dis) (reg)->bitfields.VGA_PACK_DIS = vga_pack_dis
#define set_CRTC_EXT_CNTL_vga_mem_ps_en(reg, vga_mem_ps_en) (reg)->bitfields.VGA_MEM_PS_EN = vga_mem_ps_en
#define set_CRTC_EXT_CNTL_vcrtc_idx_master(reg, vcrtc_idx_master) (reg)->bitfields.VCRTC_IDX_MASTER = vcrtc_idx_master

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union WAIT_UNTIL regWAIT_UNTIL;

#ifdef DEBUG
__inline void set_WAIT_UNTIL_wait_crtc_pflip(regWAIT_UNTIL *reg, unsigned int wait_crtc_pflip)
{
  reg->bitfields.WAIT_CRTC_PFLIP = wait_crtc_pflip;
  if (reg->bitfields.WAIT_CRTC_PFLIP != wait_crtc_pflip) HSLDPF(E_ERROR_MESSAGE,"WAIT_UNTIL::WAIT_CRTC_PFLIP data too large\n");
}
__inline void set_WAIT_UNTIL_wait_re_crtc_vline(regWAIT_UNTIL *reg, unsigned int wait_re_crtc_vline)
{
  reg->bitfields.WAIT_RE_CRTC_VLINE = wait_re_crtc_vline;
  if (reg->bitfields.WAIT_RE_CRTC_VLINE != wait_re_crtc_vline) HSLDPF(E_ERROR_MESSAGE,"WAIT_UNTIL::WAIT_RE_CRTC_VLINE data too large\n");
}
__inline void set_WAIT_UNTIL_wait_fe_crtc_vline(regWAIT_UNTIL *reg, unsigned int wait_fe_crtc_vline)
{
  reg->bitfields.WAIT_FE_CRTC_VLINE = wait_fe_crtc_vline;
  if (reg->bitfields.WAIT_FE_CRTC_VLINE != wait_fe_crtc_vline) HSLDPF(E_ERROR_MESSAGE,"WAIT_UNTIL::WAIT_FE_CRTC_VLINE data too large\n");
}
__inline void set_WAIT_UNTIL_wait_crtc_vline(regWAIT_UNTIL *reg, unsigned int wait_crtc_vline)
{
  reg->bitfields.WAIT_CRTC_VLINE = wait_crtc_vline;
  if (reg->bitfields.WAIT_CRTC_VLINE != wait_crtc_vline) HSLDPF(E_ERROR_MESSAGE,"WAIT_UNTIL::WAIT_CRTC_VLINE data too large\n");
}
__inline void set_WAIT_UNTIL_wait_dma_viph0_idle(regWAIT_UNTIL *reg, unsigned int wait_dma_viph0_idle)
{
  reg->bitfields.WAIT_DMA_VIPH0_IDLE = wait_dma_viph0_idle;
  if (reg->bitfields.WAIT_DMA_VIPH0_IDLE != wait_dma_viph0_idle) HSLDPF(E_ERROR_MESSAGE,"WAIT_UNTIL::WAIT_DMA_VIPH0_IDLE data too large\n");
}
__inline void set_WAIT_UNTIL_wait_dma_viph1_idle(regWAIT_UNTIL *reg, unsigned int wait_dma_viph1_idle)
{
  reg->bitfields.WAIT_DMA_VIPH1_IDLE = wait_dma_viph1_idle;
  if (reg->bitfields.WAIT_DMA_VIPH1_IDLE != wait_dma_viph1_idle) HSLDPF(E_ERROR_MESSAGE,"WAIT_UNTIL::WAIT_DMA_VIPH1_IDLE data too large\n");
}
__inline void set_WAIT_UNTIL_wait_dma_viph2_idle(regWAIT_UNTIL *reg, unsigned int wait_dma_viph2_idle)
{
  reg->bitfields.WAIT_DMA_VIPH2_IDLE = wait_dma_viph2_idle;
  if (reg->bitfields.WAIT_DMA_VIPH2_IDLE != wait_dma_viph2_idle) HSLDPF(E_ERROR_MESSAGE,"WAIT_UNTIL::WAIT_DMA_VIPH2_IDLE data too large\n");
}
__inline void set_WAIT_UNTIL_wait_dma_viph3_idle(regWAIT_UNTIL *reg, unsigned int wait_dma_viph3_idle)
{
  reg->bitfields.WAIT_DMA_VIPH3_IDLE = wait_dma_viph3_idle;
  if (reg->bitfields.WAIT_DMA_VIPH3_IDLE != wait_dma_viph3_idle) HSLDPF(E_ERROR_MESSAGE,"WAIT_UNTIL::WAIT_DMA_VIPH3_IDLE data too large\n");
}
__inline void set_WAIT_UNTIL_wait_dma_vid_idle(regWAIT_UNTIL *reg, unsigned int wait_dma_vid_idle)
{
  reg->bitfields.WAIT_DMA_VID_IDLE = wait_dma_vid_idle;
  if (reg->bitfields.WAIT_DMA_VID_IDLE != wait_dma_vid_idle) HSLDPF(E_ERROR_MESSAGE,"WAIT_UNTIL::WAIT_DMA_VID_IDLE data too large\n");
}
__inline void set_WAIT_UNTIL_wait_dma_gui_idle(regWAIT_UNTIL *reg, unsigned int wait_dma_gui_idle)
{
  reg->bitfields.WAIT_DMA_GUI_IDLE = wait_dma_gui_idle;
  if (reg->bitfields.WAIT_DMA_GUI_IDLE != wait_dma_gui_idle) HSLDPF(E_ERROR_MESSAGE,"WAIT_UNTIL::WAIT_DMA_GUI_IDLE data too large\n");
}
__inline void set_WAIT_UNTIL_wait_cmdfifo(regWAIT_UNTIL *reg, unsigned int wait_cmdfifo)
{
  reg->bitfields.WAIT_CMDFIFO = wait_cmdfifo;
  if (reg->bitfields.WAIT_CMDFIFO != wait_cmdfifo) HSLDPF(E_ERROR_MESSAGE,"WAIT_UNTIL::WAIT_CMDFIFO data too large\n");
}
__inline void set_WAIT_UNTIL_wait_ov0_flip(regWAIT_UNTIL *reg, unsigned int wait_ov0_flip)
{
  reg->bitfields.WAIT_OV0_FLIP = wait_ov0_flip;
  if (reg->bitfields.WAIT_OV0_FLIP != wait_ov0_flip) HSLDPF(E_ERROR_MESSAGE,"WAIT_UNTIL::WAIT_OV0_FLIP data too large\n");
}
__inline void set_WAIT_UNTIL_wait_ov0_slicedone(regWAIT_UNTIL *reg, unsigned int wait_ov0_slicedone)
{
  reg->bitfields.WAIT_OV0_SLICEDONE = wait_ov0_slicedone;
  if (reg->bitfields.WAIT_OV0_SLICEDONE != wait_ov0_slicedone) HSLDPF(E_ERROR_MESSAGE,"WAIT_UNTIL::WAIT_OV0_SLICEDONE data too large\n");
}
__inline void set_WAIT_UNTIL_wait_2d_idle(regWAIT_UNTIL *reg, unsigned int wait_2d_idle)
{
  reg->bitfields.WAIT_2D_IDLE = wait_2d_idle;
  if (reg->bitfields.WAIT_2D_IDLE != wait_2d_idle) HSLDPF(E_ERROR_MESSAGE,"WAIT_UNTIL::WAIT_2D_IDLE data too large\n");
}
__inline void set_WAIT_UNTIL_wait_3d_idle(regWAIT_UNTIL *reg, unsigned int wait_3d_idle)
{
  reg->bitfields.WAIT_3D_IDLE = wait_3d_idle;
  if (reg->bitfields.WAIT_3D_IDLE != wait_3d_idle) HSLDPF(E_ERROR_MESSAGE,"WAIT_UNTIL::WAIT_3D_IDLE data too large\n");
}
__inline void set_WAIT_UNTIL_wait_2d_idleclean(regWAIT_UNTIL *reg, unsigned int wait_2d_idleclean)
{
  reg->bitfields.WAIT_2D_IDLECLEAN = wait_2d_idleclean;
  if (reg->bitfields.WAIT_2D_IDLECLEAN != wait_2d_idleclean) HSLDPF(E_ERROR_MESSAGE,"WAIT_UNTIL::WAIT_2D_IDLECLEAN data too large\n");
}
__inline void set_WAIT_UNTIL_wait_3d_idleclean(regWAIT_UNTIL *reg, unsigned int wait_3d_idleclean)
{
  reg->bitfields.WAIT_3D_IDLECLEAN = wait_3d_idleclean;
  if (reg->bitfields.WAIT_3D_IDLECLEAN != wait_3d_idleclean) HSLDPF(E_ERROR_MESSAGE,"WAIT_UNTIL::WAIT_3D_IDLECLEAN data too large\n");
}
__inline void set_WAIT_UNTIL_wait_host_idleclean(regWAIT_UNTIL *reg, unsigned int wait_host_idleclean)
{
  reg->bitfields.WAIT_HOST_IDLECLEAN = wait_host_idleclean;
  if (reg->bitfields.WAIT_HOST_IDLECLEAN != wait_host_idleclean) HSLDPF(E_ERROR_MESSAGE,"WAIT_UNTIL::WAIT_HOST_IDLECLEAN data too large\n");
}
__inline void set_WAIT_UNTIL_wait_extern_sig(regWAIT_UNTIL *reg, unsigned int wait_extern_sig)
{
  reg->bitfields.WAIT_EXTERN_SIG = wait_extern_sig;
  if (reg->bitfields.WAIT_EXTERN_SIG != wait_extern_sig) HSLDPF(E_ERROR_MESSAGE,"WAIT_UNTIL::WAIT_EXTERN_SIG data too large\n");
}
__inline void set_WAIT_UNTIL_cmdfifo_entries(regWAIT_UNTIL *reg, unsigned int cmdfifo_entries)
{
  reg->bitfields.CMDFIFO_ENTRIES = cmdfifo_entries;
  if (reg->bitfields.CMDFIFO_ENTRIES != cmdfifo_entries) HSLDPF(E_ERROR_MESSAGE,"WAIT_UNTIL::CMDFIFO_ENTRIES data too large\n");
}
__inline void set_WAIT_UNTIL_wait_both_crtc_pflip(regWAIT_UNTIL *reg, unsigned int wait_both_crtc_pflip)
{
  reg->bitfields.WAIT_BOTH_CRTC_PFLIP = wait_both_crtc_pflip;
  if (reg->bitfields.WAIT_BOTH_CRTC_PFLIP != wait_both_crtc_pflip) HSLDPF(E_ERROR_MESSAGE,"WAIT_UNTIL::WAIT_BOTH_CRTC_PFLIP data too large\n");
}
__inline void set_WAIT_UNTIL_eng_display_select(regWAIT_UNTIL *reg, unsigned int eng_display_select)
{
  reg->bitfields.ENG_DISPLAY_SELECT = eng_display_select;
  if (reg->bitfields.ENG_DISPLAY_SELECT != eng_display_select) HSLDPF(E_ERROR_MESSAGE,"WAIT_UNTIL::ENG_DISPLAY_SELECT data too large\n");
}
#else
#define set_WAIT_UNTIL_wait_crtc_pflip(reg, wait_crtc_pflip) (reg)->bitfields.WAIT_CRTC_PFLIP = wait_crtc_pflip
#define set_WAIT_UNTIL_wait_re_crtc_vline(reg, wait_re_crtc_vline) (reg)->bitfields.WAIT_RE_CRTC_VLINE = wait_re_crtc_vline
#define set_WAIT_UNTIL_wait_fe_crtc_vline(reg, wait_fe_crtc_vline) (reg)->bitfields.WAIT_FE_CRTC_VLINE = wait_fe_crtc_vline
#define set_WAIT_UNTIL_wait_crtc_vline(reg, wait_crtc_vline) (reg)->bitfields.WAIT_CRTC_VLINE = wait_crtc_vline
#define set_WAIT_UNTIL_wait_dma_viph0_idle(reg, wait_dma_viph0_idle) (reg)->bitfields.WAIT_DMA_VIPH0_IDLE = wait_dma_viph0_idle
#define set_WAIT_UNTIL_wait_dma_viph1_idle(reg, wait_dma_viph1_idle) (reg)->bitfields.WAIT_DMA_VIPH1_IDLE = wait_dma_viph1_idle
#define set_WAIT_UNTIL_wait_dma_viph2_idle(reg, wait_dma_viph2_idle) (reg)->bitfields.WAIT_DMA_VIPH2_IDLE = wait_dma_viph2_idle
#define set_WAIT_UNTIL_wait_dma_viph3_idle(reg, wait_dma_viph3_idle) (reg)->bitfields.WAIT_DMA_VIPH3_IDLE = wait_dma_viph3_idle
#define set_WAIT_UNTIL_wait_dma_vid_idle(reg, wait_dma_vid_idle) (reg)->bitfields.WAIT_DMA_VID_IDLE = wait_dma_vid_idle
#define set_WAIT_UNTIL_wait_dma_gui_idle(reg, wait_dma_gui_idle) (reg)->bitfields.WAIT_DMA_GUI_IDLE = wait_dma_gui_idle
#define set_WAIT_UNTIL_wait_cmdfifo(reg, wait_cmdfifo) (reg)->bitfields.WAIT_CMDFIFO = wait_cmdfifo
#define set_WAIT_UNTIL_wait_ov0_flip(reg, wait_ov0_flip) (reg)->bitfields.WAIT_OV0_FLIP = wait_ov0_flip
#define set_WAIT_UNTIL_wait_ov0_slicedone(reg, wait_ov0_slicedone) (reg)->bitfields.WAIT_OV0_SLICEDONE = wait_ov0_slicedone
#define set_WAIT_UNTIL_wait_2d_idle(reg, wait_2d_idle) (reg)->bitfields.WAIT_2D_IDLE = wait_2d_idle
#define set_WAIT_UNTIL_wait_3d_idle(reg, wait_3d_idle) (reg)->bitfields.WAIT_3D_IDLE = wait_3d_idle
#define set_WAIT_UNTIL_wait_2d_idleclean(reg, wait_2d_idleclean) (reg)->bitfields.WAIT_2D_IDLECLEAN = wait_2d_idleclean
#define set_WAIT_UNTIL_wait_3d_idleclean(reg, wait_3d_idleclean) (reg)->bitfields.WAIT_3D_IDLECLEAN = wait_3d_idleclean
#define set_WAIT_UNTIL_wait_host_idleclean(reg, wait_host_idleclean) (reg)->bitfields.WAIT_HOST_IDLECLEAN = wait_host_idleclean
#define set_WAIT_UNTIL_wait_extern_sig(reg, wait_extern_sig) (reg)->bitfields.WAIT_EXTERN_SIG = wait_extern_sig
#define set_WAIT_UNTIL_cmdfifo_entries(reg, cmdfifo_entries) (reg)->bitfields.CMDFIFO_ENTRIES = cmdfifo_entries
#define set_WAIT_UNTIL_wait_both_crtc_pflip(reg, wait_both_crtc_pflip) (reg)->bitfields.WAIT_BOTH_CRTC_PFLIP = wait_both_crtc_pflip
#define set_WAIT_UNTIL_eng_display_select(reg, eng_display_select) (reg)->bitfields.ENG_DISPLAY_SELECT = eng_display_select

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ISYNC_CNTL regISYNC_CNTL;

#ifdef DEBUG
__inline void set_ISYNC_CNTL_isync_any2d_idle3d(regISYNC_CNTL *reg, unsigned int isync_any2d_idle3d)
{
  reg->bitfields.ISYNC_ANY2D_IDLE3D = isync_any2d_idle3d;
  if (reg->bitfields.ISYNC_ANY2D_IDLE3D != isync_any2d_idle3d) HSLDPF(E_ERROR_MESSAGE,"ISYNC_CNTL::ISYNC_ANY2D_IDLE3D data too large\n");
}
__inline void set_ISYNC_CNTL_isync_any3d_idle2d(regISYNC_CNTL *reg, unsigned int isync_any3d_idle2d)
{
  reg->bitfields.ISYNC_ANY3D_IDLE2D = isync_any3d_idle2d;
  if (reg->bitfields.ISYNC_ANY3D_IDLE2D != isync_any3d_idle2d) HSLDPF(E_ERROR_MESSAGE,"ISYNC_CNTL::ISYNC_ANY3D_IDLE2D data too large\n");
}
__inline void set_ISYNC_CNTL_isync_trig2d_idle3d(regISYNC_CNTL *reg, unsigned int isync_trig2d_idle3d)
{
  reg->bitfields.ISYNC_TRIG2D_IDLE3D = isync_trig2d_idle3d;
  if (reg->bitfields.ISYNC_TRIG2D_IDLE3D != isync_trig2d_idle3d) HSLDPF(E_ERROR_MESSAGE,"ISYNC_CNTL::ISYNC_TRIG2D_IDLE3D data too large\n");
}
__inline void set_ISYNC_CNTL_isync_trig3d_idle2d(regISYNC_CNTL *reg, unsigned int isync_trig3d_idle2d)
{
  reg->bitfields.ISYNC_TRIG3D_IDLE2D = isync_trig3d_idle2d;
  if (reg->bitfields.ISYNC_TRIG3D_IDLE2D != isync_trig3d_idle2d) HSLDPF(E_ERROR_MESSAGE,"ISYNC_CNTL::ISYNC_TRIG3D_IDLE2D data too large\n");
}
__inline void set_ISYNC_CNTL_isync_wait_idlegui(regISYNC_CNTL *reg, unsigned int isync_wait_idlegui)
{
  reg->bitfields.ISYNC_WAIT_IDLEGUI = isync_wait_idlegui;
  if (reg->bitfields.ISYNC_WAIT_IDLEGUI != isync_wait_idlegui) HSLDPF(E_ERROR_MESSAGE,"ISYNC_CNTL::ISYNC_WAIT_IDLEGUI data too large\n");
}
__inline void set_ISYNC_CNTL_isync_cpscratch_idlegui(regISYNC_CNTL *reg, unsigned int isync_cpscratch_idlegui)
{
  reg->bitfields.ISYNC_CPSCRATCH_IDLEGUI = isync_cpscratch_idlegui;
  if (reg->bitfields.ISYNC_CPSCRATCH_IDLEGUI != isync_cpscratch_idlegui) HSLDPF(E_ERROR_MESSAGE,"ISYNC_CNTL::ISYNC_CPSCRATCH_IDLEGUI data too large\n");
}
#else
#define set_ISYNC_CNTL_isync_any2d_idle3d(reg, isync_any2d_idle3d) (reg)->bitfields.ISYNC_ANY2D_IDLE3D = isync_any2d_idle3d
#define set_ISYNC_CNTL_isync_any3d_idle2d(reg, isync_any3d_idle2d) (reg)->bitfields.ISYNC_ANY3D_IDLE2D = isync_any3d_idle2d
#define set_ISYNC_CNTL_isync_trig2d_idle3d(reg, isync_trig2d_idle3d) (reg)->bitfields.ISYNC_TRIG2D_IDLE3D = isync_trig2d_idle3d
#define set_ISYNC_CNTL_isync_trig3d_idle2d(reg, isync_trig3d_idle2d) (reg)->bitfields.ISYNC_TRIG3D_IDLE2D = isync_trig3d_idle2d
#define set_ISYNC_CNTL_isync_wait_idlegui(reg, isync_wait_idlegui) (reg)->bitfields.ISYNC_WAIT_IDLEGUI = isync_wait_idlegui
#define set_ISYNC_CNTL_isync_cpscratch_idlegui(reg, isync_cpscratch_idlegui) (reg)->bitfields.ISYNC_CPSCRATCH_IDLEGUI = isync_cpscratch_idlegui

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RBBM_GUICNTL regRBBM_GUICNTL;

#ifdef DEBUG
__inline void set_RBBM_GUICNTL_host_data_swap(regRBBM_GUICNTL *reg, unsigned int host_data_swap)
{
  reg->bitfields.HOST_DATA_SWAP = host_data_swap;
  if (reg->bitfields.HOST_DATA_SWAP != host_data_swap) HSLDPF(E_ERROR_MESSAGE,"RBBM_GUICNTL::HOST_DATA_SWAP data too large\n");
}
#else
#define set_RBBM_GUICNTL_host_data_swap(reg, host_data_swap) (reg)->bitfields.HOST_DATA_SWAP = host_data_swap

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RBBM_STATUS regRBBM_STATUS;

#ifdef DEBUG
__inline void set_RBBM_STATUS_cmdfifo_avail(regRBBM_STATUS *reg, unsigned int cmdfifo_avail)
{
  reg->bitfields.CMDFIFO_AVAIL = cmdfifo_avail;
  if (reg->bitfields.CMDFIFO_AVAIL != cmdfifo_avail) HSLDPF(E_ERROR_MESSAGE,"RBBM_STATUS::CMDFIFO_AVAIL data too large\n");
}
__inline void set_RBBM_STATUS_hirq_on_rbb(regRBBM_STATUS *reg, unsigned int hirq_on_rbb)
{
  reg->bitfields.HIRQ_ON_RBB = hirq_on_rbb;
  if (reg->bitfields.HIRQ_ON_RBB != hirq_on_rbb) HSLDPF(E_ERROR_MESSAGE,"RBBM_STATUS::HIRQ_ON_RBB data too large\n");
}
__inline void set_RBBM_STATUS_cprq_on_rbb(regRBBM_STATUS *reg, unsigned int cprq_on_rbb)
{
  reg->bitfields.CPRQ_ON_RBB = cprq_on_rbb;
  if (reg->bitfields.CPRQ_ON_RBB != cprq_on_rbb) HSLDPF(E_ERROR_MESSAGE,"RBBM_STATUS::CPRQ_ON_RBB data too large\n");
}
__inline void set_RBBM_STATUS_cfrq_on_rbb(regRBBM_STATUS *reg, unsigned int cfrq_on_rbb)
{
  reg->bitfields.CFRQ_ON_RBB = cfrq_on_rbb;
  if (reg->bitfields.CFRQ_ON_RBB != cfrq_on_rbb) HSLDPF(E_ERROR_MESSAGE,"RBBM_STATUS::CFRQ_ON_RBB data too large\n");
}
__inline void set_RBBM_STATUS_hirq_in_rtbuf(regRBBM_STATUS *reg, unsigned int hirq_in_rtbuf)
{
  reg->bitfields.HIRQ_IN_RTBUF = hirq_in_rtbuf;
  if (reg->bitfields.HIRQ_IN_RTBUF != hirq_in_rtbuf) HSLDPF(E_ERROR_MESSAGE,"RBBM_STATUS::HIRQ_IN_RTBUF data too large\n");
}
__inline void set_RBBM_STATUS_cprq_in_rtbuf(regRBBM_STATUS *reg, unsigned int cprq_in_rtbuf)
{
  reg->bitfields.CPRQ_IN_RTBUF = cprq_in_rtbuf;
  if (reg->bitfields.CPRQ_IN_RTBUF != cprq_in_rtbuf) HSLDPF(E_ERROR_MESSAGE,"RBBM_STATUS::CPRQ_IN_RTBUF data too large\n");
}
__inline void set_RBBM_STATUS_cfrq_in_rtbuf(regRBBM_STATUS *reg, unsigned int cfrq_in_rtbuf)
{
  reg->bitfields.CFRQ_IN_RTBUF = cfrq_in_rtbuf;
  if (reg->bitfields.CFRQ_IN_RTBUF != cfrq_in_rtbuf) HSLDPF(E_ERROR_MESSAGE,"RBBM_STATUS::CFRQ_IN_RTBUF data too large\n");
}
__inline void set_RBBM_STATUS_cf_pipe_busy(regRBBM_STATUS *reg, unsigned int cf_pipe_busy)
{
  reg->bitfields.CF_PIPE_BUSY = cf_pipe_busy;
  if (reg->bitfields.CF_PIPE_BUSY != cf_pipe_busy) HSLDPF(E_ERROR_MESSAGE,"RBBM_STATUS::CF_PIPE_BUSY data too large\n");
}
__inline void set_RBBM_STATUS_eng_ev_busy(regRBBM_STATUS *reg, unsigned int eng_ev_busy)
{
  reg->bitfields.ENG_EV_BUSY = eng_ev_busy;
  if (reg->bitfields.ENG_EV_BUSY != eng_ev_busy) HSLDPF(E_ERROR_MESSAGE,"RBBM_STATUS::ENG_EV_BUSY data too large\n");
}
__inline void set_RBBM_STATUS_cp_cmdstrm_busy(regRBBM_STATUS *reg, unsigned int cp_cmdstrm_busy)
{
  reg->bitfields.CP_CMDSTRM_BUSY = cp_cmdstrm_busy;
  if (reg->bitfields.CP_CMDSTRM_BUSY != cp_cmdstrm_busy) HSLDPF(E_ERROR_MESSAGE,"RBBM_STATUS::CP_CMDSTRM_BUSY data too large\n");
}
__inline void set_RBBM_STATUS_e2_busy(regRBBM_STATUS *reg, unsigned int e2_busy)
{
  reg->bitfields.E2_BUSY = e2_busy;
  if (reg->bitfields.E2_BUSY != e2_busy) HSLDPF(E_ERROR_MESSAGE,"RBBM_STATUS::E2_BUSY data too large\n");
}
__inline void set_RBBM_STATUS_rb2d_busy(regRBBM_STATUS *reg, unsigned int rb2d_busy)
{
  reg->bitfields.RB2D_BUSY = rb2d_busy;
  if (reg->bitfields.RB2D_BUSY != rb2d_busy) HSLDPF(E_ERROR_MESSAGE,"RBBM_STATUS::RB2D_BUSY data too large\n");
}
__inline void set_RBBM_STATUS_rb3d_busy(regRBBM_STATUS *reg, unsigned int rb3d_busy)
{
  reg->bitfields.RB3D_BUSY = rb3d_busy;
  if (reg->bitfields.RB3D_BUSY != rb3d_busy) HSLDPF(E_ERROR_MESSAGE,"RBBM_STATUS::RB3D_BUSY data too large\n");
}
__inline void set_RBBM_STATUS_vap_busy(regRBBM_STATUS *reg, unsigned int vap_busy)
{
  reg->bitfields.VAP_BUSY = vap_busy;
  if (reg->bitfields.VAP_BUSY != vap_busy) HSLDPF(E_ERROR_MESSAGE,"RBBM_STATUS::VAP_BUSY data too large\n");
}
__inline void set_RBBM_STATUS_re_busy(regRBBM_STATUS *reg, unsigned int re_busy)
{
  reg->bitfields.RE_BUSY = re_busy;
  if (reg->bitfields.RE_BUSY != re_busy) HSLDPF(E_ERROR_MESSAGE,"RBBM_STATUS::RE_BUSY data too large\n");
}
__inline void set_RBBM_STATUS_tam_busy(regRBBM_STATUS *reg, unsigned int tam_busy)
{
  reg->bitfields.TAM_BUSY = tam_busy;
  if (reg->bitfields.TAM_BUSY != tam_busy) HSLDPF(E_ERROR_MESSAGE,"RBBM_STATUS::TAM_BUSY data too large\n");
}
__inline void set_RBBM_STATUS_tdm_busy(regRBBM_STATUS *reg, unsigned int tdm_busy)
{
  reg->bitfields.TDM_BUSY = tdm_busy;
  if (reg->bitfields.TDM_BUSY != tdm_busy) HSLDPF(E_ERROR_MESSAGE,"RBBM_STATUS::TDM_BUSY data too large\n");
}
__inline void set_RBBM_STATUS_pb_busy(regRBBM_STATUS *reg, unsigned int pb_busy)
{
  reg->bitfields.PB_BUSY = pb_busy;
  if (reg->bitfields.PB_BUSY != pb_busy) HSLDPF(E_ERROR_MESSAGE,"RBBM_STATUS::PB_BUSY data too large\n");
}
__inline void set_RBBM_STATUS_tim_busy(regRBBM_STATUS *reg, unsigned int tim_busy)
{
  reg->bitfields.TIM_BUSY = tim_busy;
  if (reg->bitfields.TIM_BUSY != tim_busy) HSLDPF(E_ERROR_MESSAGE,"RBBM_STATUS::TIM_BUSY data too large\n");
}
__inline void set_RBBM_STATUS_gui_active(regRBBM_STATUS *reg, unsigned int gui_active)
{
  reg->bitfields.GUI_ACTIVE = gui_active;
  if (reg->bitfields.GUI_ACTIVE != gui_active) HSLDPF(E_ERROR_MESSAGE,"RBBM_STATUS::GUI_ACTIVE data too large\n");
}
#else
#define set_RBBM_STATUS_cmdfifo_avail(reg, cmdfifo_avail) (reg)->bitfields.CMDFIFO_AVAIL = cmdfifo_avail
#define set_RBBM_STATUS_hirq_on_rbb(reg, hirq_on_rbb) (reg)->bitfields.HIRQ_ON_RBB = hirq_on_rbb
#define set_RBBM_STATUS_cprq_on_rbb(reg, cprq_on_rbb) (reg)->bitfields.CPRQ_ON_RBB = cprq_on_rbb
#define set_RBBM_STATUS_cfrq_on_rbb(reg, cfrq_on_rbb) (reg)->bitfields.CFRQ_ON_RBB = cfrq_on_rbb
#define set_RBBM_STATUS_hirq_in_rtbuf(reg, hirq_in_rtbuf) (reg)->bitfields.HIRQ_IN_RTBUF = hirq_in_rtbuf
#define set_RBBM_STATUS_cprq_in_rtbuf(reg, cprq_in_rtbuf) (reg)->bitfields.CPRQ_IN_RTBUF = cprq_in_rtbuf
#define set_RBBM_STATUS_cfrq_in_rtbuf(reg, cfrq_in_rtbuf) (reg)->bitfields.CFRQ_IN_RTBUF = cfrq_in_rtbuf
#define set_RBBM_STATUS_cf_pipe_busy(reg, cf_pipe_busy) (reg)->bitfields.CF_PIPE_BUSY = cf_pipe_busy
#define set_RBBM_STATUS_eng_ev_busy(reg, eng_ev_busy) (reg)->bitfields.ENG_EV_BUSY = eng_ev_busy
#define set_RBBM_STATUS_cp_cmdstrm_busy(reg, cp_cmdstrm_busy) (reg)->bitfields.CP_CMDSTRM_BUSY = cp_cmdstrm_busy
#define set_RBBM_STATUS_e2_busy(reg, e2_busy) (reg)->bitfields.E2_BUSY = e2_busy
#define set_RBBM_STATUS_rb2d_busy(reg, rb2d_busy) (reg)->bitfields.RB2D_BUSY = rb2d_busy
#define set_RBBM_STATUS_rb3d_busy(reg, rb3d_busy) (reg)->bitfields.RB3D_BUSY = rb3d_busy
#define set_RBBM_STATUS_vap_busy(reg, vap_busy) (reg)->bitfields.VAP_BUSY = vap_busy
#define set_RBBM_STATUS_re_busy(reg, re_busy) (reg)->bitfields.RE_BUSY = re_busy
#define set_RBBM_STATUS_tam_busy(reg, tam_busy) (reg)->bitfields.TAM_BUSY = tam_busy
#define set_RBBM_STATUS_tdm_busy(reg, tdm_busy) (reg)->bitfields.TDM_BUSY = tdm_busy
#define set_RBBM_STATUS_pb_busy(reg, pb_busy) (reg)->bitfields.PB_BUSY = pb_busy
#define set_RBBM_STATUS_tim_busy(reg, tim_busy) (reg)->bitfields.TIM_BUSY = tim_busy
#define set_RBBM_STATUS_gui_active(reg, gui_active) (reg)->bitfields.GUI_ACTIVE = gui_active

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RBBM_CNTL regRBBM_CNTL;

#ifdef DEBUG
__inline void set_RBBM_CNTL_rb_settle(regRBBM_CNTL *reg, unsigned int rb_settle)
{
  reg->bitfields.RB_SETTLE = rb_settle;
  if (reg->bitfields.RB_SETTLE != rb_settle) HSLDPF(E_ERROR_MESSAGE,"RBBM_CNTL::RB_SETTLE data too large\n");
}
__inline void set_RBBM_CNTL_abortclks_hi(regRBBM_CNTL *reg, unsigned int abortclks_hi)
{
  reg->bitfields.ABORTCLKS_HI = abortclks_hi;
  if (reg->bitfields.ABORTCLKS_HI != abortclks_hi) HSLDPF(E_ERROR_MESSAGE,"RBBM_CNTL::ABORTCLKS_HI data too large\n");
}
__inline void set_RBBM_CNTL_abortclks_cp(regRBBM_CNTL *reg, unsigned int abortclks_cp)
{
  reg->bitfields.ABORTCLKS_CP = abortclks_cp;
  if (reg->bitfields.ABORTCLKS_CP != abortclks_cp) HSLDPF(E_ERROR_MESSAGE,"RBBM_CNTL::ABORTCLKS_CP data too large\n");
}
__inline void set_RBBM_CNTL_abortclks_cfifo(regRBBM_CNTL *reg, unsigned int abortclks_cfifo)
{
  reg->bitfields.ABORTCLKS_CFIFO = abortclks_cfifo;
  if (reg->bitfields.ABORTCLKS_CFIFO != abortclks_cfifo) HSLDPF(E_ERROR_MESSAGE,"RBBM_CNTL::ABORTCLKS_CFIFO data too large\n");
}
__inline void set_RBBM_CNTL_cpq_data_swap(regRBBM_CNTL *reg, unsigned int cpq_data_swap)
{
  reg->bitfields.CPQ_DATA_SWAP = cpq_data_swap;
  if (reg->bitfields.CPQ_DATA_SWAP != cpq_data_swap) HSLDPF(E_ERROR_MESSAGE,"RBBM_CNTL::CPQ_DATA_SWAP data too large\n");
}
__inline void set_RBBM_CNTL_no_abort_idct(regRBBM_CNTL *reg, unsigned int no_abort_idct)
{
  reg->bitfields.NO_ABORT_IDCT = no_abort_idct;
  if (reg->bitfields.NO_ABORT_IDCT != no_abort_idct) HSLDPF(E_ERROR_MESSAGE,"RBBM_CNTL::NO_ABORT_IDCT data too large\n");
}
__inline void set_RBBM_CNTL_no_abort_bios(regRBBM_CNTL *reg, unsigned int no_abort_bios)
{
  reg->bitfields.NO_ABORT_BIOS = no_abort_bios;
  if (reg->bitfields.NO_ABORT_BIOS != no_abort_bios) HSLDPF(E_ERROR_MESSAGE,"RBBM_CNTL::NO_ABORT_BIOS data too large\n");
}
__inline void set_RBBM_CNTL_no_abort_tvout(regRBBM_CNTL *reg, unsigned int no_abort_tvout)
{
  reg->bitfields.NO_ABORT_TVOUT = no_abort_tvout;
  if (reg->bitfields.NO_ABORT_TVOUT != no_abort_tvout) HSLDPF(E_ERROR_MESSAGE,"RBBM_CNTL::NO_ABORT_TVOUT data too large\n");
}
__inline void set_RBBM_CNTL_no_abort_cp(regRBBM_CNTL *reg, unsigned int no_abort_cp)
{
  reg->bitfields.NO_ABORT_CP = no_abort_cp;
  if (reg->bitfields.NO_ABORT_CP != no_abort_cp) HSLDPF(E_ERROR_MESSAGE,"RBBM_CNTL::NO_ABORT_CP data too large\n");
}
__inline void set_RBBM_CNTL_no_abort_hi(regRBBM_CNTL *reg, unsigned int no_abort_hi)
{
  reg->bitfields.NO_ABORT_HI = no_abort_hi;
  if (reg->bitfields.NO_ABORT_HI != no_abort_hi) HSLDPF(E_ERROR_MESSAGE,"RBBM_CNTL::NO_ABORT_HI data too large\n");
}
__inline void set_RBBM_CNTL_no_abort_hdp(regRBBM_CNTL *reg, unsigned int no_abort_hdp)
{
  reg->bitfields.NO_ABORT_HDP = no_abort_hdp;
  if (reg->bitfields.NO_ABORT_HDP != no_abort_hdp) HSLDPF(E_ERROR_MESSAGE,"RBBM_CNTL::NO_ABORT_HDP data too large\n");
}
__inline void set_RBBM_CNTL_no_abort_mc(regRBBM_CNTL *reg, unsigned int no_abort_mc)
{
  reg->bitfields.NO_ABORT_MC = no_abort_mc;
  if (reg->bitfields.NO_ABORT_MC != no_abort_mc) HSLDPF(E_ERROR_MESSAGE,"RBBM_CNTL::NO_ABORT_MC data too large\n");
}
__inline void set_RBBM_CNTL_no_abort_aic(regRBBM_CNTL *reg, unsigned int no_abort_aic)
{
  reg->bitfields.NO_ABORT_AIC = no_abort_aic;
  if (reg->bitfields.NO_ABORT_AIC != no_abort_aic) HSLDPF(E_ERROR_MESSAGE,"RBBM_CNTL::NO_ABORT_AIC data too large\n");
}
__inline void set_RBBM_CNTL_no_abort_vip(regRBBM_CNTL *reg, unsigned int no_abort_vip)
{
  reg->bitfields.NO_ABORT_VIP = no_abort_vip;
  if (reg->bitfields.NO_ABORT_VIP != no_abort_vip) HSLDPF(E_ERROR_MESSAGE,"RBBM_CNTL::NO_ABORT_VIP data too large\n");
}
__inline void set_RBBM_CNTL_no_abort_disp(regRBBM_CNTL *reg, unsigned int no_abort_disp)
{
  reg->bitfields.NO_ABORT_DISP = no_abort_disp;
  if (reg->bitfields.NO_ABORT_DISP != no_abort_disp) HSLDPF(E_ERROR_MESSAGE,"RBBM_CNTL::NO_ABORT_DISP data too large\n");
}
__inline void set_RBBM_CNTL_no_abort_cg(regRBBM_CNTL *reg, unsigned int no_abort_cg)
{
  reg->bitfields.NO_ABORT_CG = no_abort_cg;
  if (reg->bitfields.NO_ABORT_CG != no_abort_cg) HSLDPF(E_ERROR_MESSAGE,"RBBM_CNTL::NO_ABORT_CG data too large\n");
}
#else
#define set_RBBM_CNTL_rb_settle(reg, rb_settle) (reg)->bitfields.RB_SETTLE = rb_settle
#define set_RBBM_CNTL_abortclks_hi(reg, abortclks_hi) (reg)->bitfields.ABORTCLKS_HI = abortclks_hi
#define set_RBBM_CNTL_abortclks_cp(reg, abortclks_cp) (reg)->bitfields.ABORTCLKS_CP = abortclks_cp
#define set_RBBM_CNTL_abortclks_cfifo(reg, abortclks_cfifo) (reg)->bitfields.ABORTCLKS_CFIFO = abortclks_cfifo
#define set_RBBM_CNTL_cpq_data_swap(reg, cpq_data_swap) (reg)->bitfields.CPQ_DATA_SWAP = cpq_data_swap
#define set_RBBM_CNTL_no_abort_idct(reg, no_abort_idct) (reg)->bitfields.NO_ABORT_IDCT = no_abort_idct
#define set_RBBM_CNTL_no_abort_bios(reg, no_abort_bios) (reg)->bitfields.NO_ABORT_BIOS = no_abort_bios
#define set_RBBM_CNTL_no_abort_tvout(reg, no_abort_tvout) (reg)->bitfields.NO_ABORT_TVOUT = no_abort_tvout
#define set_RBBM_CNTL_no_abort_cp(reg, no_abort_cp) (reg)->bitfields.NO_ABORT_CP = no_abort_cp
#define set_RBBM_CNTL_no_abort_hi(reg, no_abort_hi) (reg)->bitfields.NO_ABORT_HI = no_abort_hi
#define set_RBBM_CNTL_no_abort_hdp(reg, no_abort_hdp) (reg)->bitfields.NO_ABORT_HDP = no_abort_hdp
#define set_RBBM_CNTL_no_abort_mc(reg, no_abort_mc) (reg)->bitfields.NO_ABORT_MC = no_abort_mc
#define set_RBBM_CNTL_no_abort_aic(reg, no_abort_aic) (reg)->bitfields.NO_ABORT_AIC = no_abort_aic
#define set_RBBM_CNTL_no_abort_vip(reg, no_abort_vip) (reg)->bitfields.NO_ABORT_VIP = no_abort_vip
#define set_RBBM_CNTL_no_abort_disp(reg, no_abort_disp) (reg)->bitfields.NO_ABORT_DISP = no_abort_disp
#define set_RBBM_CNTL_no_abort_cg(reg, no_abort_cg) (reg)->bitfields.NO_ABORT_CG = no_abort_cg

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RBBM_SOFT_RESET regRBBM_SOFT_RESET;

#ifdef DEBUG
__inline void set_RBBM_SOFT_RESET_soft_reset_cp(regRBBM_SOFT_RESET *reg, unsigned int soft_reset_cp)
{
  reg->bitfields.SOFT_RESET_CP = soft_reset_cp;
  if (reg->bitfields.SOFT_RESET_CP != soft_reset_cp) HSLDPF(E_ERROR_MESSAGE,"RBBM_SOFT_RESET::SOFT_RESET_CP data too large\n");
}
__inline void set_RBBM_SOFT_RESET_soft_reset_hi(regRBBM_SOFT_RESET *reg, unsigned int soft_reset_hi)
{
  reg->bitfields.SOFT_RESET_HI = soft_reset_hi;
  if (reg->bitfields.SOFT_RESET_HI != soft_reset_hi) HSLDPF(E_ERROR_MESSAGE,"RBBM_SOFT_RESET::SOFT_RESET_HI data too large\n");
}
__inline void set_RBBM_SOFT_RESET_soft_reset_vap(regRBBM_SOFT_RESET *reg, unsigned int soft_reset_vap)
{
  reg->bitfields.SOFT_RESET_VAP = soft_reset_vap;
  if (reg->bitfields.SOFT_RESET_VAP != soft_reset_vap) HSLDPF(E_ERROR_MESSAGE,"RBBM_SOFT_RESET::SOFT_RESET_VAP data too large\n");
}
__inline void set_RBBM_SOFT_RESET_soft_reset_re(regRBBM_SOFT_RESET *reg, unsigned int soft_reset_re)
{
  reg->bitfields.SOFT_RESET_RE = soft_reset_re;
  if (reg->bitfields.SOFT_RESET_RE != soft_reset_re) HSLDPF(E_ERROR_MESSAGE,"RBBM_SOFT_RESET::SOFT_RESET_RE data too large\n");
}
__inline void set_RBBM_SOFT_RESET_soft_reset_pp(regRBBM_SOFT_RESET *reg, unsigned int soft_reset_pp)
{
  reg->bitfields.SOFT_RESET_PP = soft_reset_pp;
  if (reg->bitfields.SOFT_RESET_PP != soft_reset_pp) HSLDPF(E_ERROR_MESSAGE,"RBBM_SOFT_RESET::SOFT_RESET_PP data too large\n");
}
__inline void set_RBBM_SOFT_RESET_soft_reset_e2(regRBBM_SOFT_RESET *reg, unsigned int soft_reset_e2)
{
  reg->bitfields.SOFT_RESET_E2 = soft_reset_e2;
  if (reg->bitfields.SOFT_RESET_E2 != soft_reset_e2) HSLDPF(E_ERROR_MESSAGE,"RBBM_SOFT_RESET::SOFT_RESET_E2 data too large\n");
}
__inline void set_RBBM_SOFT_RESET_soft_reset_rb(regRBBM_SOFT_RESET *reg, unsigned int soft_reset_rb)
{
  reg->bitfields.SOFT_RESET_RB = soft_reset_rb;
  if (reg->bitfields.SOFT_RESET_RB != soft_reset_rb) HSLDPF(E_ERROR_MESSAGE,"RBBM_SOFT_RESET::SOFT_RESET_RB data too large\n");
}
__inline void set_RBBM_SOFT_RESET_soft_reset_hdp(regRBBM_SOFT_RESET *reg, unsigned int soft_reset_hdp)
{
  reg->bitfields.SOFT_RESET_HDP = soft_reset_hdp;
  if (reg->bitfields.SOFT_RESET_HDP != soft_reset_hdp) HSLDPF(E_ERROR_MESSAGE,"RBBM_SOFT_RESET::SOFT_RESET_HDP data too large\n");
}
__inline void set_RBBM_SOFT_RESET_soft_reset_mc(regRBBM_SOFT_RESET *reg, unsigned int soft_reset_mc)
{
  reg->bitfields.SOFT_RESET_MC = soft_reset_mc;
  if (reg->bitfields.SOFT_RESET_MC != soft_reset_mc) HSLDPF(E_ERROR_MESSAGE,"RBBM_SOFT_RESET::SOFT_RESET_MC data too large\n");
}
__inline void set_RBBM_SOFT_RESET_soft_reset_aic(regRBBM_SOFT_RESET *reg, unsigned int soft_reset_aic)
{
  reg->bitfields.SOFT_RESET_AIC = soft_reset_aic;
  if (reg->bitfields.SOFT_RESET_AIC != soft_reset_aic) HSLDPF(E_ERROR_MESSAGE,"RBBM_SOFT_RESET::SOFT_RESET_AIC data too large\n");
}
__inline void set_RBBM_SOFT_RESET_soft_reset_vip(regRBBM_SOFT_RESET *reg, unsigned int soft_reset_vip)
{
  reg->bitfields.SOFT_RESET_VIP = soft_reset_vip;
  if (reg->bitfields.SOFT_RESET_VIP != soft_reset_vip) HSLDPF(E_ERROR_MESSAGE,"RBBM_SOFT_RESET::SOFT_RESET_VIP data too large\n");
}
__inline void set_RBBM_SOFT_RESET_soft_reset_disp(regRBBM_SOFT_RESET *reg, unsigned int soft_reset_disp)
{
  reg->bitfields.SOFT_RESET_DISP = soft_reset_disp;
  if (reg->bitfields.SOFT_RESET_DISP != soft_reset_disp) HSLDPF(E_ERROR_MESSAGE,"RBBM_SOFT_RESET::SOFT_RESET_DISP data too large\n");
}
__inline void set_RBBM_SOFT_RESET_soft_reset_cg(regRBBM_SOFT_RESET *reg, unsigned int soft_reset_cg)
{
  reg->bitfields.SOFT_RESET_CG = soft_reset_cg;
  if (reg->bitfields.SOFT_RESET_CG != soft_reset_cg) HSLDPF(E_ERROR_MESSAGE,"RBBM_SOFT_RESET::SOFT_RESET_CG data too large\n");
}
#else
#define set_RBBM_SOFT_RESET_soft_reset_cp(reg, soft_reset_cp) (reg)->bitfields.SOFT_RESET_CP = soft_reset_cp
#define set_RBBM_SOFT_RESET_soft_reset_hi(reg, soft_reset_hi) (reg)->bitfields.SOFT_RESET_HI = soft_reset_hi
#define set_RBBM_SOFT_RESET_soft_reset_vap(reg, soft_reset_vap) (reg)->bitfields.SOFT_RESET_VAP = soft_reset_vap
#define set_RBBM_SOFT_RESET_soft_reset_re(reg, soft_reset_re) (reg)->bitfields.SOFT_RESET_RE = soft_reset_re
#define set_RBBM_SOFT_RESET_soft_reset_pp(reg, soft_reset_pp) (reg)->bitfields.SOFT_RESET_PP = soft_reset_pp
#define set_RBBM_SOFT_RESET_soft_reset_e2(reg, soft_reset_e2) (reg)->bitfields.SOFT_RESET_E2 = soft_reset_e2
#define set_RBBM_SOFT_RESET_soft_reset_rb(reg, soft_reset_rb) (reg)->bitfields.SOFT_RESET_RB = soft_reset_rb
#define set_RBBM_SOFT_RESET_soft_reset_hdp(reg, soft_reset_hdp) (reg)->bitfields.SOFT_RESET_HDP = soft_reset_hdp
#define set_RBBM_SOFT_RESET_soft_reset_mc(reg, soft_reset_mc) (reg)->bitfields.SOFT_RESET_MC = soft_reset_mc
#define set_RBBM_SOFT_RESET_soft_reset_aic(reg, soft_reset_aic) (reg)->bitfields.SOFT_RESET_AIC = soft_reset_aic
#define set_RBBM_SOFT_RESET_soft_reset_vip(reg, soft_reset_vip) (reg)->bitfields.SOFT_RESET_VIP = soft_reset_vip
#define set_RBBM_SOFT_RESET_soft_reset_disp(reg, soft_reset_disp) (reg)->bitfields.SOFT_RESET_DISP = soft_reset_disp
#define set_RBBM_SOFT_RESET_soft_reset_cg(reg, soft_reset_cg) (reg)->bitfields.SOFT_RESET_CG = soft_reset_cg

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union NQWAIT_UNTIL regNQWAIT_UNTIL;

#ifdef DEBUG
__inline void set_NQWAIT_UNTIL_wait_gui_idle(regNQWAIT_UNTIL *reg, unsigned int wait_gui_idle)
{
  reg->bitfields.WAIT_GUI_IDLE = wait_gui_idle;
  if (reg->bitfields.WAIT_GUI_IDLE != wait_gui_idle) HSLDPF(E_ERROR_MESSAGE,"NQWAIT_UNTIL::WAIT_GUI_IDLE data too large\n");
}
#else
#define set_NQWAIT_UNTIL_wait_gui_idle(reg, wait_gui_idle) (reg)->bitfields.WAIT_GUI_IDLE = wait_gui_idle

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RBBM_DEBUG regRBBM_DEBUG;

#ifdef DEBUG
__inline void set_RBBM_DEBUG_rbbm_debug(regRBBM_DEBUG *reg, unsigned int rbbm_debug)
{
  reg->bitfields.RBBM_DEBUG = rbbm_debug;
  if (reg->bitfields.RBBM_DEBUG != rbbm_debug) HSLDPF(E_ERROR_MESSAGE,"RBBM_DEBUG::RBBM_DEBUG data too large\n");
}
#else
#define set_RBBM_DEBUG_rbbm_debug(reg, rbbm_debug) (reg)->bitfields.RBBM_DEBUG = rbbm_debug

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RBBM_CMDFIFO_ADDR regRBBM_CMDFIFO_ADDR;

#ifdef DEBUG
__inline void set_RBBM_CMDFIFO_ADDR_cmdfifo_addr(regRBBM_CMDFIFO_ADDR *reg, unsigned int cmdfifo_addr)
{
  reg->bitfields.CMDFIFO_ADDR = cmdfifo_addr;
  if (reg->bitfields.CMDFIFO_ADDR != cmdfifo_addr) HSLDPF(E_ERROR_MESSAGE,"RBBM_CMDFIFO_ADDR::CMDFIFO_ADDR data too large\n");
}
#else
#define set_RBBM_CMDFIFO_ADDR_cmdfifo_addr(reg, cmdfifo_addr) (reg)->bitfields.CMDFIFO_ADDR = cmdfifo_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RBBM_CMDFIFO_DATAL regRBBM_CMDFIFO_DATAL;

#ifdef DEBUG
__inline void set_RBBM_CMDFIFO_DATAL_cmdfifo_datal(regRBBM_CMDFIFO_DATAL *reg, unsigned int cmdfifo_datal)
{
  reg->bitfields.CMDFIFO_DATAL = cmdfifo_datal;
  if (reg->bitfields.CMDFIFO_DATAL != cmdfifo_datal) HSLDPF(E_ERROR_MESSAGE,"RBBM_CMDFIFO_DATAL::CMDFIFO_DATAL data too large\n");
}
#else
#define set_RBBM_CMDFIFO_DATAL_cmdfifo_datal(reg, cmdfifo_datal) (reg)->bitfields.CMDFIFO_DATAL = cmdfifo_datal

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RBBM_CMDFIFO_DATAH regRBBM_CMDFIFO_DATAH;

#ifdef DEBUG
__inline void set_RBBM_CMDFIFO_DATAH_cmdfifo_datah(regRBBM_CMDFIFO_DATAH *reg, unsigned int cmdfifo_datah)
{
  reg->bitfields.CMDFIFO_DATAH = cmdfifo_datah;
  if (reg->bitfields.CMDFIFO_DATAH != cmdfifo_datah) HSLDPF(E_ERROR_MESSAGE,"RBBM_CMDFIFO_DATAH::CMDFIFO_DATAH data too large\n");
}
#else
#define set_RBBM_CMDFIFO_DATAH_cmdfifo_datah(reg, cmdfifo_datah) (reg)->bitfields.CMDFIFO_DATAH = cmdfifo_datah

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RBBM_CMDFIFO_STAT regRBBM_CMDFIFO_STAT;

#ifdef DEBUG
__inline void set_RBBM_CMDFIFO_STAT_cmdfifo_rptr(regRBBM_CMDFIFO_STAT *reg, unsigned int cmdfifo_rptr)
{
  reg->bitfields.CMDFIFO_RPTR = cmdfifo_rptr;
  if (reg->bitfields.CMDFIFO_RPTR != cmdfifo_rptr) HSLDPF(E_ERROR_MESSAGE,"RBBM_CMDFIFO_STAT::CMDFIFO_RPTR data too large\n");
}
__inline void set_RBBM_CMDFIFO_STAT_cmdfifo_wptr(regRBBM_CMDFIFO_STAT *reg, unsigned int cmdfifo_wptr)
{
  reg->bitfields.CMDFIFO_WPTR = cmdfifo_wptr;
  if (reg->bitfields.CMDFIFO_WPTR != cmdfifo_wptr) HSLDPF(E_ERROR_MESSAGE,"RBBM_CMDFIFO_STAT::CMDFIFO_WPTR data too large\n");
}
#else
#define set_RBBM_CMDFIFO_STAT_cmdfifo_rptr(reg, cmdfifo_rptr) (reg)->bitfields.CMDFIFO_RPTR = cmdfifo_rptr
#define set_RBBM_CMDFIFO_STAT_cmdfifo_wptr(reg, cmdfifo_wptr) (reg)->bitfields.CMDFIFO_WPTR = cmdfifo_wptr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RBBM_PERF_CNTL regRBBM_PERF_CNTL;

#ifdef DEBUG
__inline void set_RBBM_PERF_CNTL_perfsel1(regRBBM_PERF_CNTL *reg, unsigned int perfsel1)
{
  reg->bitfields.PERFSEL1 = perfsel1;
  if (reg->bitfields.PERFSEL1 != perfsel1) HSLDPF(E_ERROR_MESSAGE,"RBBM_PERF_CNTL::PERFSEL1 data too large\n");
}
__inline void set_RBBM_PERF_CNTL_clr_perf1(regRBBM_PERF_CNTL *reg, unsigned int clr_perf1)
{
  reg->bitfields.CLR_PERF1 = clr_perf1;
  if (reg->bitfields.CLR_PERF1 != clr_perf1) HSLDPF(E_ERROR_MESSAGE,"RBBM_PERF_CNTL::CLR_PERF1 data too large\n");
}
__inline void set_RBBM_PERF_CNTL_en_perf1(regRBBM_PERF_CNTL *reg, unsigned int en_perf1)
{
  reg->bitfields.EN_PERF1 = en_perf1;
  if (reg->bitfields.EN_PERF1 != en_perf1) HSLDPF(E_ERROR_MESSAGE,"RBBM_PERF_CNTL::EN_PERF1 data too large\n");
}
__inline void set_RBBM_PERF_CNTL_perfsel2(regRBBM_PERF_CNTL *reg, unsigned int perfsel2)
{
  reg->bitfields.PERFSEL2 = perfsel2;
  if (reg->bitfields.PERFSEL2 != perfsel2) HSLDPF(E_ERROR_MESSAGE,"RBBM_PERF_CNTL::PERFSEL2 data too large\n");
}
__inline void set_RBBM_PERF_CNTL_clr_perf2(regRBBM_PERF_CNTL *reg, unsigned int clr_perf2)
{
  reg->bitfields.CLR_PERF2 = clr_perf2;
  if (reg->bitfields.CLR_PERF2 != clr_perf2) HSLDPF(E_ERROR_MESSAGE,"RBBM_PERF_CNTL::CLR_PERF2 data too large\n");
}
__inline void set_RBBM_PERF_CNTL_en_perf2(regRBBM_PERF_CNTL *reg, unsigned int en_perf2)
{
  reg->bitfields.EN_PERF2 = en_perf2;
  if (reg->bitfields.EN_PERF2 != en_perf2) HSLDPF(E_ERROR_MESSAGE,"RBBM_PERF_CNTL::EN_PERF2 data too large\n");
}
__inline void set_RBBM_PERF_CNTL_sync_sel(regRBBM_PERF_CNTL *reg, unsigned int sync_sel)
{
  reg->bitfields.SYNC_SEL = sync_sel;
  if (reg->bitfields.SYNC_SEL != sync_sel) HSLDPF(E_ERROR_MESSAGE,"RBBM_PERF_CNTL::SYNC_SEL data too large\n");
}
#else
#define set_RBBM_PERF_CNTL_perfsel1(reg, perfsel1) (reg)->bitfields.PERFSEL1 = perfsel1
#define set_RBBM_PERF_CNTL_clr_perf1(reg, clr_perf1) (reg)->bitfields.CLR_PERF1 = clr_perf1
#define set_RBBM_PERF_CNTL_en_perf1(reg, en_perf1) (reg)->bitfields.EN_PERF1 = en_perf1
#define set_RBBM_PERF_CNTL_perfsel2(reg, perfsel2) (reg)->bitfields.PERFSEL2 = perfsel2
#define set_RBBM_PERF_CNTL_clr_perf2(reg, clr_perf2) (reg)->bitfields.CLR_PERF2 = clr_perf2
#define set_RBBM_PERF_CNTL_en_perf2(reg, en_perf2) (reg)->bitfields.EN_PERF2 = en_perf2
#define set_RBBM_PERF_CNTL_sync_sel(reg, sync_sel) (reg)->bitfields.SYNC_SEL = sync_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RBBM_PERF_COUNT1 regRBBM_PERF_COUNT1;

#ifdef DEBUG
__inline void set_RBBM_PERF_COUNT1_perf_count1(regRBBM_PERF_COUNT1 *reg, unsigned int perf_count1)
{
  reg->bitfields.PERF_COUNT1 = perf_count1;
  if (reg->bitfields.PERF_COUNT1 != perf_count1) HSLDPF(E_ERROR_MESSAGE,"RBBM_PERF_COUNT1::PERF_COUNT1 data too large\n");
}
#else
#define set_RBBM_PERF_COUNT1_perf_count1(reg, perf_count1) (reg)->bitfields.PERF_COUNT1 = perf_count1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RBBM_PERF_COUNT2 regRBBM_PERF_COUNT2;

#ifdef DEBUG
__inline void set_RBBM_PERF_COUNT2_perf_count2(regRBBM_PERF_COUNT2 *reg, unsigned int perf_count2)
{
  reg->bitfields.PERF_COUNT2 = perf_count2;
  if (reg->bitfields.PERF_COUNT2 != perf_count2) HSLDPF(E_ERROR_MESSAGE,"RBBM_PERF_COUNT2::PERF_COUNT2 data too large\n");
}
#else
#define set_RBBM_PERF_COUNT2_perf_count2(reg, perf_count2) (reg)->bitfields.PERF_COUNT2 = perf_count2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GENFC_RD regGENFC_RD;

#ifdef DEBUG
__inline void set_GENFC_RD_vsync_sel_r(regGENFC_RD *reg, unsigned int vsync_sel_r)
{
  reg->bitfields.VSYNC_SEL_R = vsync_sel_r;
  if (reg->bitfields.VSYNC_SEL_R != vsync_sel_r) HSLDPF(E_ERROR_MESSAGE,"GENFC_RD::VSYNC_SEL_R data too large\n");
}
#else
#define set_GENFC_RD_vsync_sel_r(reg, vsync_sel_r) (reg)->bitfields.VSYNC_SEL_R = vsync_sel_r

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GENFC_WT regGENFC_WT;

#ifdef DEBUG
__inline void set_GENFC_WT_vsync_sel_w(regGENFC_WT *reg, unsigned int vsync_sel_w)
{
  reg->bitfields.VSYNC_SEL_W = vsync_sel_w;
  if (reg->bitfields.VSYNC_SEL_W != vsync_sel_w) HSLDPF(E_ERROR_MESSAGE,"GENFC_WT::VSYNC_SEL_W data too large\n");
}
#else
#define set_GENFC_WT_vsync_sel_w(reg, vsync_sel_w) (reg)->bitfields.VSYNC_SEL_W = vsync_sel_w

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GENS0 regGENS0;

#ifdef DEBUG
__inline void set_GENS0_sense_switch(regGENS0 *reg, unsigned int sense_switch)
{
  reg->bitfields.SENSE_SWITCH = sense_switch;
  if (reg->bitfields.SENSE_SWITCH != sense_switch) HSLDPF(E_ERROR_MESSAGE,"GENS0::SENSE_SWITCH data too large\n");
}
__inline void set_GENS0_crt_intr(regGENS0 *reg, unsigned int crt_intr)
{
  reg->bitfields.CRT_INTR = crt_intr;
  if (reg->bitfields.CRT_INTR != crt_intr) HSLDPF(E_ERROR_MESSAGE,"GENS0::CRT_INTR data too large\n");
}
#else
#define set_GENS0_sense_switch(reg, sense_switch) (reg)->bitfields.SENSE_SWITCH = sense_switch
#define set_GENS0_crt_intr(reg, crt_intr) (reg)->bitfields.CRT_INTR = crt_intr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GENS1 regGENS1;

#ifdef DEBUG
__inline void set_GENS1_no_display(regGENS1 *reg, unsigned int no_display)
{
  reg->bitfields.NO_DISPLAY = no_display;
  if (reg->bitfields.NO_DISPLAY != no_display) HSLDPF(E_ERROR_MESSAGE,"GENS1::NO_DISPLAY data too large\n");
}
__inline void set_GENS1_vga_vstatus(regGENS1 *reg, unsigned int vga_vstatus)
{
  reg->bitfields.VGA_VSTATUS = vga_vstatus;
  if (reg->bitfields.VGA_VSTATUS != vga_vstatus) HSLDPF(E_ERROR_MESSAGE,"GENS1::VGA_VSTATUS data too large\n");
}
__inline void set_GENS1_pixel_read_back(regGENS1 *reg, unsigned int pixel_read_back)
{
  reg->bitfields.PIXEL_READ_BACK = pixel_read_back;
  if (reg->bitfields.PIXEL_READ_BACK != pixel_read_back) HSLDPF(E_ERROR_MESSAGE,"GENS1::PIXEL_READ_BACK data too large\n");
}
#else
#define set_GENS1_no_display(reg, no_display) (reg)->bitfields.NO_DISPLAY = no_display
#define set_GENS1_vga_vstatus(reg, vga_vstatus) (reg)->bitfields.VGA_VSTATUS = vga_vstatus
#define set_GENS1_pixel_read_back(reg, pixel_read_back) (reg)->bitfields.PIXEL_READ_BACK = pixel_read_back

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_DATA regDAC_DATA;

#ifdef DEBUG
__inline void set_DAC_DATA_dac_data(regDAC_DATA *reg, unsigned int dac_data)
{
  reg->bitfields.DAC_DATA = dac_data;
  if (reg->bitfields.DAC_DATA != dac_data) HSLDPF(E_ERROR_MESSAGE,"DAC_DATA::DAC_DATA data too large\n");
}
#else
#define set_DAC_DATA_dac_data(reg, dac_data) (reg)->bitfields.DAC_DATA = dac_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_MASK regDAC_MASK;

#ifdef DEBUG
__inline void set_DAC_MASK_dac_mask(regDAC_MASK *reg, unsigned int dac_mask)
{
  reg->bitfields.DAC_MASK = dac_mask;
  if (reg->bitfields.DAC_MASK != dac_mask) HSLDPF(E_ERROR_MESSAGE,"DAC_MASK::DAC_MASK data too large\n");
}
#else
#define set_DAC_MASK_dac_mask(reg, dac_mask) (reg)->bitfields.DAC_MASK = dac_mask

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_R_INDEX regDAC_R_INDEX;

#ifdef DEBUG
__inline void set_DAC_R_INDEX_dac_r_index(regDAC_R_INDEX *reg, unsigned int dac_r_index)
{
  reg->bitfields.DAC_R_INDEX = dac_r_index;
  if (reg->bitfields.DAC_R_INDEX != dac_r_index) HSLDPF(E_ERROR_MESSAGE,"DAC_R_INDEX::DAC_R_INDEX data too large\n");
}
#else
#define set_DAC_R_INDEX_dac_r_index(reg, dac_r_index) (reg)->bitfields.DAC_R_INDEX = dac_r_index

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_W_INDEX regDAC_W_INDEX;

#ifdef DEBUG
__inline void set_DAC_W_INDEX_dac_w_index(regDAC_W_INDEX *reg, unsigned int dac_w_index)
{
  reg->bitfields.DAC_W_INDEX = dac_w_index;
  if (reg->bitfields.DAC_W_INDEX != dac_w_index) HSLDPF(E_ERROR_MESSAGE,"DAC_W_INDEX::DAC_W_INDEX data too large\n");
}
#else
#define set_DAC_W_INDEX_dac_w_index(reg, dac_w_index) (reg)->bitfields.DAC_W_INDEX = dac_w_index

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SEQ00 regSEQ00;

#ifdef DEBUG
__inline void set_SEQ00_seq_rst0b(regSEQ00 *reg, unsigned int seq_rst0b)
{
  reg->bitfields.SEQ_RST0B = seq_rst0b;
  if (reg->bitfields.SEQ_RST0B != seq_rst0b) HSLDPF(E_ERROR_MESSAGE,"SEQ00::SEQ_RST0B data too large\n");
}
__inline void set_SEQ00_seq_rst1b(regSEQ00 *reg, unsigned int seq_rst1b)
{
  reg->bitfields.SEQ_RST1B = seq_rst1b;
  if (reg->bitfields.SEQ_RST1B != seq_rst1b) HSLDPF(E_ERROR_MESSAGE,"SEQ00::SEQ_RST1B data too large\n");
}
#else
#define set_SEQ00_seq_rst0b(reg, seq_rst0b) (reg)->bitfields.SEQ_RST0B = seq_rst0b
#define set_SEQ00_seq_rst1b(reg, seq_rst1b) (reg)->bitfields.SEQ_RST1B = seq_rst1b

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SEQ01 regSEQ01;

#ifdef DEBUG
__inline void set_SEQ01_seq_dot8(regSEQ01 *reg, unsigned int seq_dot8)
{
  reg->bitfields.SEQ_DOT8 = seq_dot8;
  if (reg->bitfields.SEQ_DOT8 != seq_dot8) HSLDPF(E_ERROR_MESSAGE,"SEQ01::SEQ_DOT8 data too large\n");
}
__inline void set_SEQ01_seq_shift2(regSEQ01 *reg, unsigned int seq_shift2)
{
  reg->bitfields.SEQ_SHIFT2 = seq_shift2;
  if (reg->bitfields.SEQ_SHIFT2 != seq_shift2) HSLDPF(E_ERROR_MESSAGE,"SEQ01::SEQ_SHIFT2 data too large\n");
}
__inline void set_SEQ01_seq_pclkby2(regSEQ01 *reg, unsigned int seq_pclkby2)
{
  reg->bitfields.SEQ_PCLKBY2 = seq_pclkby2;
  if (reg->bitfields.SEQ_PCLKBY2 != seq_pclkby2) HSLDPF(E_ERROR_MESSAGE,"SEQ01::SEQ_PCLKBY2 data too large\n");
}
__inline void set_SEQ01_seq_shift4(regSEQ01 *reg, unsigned int seq_shift4)
{
  reg->bitfields.SEQ_SHIFT4 = seq_shift4;
  if (reg->bitfields.SEQ_SHIFT4 != seq_shift4) HSLDPF(E_ERROR_MESSAGE,"SEQ01::SEQ_SHIFT4 data too large\n");
}
__inline void set_SEQ01_seq_maxbw(regSEQ01 *reg, unsigned int seq_maxbw)
{
  reg->bitfields.SEQ_MAXBW = seq_maxbw;
  if (reg->bitfields.SEQ_MAXBW != seq_maxbw) HSLDPF(E_ERROR_MESSAGE,"SEQ01::SEQ_MAXBW data too large\n");
}
#else
#define set_SEQ01_seq_dot8(reg, seq_dot8) (reg)->bitfields.SEQ_DOT8 = seq_dot8
#define set_SEQ01_seq_shift2(reg, seq_shift2) (reg)->bitfields.SEQ_SHIFT2 = seq_shift2
#define set_SEQ01_seq_pclkby2(reg, seq_pclkby2) (reg)->bitfields.SEQ_PCLKBY2 = seq_pclkby2
#define set_SEQ01_seq_shift4(reg, seq_shift4) (reg)->bitfields.SEQ_SHIFT4 = seq_shift4
#define set_SEQ01_seq_maxbw(reg, seq_maxbw) (reg)->bitfields.SEQ_MAXBW = seq_maxbw

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SEQ03 regSEQ03;

#ifdef DEBUG
__inline void set_SEQ03_seq_font_b1(regSEQ03 *reg, unsigned int seq_font_b1)
{
  reg->bitfields.SEQ_FONT_B1 = seq_font_b1;
  if (reg->bitfields.SEQ_FONT_B1 != seq_font_b1) HSLDPF(E_ERROR_MESSAGE,"SEQ03::SEQ_FONT_B1 data too large\n");
}
__inline void set_SEQ03_seq_font_b2(regSEQ03 *reg, unsigned int seq_font_b2)
{
  reg->bitfields.SEQ_FONT_B2 = seq_font_b2;
  if (reg->bitfields.SEQ_FONT_B2 != seq_font_b2) HSLDPF(E_ERROR_MESSAGE,"SEQ03::SEQ_FONT_B2 data too large\n");
}
__inline void set_SEQ03_seq_font_a1(regSEQ03 *reg, unsigned int seq_font_a1)
{
  reg->bitfields.SEQ_FONT_A1 = seq_font_a1;
  if (reg->bitfields.SEQ_FONT_A1 != seq_font_a1) HSLDPF(E_ERROR_MESSAGE,"SEQ03::SEQ_FONT_A1 data too large\n");
}
__inline void set_SEQ03_seq_font_a2(regSEQ03 *reg, unsigned int seq_font_a2)
{
  reg->bitfields.SEQ_FONT_A2 = seq_font_a2;
  if (reg->bitfields.SEQ_FONT_A2 != seq_font_a2) HSLDPF(E_ERROR_MESSAGE,"SEQ03::SEQ_FONT_A2 data too large\n");
}
__inline void set_SEQ03_seq_font_b0(regSEQ03 *reg, unsigned int seq_font_b0)
{
  reg->bitfields.SEQ_FONT_B0 = seq_font_b0;
  if (reg->bitfields.SEQ_FONT_B0 != seq_font_b0) HSLDPF(E_ERROR_MESSAGE,"SEQ03::SEQ_FONT_B0 data too large\n");
}
__inline void set_SEQ03_seq_font_a0(regSEQ03 *reg, unsigned int seq_font_a0)
{
  reg->bitfields.SEQ_FONT_A0 = seq_font_a0;
  if (reg->bitfields.SEQ_FONT_A0 != seq_font_a0) HSLDPF(E_ERROR_MESSAGE,"SEQ03::SEQ_FONT_A0 data too large\n");
}
#else
#define set_SEQ03_seq_font_b1(reg, seq_font_b1) (reg)->bitfields.SEQ_FONT_B1 = seq_font_b1
#define set_SEQ03_seq_font_b2(reg, seq_font_b2) (reg)->bitfields.SEQ_FONT_B2 = seq_font_b2
#define set_SEQ03_seq_font_a1(reg, seq_font_a1) (reg)->bitfields.SEQ_FONT_A1 = seq_font_a1
#define set_SEQ03_seq_font_a2(reg, seq_font_a2) (reg)->bitfields.SEQ_FONT_A2 = seq_font_a2
#define set_SEQ03_seq_font_b0(reg, seq_font_b0) (reg)->bitfields.SEQ_FONT_B0 = seq_font_b0
#define set_SEQ03_seq_font_a0(reg, seq_font_a0) (reg)->bitfields.SEQ_FONT_A0 = seq_font_a0

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT00 regCRT00;

#ifdef DEBUG
__inline void set_CRT00_h_total(regCRT00 *reg, unsigned int h_total)
{
  reg->bitfields.H_TOTAL = h_total;
  if (reg->bitfields.H_TOTAL != h_total) HSLDPF(E_ERROR_MESSAGE,"CRT00::H_TOTAL data too large\n");
}
#else
#define set_CRT00_h_total(reg, h_total) (reg)->bitfields.H_TOTAL = h_total

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT01 regCRT01;

#ifdef DEBUG
__inline void set_CRT01_h_disp_end(regCRT01 *reg, unsigned int h_disp_end)
{
  reg->bitfields.H_DISP_END = h_disp_end;
  if (reg->bitfields.H_DISP_END != h_disp_end) HSLDPF(E_ERROR_MESSAGE,"CRT01::H_DISP_END data too large\n");
}
#else
#define set_CRT01_h_disp_end(reg, h_disp_end) (reg)->bitfields.H_DISP_END = h_disp_end

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT02 regCRT02;

#ifdef DEBUG
__inline void set_CRT02_h_blank_start(regCRT02 *reg, unsigned int h_blank_start)
{
  reg->bitfields.H_BLANK_START = h_blank_start;
  if (reg->bitfields.H_BLANK_START != h_blank_start) HSLDPF(E_ERROR_MESSAGE,"CRT02::H_BLANK_START data too large\n");
}
#else
#define set_CRT02_h_blank_start(reg, h_blank_start) (reg)->bitfields.H_BLANK_START = h_blank_start

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT03 regCRT03;

#ifdef DEBUG
__inline void set_CRT03_h_blank_end(regCRT03 *reg, unsigned int h_blank_end)
{
  reg->bitfields.H_BLANK_END = h_blank_end;
  if (reg->bitfields.H_BLANK_END != h_blank_end) HSLDPF(E_ERROR_MESSAGE,"CRT03::H_BLANK_END data too large\n");
}
__inline void set_CRT03_h_de_skew(regCRT03 *reg, unsigned int h_de_skew)
{
  reg->bitfields.H_DE_SKEW = h_de_skew;
  if (reg->bitfields.H_DE_SKEW != h_de_skew) HSLDPF(E_ERROR_MESSAGE,"CRT03::H_DE_SKEW data too large\n");
}
__inline void set_CRT03_cr10cr11_r_dis_b(regCRT03 *reg, unsigned int cr10cr11_r_dis_b)
{
  reg->bitfields.CR10CR11_R_DIS_B = cr10cr11_r_dis_b;
  if (reg->bitfields.CR10CR11_R_DIS_B != cr10cr11_r_dis_b) HSLDPF(E_ERROR_MESSAGE,"CRT03::CR10CR11_R_DIS_B data too large\n");
}
#else
#define set_CRT03_h_blank_end(reg, h_blank_end) (reg)->bitfields.H_BLANK_END = h_blank_end
#define set_CRT03_h_de_skew(reg, h_de_skew) (reg)->bitfields.H_DE_SKEW = h_de_skew
#define set_CRT03_cr10cr11_r_dis_b(reg, cr10cr11_r_dis_b) (reg)->bitfields.CR10CR11_R_DIS_B = cr10cr11_r_dis_b

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT04 regCRT04;

#ifdef DEBUG
__inline void set_CRT04_h_sync_start(regCRT04 *reg, unsigned int h_sync_start)
{
  reg->bitfields.H_SYNC_START = h_sync_start;
  if (reg->bitfields.H_SYNC_START != h_sync_start) HSLDPF(E_ERROR_MESSAGE,"CRT04::H_SYNC_START data too large\n");
}
#else
#define set_CRT04_h_sync_start(reg, h_sync_start) (reg)->bitfields.H_SYNC_START = h_sync_start

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT05 regCRT05;

#ifdef DEBUG
__inline void set_CRT05_h_sync_end(regCRT05 *reg, unsigned int h_sync_end)
{
  reg->bitfields.H_SYNC_END = h_sync_end;
  if (reg->bitfields.H_SYNC_END != h_sync_end) HSLDPF(E_ERROR_MESSAGE,"CRT05::H_SYNC_END data too large\n");
}
__inline void set_CRT05_h_sync_skew(regCRT05 *reg, unsigned int h_sync_skew)
{
  reg->bitfields.H_SYNC_SKEW = h_sync_skew;
  if (reg->bitfields.H_SYNC_SKEW != h_sync_skew) HSLDPF(E_ERROR_MESSAGE,"CRT05::H_SYNC_SKEW data too large\n");
}
__inline void set_CRT05_h_blank_end_b5(regCRT05 *reg, unsigned int h_blank_end_b5)
{
  reg->bitfields.H_BLANK_END_B5 = h_blank_end_b5;
  if (reg->bitfields.H_BLANK_END_B5 != h_blank_end_b5) HSLDPF(E_ERROR_MESSAGE,"CRT05::H_BLANK_END_B5 data too large\n");
}
#else
#define set_CRT05_h_sync_end(reg, h_sync_end) (reg)->bitfields.H_SYNC_END = h_sync_end
#define set_CRT05_h_sync_skew(reg, h_sync_skew) (reg)->bitfields.H_SYNC_SKEW = h_sync_skew
#define set_CRT05_h_blank_end_b5(reg, h_blank_end_b5) (reg)->bitfields.H_BLANK_END_B5 = h_blank_end_b5

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT06 regCRT06;

#ifdef DEBUG
__inline void set_CRT06_v_total(regCRT06 *reg, unsigned int v_total)
{
  reg->bitfields.V_TOTAL = v_total;
  if (reg->bitfields.V_TOTAL != v_total) HSLDPF(E_ERROR_MESSAGE,"CRT06::V_TOTAL data too large\n");
}
#else
#define set_CRT06_v_total(reg, v_total) (reg)->bitfields.V_TOTAL = v_total

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT07 regCRT07;

#ifdef DEBUG
__inline void set_CRT07_v_total_b8(regCRT07 *reg, unsigned int v_total_b8)
{
  reg->bitfields.V_TOTAL_B8 = v_total_b8;
  if (reg->bitfields.V_TOTAL_B8 != v_total_b8) HSLDPF(E_ERROR_MESSAGE,"CRT07::V_TOTAL_B8 data too large\n");
}
__inline void set_CRT07_v_disp_end_b8(regCRT07 *reg, unsigned int v_disp_end_b8)
{
  reg->bitfields.V_DISP_END_B8 = v_disp_end_b8;
  if (reg->bitfields.V_DISP_END_B8 != v_disp_end_b8) HSLDPF(E_ERROR_MESSAGE,"CRT07::V_DISP_END_B8 data too large\n");
}
__inline void set_CRT07_v_sync_start_b8(regCRT07 *reg, unsigned int v_sync_start_b8)
{
  reg->bitfields.V_SYNC_START_B8 = v_sync_start_b8;
  if (reg->bitfields.V_SYNC_START_B8 != v_sync_start_b8) HSLDPF(E_ERROR_MESSAGE,"CRT07::V_SYNC_START_B8 data too large\n");
}
__inline void set_CRT07_v_blank_start_b8(regCRT07 *reg, unsigned int v_blank_start_b8)
{
  reg->bitfields.V_BLANK_START_B8 = v_blank_start_b8;
  if (reg->bitfields.V_BLANK_START_B8 != v_blank_start_b8) HSLDPF(E_ERROR_MESSAGE,"CRT07::V_BLANK_START_B8 data too large\n");
}
__inline void set_CRT07_line_cmp_b8(regCRT07 *reg, unsigned int line_cmp_b8)
{
  reg->bitfields.LINE_CMP_B8 = line_cmp_b8;
  if (reg->bitfields.LINE_CMP_B8 != line_cmp_b8) HSLDPF(E_ERROR_MESSAGE,"CRT07::LINE_CMP_B8 data too large\n");
}
__inline void set_CRT07_v_total_b9(regCRT07 *reg, unsigned int v_total_b9)
{
  reg->bitfields.V_TOTAL_B9 = v_total_b9;
  if (reg->bitfields.V_TOTAL_B9 != v_total_b9) HSLDPF(E_ERROR_MESSAGE,"CRT07::V_TOTAL_B9 data too large\n");
}
__inline void set_CRT07_v_disp_end_b9(regCRT07 *reg, unsigned int v_disp_end_b9)
{
  reg->bitfields.V_DISP_END_B9 = v_disp_end_b9;
  if (reg->bitfields.V_DISP_END_B9 != v_disp_end_b9) HSLDPF(E_ERROR_MESSAGE,"CRT07::V_DISP_END_B9 data too large\n");
}
__inline void set_CRT07_v_sync_start_b9(regCRT07 *reg, unsigned int v_sync_start_b9)
{
  reg->bitfields.V_SYNC_START_B9 = v_sync_start_b9;
  if (reg->bitfields.V_SYNC_START_B9 != v_sync_start_b9) HSLDPF(E_ERROR_MESSAGE,"CRT07::V_SYNC_START_B9 data too large\n");
}
#else
#define set_CRT07_v_total_b8(reg, v_total_b8) (reg)->bitfields.V_TOTAL_B8 = v_total_b8
#define set_CRT07_v_disp_end_b8(reg, v_disp_end_b8) (reg)->bitfields.V_DISP_END_B8 = v_disp_end_b8
#define set_CRT07_v_sync_start_b8(reg, v_sync_start_b8) (reg)->bitfields.V_SYNC_START_B8 = v_sync_start_b8
#define set_CRT07_v_blank_start_b8(reg, v_blank_start_b8) (reg)->bitfields.V_BLANK_START_B8 = v_blank_start_b8
#define set_CRT07_line_cmp_b8(reg, line_cmp_b8) (reg)->bitfields.LINE_CMP_B8 = line_cmp_b8
#define set_CRT07_v_total_b9(reg, v_total_b9) (reg)->bitfields.V_TOTAL_B9 = v_total_b9
#define set_CRT07_v_disp_end_b9(reg, v_disp_end_b9) (reg)->bitfields.V_DISP_END_B9 = v_disp_end_b9
#define set_CRT07_v_sync_start_b9(reg, v_sync_start_b9) (reg)->bitfields.V_SYNC_START_B9 = v_sync_start_b9

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT08 regCRT08;

#ifdef DEBUG
__inline void set_CRT08_row_scan_start(regCRT08 *reg, unsigned int row_scan_start)
{
  reg->bitfields.ROW_SCAN_START = row_scan_start;
  if (reg->bitfields.ROW_SCAN_START != row_scan_start) HSLDPF(E_ERROR_MESSAGE,"CRT08::ROW_SCAN_START data too large\n");
}
__inline void set_CRT08_byte_pan(regCRT08 *reg, unsigned int byte_pan)
{
  reg->bitfields.BYTE_PAN = byte_pan;
  if (reg->bitfields.BYTE_PAN != byte_pan) HSLDPF(E_ERROR_MESSAGE,"CRT08::BYTE_PAN data too large\n");
}
#else
#define set_CRT08_row_scan_start(reg, row_scan_start) (reg)->bitfields.ROW_SCAN_START = row_scan_start
#define set_CRT08_byte_pan(reg, byte_pan) (reg)->bitfields.BYTE_PAN = byte_pan

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT09 regCRT09;

#ifdef DEBUG
__inline void set_CRT09_max_row_scan(regCRT09 *reg, unsigned int max_row_scan)
{
  reg->bitfields.MAX_ROW_SCAN = max_row_scan;
  if (reg->bitfields.MAX_ROW_SCAN != max_row_scan) HSLDPF(E_ERROR_MESSAGE,"CRT09::MAX_ROW_SCAN data too large\n");
}
__inline void set_CRT09_v_blank_start_b9(regCRT09 *reg, unsigned int v_blank_start_b9)
{
  reg->bitfields.V_BLANK_START_B9 = v_blank_start_b9;
  if (reg->bitfields.V_BLANK_START_B9 != v_blank_start_b9) HSLDPF(E_ERROR_MESSAGE,"CRT09::V_BLANK_START_B9 data too large\n");
}
__inline void set_CRT09_line_cmp_b9(regCRT09 *reg, unsigned int line_cmp_b9)
{
  reg->bitfields.LINE_CMP_B9 = line_cmp_b9;
  if (reg->bitfields.LINE_CMP_B9 != line_cmp_b9) HSLDPF(E_ERROR_MESSAGE,"CRT09::LINE_CMP_B9 data too large\n");
}
__inline void set_CRT09_double_char_height(regCRT09 *reg, unsigned int double_char_height)
{
  reg->bitfields.DOUBLE_CHAR_HEIGHT = double_char_height;
  if (reg->bitfields.DOUBLE_CHAR_HEIGHT != double_char_height) HSLDPF(E_ERROR_MESSAGE,"CRT09::DOUBLE_CHAR_HEIGHT data too large\n");
}
#else
#define set_CRT09_max_row_scan(reg, max_row_scan) (reg)->bitfields.MAX_ROW_SCAN = max_row_scan
#define set_CRT09_v_blank_start_b9(reg, v_blank_start_b9) (reg)->bitfields.V_BLANK_START_B9 = v_blank_start_b9
#define set_CRT09_line_cmp_b9(reg, line_cmp_b9) (reg)->bitfields.LINE_CMP_B9 = line_cmp_b9
#define set_CRT09_double_char_height(reg, double_char_height) (reg)->bitfields.DOUBLE_CHAR_HEIGHT = double_char_height

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT0A regCRT0A;

#ifdef DEBUG
__inline void set_CRT0A_cursor_start(regCRT0A *reg, unsigned int cursor_start)
{
  reg->bitfields.CURSOR_START = cursor_start;
  if (reg->bitfields.CURSOR_START != cursor_start) HSLDPF(E_ERROR_MESSAGE,"CRT0A::CURSOR_START data too large\n");
}
__inline void set_CRT0A_cursor_disable(regCRT0A *reg, unsigned int cursor_disable)
{
  reg->bitfields.CURSOR_DISABLE = cursor_disable;
  if (reg->bitfields.CURSOR_DISABLE != cursor_disable) HSLDPF(E_ERROR_MESSAGE,"CRT0A::CURSOR_DISABLE data too large\n");
}
#else
#define set_CRT0A_cursor_start(reg, cursor_start) (reg)->bitfields.CURSOR_START = cursor_start
#define set_CRT0A_cursor_disable(reg, cursor_disable) (reg)->bitfields.CURSOR_DISABLE = cursor_disable

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT0B regCRT0B;

#ifdef DEBUG
__inline void set_CRT0B_cursor_end(regCRT0B *reg, unsigned int cursor_end)
{
  reg->bitfields.CURSOR_END = cursor_end;
  if (reg->bitfields.CURSOR_END != cursor_end) HSLDPF(E_ERROR_MESSAGE,"CRT0B::CURSOR_END data too large\n");
}
__inline void set_CRT0B_cursor_skew(regCRT0B *reg, unsigned int cursor_skew)
{
  reg->bitfields.CURSOR_SKEW = cursor_skew;
  if (reg->bitfields.CURSOR_SKEW != cursor_skew) HSLDPF(E_ERROR_MESSAGE,"CRT0B::CURSOR_SKEW data too large\n");
}
#else
#define set_CRT0B_cursor_end(reg, cursor_end) (reg)->bitfields.CURSOR_END = cursor_end
#define set_CRT0B_cursor_skew(reg, cursor_skew) (reg)->bitfields.CURSOR_SKEW = cursor_skew

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT0C regCRT0C;

#ifdef DEBUG
__inline void set_CRT0C_disp_start(regCRT0C *reg, unsigned int disp_start)
{
  reg->bitfields.DISP_START = disp_start;
  if (reg->bitfields.DISP_START != disp_start) HSLDPF(E_ERROR_MESSAGE,"CRT0C::DISP_START data too large\n");
}
#else
#define set_CRT0C_disp_start(reg, disp_start) (reg)->bitfields.DISP_START = disp_start

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT0D regCRT0D;

#ifdef DEBUG
__inline void set_CRT0D_disp_start(regCRT0D *reg, unsigned int disp_start)
{
  reg->bitfields.DISP_START = disp_start;
  if (reg->bitfields.DISP_START != disp_start) HSLDPF(E_ERROR_MESSAGE,"CRT0D::DISP_START data too large\n");
}
#else
#define set_CRT0D_disp_start(reg, disp_start) (reg)->bitfields.DISP_START = disp_start

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT0E regCRT0E;

#ifdef DEBUG
__inline void set_CRT0E_cursor_loc_hi(regCRT0E *reg, unsigned int cursor_loc_hi)
{
  reg->bitfields.CURSOR_LOC_HI = cursor_loc_hi;
  if (reg->bitfields.CURSOR_LOC_HI != cursor_loc_hi) HSLDPF(E_ERROR_MESSAGE,"CRT0E::CURSOR_LOC_HI data too large\n");
}
#else
#define set_CRT0E_cursor_loc_hi(reg, cursor_loc_hi) (reg)->bitfields.CURSOR_LOC_HI = cursor_loc_hi

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT0F regCRT0F;

#ifdef DEBUG
__inline void set_CRT0F_cursor_loc_lo(regCRT0F *reg, unsigned int cursor_loc_lo)
{
  reg->bitfields.CURSOR_LOC_LO = cursor_loc_lo;
  if (reg->bitfields.CURSOR_LOC_LO != cursor_loc_lo) HSLDPF(E_ERROR_MESSAGE,"CRT0F::CURSOR_LOC_LO data too large\n");
}
#else
#define set_CRT0F_cursor_loc_lo(reg, cursor_loc_lo) (reg)->bitfields.CURSOR_LOC_LO = cursor_loc_lo

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT10 regCRT10;

#ifdef DEBUG
__inline void set_CRT10_v_sync_start(regCRT10 *reg, unsigned int v_sync_start)
{
  reg->bitfields.V_SYNC_START = v_sync_start;
  if (reg->bitfields.V_SYNC_START != v_sync_start) HSLDPF(E_ERROR_MESSAGE,"CRT10::V_SYNC_START data too large\n");
}
#else
#define set_CRT10_v_sync_start(reg, v_sync_start) (reg)->bitfields.V_SYNC_START = v_sync_start

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT11 regCRT11;

#ifdef DEBUG
__inline void set_CRT11_v_sync_end(regCRT11 *reg, unsigned int v_sync_end)
{
  reg->bitfields.V_SYNC_END = v_sync_end;
  if (reg->bitfields.V_SYNC_END != v_sync_end) HSLDPF(E_ERROR_MESSAGE,"CRT11::V_SYNC_END data too large\n");
}
__inline void set_CRT11_v_intr_clr(regCRT11 *reg, unsigned int v_intr_clr)
{
  reg->bitfields.V_INTR_CLR = v_intr_clr;
  if (reg->bitfields.V_INTR_CLR != v_intr_clr) HSLDPF(E_ERROR_MESSAGE,"CRT11::V_INTR_CLR data too large\n");
}
__inline void set_CRT11_v_intr_en(regCRT11 *reg, unsigned int v_intr_en)
{
  reg->bitfields.V_INTR_EN = v_intr_en;
  if (reg->bitfields.V_INTR_EN != v_intr_en) HSLDPF(E_ERROR_MESSAGE,"CRT11::V_INTR_EN data too large\n");
}
__inline void set_CRT11_sel5_refresh_cyc(regCRT11 *reg, unsigned int sel5_refresh_cyc)
{
  reg->bitfields.SEL5_REFRESH_CYC = sel5_refresh_cyc;
  if (reg->bitfields.SEL5_REFRESH_CYC != sel5_refresh_cyc) HSLDPF(E_ERROR_MESSAGE,"CRT11::SEL5_REFRESH_CYC data too large\n");
}
__inline void set_CRT11_c0t7_wr_only(regCRT11 *reg, unsigned int c0t7_wr_only)
{
  reg->bitfields.C0T7_WR_ONLY = c0t7_wr_only;
  if (reg->bitfields.C0T7_WR_ONLY != c0t7_wr_only) HSLDPF(E_ERROR_MESSAGE,"CRT11::C0T7_WR_ONLY data too large\n");
}
#else
#define set_CRT11_v_sync_end(reg, v_sync_end) (reg)->bitfields.V_SYNC_END = v_sync_end
#define set_CRT11_v_intr_clr(reg, v_intr_clr) (reg)->bitfields.V_INTR_CLR = v_intr_clr
#define set_CRT11_v_intr_en(reg, v_intr_en) (reg)->bitfields.V_INTR_EN = v_intr_en
#define set_CRT11_sel5_refresh_cyc(reg, sel5_refresh_cyc) (reg)->bitfields.SEL5_REFRESH_CYC = sel5_refresh_cyc
#define set_CRT11_c0t7_wr_only(reg, c0t7_wr_only) (reg)->bitfields.C0T7_WR_ONLY = c0t7_wr_only

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT12 regCRT12;

#ifdef DEBUG
__inline void set_CRT12_v_disp_end(regCRT12 *reg, unsigned int v_disp_end)
{
  reg->bitfields.V_DISP_END = v_disp_end;
  if (reg->bitfields.V_DISP_END != v_disp_end) HSLDPF(E_ERROR_MESSAGE,"CRT12::V_DISP_END data too large\n");
}
#else
#define set_CRT12_v_disp_end(reg, v_disp_end) (reg)->bitfields.V_DISP_END = v_disp_end

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT13 regCRT13;

#ifdef DEBUG
__inline void set_CRT13_disp_pitch(regCRT13 *reg, unsigned int disp_pitch)
{
  reg->bitfields.DISP_PITCH = disp_pitch;
  if (reg->bitfields.DISP_PITCH != disp_pitch) HSLDPF(E_ERROR_MESSAGE,"CRT13::DISP_PITCH data too large\n");
}
#else
#define set_CRT13_disp_pitch(reg, disp_pitch) (reg)->bitfields.DISP_PITCH = disp_pitch

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT15 regCRT15;

#ifdef DEBUG
__inline void set_CRT15_v_blank_start(regCRT15 *reg, unsigned int v_blank_start)
{
  reg->bitfields.V_BLANK_START = v_blank_start;
  if (reg->bitfields.V_BLANK_START != v_blank_start) HSLDPF(E_ERROR_MESSAGE,"CRT15::V_BLANK_START data too large\n");
}
#else
#define set_CRT15_v_blank_start(reg, v_blank_start) (reg)->bitfields.V_BLANK_START = v_blank_start

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT16 regCRT16;

#ifdef DEBUG
__inline void set_CRT16_v_blank_end(regCRT16 *reg, unsigned int v_blank_end)
{
  reg->bitfields.V_BLANK_END = v_blank_end;
  if (reg->bitfields.V_BLANK_END != v_blank_end) HSLDPF(E_ERROR_MESSAGE,"CRT16::V_BLANK_END data too large\n");
}
#else
#define set_CRT16_v_blank_end(reg, v_blank_end) (reg)->bitfields.V_BLANK_END = v_blank_end

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT18 regCRT18;

#ifdef DEBUG
__inline void set_CRT18_line_cmp(regCRT18 *reg, unsigned int line_cmp)
{
  reg->bitfields.LINE_CMP = line_cmp;
  if (reg->bitfields.LINE_CMP != line_cmp) HSLDPF(E_ERROR_MESSAGE,"CRT18::LINE_CMP data too large\n");
}
#else
#define set_CRT18_line_cmp(reg, line_cmp) (reg)->bitfields.LINE_CMP = line_cmp

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT00_S regCRT00_S;

#ifdef DEBUG
__inline void set_CRT00_S_h_total_s(regCRT00_S *reg, unsigned int h_total_s)
{
  reg->bitfields.H_TOTAL_S = h_total_s;
  if (reg->bitfields.H_TOTAL_S != h_total_s) HSLDPF(E_ERROR_MESSAGE,"CRT00_S::H_TOTAL_S data too large\n");
}
#else
#define set_CRT00_S_h_total_s(reg, h_total_s) (reg)->bitfields.H_TOTAL_S = h_total_s

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT01_S regCRT01_S;

#ifdef DEBUG
__inline void set_CRT01_S_h_disp_end_s(regCRT01_S *reg, unsigned int h_disp_end_s)
{
  reg->bitfields.H_DISP_END_S = h_disp_end_s;
  if (reg->bitfields.H_DISP_END_S != h_disp_end_s) HSLDPF(E_ERROR_MESSAGE,"CRT01_S::H_DISP_END_S data too large\n");
}
#else
#define set_CRT01_S_h_disp_end_s(reg, h_disp_end_s) (reg)->bitfields.H_DISP_END_S = h_disp_end_s

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT02_S regCRT02_S;

#ifdef DEBUG
__inline void set_CRT02_S_h_blank_start_s(regCRT02_S *reg, unsigned int h_blank_start_s)
{
  reg->bitfields.H_BLANK_START_S = h_blank_start_s;
  if (reg->bitfields.H_BLANK_START_S != h_blank_start_s) HSLDPF(E_ERROR_MESSAGE,"CRT02_S::H_BLANK_START_S data too large\n");
}
#else
#define set_CRT02_S_h_blank_start_s(reg, h_blank_start_s) (reg)->bitfields.H_BLANK_START_S = h_blank_start_s

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT03_S regCRT03_S;

#ifdef DEBUG
__inline void set_CRT03_S_h_blank_end_s(regCRT03_S *reg, unsigned int h_blank_end_s)
{
  reg->bitfields.H_BLANK_END_S = h_blank_end_s;
  if (reg->bitfields.H_BLANK_END_S != h_blank_end_s) HSLDPF(E_ERROR_MESSAGE,"CRT03_S::H_BLANK_END_S data too large\n");
}
__inline void set_CRT03_S_h_de_skew_s(regCRT03_S *reg, unsigned int h_de_skew_s)
{
  reg->bitfields.H_DE_SKEW_S = h_de_skew_s;
  if (reg->bitfields.H_DE_SKEW_S != h_de_skew_s) HSLDPF(E_ERROR_MESSAGE,"CRT03_S::H_DE_SKEW_S data too large\n");
}
__inline void set_CRT03_S_cr10cr11_r_dis_b_m(regCRT03_S *reg, unsigned int cr10cr11_r_dis_b_m)
{
  reg->bitfields.CR10CR11_R_DIS_B_M = cr10cr11_r_dis_b_m;
  if (reg->bitfields.CR10CR11_R_DIS_B_M != cr10cr11_r_dis_b_m) HSLDPF(E_ERROR_MESSAGE,"CRT03_S::CR10CR11_R_DIS_B_M data too large\n");
}
#else
#define set_CRT03_S_h_blank_end_s(reg, h_blank_end_s) (reg)->bitfields.H_BLANK_END_S = h_blank_end_s
#define set_CRT03_S_h_de_skew_s(reg, h_de_skew_s) (reg)->bitfields.H_DE_SKEW_S = h_de_skew_s
#define set_CRT03_S_cr10cr11_r_dis_b_m(reg, cr10cr11_r_dis_b_m) (reg)->bitfields.CR10CR11_R_DIS_B_M = cr10cr11_r_dis_b_m

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT04_S regCRT04_S;

#ifdef DEBUG
__inline void set_CRT04_S_h_sync_start_s(regCRT04_S *reg, unsigned int h_sync_start_s)
{
  reg->bitfields.H_SYNC_START_S = h_sync_start_s;
  if (reg->bitfields.H_SYNC_START_S != h_sync_start_s) HSLDPF(E_ERROR_MESSAGE,"CRT04_S::H_SYNC_START_S data too large\n");
}
#else
#define set_CRT04_S_h_sync_start_s(reg, h_sync_start_s) (reg)->bitfields.H_SYNC_START_S = h_sync_start_s

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT05_S regCRT05_S;

#ifdef DEBUG
__inline void set_CRT05_S_h_sync_end_s(regCRT05_S *reg, unsigned int h_sync_end_s)
{
  reg->bitfields.H_SYNC_END_S = h_sync_end_s;
  if (reg->bitfields.H_SYNC_END_S != h_sync_end_s) HSLDPF(E_ERROR_MESSAGE,"CRT05_S::H_SYNC_END_S data too large\n");
}
__inline void set_CRT05_S_h_sync_skew_s(regCRT05_S *reg, unsigned int h_sync_skew_s)
{
  reg->bitfields.H_SYNC_SKEW_S = h_sync_skew_s;
  if (reg->bitfields.H_SYNC_SKEW_S != h_sync_skew_s) HSLDPF(E_ERROR_MESSAGE,"CRT05_S::H_SYNC_SKEW_S data too large\n");
}
__inline void set_CRT05_S_h_blank_end_b5_s(regCRT05_S *reg, unsigned int h_blank_end_b5_s)
{
  reg->bitfields.H_BLANK_END_B5_S = h_blank_end_b5_s;
  if (reg->bitfields.H_BLANK_END_B5_S != h_blank_end_b5_s) HSLDPF(E_ERROR_MESSAGE,"CRT05_S::H_BLANK_END_B5_S data too large\n");
}
#else
#define set_CRT05_S_h_sync_end_s(reg, h_sync_end_s) (reg)->bitfields.H_SYNC_END_S = h_sync_end_s
#define set_CRT05_S_h_sync_skew_s(reg, h_sync_skew_s) (reg)->bitfields.H_SYNC_SKEW_S = h_sync_skew_s
#define set_CRT05_S_h_blank_end_b5_s(reg, h_blank_end_b5_s) (reg)->bitfields.H_BLANK_END_B5_S = h_blank_end_b5_s

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT06_S regCRT06_S;

#ifdef DEBUG
__inline void set_CRT06_S_v_total_s(regCRT06_S *reg, unsigned int v_total_s)
{
  reg->bitfields.V_TOTAL_S = v_total_s;
  if (reg->bitfields.V_TOTAL_S != v_total_s) HSLDPF(E_ERROR_MESSAGE,"CRT06_S::V_TOTAL_S data too large\n");
}
#else
#define set_CRT06_S_v_total_s(reg, v_total_s) (reg)->bitfields.V_TOTAL_S = v_total_s

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT07_S regCRT07_S;

#ifdef DEBUG
__inline void set_CRT07_S_v_total_b8_s(regCRT07_S *reg, unsigned int v_total_b8_s)
{
  reg->bitfields.V_TOTAL_B8_S = v_total_b8_s;
  if (reg->bitfields.V_TOTAL_B8_S != v_total_b8_s) HSLDPF(E_ERROR_MESSAGE,"CRT07_S::V_TOTAL_B8_S data too large\n");
}
__inline void set_CRT07_S_v_disp_end_b8_s(regCRT07_S *reg, unsigned int v_disp_end_b8_s)
{
  reg->bitfields.V_DISP_END_B8_S = v_disp_end_b8_s;
  if (reg->bitfields.V_DISP_END_B8_S != v_disp_end_b8_s) HSLDPF(E_ERROR_MESSAGE,"CRT07_S::V_DISP_END_B8_S data too large\n");
}
__inline void set_CRT07_S_v_sync_start_b8_s(regCRT07_S *reg, unsigned int v_sync_start_b8_s)
{
  reg->bitfields.V_SYNC_START_B8_S = v_sync_start_b8_s;
  if (reg->bitfields.V_SYNC_START_B8_S != v_sync_start_b8_s) HSLDPF(E_ERROR_MESSAGE,"CRT07_S::V_SYNC_START_B8_S data too large\n");
}
__inline void set_CRT07_S_v_blank_start_b8_s(regCRT07_S *reg, unsigned int v_blank_start_b8_s)
{
  reg->bitfields.V_BLANK_START_B8_S = v_blank_start_b8_s;
  if (reg->bitfields.V_BLANK_START_B8_S != v_blank_start_b8_s) HSLDPF(E_ERROR_MESSAGE,"CRT07_S::V_BLANK_START_B8_S data too large\n");
}
__inline void set_CRT07_S_line_cmp_b8_m(regCRT07_S *reg, unsigned int line_cmp_b8_m)
{
  reg->bitfields.LINE_CMP_B8_M = line_cmp_b8_m;
  if (reg->bitfields.LINE_CMP_B8_M != line_cmp_b8_m) HSLDPF(E_ERROR_MESSAGE,"CRT07_S::LINE_CMP_B8_M data too large\n");
}
__inline void set_CRT07_S_v_total_b9_s(regCRT07_S *reg, unsigned int v_total_b9_s)
{
  reg->bitfields.V_TOTAL_B9_S = v_total_b9_s;
  if (reg->bitfields.V_TOTAL_B9_S != v_total_b9_s) HSLDPF(E_ERROR_MESSAGE,"CRT07_S::V_TOTAL_B9_S data too large\n");
}
__inline void set_CRT07_S_v_disp_end_b9_s(regCRT07_S *reg, unsigned int v_disp_end_b9_s)
{
  reg->bitfields.V_DISP_END_B9_S = v_disp_end_b9_s;
  if (reg->bitfields.V_DISP_END_B9_S != v_disp_end_b9_s) HSLDPF(E_ERROR_MESSAGE,"CRT07_S::V_DISP_END_B9_S data too large\n");
}
__inline void set_CRT07_S_v_sync_start_b9_s(regCRT07_S *reg, unsigned int v_sync_start_b9_s)
{
  reg->bitfields.V_SYNC_START_B9_S = v_sync_start_b9_s;
  if (reg->bitfields.V_SYNC_START_B9_S != v_sync_start_b9_s) HSLDPF(E_ERROR_MESSAGE,"CRT07_S::V_SYNC_START_B9_S data too large\n");
}
#else
#define set_CRT07_S_v_total_b8_s(reg, v_total_b8_s) (reg)->bitfields.V_TOTAL_B8_S = v_total_b8_s
#define set_CRT07_S_v_disp_end_b8_s(reg, v_disp_end_b8_s) (reg)->bitfields.V_DISP_END_B8_S = v_disp_end_b8_s
#define set_CRT07_S_v_sync_start_b8_s(reg, v_sync_start_b8_s) (reg)->bitfields.V_SYNC_START_B8_S = v_sync_start_b8_s
#define set_CRT07_S_v_blank_start_b8_s(reg, v_blank_start_b8_s) (reg)->bitfields.V_BLANK_START_B8_S = v_blank_start_b8_s
#define set_CRT07_S_line_cmp_b8_m(reg, line_cmp_b8_m) (reg)->bitfields.LINE_CMP_B8_M = line_cmp_b8_m
#define set_CRT07_S_v_total_b9_s(reg, v_total_b9_s) (reg)->bitfields.V_TOTAL_B9_S = v_total_b9_s
#define set_CRT07_S_v_disp_end_b9_s(reg, v_disp_end_b9_s) (reg)->bitfields.V_DISP_END_B9_S = v_disp_end_b9_s
#define set_CRT07_S_v_sync_start_b9_s(reg, v_sync_start_b9_s) (reg)->bitfields.V_SYNC_START_B9_S = v_sync_start_b9_s

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT08_S regCRT08_S;

#ifdef DEBUG
__inline void set_CRT08_S_row_scan_start_m(regCRT08_S *reg, unsigned int row_scan_start_m)
{
  reg->bitfields.ROW_SCAN_START_M = row_scan_start_m;
  if (reg->bitfields.ROW_SCAN_START_M != row_scan_start_m) HSLDPF(E_ERROR_MESSAGE,"CRT08_S::ROW_SCAN_START_M data too large\n");
}
__inline void set_CRT08_S_byte_pan_m(regCRT08_S *reg, unsigned int byte_pan_m)
{
  reg->bitfields.BYTE_PAN_M = byte_pan_m;
  if (reg->bitfields.BYTE_PAN_M != byte_pan_m) HSLDPF(E_ERROR_MESSAGE,"CRT08_S::BYTE_PAN_M data too large\n");
}
#else
#define set_CRT08_S_row_scan_start_m(reg, row_scan_start_m) (reg)->bitfields.ROW_SCAN_START_M = row_scan_start_m
#define set_CRT08_S_byte_pan_m(reg, byte_pan_m) (reg)->bitfields.BYTE_PAN_M = byte_pan_m

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT09_S regCRT09_S;

#ifdef DEBUG
__inline void set_CRT09_S_max_row_scan_s(regCRT09_S *reg, unsigned int max_row_scan_s)
{
  reg->bitfields.MAX_ROW_SCAN_S = max_row_scan_s;
  if (reg->bitfields.MAX_ROW_SCAN_S != max_row_scan_s) HSLDPF(E_ERROR_MESSAGE,"CRT09_S::MAX_ROW_SCAN_S data too large\n");
}
__inline void set_CRT09_S_v_blank_start_b9_s(regCRT09_S *reg, unsigned int v_blank_start_b9_s)
{
  reg->bitfields.V_BLANK_START_B9_S = v_blank_start_b9_s;
  if (reg->bitfields.V_BLANK_START_B9_S != v_blank_start_b9_s) HSLDPF(E_ERROR_MESSAGE,"CRT09_S::V_BLANK_START_B9_S data too large\n");
}
__inline void set_CRT09_S_line_cmp_b9_m(regCRT09_S *reg, unsigned int line_cmp_b9_m)
{
  reg->bitfields.LINE_CMP_B9_M = line_cmp_b9_m;
  if (reg->bitfields.LINE_CMP_B9_M != line_cmp_b9_m) HSLDPF(E_ERROR_MESSAGE,"CRT09_S::LINE_CMP_B9_M data too large\n");
}
__inline void set_CRT09_S_double_char_height_m(regCRT09_S *reg, unsigned int double_char_height_m)
{
  reg->bitfields.DOUBLE_CHAR_HEIGHT_M = double_char_height_m;
  if (reg->bitfields.DOUBLE_CHAR_HEIGHT_M != double_char_height_m) HSLDPF(E_ERROR_MESSAGE,"CRT09_S::DOUBLE_CHAR_HEIGHT_M data too large\n");
}
#else
#define set_CRT09_S_max_row_scan_s(reg, max_row_scan_s) (reg)->bitfields.MAX_ROW_SCAN_S = max_row_scan_s
#define set_CRT09_S_v_blank_start_b9_s(reg, v_blank_start_b9_s) (reg)->bitfields.V_BLANK_START_B9_S = v_blank_start_b9_s
#define set_CRT09_S_line_cmp_b9_m(reg, line_cmp_b9_m) (reg)->bitfields.LINE_CMP_B9_M = line_cmp_b9_m
#define set_CRT09_S_double_char_height_m(reg, double_char_height_m) (reg)->bitfields.DOUBLE_CHAR_HEIGHT_M = double_char_height_m

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT0A_S regCRT0A_S;

#ifdef DEBUG
__inline void set_CRT0A_S_cursor_start_s(regCRT0A_S *reg, unsigned int cursor_start_s)
{
  reg->bitfields.CURSOR_START_S = cursor_start_s;
  if (reg->bitfields.CURSOR_START_S != cursor_start_s) HSLDPF(E_ERROR_MESSAGE,"CRT0A_S::CURSOR_START_S data too large\n");
}
__inline void set_CRT0A_S_cursor_disable_m(regCRT0A_S *reg, unsigned int cursor_disable_m)
{
  reg->bitfields.CURSOR_DISABLE_M = cursor_disable_m;
  if (reg->bitfields.CURSOR_DISABLE_M != cursor_disable_m) HSLDPF(E_ERROR_MESSAGE,"CRT0A_S::CURSOR_DISABLE_M data too large\n");
}
#else
#define set_CRT0A_S_cursor_start_s(reg, cursor_start_s) (reg)->bitfields.CURSOR_START_S = cursor_start_s
#define set_CRT0A_S_cursor_disable_m(reg, cursor_disable_m) (reg)->bitfields.CURSOR_DISABLE_M = cursor_disable_m

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT0B_S regCRT0B_S;

#ifdef DEBUG
__inline void set_CRT0B_S_cursor_end_s(regCRT0B_S *reg, unsigned int cursor_end_s)
{
  reg->bitfields.CURSOR_END_S = cursor_end_s;
  if (reg->bitfields.CURSOR_END_S != cursor_end_s) HSLDPF(E_ERROR_MESSAGE,"CRT0B_S::CURSOR_END_S data too large\n");
}
__inline void set_CRT0B_S_cursor_skew_m(regCRT0B_S *reg, unsigned int cursor_skew_m)
{
  reg->bitfields.CURSOR_SKEW_M = cursor_skew_m;
  if (reg->bitfields.CURSOR_SKEW_M != cursor_skew_m) HSLDPF(E_ERROR_MESSAGE,"CRT0B_S::CURSOR_SKEW_M data too large\n");
}
#else
#define set_CRT0B_S_cursor_end_s(reg, cursor_end_s) (reg)->bitfields.CURSOR_END_S = cursor_end_s
#define set_CRT0B_S_cursor_skew_m(reg, cursor_skew_m) (reg)->bitfields.CURSOR_SKEW_M = cursor_skew_m

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT0C_S regCRT0C_S;

#ifdef DEBUG
__inline void set_CRT0C_S_disp_start_m(regCRT0C_S *reg, unsigned int disp_start_m)
{
  reg->bitfields.DISP_START_M = disp_start_m;
  if (reg->bitfields.DISP_START_M != disp_start_m) HSLDPF(E_ERROR_MESSAGE,"CRT0C_S::DISP_START_M data too large\n");
}
#else
#define set_CRT0C_S_disp_start_m(reg, disp_start_m) (reg)->bitfields.DISP_START_M = disp_start_m

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT0D_S regCRT0D_S;

#ifdef DEBUG
__inline void set_CRT0D_S_disp_start_m(regCRT0D_S *reg, unsigned int disp_start_m)
{
  reg->bitfields.DISP_START_M = disp_start_m;
  if (reg->bitfields.DISP_START_M != disp_start_m) HSLDPF(E_ERROR_MESSAGE,"CRT0D_S::DISP_START_M data too large\n");
}
#else
#define set_CRT0D_S_disp_start_m(reg, disp_start_m) (reg)->bitfields.DISP_START_M = disp_start_m

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT0E_S regCRT0E_S;

#ifdef DEBUG
__inline void set_CRT0E_S_cursor_loc_hi_m(regCRT0E_S *reg, unsigned int cursor_loc_hi_m)
{
  reg->bitfields.CURSOR_LOC_HI_M = cursor_loc_hi_m;
  if (reg->bitfields.CURSOR_LOC_HI_M != cursor_loc_hi_m) HSLDPF(E_ERROR_MESSAGE,"CRT0E_S::CURSOR_LOC_HI_M data too large\n");
}
#else
#define set_CRT0E_S_cursor_loc_hi_m(reg, cursor_loc_hi_m) (reg)->bitfields.CURSOR_LOC_HI_M = cursor_loc_hi_m

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT0F_S regCRT0F_S;

#ifdef DEBUG
__inline void set_CRT0F_S_cursor_loc_lo_m(regCRT0F_S *reg, unsigned int cursor_loc_lo_m)
{
  reg->bitfields.CURSOR_LOC_LO_M = cursor_loc_lo_m;
  if (reg->bitfields.CURSOR_LOC_LO_M != cursor_loc_lo_m) HSLDPF(E_ERROR_MESSAGE,"CRT0F_S::CURSOR_LOC_LO_M data too large\n");
}
#else
#define set_CRT0F_S_cursor_loc_lo_m(reg, cursor_loc_lo_m) (reg)->bitfields.CURSOR_LOC_LO_M = cursor_loc_lo_m

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT10_S regCRT10_S;

#ifdef DEBUG
__inline void set_CRT10_S_v_sync_start_s(regCRT10_S *reg, unsigned int v_sync_start_s)
{
  reg->bitfields.V_SYNC_START_S = v_sync_start_s;
  if (reg->bitfields.V_SYNC_START_S != v_sync_start_s) HSLDPF(E_ERROR_MESSAGE,"CRT10_S::V_SYNC_START_S data too large\n");
}
#else
#define set_CRT10_S_v_sync_start_s(reg, v_sync_start_s) (reg)->bitfields.V_SYNC_START_S = v_sync_start_s

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT11_S regCRT11_S;

#ifdef DEBUG
__inline void set_CRT11_S_v_sync_end_s(regCRT11_S *reg, unsigned int v_sync_end_s)
{
  reg->bitfields.V_SYNC_END_S = v_sync_end_s;
  if (reg->bitfields.V_SYNC_END_S != v_sync_end_s) HSLDPF(E_ERROR_MESSAGE,"CRT11_S::V_SYNC_END_S data too large\n");
}
__inline void set_CRT11_S_v_intr_clr_m(regCRT11_S *reg, unsigned int v_intr_clr_m)
{
  reg->bitfields.V_INTR_CLR_M = v_intr_clr_m;
  if (reg->bitfields.V_INTR_CLR_M != v_intr_clr_m) HSLDPF(E_ERROR_MESSAGE,"CRT11_S::V_INTR_CLR_M data too large\n");
}
__inline void set_CRT11_S_v_intr_en_m(regCRT11_S *reg, unsigned int v_intr_en_m)
{
  reg->bitfields.V_INTR_EN_M = v_intr_en_m;
  if (reg->bitfields.V_INTR_EN_M != v_intr_en_m) HSLDPF(E_ERROR_MESSAGE,"CRT11_S::V_INTR_EN_M data too large\n");
}
__inline void set_CRT11_S_sel5_refresh_cyc_m(regCRT11_S *reg, unsigned int sel5_refresh_cyc_m)
{
  reg->bitfields.SEL5_REFRESH_CYC_M = sel5_refresh_cyc_m;
  if (reg->bitfields.SEL5_REFRESH_CYC_M != sel5_refresh_cyc_m) HSLDPF(E_ERROR_MESSAGE,"CRT11_S::SEL5_REFRESH_CYC_M data too large\n");
}
__inline void set_CRT11_S_c0t7_wr_only_m(regCRT11_S *reg, unsigned int c0t7_wr_only_m)
{
  reg->bitfields.C0T7_WR_ONLY_M = c0t7_wr_only_m;
  if (reg->bitfields.C0T7_WR_ONLY_M != c0t7_wr_only_m) HSLDPF(E_ERROR_MESSAGE,"CRT11_S::C0T7_WR_ONLY_M data too large\n");
}
#else
#define set_CRT11_S_v_sync_end_s(reg, v_sync_end_s) (reg)->bitfields.V_SYNC_END_S = v_sync_end_s
#define set_CRT11_S_v_intr_clr_m(reg, v_intr_clr_m) (reg)->bitfields.V_INTR_CLR_M = v_intr_clr_m
#define set_CRT11_S_v_intr_en_m(reg, v_intr_en_m) (reg)->bitfields.V_INTR_EN_M = v_intr_en_m
#define set_CRT11_S_sel5_refresh_cyc_m(reg, sel5_refresh_cyc_m) (reg)->bitfields.SEL5_REFRESH_CYC_M = sel5_refresh_cyc_m
#define set_CRT11_S_c0t7_wr_only_m(reg, c0t7_wr_only_m) (reg)->bitfields.C0T7_WR_ONLY_M = c0t7_wr_only_m

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT12_S regCRT12_S;

#ifdef DEBUG
__inline void set_CRT12_S_v_disp_end_s(regCRT12_S *reg, unsigned int v_disp_end_s)
{
  reg->bitfields.V_DISP_END_S = v_disp_end_s;
  if (reg->bitfields.V_DISP_END_S != v_disp_end_s) HSLDPF(E_ERROR_MESSAGE,"CRT12_S::V_DISP_END_S data too large\n");
}
#else
#define set_CRT12_S_v_disp_end_s(reg, v_disp_end_s) (reg)->bitfields.V_DISP_END_S = v_disp_end_s

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT13_S regCRT13_S;

#ifdef DEBUG
__inline void set_CRT13_S_disp_pitch_m(regCRT13_S *reg, unsigned int disp_pitch_m)
{
  reg->bitfields.DISP_PITCH_M = disp_pitch_m;
  if (reg->bitfields.DISP_PITCH_M != disp_pitch_m) HSLDPF(E_ERROR_MESSAGE,"CRT13_S::DISP_PITCH_M data too large\n");
}
#else
#define set_CRT13_S_disp_pitch_m(reg, disp_pitch_m) (reg)->bitfields.DISP_PITCH_M = disp_pitch_m

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT15_S regCRT15_S;

#ifdef DEBUG
__inline void set_CRT15_S_v_blank_start_s(regCRT15_S *reg, unsigned int v_blank_start_s)
{
  reg->bitfields.V_BLANK_START_S = v_blank_start_s;
  if (reg->bitfields.V_BLANK_START_S != v_blank_start_s) HSLDPF(E_ERROR_MESSAGE,"CRT15_S::V_BLANK_START_S data too large\n");
}
#else
#define set_CRT15_S_v_blank_start_s(reg, v_blank_start_s) (reg)->bitfields.V_BLANK_START_S = v_blank_start_s

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT16_S regCRT16_S;

#ifdef DEBUG
__inline void set_CRT16_S_v_blank_end_s(regCRT16_S *reg, unsigned int v_blank_end_s)
{
  reg->bitfields.V_BLANK_END_S = v_blank_end_s;
  if (reg->bitfields.V_BLANK_END_S != v_blank_end_s) HSLDPF(E_ERROR_MESSAGE,"CRT16_S::V_BLANK_END_S data too large\n");
}
#else
#define set_CRT16_S_v_blank_end_s(reg, v_blank_end_s) (reg)->bitfields.V_BLANK_END_S = v_blank_end_s

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT18_S regCRT18_S;

#ifdef DEBUG
__inline void set_CRT18_S_line_cmp_m(regCRT18_S *reg, unsigned int line_cmp_m)
{
  reg->bitfields.LINE_CMP_M = line_cmp_m;
  if (reg->bitfields.LINE_CMP_M != line_cmp_m) HSLDPF(E_ERROR_MESSAGE,"CRT18_S::LINE_CMP_M data too large\n");
}
#else
#define set_CRT18_S_line_cmp_m(reg, line_cmp_m) (reg)->bitfields.LINE_CMP_M = line_cmp_m

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTRX regATTRX;

#ifdef DEBUG
__inline void set_ATTRX_attr_idx(regATTRX *reg, unsigned int attr_idx)
{
  reg->bitfields.ATTR_IDX = attr_idx;
  if (reg->bitfields.ATTR_IDX != attr_idx) HSLDPF(E_ERROR_MESSAGE,"ATTRX::ATTR_IDX data too large\n");
}
__inline void set_ATTRX_attr_pal_rw_enb(regATTRX *reg, unsigned int attr_pal_rw_enb)
{
  reg->bitfields.ATTR_PAL_RW_ENB = attr_pal_rw_enb;
  if (reg->bitfields.ATTR_PAL_RW_ENB != attr_pal_rw_enb) HSLDPF(E_ERROR_MESSAGE,"ATTRX::ATTR_PAL_RW_ENB data too large\n");
}
#else
#define set_ATTRX_attr_idx(reg, attr_idx) (reg)->bitfields.ATTR_IDX = attr_idx
#define set_ATTRX_attr_pal_rw_enb(reg, attr_pal_rw_enb) (reg)->bitfields.ATTR_PAL_RW_ENB = attr_pal_rw_enb

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTRDW regATTRDW;

#ifdef DEBUG
__inline void set_ATTRDW_attr_data(regATTRDW *reg, unsigned int attr_data)
{
  reg->bitfields.ATTR_DATA = attr_data;
  if (reg->bitfields.ATTR_DATA != attr_data) HSLDPF(E_ERROR_MESSAGE,"ATTRDW::ATTR_DATA data too large\n");
}
#else
#define set_ATTRDW_attr_data(reg, attr_data) (reg)->bitfields.ATTR_DATA = attr_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTRDR regATTRDR;

#ifdef DEBUG
__inline void set_ATTRDR_attr_data(regATTRDR *reg, unsigned int attr_data)
{
  reg->bitfields.ATTR_DATA = attr_data;
  if (reg->bitfields.ATTR_DATA != attr_data) HSLDPF(E_ERROR_MESSAGE,"ATTRDR::ATTR_DATA data too large\n");
}
#else
#define set_ATTRDR_attr_data(reg, attr_data) (reg)->bitfields.ATTR_DATA = attr_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTR00 regATTR00;

#ifdef DEBUG
__inline void set_ATTR00_attr_pal(regATTR00 *reg, unsigned int attr_pal)
{
  reg->bitfields.ATTR_PAL = attr_pal;
  if (reg->bitfields.ATTR_PAL != attr_pal) HSLDPF(E_ERROR_MESSAGE,"ATTR00::ATTR_PAL data too large\n");
}
#else
#define set_ATTR00_attr_pal(reg, attr_pal) (reg)->bitfields.ATTR_PAL = attr_pal

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTR01 regATTR01;

#ifdef DEBUG
__inline void set_ATTR01_attr_pal(regATTR01 *reg, unsigned int attr_pal)
{
  reg->bitfields.ATTR_PAL = attr_pal;
  if (reg->bitfields.ATTR_PAL != attr_pal) HSLDPF(E_ERROR_MESSAGE,"ATTR01::ATTR_PAL data too large\n");
}
#else
#define set_ATTR01_attr_pal(reg, attr_pal) (reg)->bitfields.ATTR_PAL = attr_pal

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTR02 regATTR02;

#ifdef DEBUG
__inline void set_ATTR02_attr_pal(regATTR02 *reg, unsigned int attr_pal)
{
  reg->bitfields.ATTR_PAL = attr_pal;
  if (reg->bitfields.ATTR_PAL != attr_pal) HSLDPF(E_ERROR_MESSAGE,"ATTR02::ATTR_PAL data too large\n");
}
#else
#define set_ATTR02_attr_pal(reg, attr_pal) (reg)->bitfields.ATTR_PAL = attr_pal

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTR03 regATTR03;

#ifdef DEBUG
__inline void set_ATTR03_attr_pal(regATTR03 *reg, unsigned int attr_pal)
{
  reg->bitfields.ATTR_PAL = attr_pal;
  if (reg->bitfields.ATTR_PAL != attr_pal) HSLDPF(E_ERROR_MESSAGE,"ATTR03::ATTR_PAL data too large\n");
}
#else
#define set_ATTR03_attr_pal(reg, attr_pal) (reg)->bitfields.ATTR_PAL = attr_pal

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTR04 regATTR04;

#ifdef DEBUG
__inline void set_ATTR04_attr_pal(regATTR04 *reg, unsigned int attr_pal)
{
  reg->bitfields.ATTR_PAL = attr_pal;
  if (reg->bitfields.ATTR_PAL != attr_pal) HSLDPF(E_ERROR_MESSAGE,"ATTR04::ATTR_PAL data too large\n");
}
#else
#define set_ATTR04_attr_pal(reg, attr_pal) (reg)->bitfields.ATTR_PAL = attr_pal

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTR05 regATTR05;

#ifdef DEBUG
__inline void set_ATTR05_attr_pal(regATTR05 *reg, unsigned int attr_pal)
{
  reg->bitfields.ATTR_PAL = attr_pal;
  if (reg->bitfields.ATTR_PAL != attr_pal) HSLDPF(E_ERROR_MESSAGE,"ATTR05::ATTR_PAL data too large\n");
}
#else
#define set_ATTR05_attr_pal(reg, attr_pal) (reg)->bitfields.ATTR_PAL = attr_pal

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTR06 regATTR06;

#ifdef DEBUG
__inline void set_ATTR06_attr_pal(regATTR06 *reg, unsigned int attr_pal)
{
  reg->bitfields.ATTR_PAL = attr_pal;
  if (reg->bitfields.ATTR_PAL != attr_pal) HSLDPF(E_ERROR_MESSAGE,"ATTR06::ATTR_PAL data too large\n");
}
#else
#define set_ATTR06_attr_pal(reg, attr_pal) (reg)->bitfields.ATTR_PAL = attr_pal

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTR07 regATTR07;

#ifdef DEBUG
__inline void set_ATTR07_attr_pal(regATTR07 *reg, unsigned int attr_pal)
{
  reg->bitfields.ATTR_PAL = attr_pal;
  if (reg->bitfields.ATTR_PAL != attr_pal) HSLDPF(E_ERROR_MESSAGE,"ATTR07::ATTR_PAL data too large\n");
}
#else
#define set_ATTR07_attr_pal(reg, attr_pal) (reg)->bitfields.ATTR_PAL = attr_pal

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTR08 regATTR08;

#ifdef DEBUG
__inline void set_ATTR08_attr_pal(regATTR08 *reg, unsigned int attr_pal)
{
  reg->bitfields.ATTR_PAL = attr_pal;
  if (reg->bitfields.ATTR_PAL != attr_pal) HSLDPF(E_ERROR_MESSAGE,"ATTR08::ATTR_PAL data too large\n");
}
#else
#define set_ATTR08_attr_pal(reg, attr_pal) (reg)->bitfields.ATTR_PAL = attr_pal

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTR09 regATTR09;

#ifdef DEBUG
__inline void set_ATTR09_attr_pal(regATTR09 *reg, unsigned int attr_pal)
{
  reg->bitfields.ATTR_PAL = attr_pal;
  if (reg->bitfields.ATTR_PAL != attr_pal) HSLDPF(E_ERROR_MESSAGE,"ATTR09::ATTR_PAL data too large\n");
}
#else
#define set_ATTR09_attr_pal(reg, attr_pal) (reg)->bitfields.ATTR_PAL = attr_pal

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTR0A regATTR0A;

#ifdef DEBUG
__inline void set_ATTR0A_attr_pal(regATTR0A *reg, unsigned int attr_pal)
{
  reg->bitfields.ATTR_PAL = attr_pal;
  if (reg->bitfields.ATTR_PAL != attr_pal) HSLDPF(E_ERROR_MESSAGE,"ATTR0A::ATTR_PAL data too large\n");
}
#else
#define set_ATTR0A_attr_pal(reg, attr_pal) (reg)->bitfields.ATTR_PAL = attr_pal

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTR0B regATTR0B;

#ifdef DEBUG
__inline void set_ATTR0B_attr_pal(regATTR0B *reg, unsigned int attr_pal)
{
  reg->bitfields.ATTR_PAL = attr_pal;
  if (reg->bitfields.ATTR_PAL != attr_pal) HSLDPF(E_ERROR_MESSAGE,"ATTR0B::ATTR_PAL data too large\n");
}
#else
#define set_ATTR0B_attr_pal(reg, attr_pal) (reg)->bitfields.ATTR_PAL = attr_pal

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTR0C regATTR0C;

#ifdef DEBUG
__inline void set_ATTR0C_attr_pal(regATTR0C *reg, unsigned int attr_pal)
{
  reg->bitfields.ATTR_PAL = attr_pal;
  if (reg->bitfields.ATTR_PAL != attr_pal) HSLDPF(E_ERROR_MESSAGE,"ATTR0C::ATTR_PAL data too large\n");
}
#else
#define set_ATTR0C_attr_pal(reg, attr_pal) (reg)->bitfields.ATTR_PAL = attr_pal

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTR0D regATTR0D;

#ifdef DEBUG
__inline void set_ATTR0D_attr_pal(regATTR0D *reg, unsigned int attr_pal)
{
  reg->bitfields.ATTR_PAL = attr_pal;
  if (reg->bitfields.ATTR_PAL != attr_pal) HSLDPF(E_ERROR_MESSAGE,"ATTR0D::ATTR_PAL data too large\n");
}
#else
#define set_ATTR0D_attr_pal(reg, attr_pal) (reg)->bitfields.ATTR_PAL = attr_pal

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTR0E regATTR0E;

#ifdef DEBUG
__inline void set_ATTR0E_attr_pal(regATTR0E *reg, unsigned int attr_pal)
{
  reg->bitfields.ATTR_PAL = attr_pal;
  if (reg->bitfields.ATTR_PAL != attr_pal) HSLDPF(E_ERROR_MESSAGE,"ATTR0E::ATTR_PAL data too large\n");
}
#else
#define set_ATTR0E_attr_pal(reg, attr_pal) (reg)->bitfields.ATTR_PAL = attr_pal

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTR0F regATTR0F;

#ifdef DEBUG
__inline void set_ATTR0F_attr_pal(regATTR0F *reg, unsigned int attr_pal)
{
  reg->bitfields.ATTR_PAL = attr_pal;
  if (reg->bitfields.ATTR_PAL != attr_pal) HSLDPF(E_ERROR_MESSAGE,"ATTR0F::ATTR_PAL data too large\n");
}
#else
#define set_ATTR0F_attr_pal(reg, attr_pal) (reg)->bitfields.ATTR_PAL = attr_pal

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTR10 regATTR10;

#ifdef DEBUG
__inline void set_ATTR10_attr_grph_mode(regATTR10 *reg, unsigned int attr_grph_mode)
{
  reg->bitfields.ATTR_GRPH_MODE = attr_grph_mode;
  if (reg->bitfields.ATTR_GRPH_MODE != attr_grph_mode) HSLDPF(E_ERROR_MESSAGE,"ATTR10::ATTR_GRPH_MODE data too large\n");
}
__inline void set_ATTR10_attr_mono_en(regATTR10 *reg, unsigned int attr_mono_en)
{
  reg->bitfields.ATTR_MONO_EN = attr_mono_en;
  if (reg->bitfields.ATTR_MONO_EN != attr_mono_en) HSLDPF(E_ERROR_MESSAGE,"ATTR10::ATTR_MONO_EN data too large\n");
}
__inline void set_ATTR10_attr_lgrph_en(regATTR10 *reg, unsigned int attr_lgrph_en)
{
  reg->bitfields.ATTR_LGRPH_EN = attr_lgrph_en;
  if (reg->bitfields.ATTR_LGRPH_EN != attr_lgrph_en) HSLDPF(E_ERROR_MESSAGE,"ATTR10::ATTR_LGRPH_EN data too large\n");
}
__inline void set_ATTR10_attr_blink_en(regATTR10 *reg, unsigned int attr_blink_en)
{
  reg->bitfields.ATTR_BLINK_EN = attr_blink_en;
  if (reg->bitfields.ATTR_BLINK_EN != attr_blink_en) HSLDPF(E_ERROR_MESSAGE,"ATTR10::ATTR_BLINK_EN data too large\n");
}
__inline void set_ATTR10_attr_pantoponly(regATTR10 *reg, unsigned int attr_pantoponly)
{
  reg->bitfields.ATTR_PANTOPONLY = attr_pantoponly;
  if (reg->bitfields.ATTR_PANTOPONLY != attr_pantoponly) HSLDPF(E_ERROR_MESSAGE,"ATTR10::ATTR_PANTOPONLY data too large\n");
}
__inline void set_ATTR10_attr_pclkby2(regATTR10 *reg, unsigned int attr_pclkby2)
{
  reg->bitfields.ATTR_PCLKBY2 = attr_pclkby2;
  if (reg->bitfields.ATTR_PCLKBY2 != attr_pclkby2) HSLDPF(E_ERROR_MESSAGE,"ATTR10::ATTR_PCLKBY2 data too large\n");
}
__inline void set_ATTR10_attr_csel_en(regATTR10 *reg, unsigned int attr_csel_en)
{
  reg->bitfields.ATTR_CSEL_EN = attr_csel_en;
  if (reg->bitfields.ATTR_CSEL_EN != attr_csel_en) HSLDPF(E_ERROR_MESSAGE,"ATTR10::ATTR_CSEL_EN data too large\n");
}
#else
#define set_ATTR10_attr_grph_mode(reg, attr_grph_mode) (reg)->bitfields.ATTR_GRPH_MODE = attr_grph_mode
#define set_ATTR10_attr_mono_en(reg, attr_mono_en) (reg)->bitfields.ATTR_MONO_EN = attr_mono_en
#define set_ATTR10_attr_lgrph_en(reg, attr_lgrph_en) (reg)->bitfields.ATTR_LGRPH_EN = attr_lgrph_en
#define set_ATTR10_attr_blink_en(reg, attr_blink_en) (reg)->bitfields.ATTR_BLINK_EN = attr_blink_en
#define set_ATTR10_attr_pantoponly(reg, attr_pantoponly) (reg)->bitfields.ATTR_PANTOPONLY = attr_pantoponly
#define set_ATTR10_attr_pclkby2(reg, attr_pclkby2) (reg)->bitfields.ATTR_PCLKBY2 = attr_pclkby2
#define set_ATTR10_attr_csel_en(reg, attr_csel_en) (reg)->bitfields.ATTR_CSEL_EN = attr_csel_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTR11 regATTR11;

#ifdef DEBUG
__inline void set_ATTR11_attr_ovsc(regATTR11 *reg, unsigned int attr_ovsc)
{
  reg->bitfields.ATTR_OVSC = attr_ovsc;
  if (reg->bitfields.ATTR_OVSC != attr_ovsc) HSLDPF(E_ERROR_MESSAGE,"ATTR11::ATTR_OVSC data too large\n");
}
#else
#define set_ATTR11_attr_ovsc(reg, attr_ovsc) (reg)->bitfields.ATTR_OVSC = attr_ovsc

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTR12 regATTR12;

#ifdef DEBUG
__inline void set_ATTR12_attr_map_en(regATTR12 *reg, unsigned int attr_map_en)
{
  reg->bitfields.ATTR_MAP_EN = attr_map_en;
  if (reg->bitfields.ATTR_MAP_EN != attr_map_en) HSLDPF(E_ERROR_MESSAGE,"ATTR12::ATTR_MAP_EN data too large\n");
}
__inline void set_ATTR12_attr_vsmux(regATTR12 *reg, unsigned int attr_vsmux)
{
  reg->bitfields.ATTR_VSMUX = attr_vsmux;
  if (reg->bitfields.ATTR_VSMUX != attr_vsmux) HSLDPF(E_ERROR_MESSAGE,"ATTR12::ATTR_VSMUX data too large\n");
}
#else
#define set_ATTR12_attr_map_en(reg, attr_map_en) (reg)->bitfields.ATTR_MAP_EN = attr_map_en
#define set_ATTR12_attr_vsmux(reg, attr_vsmux) (reg)->bitfields.ATTR_VSMUX = attr_vsmux

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTR13 regATTR13;

#ifdef DEBUG
__inline void set_ATTR13_attr_ppan(regATTR13 *reg, unsigned int attr_ppan)
{
  reg->bitfields.ATTR_PPAN = attr_ppan;
  if (reg->bitfields.ATTR_PPAN != attr_ppan) HSLDPF(E_ERROR_MESSAGE,"ATTR13::ATTR_PPAN data too large\n");
}
#else
#define set_ATTR13_attr_ppan(reg, attr_ppan) (reg)->bitfields.ATTR_PPAN = attr_ppan

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ATTR14 regATTR14;

#ifdef DEBUG
__inline void set_ATTR14_attr_csel1(regATTR14 *reg, unsigned int attr_csel1)
{
  reg->bitfields.ATTR_CSEL1 = attr_csel1;
  if (reg->bitfields.ATTR_CSEL1 != attr_csel1) HSLDPF(E_ERROR_MESSAGE,"ATTR14::ATTR_CSEL1 data too large\n");
}
__inline void set_ATTR14_attr_csel2(regATTR14 *reg, unsigned int attr_csel2)
{
  reg->bitfields.ATTR_CSEL2 = attr_csel2;
  if (reg->bitfields.ATTR_CSEL2 != attr_csel2) HSLDPF(E_ERROR_MESSAGE,"ATTR14::ATTR_CSEL2 data too large\n");
}
#else
#define set_ATTR14_attr_csel1(reg, attr_csel1) (reg)->bitfields.ATTR_CSEL1 = attr_csel1
#define set_ATTR14_attr_csel2(reg, attr_csel2) (reg)->bitfields.ATTR_CSEL2 = attr_csel2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250VCLK_ECP_CNTL regrv250VCLK_ECP_CNTL;

#ifdef DEBUG
__inline void set_rv250VCLK_ECP_CNTL_vclk_src_sel(regrv250VCLK_ECP_CNTL *reg, unsigned int vclk_src_sel)
{
  reg->bitfields.VCLK_SRC_SEL = vclk_src_sel;
  if (reg->bitfields.VCLK_SRC_SEL != vclk_src_sel) HSLDPF(E_ERROR_MESSAGE,"rv250VCLK_ECP_CNTL::VCLK_SRC_SEL data too large\n");
}
__inline void set_rv250VCLK_ECP_CNTL_vclk_invert(regrv250VCLK_ECP_CNTL *reg, unsigned int vclk_invert)
{
  reg->bitfields.VCLK_INVERT = vclk_invert;
  if (reg->bitfields.VCLK_INVERT != vclk_invert) HSLDPF(E_ERROR_MESSAGE,"rv250VCLK_ECP_CNTL::VCLK_INVERT data too large\n");
}
__inline void set_rv250VCLK_ECP_CNTL_pixclk_src_invert(regrv250VCLK_ECP_CNTL *reg, unsigned int pixclk_src_invert)
{
  reg->bitfields.PIXCLK_SRC_INVERT = pixclk_src_invert;
  if (reg->bitfields.PIXCLK_SRC_INVERT != pixclk_src_invert) HSLDPF(E_ERROR_MESSAGE,"rv250VCLK_ECP_CNTL::PIXCLK_SRC_INVERT data too large\n");
}
__inline void set_rv250VCLK_ECP_CNTL_pixclk_always_onb(regrv250VCLK_ECP_CNTL *reg, unsigned int pixclk_always_onb)
{
  reg->bitfields.PIXCLK_ALWAYS_ONb = pixclk_always_onb;
  if (reg->bitfields.PIXCLK_ALWAYS_ONb != pixclk_always_onb) HSLDPF(E_ERROR_MESSAGE,"rv250VCLK_ECP_CNTL::PIXCLK_ALWAYS_ONb data too large\n");
}
__inline void set_rv250VCLK_ECP_CNTL_pixclk_dac_always_onb(regrv250VCLK_ECP_CNTL *reg, unsigned int pixclk_dac_always_onb)
{
  reg->bitfields.PIXCLK_DAC_ALWAYS_ONb = pixclk_dac_always_onb;
  if (reg->bitfields.PIXCLK_DAC_ALWAYS_ONb != pixclk_dac_always_onb) HSLDPF(E_ERROR_MESSAGE,"rv250VCLK_ECP_CNTL::PIXCLK_DAC_ALWAYS_ONb data too large\n");
}
__inline void set_rv250VCLK_ECP_CNTL_ecp_div(regrv250VCLK_ECP_CNTL *reg, unsigned int ecp_div)
{
  reg->bitfields.ECP_DIV = ecp_div;
  if (reg->bitfields.ECP_DIV != ecp_div) HSLDPF(E_ERROR_MESSAGE,"rv250VCLK_ECP_CNTL::ECP_DIV data too large\n");
}
__inline void set_rv250VCLK_ECP_CNTL_ecp_force_on(regrv250VCLK_ECP_CNTL *reg, unsigned int ecp_force_on)
{
  reg->bitfields.ECP_FORCE_ON = ecp_force_on;
  if (reg->bitfields.ECP_FORCE_ON != ecp_force_on) HSLDPF(E_ERROR_MESSAGE,"rv250VCLK_ECP_CNTL::ECP_FORCE_ON data too large\n");
}
__inline void set_rv250VCLK_ECP_CNTL_subclk_force_on(regrv250VCLK_ECP_CNTL *reg, unsigned int subclk_force_on)
{
  reg->bitfields.SUBCLK_FORCE_ON = subclk_force_on;
  if (reg->bitfields.SUBCLK_FORCE_ON != subclk_force_on) HSLDPF(E_ERROR_MESSAGE,"rv250VCLK_ECP_CNTL::SUBCLK_FORCE_ON data too large\n");
}
#else
#define set_rv250VCLK_ECP_CNTL_vclk_src_sel(reg, vclk_src_sel) (reg)->bitfields.VCLK_SRC_SEL = vclk_src_sel
#define set_rv250VCLK_ECP_CNTL_vclk_invert(reg, vclk_invert) (reg)->bitfields.VCLK_INVERT = vclk_invert
#define set_rv250VCLK_ECP_CNTL_pixclk_src_invert(reg, pixclk_src_invert) (reg)->bitfields.PIXCLK_SRC_INVERT = pixclk_src_invert
#define set_rv250VCLK_ECP_CNTL_pixclk_always_onb(reg, pixclk_always_onb) (reg)->bitfields.PIXCLK_ALWAYS_ONb = pixclk_always_onb
#define set_rv250VCLK_ECP_CNTL_pixclk_dac_always_onb(reg, pixclk_dac_always_onb) (reg)->bitfields.PIXCLK_DAC_ALWAYS_ONb = pixclk_dac_always_onb
#define set_rv250VCLK_ECP_CNTL_ecp_div(reg, ecp_div) (reg)->bitfields.ECP_DIV = ecp_div
#define set_rv250VCLK_ECP_CNTL_ecp_force_on(reg, ecp_force_on) (reg)->bitfields.ECP_FORCE_ON = ecp_force_on
#define set_rv250VCLK_ECP_CNTL_subclk_force_on(reg, subclk_force_on) (reg)->bitfields.SUBCLK_FORCE_ON = subclk_force_on

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_TEST_MACRO_RW_WRITE regDISP_TEST_MACRO_RW_WRITE;

#ifdef DEBUG
__inline void set_DISP_TEST_MACRO_RW_WRITE_test_macro_rw_write1(regDISP_TEST_MACRO_RW_WRITE *reg, unsigned int test_macro_rw_write1)
{
  reg->bitfields.TEST_MACRO_RW_WRITE1 = test_macro_rw_write1;
  if (reg->bitfields.TEST_MACRO_RW_WRITE1 != test_macro_rw_write1) HSLDPF(E_ERROR_MESSAGE,"DISP_TEST_MACRO_RW_WRITE::TEST_MACRO_RW_WRITE1 data too large\n");
}
__inline void set_DISP_TEST_MACRO_RW_WRITE_test_macro_rw_write2(regDISP_TEST_MACRO_RW_WRITE *reg, unsigned int test_macro_rw_write2)
{
  reg->bitfields.TEST_MACRO_RW_WRITE2 = test_macro_rw_write2;
  if (reg->bitfields.TEST_MACRO_RW_WRITE2 != test_macro_rw_write2) HSLDPF(E_ERROR_MESSAGE,"DISP_TEST_MACRO_RW_WRITE::TEST_MACRO_RW_WRITE2 data too large\n");
}
#else
#define set_DISP_TEST_MACRO_RW_WRITE_test_macro_rw_write1(reg, test_macro_rw_write1) (reg)->bitfields.TEST_MACRO_RW_WRITE1 = test_macro_rw_write1
#define set_DISP_TEST_MACRO_RW_WRITE_test_macro_rw_write2(reg, test_macro_rw_write2) (reg)->bitfields.TEST_MACRO_RW_WRITE2 = test_macro_rw_write2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_TEST_MACRO_RW_READ regDISP_TEST_MACRO_RW_READ;

#ifdef DEBUG
__inline void set_DISP_TEST_MACRO_RW_READ_test_macro_rw_read1(regDISP_TEST_MACRO_RW_READ *reg, unsigned int test_macro_rw_read1)
{
  reg->bitfields.TEST_MACRO_RW_READ1 = test_macro_rw_read1;
  if (reg->bitfields.TEST_MACRO_RW_READ1 != test_macro_rw_read1) HSLDPF(E_ERROR_MESSAGE,"DISP_TEST_MACRO_RW_READ::TEST_MACRO_RW_READ1 data too large\n");
}
__inline void set_DISP_TEST_MACRO_RW_READ_test_macro_rw_read2(regDISP_TEST_MACRO_RW_READ *reg, unsigned int test_macro_rw_read2)
{
  reg->bitfields.TEST_MACRO_RW_READ2 = test_macro_rw_read2;
  if (reg->bitfields.TEST_MACRO_RW_READ2 != test_macro_rw_read2) HSLDPF(E_ERROR_MESSAGE,"DISP_TEST_MACRO_RW_READ::TEST_MACRO_RW_READ2 data too large\n");
}
#else
#define set_DISP_TEST_MACRO_RW_READ_test_macro_rw_read1(reg, test_macro_rw_read1) (reg)->bitfields.TEST_MACRO_RW_READ1 = test_macro_rw_read1
#define set_DISP_TEST_MACRO_RW_READ_test_macro_rw_read2(reg, test_macro_rw_read2) (reg)->bitfields.TEST_MACRO_RW_READ2 = test_macro_rw_read2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_TEST_MACRO_RW_DATA regDISP_TEST_MACRO_RW_DATA;

#ifdef DEBUG
__inline void set_DISP_TEST_MACRO_RW_DATA_test_macro_rw_data(regDISP_TEST_MACRO_RW_DATA *reg, unsigned int test_macro_rw_data)
{
  reg->bitfields.TEST_MACRO_RW_DATA = test_macro_rw_data;
  if (reg->bitfields.TEST_MACRO_RW_DATA != test_macro_rw_data) HSLDPF(E_ERROR_MESSAGE,"DISP_TEST_MACRO_RW_DATA::TEST_MACRO_RW_DATA data too large\n");
}
#else
#define set_DISP_TEST_MACRO_RW_DATA_test_macro_rw_data(reg, test_macro_rw_data) (reg)->bitfields.TEST_MACRO_RW_DATA = test_macro_rw_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250DISP_TEST_MACRO_RW_CNTL regrv250DISP_TEST_MACRO_RW_CNTL;

#ifdef DEBUG
__inline void set_rv250DISP_TEST_MACRO_RW_CNTL_test_macro_rw_start(regrv250DISP_TEST_MACRO_RW_CNTL *reg, unsigned int test_macro_rw_start)
{
  reg->bitfields.TEST_MACRO_RW_START = test_macro_rw_start;
  if (reg->bitfields.TEST_MACRO_RW_START != test_macro_rw_start) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_TEST_MACRO_RW_CNTL::TEST_MACRO_RW_START data too large\n");
}
__inline void set_rv250DISP_TEST_MACRO_RW_CNTL_test_macro_rw_op(regrv250DISP_TEST_MACRO_RW_CNTL *reg, unsigned int test_macro_rw_op)
{
  reg->bitfields.TEST_MACRO_RW_OP = test_macro_rw_op;
  if (reg->bitfields.TEST_MACRO_RW_OP != test_macro_rw_op) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_TEST_MACRO_RW_CNTL::TEST_MACRO_RW_OP data too large\n");
}
__inline void set_rv250DISP_TEST_MACRO_RW_CNTL_test_macro_rw_mode(regrv250DISP_TEST_MACRO_RW_CNTL *reg, unsigned int test_macro_rw_mode)
{
  reg->bitfields.TEST_MACRO_RW_MODE = test_macro_rw_mode;
  if (reg->bitfields.TEST_MACRO_RW_MODE != test_macro_rw_mode) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_TEST_MACRO_RW_CNTL::TEST_MACRO_RW_MODE data too large\n");
}
__inline void set_rv250DISP_TEST_MACRO_RW_CNTL_test_macro_rw_mismatch_sel(regrv250DISP_TEST_MACRO_RW_CNTL *reg, unsigned int test_macro_rw_mismatch_sel)
{
  reg->bitfields.TEST_MACRO_RW_MISMATCH_SEL = test_macro_rw_mismatch_sel;
  if (reg->bitfields.TEST_MACRO_RW_MISMATCH_SEL != test_macro_rw_mismatch_sel) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_TEST_MACRO_RW_CNTL::TEST_MACRO_RW_MISMATCH_SEL data too large\n");
}
__inline void set_rv250DISP_TEST_MACRO_RW_CNTL_test_macro_rw_mismatch(regrv250DISP_TEST_MACRO_RW_CNTL *reg, unsigned int test_macro_rw_mismatch)
{
  reg->bitfields.TEST_MACRO_RW_MISMATCH = test_macro_rw_mismatch;
  if (reg->bitfields.TEST_MACRO_RW_MISMATCH != test_macro_rw_mismatch) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_TEST_MACRO_RW_CNTL::TEST_MACRO_RW_MISMATCH data too large\n");
}
__inline void set_rv250DISP_TEST_MACRO_RW_CNTL_test_macro_rw_enable(regrv250DISP_TEST_MACRO_RW_CNTL *reg, unsigned int test_macro_rw_enable)
{
  reg->bitfields.TEST_MACRO_RW_ENABLE = test_macro_rw_enable;
  if (reg->bitfields.TEST_MACRO_RW_ENABLE != test_macro_rw_enable) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_TEST_MACRO_RW_CNTL::TEST_MACRO_RW_ENABLE data too large\n");
}
__inline void set_rv250DISP_TEST_MACRO_RW_CNTL_test_macro_rw_sclk_neg_enable(regrv250DISP_TEST_MACRO_RW_CNTL *reg, unsigned int test_macro_rw_sclk_neg_enable)
{
  reg->bitfields.TEST_MACRO_RW_SCLK_NEG_ENABLE = test_macro_rw_sclk_neg_enable;
  if (reg->bitfields.TEST_MACRO_RW_SCLK_NEG_ENABLE != test_macro_rw_sclk_neg_enable) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_TEST_MACRO_RW_CNTL::TEST_MACRO_RW_SCLK_NEG_ENABLE data too large\n");
}
#else
#define set_rv250DISP_TEST_MACRO_RW_CNTL_test_macro_rw_start(reg, test_macro_rw_start) (reg)->bitfields.TEST_MACRO_RW_START = test_macro_rw_start
#define set_rv250DISP_TEST_MACRO_RW_CNTL_test_macro_rw_op(reg, test_macro_rw_op) (reg)->bitfields.TEST_MACRO_RW_OP = test_macro_rw_op
#define set_rv250DISP_TEST_MACRO_RW_CNTL_test_macro_rw_mode(reg, test_macro_rw_mode) (reg)->bitfields.TEST_MACRO_RW_MODE = test_macro_rw_mode
#define set_rv250DISP_TEST_MACRO_RW_CNTL_test_macro_rw_mismatch_sel(reg, test_macro_rw_mismatch_sel) (reg)->bitfields.TEST_MACRO_RW_MISMATCH_SEL = test_macro_rw_mismatch_sel
#define set_rv250DISP_TEST_MACRO_RW_CNTL_test_macro_rw_mismatch(reg, test_macro_rw_mismatch) (reg)->bitfields.TEST_MACRO_RW_MISMATCH = test_macro_rw_mismatch
#define set_rv250DISP_TEST_MACRO_RW_CNTL_test_macro_rw_enable(reg, test_macro_rw_enable) (reg)->bitfields.TEST_MACRO_RW_ENABLE = test_macro_rw_enable
#define set_rv250DISP_TEST_MACRO_RW_CNTL_test_macro_rw_sclk_neg_enable(reg, test_macro_rw_sclk_neg_enable) (reg)->bitfields.TEST_MACRO_RW_SCLK_NEG_ENABLE = test_macro_rw_sclk_neg_enable

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250PIXCLKS_CNTL regrv250PIXCLKS_CNTL;

#ifdef DEBUG
__inline void set_rv250PIXCLKS_CNTL_pix2clk_src_sel(regrv250PIXCLKS_CNTL *reg, unsigned int pix2clk_src_sel)
{
  reg->bitfields.PIX2CLK_SRC_SEL = pix2clk_src_sel;
  if (reg->bitfields.PIX2CLK_SRC_SEL != pix2clk_src_sel) HSLDPF(E_ERROR_MESSAGE,"rv250PIXCLKS_CNTL::PIX2CLK_SRC_SEL data too large\n");
}
__inline void set_rv250PIXCLKS_CNTL_pix2clk_invert(regrv250PIXCLKS_CNTL *reg, unsigned int pix2clk_invert)
{
  reg->bitfields.PIX2CLK_INVERT = pix2clk_invert;
  if (reg->bitfields.PIX2CLK_INVERT != pix2clk_invert) HSLDPF(E_ERROR_MESSAGE,"rv250PIXCLKS_CNTL::PIX2CLK_INVERT data too large\n");
}
__inline void set_rv250PIXCLKS_CNTL_pix2clk_src_invert(regrv250PIXCLKS_CNTL *reg, unsigned int pix2clk_src_invert)
{
  reg->bitfields.PIX2CLK_SRC_INVERT = pix2clk_src_invert;
  if (reg->bitfields.PIX2CLK_SRC_INVERT != pix2clk_src_invert) HSLDPF(E_ERROR_MESSAGE,"rv250PIXCLKS_CNTL::PIX2CLK_SRC_INVERT data too large\n");
}
__inline void set_rv250PIXCLKS_CNTL_pix2clk_always_onb(regrv250PIXCLKS_CNTL *reg, unsigned int pix2clk_always_onb)
{
  reg->bitfields.PIX2CLK_ALWAYS_ONb = pix2clk_always_onb;
  if (reg->bitfields.PIX2CLK_ALWAYS_ONb != pix2clk_always_onb) HSLDPF(E_ERROR_MESSAGE,"rv250PIXCLKS_CNTL::PIX2CLK_ALWAYS_ONb data too large\n");
}
__inline void set_rv250PIXCLKS_CNTL_pix2clk_dac_always_onb(regrv250PIXCLKS_CNTL *reg, unsigned int pix2clk_dac_always_onb)
{
  reg->bitfields.PIX2CLK_DAC_ALWAYS_ONb = pix2clk_dac_always_onb;
  if (reg->bitfields.PIX2CLK_DAC_ALWAYS_ONb != pix2clk_dac_always_onb) HSLDPF(E_ERROR_MESSAGE,"rv250PIXCLKS_CNTL::PIX2CLK_DAC_ALWAYS_ONb data too large\n");
}
__inline void set_rv250PIXCLKS_CNTL_pixclk_tv_src_sel(regrv250PIXCLKS_CNTL *reg, unsigned int pixclk_tv_src_sel)
{
  reg->bitfields.PIXCLK_TV_SRC_SEL = pixclk_tv_src_sel;
  if (reg->bitfields.PIXCLK_TV_SRC_SEL != pixclk_tv_src_sel) HSLDPF(E_ERROR_MESSAGE,"rv250PIXCLKS_CNTL::PIXCLK_TV_SRC_SEL data too large\n");
}
__inline void set_rv250PIXCLKS_CNTL_pixclk_blend_always_onb(regrv250PIXCLKS_CNTL *reg, unsigned int pixclk_blend_always_onb)
{
  reg->bitfields.PIXCLK_BLEND_ALWAYS_ONb = pixclk_blend_always_onb;
  if (reg->bitfields.PIXCLK_BLEND_ALWAYS_ONb != pixclk_blend_always_onb) HSLDPF(E_ERROR_MESSAGE,"rv250PIXCLKS_CNTL::PIXCLK_BLEND_ALWAYS_ONb data too large\n");
}
__inline void set_rv250PIXCLKS_CNTL_pixclk_gv_always_onb(regrv250PIXCLKS_CNTL *reg, unsigned int pixclk_gv_always_onb)
{
  reg->bitfields.PIXCLK_GV_ALWAYS_ONb = pixclk_gv_always_onb;
  if (reg->bitfields.PIXCLK_GV_ALWAYS_ONb != pixclk_gv_always_onb) HSLDPF(E_ERROR_MESSAGE,"rv250PIXCLKS_CNTL::PIXCLK_GV_ALWAYS_ONb data too large\n");
}
__inline void set_rv250PIXCLKS_CNTL_pixclk_dig_tmds_always_onb(regrv250PIXCLKS_CNTL *reg, unsigned int pixclk_dig_tmds_always_onb)
{
  reg->bitfields.PIXCLK_DIG_TMDS_ALWAYS_ONb = pixclk_dig_tmds_always_onb;
  if (reg->bitfields.PIXCLK_DIG_TMDS_ALWAYS_ONb != pixclk_dig_tmds_always_onb) HSLDPF(E_ERROR_MESSAGE,"rv250PIXCLKS_CNTL::PIXCLK_DIG_TMDS_ALWAYS_ONb data too large\n");
}
__inline void set_rv250PIXCLKS_CNTL_pixclk_lvds_always_onb(regrv250PIXCLKS_CNTL *reg, unsigned int pixclk_lvds_always_onb)
{
  reg->bitfields.PIXCLK_LVDS_ALWAYS_ONb = pixclk_lvds_always_onb;
  if (reg->bitfields.PIXCLK_LVDS_ALWAYS_ONb != pixclk_lvds_always_onb) HSLDPF(E_ERROR_MESSAGE,"rv250PIXCLKS_CNTL::PIXCLK_LVDS_ALWAYS_ONb data too large\n");
}
__inline void set_rv250PIXCLKS_CNTL_pixclk_tmds_always_onb(regrv250PIXCLKS_CNTL *reg, unsigned int pixclk_tmds_always_onb)
{
  reg->bitfields.PIXCLK_TMDS_ALWAYS_ONb = pixclk_tmds_always_onb;
  if (reg->bitfields.PIXCLK_TMDS_ALWAYS_ONb != pixclk_tmds_always_onb) HSLDPF(E_ERROR_MESSAGE,"rv250PIXCLKS_CNTL::PIXCLK_TMDS_ALWAYS_ONb data too large\n");
}
__inline void set_rv250PIXCLKS_CNTL_dvoclkc_in_phase(regrv250PIXCLKS_CNTL *reg, unsigned int dvoclkc_in_phase)
{
  reg->bitfields.DVOCLKC_IN_PHASE = dvoclkc_in_phase;
  if (reg->bitfields.DVOCLKC_IN_PHASE != dvoclkc_in_phase) HSLDPF(E_ERROR_MESSAGE,"rv250PIXCLKS_CNTL::DVOCLKC_IN_PHASE data too large\n");
}
__inline void set_rv250PIXCLKS_CNTL_dvoclkd_in_phase(regrv250PIXCLKS_CNTL *reg, unsigned int dvoclkd_in_phase)
{
  reg->bitfields.DVOCLKD_IN_PHASE = dvoclkd_in_phase;
  if (reg->bitfields.DVOCLKD_IN_PHASE != dvoclkd_in_phase) HSLDPF(E_ERROR_MESSAGE,"rv250PIXCLKS_CNTL::DVOCLKD_IN_PHASE data too large\n");
}
__inline void set_rv250PIXCLKS_CNTL_dvoclkc_skw_ctl(regrv250PIXCLKS_CNTL *reg, unsigned int dvoclkc_skw_ctl)
{
  reg->bitfields.DVOCLKC_SKW_CTL = dvoclkc_skw_ctl;
  if (reg->bitfields.DVOCLKC_SKW_CTL != dvoclkc_skw_ctl) HSLDPF(E_ERROR_MESSAGE,"rv250PIXCLKS_CNTL::DVOCLKC_SKW_CTL data too large\n");
}
__inline void set_rv250PIXCLKS_CNTL_dvoclkd_skw_ctl(regrv250PIXCLKS_CNTL *reg, unsigned int dvoclkd_skw_ctl)
{
  reg->bitfields.DVOCLKD_SKW_CTL = dvoclkd_skw_ctl;
  if (reg->bitfields.DVOCLKD_SKW_CTL != dvoclkd_skw_ctl) HSLDPF(E_ERROR_MESSAGE,"rv250PIXCLKS_CNTL::DVOCLKD_SKW_CTL data too large\n");
}
#else
#define set_rv250PIXCLKS_CNTL_pix2clk_src_sel(reg, pix2clk_src_sel) (reg)->bitfields.PIX2CLK_SRC_SEL = pix2clk_src_sel
#define set_rv250PIXCLKS_CNTL_pix2clk_invert(reg, pix2clk_invert) (reg)->bitfields.PIX2CLK_INVERT = pix2clk_invert
#define set_rv250PIXCLKS_CNTL_pix2clk_src_invert(reg, pix2clk_src_invert) (reg)->bitfields.PIX2CLK_SRC_INVERT = pix2clk_src_invert
#define set_rv250PIXCLKS_CNTL_pix2clk_always_onb(reg, pix2clk_always_onb) (reg)->bitfields.PIX2CLK_ALWAYS_ONb = pix2clk_always_onb
#define set_rv250PIXCLKS_CNTL_pix2clk_dac_always_onb(reg, pix2clk_dac_always_onb) (reg)->bitfields.PIX2CLK_DAC_ALWAYS_ONb = pix2clk_dac_always_onb
#define set_rv250PIXCLKS_CNTL_pixclk_tv_src_sel(reg, pixclk_tv_src_sel) (reg)->bitfields.PIXCLK_TV_SRC_SEL = pixclk_tv_src_sel
#define set_rv250PIXCLKS_CNTL_pixclk_blend_always_onb(reg, pixclk_blend_always_onb) (reg)->bitfields.PIXCLK_BLEND_ALWAYS_ONb = pixclk_blend_always_onb
#define set_rv250PIXCLKS_CNTL_pixclk_gv_always_onb(reg, pixclk_gv_always_onb) (reg)->bitfields.PIXCLK_GV_ALWAYS_ONb = pixclk_gv_always_onb
#define set_rv250PIXCLKS_CNTL_pixclk_dig_tmds_always_onb(reg, pixclk_dig_tmds_always_onb) (reg)->bitfields.PIXCLK_DIG_TMDS_ALWAYS_ONb = pixclk_dig_tmds_always_onb
#define set_rv250PIXCLKS_CNTL_pixclk_lvds_always_onb(reg, pixclk_lvds_always_onb) (reg)->bitfields.PIXCLK_LVDS_ALWAYS_ONb = pixclk_lvds_always_onb
#define set_rv250PIXCLKS_CNTL_pixclk_tmds_always_onb(reg, pixclk_tmds_always_onb) (reg)->bitfields.PIXCLK_TMDS_ALWAYS_ONb = pixclk_tmds_always_onb
#define set_rv250PIXCLKS_CNTL_dvoclkc_in_phase(reg, dvoclkc_in_phase) (reg)->bitfields.DVOCLKC_IN_PHASE = dvoclkc_in_phase
#define set_rv250PIXCLKS_CNTL_dvoclkd_in_phase(reg, dvoclkd_in_phase) (reg)->bitfields.DVOCLKD_IN_PHASE = dvoclkd_in_phase
#define set_rv250PIXCLKS_CNTL_dvoclkc_skw_ctl(reg, dvoclkc_skw_ctl) (reg)->bitfields.DVOCLKC_SKW_CTL = dvoclkc_skw_ctl
#define set_rv250PIXCLKS_CNTL_dvoclkd_skw_ctl(reg, dvoclkd_skw_ctl) (reg)->bitfields.DVOCLKD_SKW_CTL = dvoclkd_skw_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC_STATUS regCRTC_STATUS;

#ifdef DEBUG
__inline void set_CRTC_STATUS_crtc_vblank_cur(regCRTC_STATUS *reg, unsigned int crtc_vblank_cur)
{
  reg->bitfields.CRTC_VBLANK_CUR = crtc_vblank_cur;
  if (reg->bitfields.CRTC_VBLANK_CUR != crtc_vblank_cur) HSLDPF(E_ERROR_MESSAGE,"CRTC_STATUS::CRTC_VBLANK_CUR data too large\n");
}
__inline void set_CRTC_STATUS_crtc_vblank_save(regCRTC_STATUS *reg, unsigned int crtc_vblank_save)
{
  reg->bitfields.CRTC_VBLANK_SAVE = crtc_vblank_save;
  if (reg->bitfields.CRTC_VBLANK_SAVE != crtc_vblank_save) HSLDPF(E_ERROR_MESSAGE,"CRTC_STATUS::CRTC_VBLANK_SAVE data too large\n");
}
__inline void set_CRTC_STATUS_crtc_vline_sync(regCRTC_STATUS *reg, unsigned int crtc_vline_sync)
{
  reg->bitfields.CRTC_VLINE_SYNC = crtc_vline_sync;
  if (reg->bitfields.CRTC_VLINE_SYNC != crtc_vline_sync) HSLDPF(E_ERROR_MESSAGE,"CRTC_STATUS::CRTC_VLINE_SYNC data too large\n");
}
__inline void set_CRTC_STATUS_crtc_frame(regCRTC_STATUS *reg, unsigned int crtc_frame)
{
  reg->bitfields.CRTC_FRAME = crtc_frame;
  if (reg->bitfields.CRTC_FRAME != crtc_frame) HSLDPF(E_ERROR_MESSAGE,"CRTC_STATUS::CRTC_FRAME data too large\n");
}
#else
#define set_CRTC_STATUS_crtc_vblank_cur(reg, crtc_vblank_cur) (reg)->bitfields.CRTC_VBLANK_CUR = crtc_vblank_cur
#define set_CRTC_STATUS_crtc_vblank_save(reg, crtc_vblank_save) (reg)->bitfields.CRTC_VBLANK_SAVE = crtc_vblank_save
#define set_CRTC_STATUS_crtc_vline_sync(reg, crtc_vline_sync) (reg)->bitfields.CRTC_VLINE_SYNC = crtc_vline_sync
#define set_CRTC_STATUS_crtc_frame(reg, crtc_frame) (reg)->bitfields.CRTC_FRAME = crtc_frame

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GPIO_VGA_DDC regGPIO_VGA_DDC;

#ifdef DEBUG
__inline void set_GPIO_VGA_DDC_vga_dcc_data_output(regGPIO_VGA_DDC *reg, unsigned int vga_dcc_data_output)
{
  reg->bitfields.VGA_DCC_DATA_OUTPUT = vga_dcc_data_output;
  if (reg->bitfields.VGA_DCC_DATA_OUTPUT != vga_dcc_data_output) HSLDPF(E_ERROR_MESSAGE,"GPIO_VGA_DDC::VGA_DCC_DATA_OUTPUT data too large\n");
}
__inline void set_GPIO_VGA_DDC_vga_ddc_clk_output(regGPIO_VGA_DDC *reg, unsigned int vga_ddc_clk_output)
{
  reg->bitfields.VGA_DDC_CLK_OUTPUT = vga_ddc_clk_output;
  if (reg->bitfields.VGA_DDC_CLK_OUTPUT != vga_ddc_clk_output) HSLDPF(E_ERROR_MESSAGE,"GPIO_VGA_DDC::VGA_DDC_CLK_OUTPUT data too large\n");
}
__inline void set_GPIO_VGA_DDC_vga_ddc_data_input(regGPIO_VGA_DDC *reg, unsigned int vga_ddc_data_input)
{
  reg->bitfields.VGA_DDC_DATA_INPUT = vga_ddc_data_input;
  if (reg->bitfields.VGA_DDC_DATA_INPUT != vga_ddc_data_input) HSLDPF(E_ERROR_MESSAGE,"GPIO_VGA_DDC::VGA_DDC_DATA_INPUT data too large\n");
}
__inline void set_GPIO_VGA_DDC_vga_ddc_clk_input(regGPIO_VGA_DDC *reg, unsigned int vga_ddc_clk_input)
{
  reg->bitfields.VGA_DDC_CLK_INPUT = vga_ddc_clk_input;
  if (reg->bitfields.VGA_DDC_CLK_INPUT != vga_ddc_clk_input) HSLDPF(E_ERROR_MESSAGE,"GPIO_VGA_DDC::VGA_DDC_CLK_INPUT data too large\n");
}
__inline void set_GPIO_VGA_DDC_vga_ddc_data_out_en(regGPIO_VGA_DDC *reg, unsigned int vga_ddc_data_out_en)
{
  reg->bitfields.VGA_DDC_DATA_OUT_EN = vga_ddc_data_out_en;
  if (reg->bitfields.VGA_DDC_DATA_OUT_EN != vga_ddc_data_out_en) HSLDPF(E_ERROR_MESSAGE,"GPIO_VGA_DDC::VGA_DDC_DATA_OUT_EN data too large\n");
}
__inline void set_GPIO_VGA_DDC_vga_ddc_clk_out_en(regGPIO_VGA_DDC *reg, unsigned int vga_ddc_clk_out_en)
{
  reg->bitfields.VGA_DDC_CLK_OUT_EN = vga_ddc_clk_out_en;
  if (reg->bitfields.VGA_DDC_CLK_OUT_EN != vga_ddc_clk_out_en) HSLDPF(E_ERROR_MESSAGE,"GPIO_VGA_DDC::VGA_DDC_CLK_OUT_EN data too large\n");
}
#else
#define set_GPIO_VGA_DDC_vga_dcc_data_output(reg, vga_dcc_data_output) (reg)->bitfields.VGA_DCC_DATA_OUTPUT = vga_dcc_data_output
#define set_GPIO_VGA_DDC_vga_ddc_clk_output(reg, vga_ddc_clk_output) (reg)->bitfields.VGA_DDC_CLK_OUTPUT = vga_ddc_clk_output
#define set_GPIO_VGA_DDC_vga_ddc_data_input(reg, vga_ddc_data_input) (reg)->bitfields.VGA_DDC_DATA_INPUT = vga_ddc_data_input
#define set_GPIO_VGA_DDC_vga_ddc_clk_input(reg, vga_ddc_clk_input) (reg)->bitfields.VGA_DDC_CLK_INPUT = vga_ddc_clk_input
#define set_GPIO_VGA_DDC_vga_ddc_data_out_en(reg, vga_ddc_data_out_en) (reg)->bitfields.VGA_DDC_DATA_OUT_EN = vga_ddc_data_out_en
#define set_GPIO_VGA_DDC_vga_ddc_clk_out_en(reg, vga_ddc_clk_out_en) (reg)->bitfields.VGA_DDC_CLK_OUT_EN = vga_ddc_clk_out_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GPIO_DVI_DDC regGPIO_DVI_DDC;

#ifdef DEBUG
__inline void set_GPIO_DVI_DDC_dvi_ddc_data_output(regGPIO_DVI_DDC *reg, unsigned int dvi_ddc_data_output)
{
  reg->bitfields.DVI_DDC_DATA_OUTPUT = dvi_ddc_data_output;
  if (reg->bitfields.DVI_DDC_DATA_OUTPUT != dvi_ddc_data_output) HSLDPF(E_ERROR_MESSAGE,"GPIO_DVI_DDC::DVI_DDC_DATA_OUTPUT data too large\n");
}
__inline void set_GPIO_DVI_DDC_dvi_ddc_clk_output(regGPIO_DVI_DDC *reg, unsigned int dvi_ddc_clk_output)
{
  reg->bitfields.DVI_DDC_CLK_OUTPUT = dvi_ddc_clk_output;
  if (reg->bitfields.DVI_DDC_CLK_OUTPUT != dvi_ddc_clk_output) HSLDPF(E_ERROR_MESSAGE,"GPIO_DVI_DDC::DVI_DDC_CLK_OUTPUT data too large\n");
}
__inline void set_GPIO_DVI_DDC_dvi_ddc_data_input(regGPIO_DVI_DDC *reg, unsigned int dvi_ddc_data_input)
{
  reg->bitfields.DVI_DDC_DATA_INPUT = dvi_ddc_data_input;
  if (reg->bitfields.DVI_DDC_DATA_INPUT != dvi_ddc_data_input) HSLDPF(E_ERROR_MESSAGE,"GPIO_DVI_DDC::DVI_DDC_DATA_INPUT data too large\n");
}
__inline void set_GPIO_DVI_DDC_dvi_ddc_clk_input(regGPIO_DVI_DDC *reg, unsigned int dvi_ddc_clk_input)
{
  reg->bitfields.DVI_DDC_CLK_INPUT = dvi_ddc_clk_input;
  if (reg->bitfields.DVI_DDC_CLK_INPUT != dvi_ddc_clk_input) HSLDPF(E_ERROR_MESSAGE,"GPIO_DVI_DDC::DVI_DDC_CLK_INPUT data too large\n");
}
__inline void set_GPIO_DVI_DDC_dvi_ddc_data_out_en(regGPIO_DVI_DDC *reg, unsigned int dvi_ddc_data_out_en)
{
  reg->bitfields.DVI_DDC_DATA_OUT_EN = dvi_ddc_data_out_en;
  if (reg->bitfields.DVI_DDC_DATA_OUT_EN != dvi_ddc_data_out_en) HSLDPF(E_ERROR_MESSAGE,"GPIO_DVI_DDC::DVI_DDC_DATA_OUT_EN data too large\n");
}
__inline void set_GPIO_DVI_DDC_dvi_ddc_clk_out_en(regGPIO_DVI_DDC *reg, unsigned int dvi_ddc_clk_out_en)
{
  reg->bitfields.DVI_DDC_CLK_OUT_EN = dvi_ddc_clk_out_en;
  if (reg->bitfields.DVI_DDC_CLK_OUT_EN != dvi_ddc_clk_out_en) HSLDPF(E_ERROR_MESSAGE,"GPIO_DVI_DDC::DVI_DDC_CLK_OUT_EN data too large\n");
}
__inline void set_GPIO_DVI_DDC_sw_wants_to_use_dvi_i2c(regGPIO_DVI_DDC *reg, unsigned int sw_wants_to_use_dvi_i2c)
{
  reg->bitfields.SW_WANTS_TO_USE_DVI_I2C = sw_wants_to_use_dvi_i2c;
  if (reg->bitfields.SW_WANTS_TO_USE_DVI_I2C != sw_wants_to_use_dvi_i2c) HSLDPF(E_ERROR_MESSAGE,"GPIO_DVI_DDC::SW_WANTS_TO_USE_DVI_I2C data too large\n");
}
__inline void set_GPIO_DVI_DDC_sw_done_using_dvi_i2c(regGPIO_DVI_DDC *reg, unsigned int sw_done_using_dvi_i2c)
{
  reg->bitfields.SW_DONE_USING_DVI_I2C = sw_done_using_dvi_i2c;
  if (reg->bitfields.SW_DONE_USING_DVI_I2C != sw_done_using_dvi_i2c) HSLDPF(E_ERROR_MESSAGE,"GPIO_DVI_DDC::SW_DONE_USING_DVI_I2C data too large\n");
}
__inline void set_GPIO_DVI_DDC_abort_hdcp_dvi_i2c(regGPIO_DVI_DDC *reg, unsigned int abort_hdcp_dvi_i2c)
{
  reg->bitfields.ABORT_HDCP_DVI_I2C = abort_hdcp_dvi_i2c;
  if (reg->bitfields.ABORT_HDCP_DVI_I2C != abort_hdcp_dvi_i2c) HSLDPF(E_ERROR_MESSAGE,"GPIO_DVI_DDC::ABORT_HDCP_DVI_I2C data too large\n");
}
#else
#define set_GPIO_DVI_DDC_dvi_ddc_data_output(reg, dvi_ddc_data_output) (reg)->bitfields.DVI_DDC_DATA_OUTPUT = dvi_ddc_data_output
#define set_GPIO_DVI_DDC_dvi_ddc_clk_output(reg, dvi_ddc_clk_output) (reg)->bitfields.DVI_DDC_CLK_OUTPUT = dvi_ddc_clk_output
#define set_GPIO_DVI_DDC_dvi_ddc_data_input(reg, dvi_ddc_data_input) (reg)->bitfields.DVI_DDC_DATA_INPUT = dvi_ddc_data_input
#define set_GPIO_DVI_DDC_dvi_ddc_clk_input(reg, dvi_ddc_clk_input) (reg)->bitfields.DVI_DDC_CLK_INPUT = dvi_ddc_clk_input
#define set_GPIO_DVI_DDC_dvi_ddc_data_out_en(reg, dvi_ddc_data_out_en) (reg)->bitfields.DVI_DDC_DATA_OUT_EN = dvi_ddc_data_out_en
#define set_GPIO_DVI_DDC_dvi_ddc_clk_out_en(reg, dvi_ddc_clk_out_en) (reg)->bitfields.DVI_DDC_CLK_OUT_EN = dvi_ddc_clk_out_en
#define set_GPIO_DVI_DDC_sw_wants_to_use_dvi_i2c(reg, sw_wants_to_use_dvi_i2c) (reg)->bitfields.SW_WANTS_TO_USE_DVI_I2C = sw_wants_to_use_dvi_i2c
#define set_GPIO_DVI_DDC_sw_done_using_dvi_i2c(reg, sw_done_using_dvi_i2c) (reg)->bitfields.SW_DONE_USING_DVI_I2C = sw_done_using_dvi_i2c
#define set_GPIO_DVI_DDC_abort_hdcp_dvi_i2c(reg, abort_hdcp_dvi_i2c) (reg)->bitfields.ABORT_HDCP_DVI_I2C = abort_hdcp_dvi_i2c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GPIO_MONID regGPIO_MONID;

#ifdef DEBUG
__inline void set_GPIO_MONID_gpio_monid_0_output(regGPIO_MONID *reg, unsigned int gpio_monid_0_output)
{
  reg->bitfields.GPIO_MONID_0_OUTPUT = gpio_monid_0_output;
  if (reg->bitfields.GPIO_MONID_0_OUTPUT != gpio_monid_0_output) HSLDPF(E_ERROR_MESSAGE,"GPIO_MONID::GPIO_MONID_0_OUTPUT data too large\n");
}
__inline void set_GPIO_MONID_gpio_monid_1_output(regGPIO_MONID *reg, unsigned int gpio_monid_1_output)
{
  reg->bitfields.GPIO_MONID_1_OUTPUT = gpio_monid_1_output;
  if (reg->bitfields.GPIO_MONID_1_OUTPUT != gpio_monid_1_output) HSLDPF(E_ERROR_MESSAGE,"GPIO_MONID::GPIO_MONID_1_OUTPUT data too large\n");
}
__inline void set_GPIO_MONID_gpio_monid_0_input(regGPIO_MONID *reg, unsigned int gpio_monid_0_input)
{
  reg->bitfields.GPIO_MONID_0_INPUT = gpio_monid_0_input;
  if (reg->bitfields.GPIO_MONID_0_INPUT != gpio_monid_0_input) HSLDPF(E_ERROR_MESSAGE,"GPIO_MONID::GPIO_MONID_0_INPUT data too large\n");
}
__inline void set_GPIO_MONID_gpio_monid_1_input(regGPIO_MONID *reg, unsigned int gpio_monid_1_input)
{
  reg->bitfields.GPIO_MONID_1_INPUT = gpio_monid_1_input;
  if (reg->bitfields.GPIO_MONID_1_INPUT != gpio_monid_1_input) HSLDPF(E_ERROR_MESSAGE,"GPIO_MONID::GPIO_MONID_1_INPUT data too large\n");
}
__inline void set_GPIO_MONID_gpio_monid_0_out_en(regGPIO_MONID *reg, unsigned int gpio_monid_0_out_en)
{
  reg->bitfields.GPIO_MONID_0_OUT_EN = gpio_monid_0_out_en;
  if (reg->bitfields.GPIO_MONID_0_OUT_EN != gpio_monid_0_out_en) HSLDPF(E_ERROR_MESSAGE,"GPIO_MONID::GPIO_MONID_0_OUT_EN data too large\n");
}
__inline void set_GPIO_MONID_gpio_monid_1_out_en(regGPIO_MONID *reg, unsigned int gpio_monid_1_out_en)
{
  reg->bitfields.GPIO_MONID_1_OUT_EN = gpio_monid_1_out_en;
  if (reg->bitfields.GPIO_MONID_1_OUT_EN != gpio_monid_1_out_en) HSLDPF(E_ERROR_MESSAGE,"GPIO_MONID::GPIO_MONID_1_OUT_EN data too large\n");
}
#else
#define set_GPIO_MONID_gpio_monid_0_output(reg, gpio_monid_0_output) (reg)->bitfields.GPIO_MONID_0_OUTPUT = gpio_monid_0_output
#define set_GPIO_MONID_gpio_monid_1_output(reg, gpio_monid_1_output) (reg)->bitfields.GPIO_MONID_1_OUTPUT = gpio_monid_1_output
#define set_GPIO_MONID_gpio_monid_0_input(reg, gpio_monid_0_input) (reg)->bitfields.GPIO_MONID_0_INPUT = gpio_monid_0_input
#define set_GPIO_MONID_gpio_monid_1_input(reg, gpio_monid_1_input) (reg)->bitfields.GPIO_MONID_1_INPUT = gpio_monid_1_input
#define set_GPIO_MONID_gpio_monid_0_out_en(reg, gpio_monid_0_out_en) (reg)->bitfields.GPIO_MONID_0_OUT_EN = gpio_monid_0_out_en
#define set_GPIO_MONID_gpio_monid_1_out_en(reg, gpio_monid_1_out_en) (reg)->bitfields.GPIO_MONID_1_OUT_EN = gpio_monid_1_out_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GPIO_CRT2_DDC regGPIO_CRT2_DDC;

#ifdef DEBUG
__inline void set_GPIO_CRT2_DDC_crt2_ddc_data_output(regGPIO_CRT2_DDC *reg, unsigned int crt2_ddc_data_output)
{
  reg->bitfields.CRT2_DDC_DATA_OUTPUT = crt2_ddc_data_output;
  if (reg->bitfields.CRT2_DDC_DATA_OUTPUT != crt2_ddc_data_output) HSLDPF(E_ERROR_MESSAGE,"GPIO_CRT2_DDC::CRT2_DDC_DATA_OUTPUT data too large\n");
}
__inline void set_GPIO_CRT2_DDC_crt2_ddc_clk_output(regGPIO_CRT2_DDC *reg, unsigned int crt2_ddc_clk_output)
{
  reg->bitfields.CRT2_DDC_CLK_OUTPUT = crt2_ddc_clk_output;
  if (reg->bitfields.CRT2_DDC_CLK_OUTPUT != crt2_ddc_clk_output) HSLDPF(E_ERROR_MESSAGE,"GPIO_CRT2_DDC::CRT2_DDC_CLK_OUTPUT data too large\n");
}
__inline void set_GPIO_CRT2_DDC_crt2_ddc_data_input(regGPIO_CRT2_DDC *reg, unsigned int crt2_ddc_data_input)
{
  reg->bitfields.CRT2_DDC_DATA_INPUT = crt2_ddc_data_input;
  if (reg->bitfields.CRT2_DDC_DATA_INPUT != crt2_ddc_data_input) HSLDPF(E_ERROR_MESSAGE,"GPIO_CRT2_DDC::CRT2_DDC_DATA_INPUT data too large\n");
}
__inline void set_GPIO_CRT2_DDC_crt2_ddc_clk_input(regGPIO_CRT2_DDC *reg, unsigned int crt2_ddc_clk_input)
{
  reg->bitfields.CRT2_DDC_CLK_INPUT = crt2_ddc_clk_input;
  if (reg->bitfields.CRT2_DDC_CLK_INPUT != crt2_ddc_clk_input) HSLDPF(E_ERROR_MESSAGE,"GPIO_CRT2_DDC::CRT2_DDC_CLK_INPUT data too large\n");
}
__inline void set_GPIO_CRT2_DDC_crt2_ddc_data_out_en(regGPIO_CRT2_DDC *reg, unsigned int crt2_ddc_data_out_en)
{
  reg->bitfields.CRT2_DDC_DATA_OUT_EN = crt2_ddc_data_out_en;
  if (reg->bitfields.CRT2_DDC_DATA_OUT_EN != crt2_ddc_data_out_en) HSLDPF(E_ERROR_MESSAGE,"GPIO_CRT2_DDC::CRT2_DDC_DATA_OUT_EN data too large\n");
}
__inline void set_GPIO_CRT2_DDC_crt2_ddc_clk_out_en(regGPIO_CRT2_DDC *reg, unsigned int crt2_ddc_clk_out_en)
{
  reg->bitfields.CRT2_DDC_CLK_OUT_EN = crt2_ddc_clk_out_en;
  if (reg->bitfields.CRT2_DDC_CLK_OUT_EN != crt2_ddc_clk_out_en) HSLDPF(E_ERROR_MESSAGE,"GPIO_CRT2_DDC::CRT2_DDC_CLK_OUT_EN data too large\n");
}
#else
#define set_GPIO_CRT2_DDC_crt2_ddc_data_output(reg, crt2_ddc_data_output) (reg)->bitfields.CRT2_DDC_DATA_OUTPUT = crt2_ddc_data_output
#define set_GPIO_CRT2_DDC_crt2_ddc_clk_output(reg, crt2_ddc_clk_output) (reg)->bitfields.CRT2_DDC_CLK_OUTPUT = crt2_ddc_clk_output
#define set_GPIO_CRT2_DDC_crt2_ddc_data_input(reg, crt2_ddc_data_input) (reg)->bitfields.CRT2_DDC_DATA_INPUT = crt2_ddc_data_input
#define set_GPIO_CRT2_DDC_crt2_ddc_clk_input(reg, crt2_ddc_clk_input) (reg)->bitfields.CRT2_DDC_CLK_INPUT = crt2_ddc_clk_input
#define set_GPIO_CRT2_DDC_crt2_ddc_data_out_en(reg, crt2_ddc_data_out_en) (reg)->bitfields.CRT2_DDC_DATA_OUT_EN = crt2_ddc_data_out_en
#define set_GPIO_CRT2_DDC_crt2_ddc_clk_out_en(reg, crt2_ddc_clk_out_en) (reg)->bitfields.CRT2_DDC_CLK_OUT_EN = crt2_ddc_clk_out_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PALETTE_INDEX regPALETTE_INDEX;

#ifdef DEBUG
__inline void set_PALETTE_INDEX_palette_w_index(regPALETTE_INDEX *reg, unsigned int palette_w_index)
{
  reg->bitfields.PALETTE_W_INDEX = palette_w_index;
  if (reg->bitfields.PALETTE_W_INDEX != palette_w_index) HSLDPF(E_ERROR_MESSAGE,"PALETTE_INDEX::PALETTE_W_INDEX data too large\n");
}
__inline void set_PALETTE_INDEX_palette_r_index(regPALETTE_INDEX *reg, unsigned int palette_r_index)
{
  reg->bitfields.PALETTE_R_INDEX = palette_r_index;
  if (reg->bitfields.PALETTE_R_INDEX != palette_r_index) HSLDPF(E_ERROR_MESSAGE,"PALETTE_INDEX::PALETTE_R_INDEX data too large\n");
}
#else
#define set_PALETTE_INDEX_palette_w_index(reg, palette_w_index) (reg)->bitfields.PALETTE_W_INDEX = palette_w_index
#define set_PALETTE_INDEX_palette_r_index(reg, palette_r_index) (reg)->bitfields.PALETTE_R_INDEX = palette_r_index

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PALETTE_DATA regPALETTE_DATA;

#ifdef DEBUG
__inline void set_PALETTE_DATA_palette_data_b(regPALETTE_DATA *reg, unsigned int palette_data_b)
{
  reg->bitfields.PALETTE_DATA_B = palette_data_b;
  if (reg->bitfields.PALETTE_DATA_B != palette_data_b) HSLDPF(E_ERROR_MESSAGE,"PALETTE_DATA::PALETTE_DATA_B data too large\n");
}
__inline void set_PALETTE_DATA_palette_data_g(regPALETTE_DATA *reg, unsigned int palette_data_g)
{
  reg->bitfields.PALETTE_DATA_G = palette_data_g;
  if (reg->bitfields.PALETTE_DATA_G != palette_data_g) HSLDPF(E_ERROR_MESSAGE,"PALETTE_DATA::PALETTE_DATA_G data too large\n");
}
__inline void set_PALETTE_DATA_palette_data_r(regPALETTE_DATA *reg, unsigned int palette_data_r)
{
  reg->bitfields.PALETTE_DATA_R = palette_data_r;
  if (reg->bitfields.PALETTE_DATA_R != palette_data_r) HSLDPF(E_ERROR_MESSAGE,"PALETTE_DATA::PALETTE_DATA_R data too large\n");
}
#else
#define set_PALETTE_DATA_palette_data_b(reg, palette_data_b) (reg)->bitfields.PALETTE_DATA_B = palette_data_b
#define set_PALETTE_DATA_palette_data_g(reg, palette_data_g) (reg)->bitfields.PALETTE_DATA_G = palette_data_g
#define set_PALETTE_DATA_palette_data_r(reg, palette_data_r) (reg)->bitfields.PALETTE_DATA_R = palette_data_r

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PALETTE_30_DATA regPALETTE_30_DATA;

#ifdef DEBUG
__inline void set_PALETTE_30_DATA_palette_data_b(regPALETTE_30_DATA *reg, unsigned int palette_data_b)
{
  reg->bitfields.PALETTE_DATA_B = palette_data_b;
  if (reg->bitfields.PALETTE_DATA_B != palette_data_b) HSLDPF(E_ERROR_MESSAGE,"PALETTE_30_DATA::PALETTE_DATA_B data too large\n");
}
__inline void set_PALETTE_30_DATA_palette_data_g(regPALETTE_30_DATA *reg, unsigned int palette_data_g)
{
  reg->bitfields.PALETTE_DATA_G = palette_data_g;
  if (reg->bitfields.PALETTE_DATA_G != palette_data_g) HSLDPF(E_ERROR_MESSAGE,"PALETTE_30_DATA::PALETTE_DATA_G data too large\n");
}
__inline void set_PALETTE_30_DATA_palette_data_r(regPALETTE_30_DATA *reg, unsigned int palette_data_r)
{
  reg->bitfields.PALETTE_DATA_R = palette_data_r;
  if (reg->bitfields.PALETTE_DATA_R != palette_data_r) HSLDPF(E_ERROR_MESSAGE,"PALETTE_30_DATA::PALETTE_DATA_R data too large\n");
}
#else
#define set_PALETTE_30_DATA_palette_data_b(reg, palette_data_b) (reg)->bitfields.PALETTE_DATA_B = palette_data_b
#define set_PALETTE_30_DATA_palette_data_g(reg, palette_data_g) (reg)->bitfields.PALETTE_DATA_G = palette_data_g
#define set_PALETTE_30_DATA_palette_data_r(reg, palette_data_r) (reg)->bitfields.PALETTE_DATA_R = palette_data_r

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC_H_TOTAL_DISP regCRTC_H_TOTAL_DISP;

#ifdef DEBUG
__inline void set_CRTC_H_TOTAL_DISP_crtc_h_total(regCRTC_H_TOTAL_DISP *reg, unsigned int crtc_h_total)
{
  reg->bitfields.CRTC_H_TOTAL = crtc_h_total;
  if (reg->bitfields.CRTC_H_TOTAL != crtc_h_total) HSLDPF(E_ERROR_MESSAGE,"CRTC_H_TOTAL_DISP::CRTC_H_TOTAL data too large\n");
}
__inline void set_CRTC_H_TOTAL_DISP_crtc_h_disp(regCRTC_H_TOTAL_DISP *reg, unsigned int crtc_h_disp)
{
  reg->bitfields.CRTC_H_DISP = crtc_h_disp;
  if (reg->bitfields.CRTC_H_DISP != crtc_h_disp) HSLDPF(E_ERROR_MESSAGE,"CRTC_H_TOTAL_DISP::CRTC_H_DISP data too large\n");
}
#else
#define set_CRTC_H_TOTAL_DISP_crtc_h_total(reg, crtc_h_total) (reg)->bitfields.CRTC_H_TOTAL = crtc_h_total
#define set_CRTC_H_TOTAL_DISP_crtc_h_disp(reg, crtc_h_disp) (reg)->bitfields.CRTC_H_DISP = crtc_h_disp

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC_H_SYNC_STRT_WID regCRTC_H_SYNC_STRT_WID;

#ifdef DEBUG
__inline void set_CRTC_H_SYNC_STRT_WID_crtc_h_sync_strt_pix(regCRTC_H_SYNC_STRT_WID *reg, unsigned int crtc_h_sync_strt_pix)
{
  reg->bitfields.CRTC_H_SYNC_STRT_PIX = crtc_h_sync_strt_pix;
  if (reg->bitfields.CRTC_H_SYNC_STRT_PIX != crtc_h_sync_strt_pix) HSLDPF(E_ERROR_MESSAGE,"CRTC_H_SYNC_STRT_WID::CRTC_H_SYNC_STRT_PIX data too large\n");
}
__inline void set_CRTC_H_SYNC_STRT_WID_crtc_h_sync_strt_char(regCRTC_H_SYNC_STRT_WID *reg, unsigned int crtc_h_sync_strt_char)
{
  reg->bitfields.CRTC_H_SYNC_STRT_CHAR = crtc_h_sync_strt_char;
  if (reg->bitfields.CRTC_H_SYNC_STRT_CHAR != crtc_h_sync_strt_char) HSLDPF(E_ERROR_MESSAGE,"CRTC_H_SYNC_STRT_WID::CRTC_H_SYNC_STRT_CHAR data too large\n");
}
__inline void set_CRTC_H_SYNC_STRT_WID_crtc_h_sync_wid(regCRTC_H_SYNC_STRT_WID *reg, unsigned int crtc_h_sync_wid)
{
  reg->bitfields.CRTC_H_SYNC_WID = crtc_h_sync_wid;
  if (reg->bitfields.CRTC_H_SYNC_WID != crtc_h_sync_wid) HSLDPF(E_ERROR_MESSAGE,"CRTC_H_SYNC_STRT_WID::CRTC_H_SYNC_WID data too large\n");
}
__inline void set_CRTC_H_SYNC_STRT_WID_crtc_h_sync_pol(regCRTC_H_SYNC_STRT_WID *reg, unsigned int crtc_h_sync_pol)
{
  reg->bitfields.CRTC_H_SYNC_POL = crtc_h_sync_pol;
  if (reg->bitfields.CRTC_H_SYNC_POL != crtc_h_sync_pol) HSLDPF(E_ERROR_MESSAGE,"CRTC_H_SYNC_STRT_WID::CRTC_H_SYNC_POL data too large\n");
}
__inline void set_CRTC_H_SYNC_STRT_WID_crtc_h_sync_skew_tune(regCRTC_H_SYNC_STRT_WID *reg, unsigned int crtc_h_sync_skew_tune)
{
  reg->bitfields.CRTC_H_SYNC_SKEW_TUNE = crtc_h_sync_skew_tune;
  if (reg->bitfields.CRTC_H_SYNC_SKEW_TUNE != crtc_h_sync_skew_tune) HSLDPF(E_ERROR_MESSAGE,"CRTC_H_SYNC_STRT_WID::CRTC_H_SYNC_SKEW_TUNE data too large\n");
}
__inline void set_CRTC_H_SYNC_STRT_WID_crtc_h_sync_skew_tune_mode(regCRTC_H_SYNC_STRT_WID *reg, unsigned int crtc_h_sync_skew_tune_mode)
{
  reg->bitfields.CRTC_H_SYNC_SKEW_TUNE_MODE = crtc_h_sync_skew_tune_mode;
  if (reg->bitfields.CRTC_H_SYNC_SKEW_TUNE_MODE != crtc_h_sync_skew_tune_mode) HSLDPF(E_ERROR_MESSAGE,"CRTC_H_SYNC_STRT_WID::CRTC_H_SYNC_SKEW_TUNE_MODE data too large\n");
}
#else
#define set_CRTC_H_SYNC_STRT_WID_crtc_h_sync_strt_pix(reg, crtc_h_sync_strt_pix) (reg)->bitfields.CRTC_H_SYNC_STRT_PIX = crtc_h_sync_strt_pix
#define set_CRTC_H_SYNC_STRT_WID_crtc_h_sync_strt_char(reg, crtc_h_sync_strt_char) (reg)->bitfields.CRTC_H_SYNC_STRT_CHAR = crtc_h_sync_strt_char
#define set_CRTC_H_SYNC_STRT_WID_crtc_h_sync_wid(reg, crtc_h_sync_wid) (reg)->bitfields.CRTC_H_SYNC_WID = crtc_h_sync_wid
#define set_CRTC_H_SYNC_STRT_WID_crtc_h_sync_pol(reg, crtc_h_sync_pol) (reg)->bitfields.CRTC_H_SYNC_POL = crtc_h_sync_pol
#define set_CRTC_H_SYNC_STRT_WID_crtc_h_sync_skew_tune(reg, crtc_h_sync_skew_tune) (reg)->bitfields.CRTC_H_SYNC_SKEW_TUNE = crtc_h_sync_skew_tune
#define set_CRTC_H_SYNC_STRT_WID_crtc_h_sync_skew_tune_mode(reg, crtc_h_sync_skew_tune_mode) (reg)->bitfields.CRTC_H_SYNC_SKEW_TUNE_MODE = crtc_h_sync_skew_tune_mode

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC_V_TOTAL_DISP regCRTC_V_TOTAL_DISP;

#ifdef DEBUG
__inline void set_CRTC_V_TOTAL_DISP_crtc_v_total(regCRTC_V_TOTAL_DISP *reg, unsigned int crtc_v_total)
{
  reg->bitfields.CRTC_V_TOTAL = crtc_v_total;
  if (reg->bitfields.CRTC_V_TOTAL != crtc_v_total) HSLDPF(E_ERROR_MESSAGE,"CRTC_V_TOTAL_DISP::CRTC_V_TOTAL data too large\n");
}
__inline void set_CRTC_V_TOTAL_DISP_crtc_v_disp(regCRTC_V_TOTAL_DISP *reg, unsigned int crtc_v_disp)
{
  reg->bitfields.CRTC_V_DISP = crtc_v_disp;
  if (reg->bitfields.CRTC_V_DISP != crtc_v_disp) HSLDPF(E_ERROR_MESSAGE,"CRTC_V_TOTAL_DISP::CRTC_V_DISP data too large\n");
}
#else
#define set_CRTC_V_TOTAL_DISP_crtc_v_total(reg, crtc_v_total) (reg)->bitfields.CRTC_V_TOTAL = crtc_v_total
#define set_CRTC_V_TOTAL_DISP_crtc_v_disp(reg, crtc_v_disp) (reg)->bitfields.CRTC_V_DISP = crtc_v_disp

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC_V_SYNC_STRT_WID regCRTC_V_SYNC_STRT_WID;

#ifdef DEBUG
__inline void set_CRTC_V_SYNC_STRT_WID_crtc_v_sync_strt(regCRTC_V_SYNC_STRT_WID *reg, unsigned int crtc_v_sync_strt)
{
  reg->bitfields.CRTC_V_SYNC_STRT = crtc_v_sync_strt;
  if (reg->bitfields.CRTC_V_SYNC_STRT != crtc_v_sync_strt) HSLDPF(E_ERROR_MESSAGE,"CRTC_V_SYNC_STRT_WID::CRTC_V_SYNC_STRT data too large\n");
}
__inline void set_CRTC_V_SYNC_STRT_WID_crtc_v_sync_wid(regCRTC_V_SYNC_STRT_WID *reg, unsigned int crtc_v_sync_wid)
{
  reg->bitfields.CRTC_V_SYNC_WID = crtc_v_sync_wid;
  if (reg->bitfields.CRTC_V_SYNC_WID != crtc_v_sync_wid) HSLDPF(E_ERROR_MESSAGE,"CRTC_V_SYNC_STRT_WID::CRTC_V_SYNC_WID data too large\n");
}
__inline void set_CRTC_V_SYNC_STRT_WID_crtc_v_sync_pol(regCRTC_V_SYNC_STRT_WID *reg, unsigned int crtc_v_sync_pol)
{
  reg->bitfields.CRTC_V_SYNC_POL = crtc_v_sync_pol;
  if (reg->bitfields.CRTC_V_SYNC_POL != crtc_v_sync_pol) HSLDPF(E_ERROR_MESSAGE,"CRTC_V_SYNC_STRT_WID::CRTC_V_SYNC_POL data too large\n");
}
#else
#define set_CRTC_V_SYNC_STRT_WID_crtc_v_sync_strt(reg, crtc_v_sync_strt) (reg)->bitfields.CRTC_V_SYNC_STRT = crtc_v_sync_strt
#define set_CRTC_V_SYNC_STRT_WID_crtc_v_sync_wid(reg, crtc_v_sync_wid) (reg)->bitfields.CRTC_V_SYNC_WID = crtc_v_sync_wid
#define set_CRTC_V_SYNC_STRT_WID_crtc_v_sync_pol(reg, crtc_v_sync_pol) (reg)->bitfields.CRTC_V_SYNC_POL = crtc_v_sync_pol

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC_VLINE_CRNT_VLINE regCRTC_VLINE_CRNT_VLINE;

#ifdef DEBUG
__inline void set_CRTC_VLINE_CRNT_VLINE_crtc_vline(regCRTC_VLINE_CRNT_VLINE *reg, unsigned int crtc_vline)
{
  reg->bitfields.CRTC_VLINE = crtc_vline;
  if (reg->bitfields.CRTC_VLINE != crtc_vline) HSLDPF(E_ERROR_MESSAGE,"CRTC_VLINE_CRNT_VLINE::CRTC_VLINE data too large\n");
}
__inline void set_CRTC_VLINE_CRNT_VLINE_crtc_crnt_vline(regCRTC_VLINE_CRNT_VLINE *reg, unsigned int crtc_crnt_vline)
{
  reg->bitfields.CRTC_CRNT_VLINE = crtc_crnt_vline;
  if (reg->bitfields.CRTC_CRNT_VLINE != crtc_crnt_vline) HSLDPF(E_ERROR_MESSAGE,"CRTC_VLINE_CRNT_VLINE::CRTC_CRNT_VLINE data too large\n");
}
#else
#define set_CRTC_VLINE_CRNT_VLINE_crtc_vline(reg, crtc_vline) (reg)->bitfields.CRTC_VLINE = crtc_vline
#define set_CRTC_VLINE_CRNT_VLINE_crtc_crnt_vline(reg, crtc_crnt_vline) (reg)->bitfields.CRTC_CRNT_VLINE = crtc_crnt_vline

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC_CRNT_FRAME regCRTC_CRNT_FRAME;

#ifdef DEBUG
__inline void set_CRTC_CRNT_FRAME_crtc_crnt_frame(regCRTC_CRNT_FRAME *reg, unsigned int crtc_crnt_frame)
{
  reg->bitfields.CRTC_CRNT_FRAME = crtc_crnt_frame;
  if (reg->bitfields.CRTC_CRNT_FRAME != crtc_crnt_frame) HSLDPF(E_ERROR_MESSAGE,"CRTC_CRNT_FRAME::CRTC_CRNT_FRAME data too large\n");
}
#else
#define set_CRTC_CRNT_FRAME_crtc_crnt_frame(reg, crtc_crnt_frame) (reg)->bitfields.CRTC_CRNT_FRAME = crtc_crnt_frame

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC_GUI_TRIG_VLINE regCRTC_GUI_TRIG_VLINE;

#ifdef DEBUG
__inline void set_CRTC_GUI_TRIG_VLINE_crtc_gui_trig_vline_start(regCRTC_GUI_TRIG_VLINE *reg, unsigned int crtc_gui_trig_vline_start)
{
  reg->bitfields.CRTC_GUI_TRIG_VLINE_START = crtc_gui_trig_vline_start;
  if (reg->bitfields.CRTC_GUI_TRIG_VLINE_START != crtc_gui_trig_vline_start) HSLDPF(E_ERROR_MESSAGE,"CRTC_GUI_TRIG_VLINE::CRTC_GUI_TRIG_VLINE_START data too large\n");
}
__inline void set_CRTC_GUI_TRIG_VLINE_crtc_gui_trig_vline_inv(regCRTC_GUI_TRIG_VLINE *reg, unsigned int crtc_gui_trig_vline_inv)
{
  reg->bitfields.CRTC_GUI_TRIG_VLINE_INV = crtc_gui_trig_vline_inv;
  if (reg->bitfields.CRTC_GUI_TRIG_VLINE_INV != crtc_gui_trig_vline_inv) HSLDPF(E_ERROR_MESSAGE,"CRTC_GUI_TRIG_VLINE::CRTC_GUI_TRIG_VLINE_INV data too large\n");
}
__inline void set_CRTC_GUI_TRIG_VLINE_crtc_gui_trig_vline_end(regCRTC_GUI_TRIG_VLINE *reg, unsigned int crtc_gui_trig_vline_end)
{
  reg->bitfields.CRTC_GUI_TRIG_VLINE_END = crtc_gui_trig_vline_end;
  if (reg->bitfields.CRTC_GUI_TRIG_VLINE_END != crtc_gui_trig_vline_end) HSLDPF(E_ERROR_MESSAGE,"CRTC_GUI_TRIG_VLINE::CRTC_GUI_TRIG_VLINE_END data too large\n");
}
__inline void set_CRTC_GUI_TRIG_VLINE_crtc_gui_trig_vline_stall(regCRTC_GUI_TRIG_VLINE *reg, unsigned int crtc_gui_trig_vline_stall)
{
  reg->bitfields.CRTC_GUI_TRIG_VLINE_STALL = crtc_gui_trig_vline_stall;
  if (reg->bitfields.CRTC_GUI_TRIG_VLINE_STALL != crtc_gui_trig_vline_stall) HSLDPF(E_ERROR_MESSAGE,"CRTC_GUI_TRIG_VLINE::CRTC_GUI_TRIG_VLINE_STALL data too large\n");
}
__inline void set_CRTC_GUI_TRIG_VLINE_crtc_gui_trig_vline(regCRTC_GUI_TRIG_VLINE *reg, unsigned int crtc_gui_trig_vline)
{
  reg->bitfields.CRTC_GUI_TRIG_VLINE = crtc_gui_trig_vline;
  if (reg->bitfields.CRTC_GUI_TRIG_VLINE != crtc_gui_trig_vline) HSLDPF(E_ERROR_MESSAGE,"CRTC_GUI_TRIG_VLINE::CRTC_GUI_TRIG_VLINE data too large\n");
}
#else
#define set_CRTC_GUI_TRIG_VLINE_crtc_gui_trig_vline_start(reg, crtc_gui_trig_vline_start) (reg)->bitfields.CRTC_GUI_TRIG_VLINE_START = crtc_gui_trig_vline_start
#define set_CRTC_GUI_TRIG_VLINE_crtc_gui_trig_vline_inv(reg, crtc_gui_trig_vline_inv) (reg)->bitfields.CRTC_GUI_TRIG_VLINE_INV = crtc_gui_trig_vline_inv
#define set_CRTC_GUI_TRIG_VLINE_crtc_gui_trig_vline_end(reg, crtc_gui_trig_vline_end) (reg)->bitfields.CRTC_GUI_TRIG_VLINE_END = crtc_gui_trig_vline_end
#define set_CRTC_GUI_TRIG_VLINE_crtc_gui_trig_vline_stall(reg, crtc_gui_trig_vline_stall) (reg)->bitfields.CRTC_GUI_TRIG_VLINE_STALL = crtc_gui_trig_vline_stall
#define set_CRTC_GUI_TRIG_VLINE_crtc_gui_trig_vline(reg, crtc_gui_trig_vline) (reg)->bitfields.CRTC_GUI_TRIG_VLINE = crtc_gui_trig_vline

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC_DEBUG regCRTC_DEBUG;

#ifdef DEBUG
__inline void set_CRTC_DEBUG_crtc_gui_trig_bypass_en(regCRTC_DEBUG *reg, unsigned int crtc_gui_trig_bypass_en)
{
  reg->bitfields.CRTC_GUI_TRIG_BYPASS_EN = crtc_gui_trig_bypass_en;
  if (reg->bitfields.CRTC_GUI_TRIG_BYPASS_EN != crtc_gui_trig_bypass_en) HSLDPF(E_ERROR_MESSAGE,"CRTC_DEBUG::CRTC_GUI_TRIG_BYPASS_EN data too large\n");
}
__inline void set_CRTC_DEBUG_gui_trig_vline_bypass(regCRTC_DEBUG *reg, unsigned int gui_trig_vline_bypass)
{
  reg->bitfields.GUI_TRIG_VLINE_BYPASS = gui_trig_vline_bypass;
  if (reg->bitfields.GUI_TRIG_VLINE_BYPASS != gui_trig_vline_bypass) HSLDPF(E_ERROR_MESSAGE,"CRTC_DEBUG::GUI_TRIG_VLINE_BYPASS data too large\n");
}
__inline void set_CRTC_DEBUG_gui_trig_offset_bypass(regCRTC_DEBUG *reg, unsigned int gui_trig_offset_bypass)
{
  reg->bitfields.GUI_TRIG_OFFSET_BYPASS = gui_trig_offset_bypass;
  if (reg->bitfields.GUI_TRIG_OFFSET_BYPASS != gui_trig_offset_bypass) HSLDPF(E_ERROR_MESSAGE,"CRTC_DEBUG::GUI_TRIG_OFFSET_BYPASS data too large\n");
}
__inline void set_CRTC_DEBUG_gui_trig_pitch_add_bypass(regCRTC_DEBUG *reg, unsigned int gui_trig_pitch_add_bypass)
{
  reg->bitfields.GUI_TRIG_PITCH_ADD_BYPASS = gui_trig_pitch_add_bypass;
  if (reg->bitfields.GUI_TRIG_PITCH_ADD_BYPASS != gui_trig_pitch_add_bypass) HSLDPF(E_ERROR_MESSAGE,"CRTC_DEBUG::GUI_TRIG_PITCH_ADD_BYPASS data too large\n");
}
#else
#define set_CRTC_DEBUG_crtc_gui_trig_bypass_en(reg, crtc_gui_trig_bypass_en) (reg)->bitfields.CRTC_GUI_TRIG_BYPASS_EN = crtc_gui_trig_bypass_en
#define set_CRTC_DEBUG_gui_trig_vline_bypass(reg, gui_trig_vline_bypass) (reg)->bitfields.GUI_TRIG_VLINE_BYPASS = gui_trig_vline_bypass
#define set_CRTC_DEBUG_gui_trig_offset_bypass(reg, gui_trig_offset_bypass) (reg)->bitfields.GUI_TRIG_OFFSET_BYPASS = gui_trig_offset_bypass
#define set_CRTC_DEBUG_gui_trig_pitch_add_bypass(reg, gui_trig_pitch_add_bypass) (reg)->bitfields.GUI_TRIG_PITCH_ADD_BYPASS = gui_trig_pitch_add_bypass

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC_OFFSET_RIGHT regCRTC_OFFSET_RIGHT;

#ifdef DEBUG
__inline void set_CRTC_OFFSET_RIGHT_crtc_offset_right(regCRTC_OFFSET_RIGHT *reg, unsigned int crtc_offset_right)
{
  reg->bitfields.CRTC_OFFSET_RIGHT = crtc_offset_right;
  if (reg->bitfields.CRTC_OFFSET_RIGHT != crtc_offset_right) HSLDPF(E_ERROR_MESSAGE,"CRTC_OFFSET_RIGHT::CRTC_OFFSET_RIGHT data too large\n");
}
__inline void set_CRTC_OFFSET_RIGHT_crtc_gui_trig_offset(regCRTC_OFFSET_RIGHT *reg, unsigned int crtc_gui_trig_offset)
{
  reg->bitfields.CRTC_GUI_TRIG_OFFSET = crtc_gui_trig_offset;
  if (reg->bitfields.CRTC_GUI_TRIG_OFFSET != crtc_gui_trig_offset) HSLDPF(E_ERROR_MESSAGE,"CRTC_OFFSET_RIGHT::CRTC_GUI_TRIG_OFFSET data too large\n");
}
__inline void set_CRTC_OFFSET_RIGHT_crtc_offset_lock(regCRTC_OFFSET_RIGHT *reg, unsigned int crtc_offset_lock)
{
  reg->bitfields.CRTC_OFFSET_LOCK = crtc_offset_lock;
  if (reg->bitfields.CRTC_OFFSET_LOCK != crtc_offset_lock) HSLDPF(E_ERROR_MESSAGE,"CRTC_OFFSET_RIGHT::CRTC_OFFSET_LOCK data too large\n");
}
#else
#define set_CRTC_OFFSET_RIGHT_crtc_offset_right(reg, crtc_offset_right) (reg)->bitfields.CRTC_OFFSET_RIGHT = crtc_offset_right
#define set_CRTC_OFFSET_RIGHT_crtc_gui_trig_offset(reg, crtc_gui_trig_offset) (reg)->bitfields.CRTC_GUI_TRIG_OFFSET = crtc_gui_trig_offset
#define set_CRTC_OFFSET_RIGHT_crtc_offset_lock(reg, crtc_offset_lock) (reg)->bitfields.CRTC_OFFSET_LOCK = crtc_offset_lock

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC_OFFSET regCRTC_OFFSET;

#ifdef DEBUG
__inline void set_CRTC_OFFSET_crtc_offset(regCRTC_OFFSET *reg, unsigned int crtc_offset)
{
  reg->bitfields.CRTC_OFFSET = crtc_offset;
  if (reg->bitfields.CRTC_OFFSET != crtc_offset) HSLDPF(E_ERROR_MESSAGE,"CRTC_OFFSET::CRTC_OFFSET data too large\n");
}
__inline void set_CRTC_OFFSET_crtc_gui_trig_offset(regCRTC_OFFSET *reg, unsigned int crtc_gui_trig_offset)
{
  reg->bitfields.CRTC_GUI_TRIG_OFFSET = crtc_gui_trig_offset;
  if (reg->bitfields.CRTC_GUI_TRIG_OFFSET != crtc_gui_trig_offset) HSLDPF(E_ERROR_MESSAGE,"CRTC_OFFSET::CRTC_GUI_TRIG_OFFSET data too large\n");
}
__inline void set_CRTC_OFFSET_crtc_offset_lock(regCRTC_OFFSET *reg, unsigned int crtc_offset_lock)
{
  reg->bitfields.CRTC_OFFSET_LOCK = crtc_offset_lock;
  if (reg->bitfields.CRTC_OFFSET_LOCK != crtc_offset_lock) HSLDPF(E_ERROR_MESSAGE,"CRTC_OFFSET::CRTC_OFFSET_LOCK data too large\n");
}
#else
#define set_CRTC_OFFSET_crtc_offset(reg, crtc_offset) (reg)->bitfields.CRTC_OFFSET = crtc_offset
#define set_CRTC_OFFSET_crtc_gui_trig_offset(reg, crtc_gui_trig_offset) (reg)->bitfields.CRTC_GUI_TRIG_OFFSET = crtc_gui_trig_offset
#define set_CRTC_OFFSET_crtc_offset_lock(reg, crtc_offset_lock) (reg)->bitfields.CRTC_OFFSET_LOCK = crtc_offset_lock

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC_OFFSET_CNTL regCRTC_OFFSET_CNTL;

#ifdef DEBUG
__inline void set_CRTC_OFFSET_CNTL_crtc_tile_line(regCRTC_OFFSET_CNTL *reg, unsigned int crtc_tile_line)
{
  reg->bitfields.CRTC_TILE_LINE = crtc_tile_line;
  if (reg->bitfields.CRTC_TILE_LINE != crtc_tile_line) HSLDPF(E_ERROR_MESSAGE,"CRTC_OFFSET_CNTL::CRTC_TILE_LINE data too large\n");
}
__inline void set_CRTC_OFFSET_CNTL_crtc_tile_line_right(regCRTC_OFFSET_CNTL *reg, unsigned int crtc_tile_line_right)
{
  reg->bitfields.CRTC_TILE_LINE_RIGHT = crtc_tile_line_right;
  if (reg->bitfields.CRTC_TILE_LINE_RIGHT != crtc_tile_line_right) HSLDPF(E_ERROR_MESSAGE,"CRTC_OFFSET_CNTL::CRTC_TILE_LINE_RIGHT data too large\n");
}
__inline void set_CRTC_OFFSET_CNTL_crtc_tile_en_right(regCRTC_OFFSET_CNTL *reg, unsigned int crtc_tile_en_right)
{
  reg->bitfields.CRTC_TILE_EN_RIGHT = crtc_tile_en_right;
  if (reg->bitfields.CRTC_TILE_EN_RIGHT != crtc_tile_en_right) HSLDPF(E_ERROR_MESSAGE,"CRTC_OFFSET_CNTL::CRTC_TILE_EN_RIGHT data too large\n");
}
__inline void set_CRTC_OFFSET_CNTL_crtc_tile_en(regCRTC_OFFSET_CNTL *reg, unsigned int crtc_tile_en)
{
  reg->bitfields.CRTC_TILE_EN = crtc_tile_en;
  if (reg->bitfields.CRTC_TILE_EN != crtc_tile_en) HSLDPF(E_ERROR_MESSAGE,"CRTC_OFFSET_CNTL::CRTC_TILE_EN data too large\n");
}
__inline void set_CRTC_OFFSET_CNTL_crtc_offset_flip_cntl(regCRTC_OFFSET_CNTL *reg, unsigned int crtc_offset_flip_cntl)
{
  reg->bitfields.CRTC_OFFSET_FLIP_CNTL = crtc_offset_flip_cntl;
  if (reg->bitfields.CRTC_OFFSET_FLIP_CNTL != crtc_offset_flip_cntl) HSLDPF(E_ERROR_MESSAGE,"CRTC_OFFSET_CNTL::CRTC_OFFSET_FLIP_CNTL data too large\n");
}
__inline void set_CRTC_OFFSET_CNTL_crtc_stereo_offset_en(regCRTC_OFFSET_CNTL *reg, unsigned int crtc_stereo_offset_en)
{
  reg->bitfields.CRTC_STEREO_OFFSET_EN = crtc_stereo_offset_en;
  if (reg->bitfields.CRTC_STEREO_OFFSET_EN != crtc_stereo_offset_en) HSLDPF(E_ERROR_MESSAGE,"CRTC_OFFSET_CNTL::CRTC_STEREO_OFFSET_EN data too large\n");
}
__inline void set_CRTC_OFFSET_CNTL_crtc_stereo_sync_en(regCRTC_OFFSET_CNTL *reg, unsigned int crtc_stereo_sync_en)
{
  reg->bitfields.CRTC_STEREO_SYNC_EN = crtc_stereo_sync_en;
  if (reg->bitfields.CRTC_STEREO_SYNC_EN != crtc_stereo_sync_en) HSLDPF(E_ERROR_MESSAGE,"CRTC_OFFSET_CNTL::CRTC_STEREO_SYNC_EN data too large\n");
}
__inline void set_CRTC_OFFSET_CNTL_crtc_stereo_sync_out_en(regCRTC_OFFSET_CNTL *reg, unsigned int crtc_stereo_sync_out_en)
{
  reg->bitfields.CRTC_STEREO_SYNC_OUT_EN = crtc_stereo_sync_out_en;
  if (reg->bitfields.CRTC_STEREO_SYNC_OUT_EN != crtc_stereo_sync_out_en) HSLDPF(E_ERROR_MESSAGE,"CRTC_OFFSET_CNTL::CRTC_STEREO_SYNC_OUT_EN data too large\n");
}
__inline void set_CRTC_OFFSET_CNTL_crtc_stereo_sync(regCRTC_OFFSET_CNTL *reg, unsigned int crtc_stereo_sync)
{
  reg->bitfields.CRTC_STEREO_SYNC = crtc_stereo_sync;
  if (reg->bitfields.CRTC_STEREO_SYNC != crtc_stereo_sync) HSLDPF(E_ERROR_MESSAGE,"CRTC_OFFSET_CNTL::CRTC_STEREO_SYNC data too large\n");
}
__inline void set_CRTC_OFFSET_CNTL_crtc_gui_trig_offset_left_en(regCRTC_OFFSET_CNTL *reg, unsigned int crtc_gui_trig_offset_left_en)
{
  reg->bitfields.CRTC_GUI_TRIG_OFFSET_LEFT_EN = crtc_gui_trig_offset_left_en;
  if (reg->bitfields.CRTC_GUI_TRIG_OFFSET_LEFT_EN != crtc_gui_trig_offset_left_en) HSLDPF(E_ERROR_MESSAGE,"CRTC_OFFSET_CNTL::CRTC_GUI_TRIG_OFFSET_LEFT_EN data too large\n");
}
__inline void set_CRTC_OFFSET_CNTL_crtc_gui_trig_offset_right_en(regCRTC_OFFSET_CNTL *reg, unsigned int crtc_gui_trig_offset_right_en)
{
  reg->bitfields.CRTC_GUI_TRIG_OFFSET_RIGHT_EN = crtc_gui_trig_offset_right_en;
  if (reg->bitfields.CRTC_GUI_TRIG_OFFSET_RIGHT_EN != crtc_gui_trig_offset_right_en) HSLDPF(E_ERROR_MESSAGE,"CRTC_OFFSET_CNTL::CRTC_GUI_TRIG_OFFSET_RIGHT_EN data too large\n");
}
__inline void set_CRTC_OFFSET_CNTL_crtc_gui_trig_offset(regCRTC_OFFSET_CNTL *reg, unsigned int crtc_gui_trig_offset)
{
  reg->bitfields.CRTC_GUI_TRIG_OFFSET = crtc_gui_trig_offset;
  if (reg->bitfields.CRTC_GUI_TRIG_OFFSET != crtc_gui_trig_offset) HSLDPF(E_ERROR_MESSAGE,"CRTC_OFFSET_CNTL::CRTC_GUI_TRIG_OFFSET data too large\n");
}
__inline void set_CRTC_OFFSET_CNTL_crtc_offset_lock(regCRTC_OFFSET_CNTL *reg, unsigned int crtc_offset_lock)
{
  reg->bitfields.CRTC_OFFSET_LOCK = crtc_offset_lock;
  if (reg->bitfields.CRTC_OFFSET_LOCK != crtc_offset_lock) HSLDPF(E_ERROR_MESSAGE,"CRTC_OFFSET_CNTL::CRTC_OFFSET_LOCK data too large\n");
}
#else
#define set_CRTC_OFFSET_CNTL_crtc_tile_line(reg, crtc_tile_line) (reg)->bitfields.CRTC_TILE_LINE = crtc_tile_line
#define set_CRTC_OFFSET_CNTL_crtc_tile_line_right(reg, crtc_tile_line_right) (reg)->bitfields.CRTC_TILE_LINE_RIGHT = crtc_tile_line_right
#define set_CRTC_OFFSET_CNTL_crtc_tile_en_right(reg, crtc_tile_en_right) (reg)->bitfields.CRTC_TILE_EN_RIGHT = crtc_tile_en_right
#define set_CRTC_OFFSET_CNTL_crtc_tile_en(reg, crtc_tile_en) (reg)->bitfields.CRTC_TILE_EN = crtc_tile_en
#define set_CRTC_OFFSET_CNTL_crtc_offset_flip_cntl(reg, crtc_offset_flip_cntl) (reg)->bitfields.CRTC_OFFSET_FLIP_CNTL = crtc_offset_flip_cntl
#define set_CRTC_OFFSET_CNTL_crtc_stereo_offset_en(reg, crtc_stereo_offset_en) (reg)->bitfields.CRTC_STEREO_OFFSET_EN = crtc_stereo_offset_en
#define set_CRTC_OFFSET_CNTL_crtc_stereo_sync_en(reg, crtc_stereo_sync_en) (reg)->bitfields.CRTC_STEREO_SYNC_EN = crtc_stereo_sync_en
#define set_CRTC_OFFSET_CNTL_crtc_stereo_sync_out_en(reg, crtc_stereo_sync_out_en) (reg)->bitfields.CRTC_STEREO_SYNC_OUT_EN = crtc_stereo_sync_out_en
#define set_CRTC_OFFSET_CNTL_crtc_stereo_sync(reg, crtc_stereo_sync) (reg)->bitfields.CRTC_STEREO_SYNC = crtc_stereo_sync
#define set_CRTC_OFFSET_CNTL_crtc_gui_trig_offset_left_en(reg, crtc_gui_trig_offset_left_en) (reg)->bitfields.CRTC_GUI_TRIG_OFFSET_LEFT_EN = crtc_gui_trig_offset_left_en
#define set_CRTC_OFFSET_CNTL_crtc_gui_trig_offset_right_en(reg, crtc_gui_trig_offset_right_en) (reg)->bitfields.CRTC_GUI_TRIG_OFFSET_RIGHT_EN = crtc_gui_trig_offset_right_en
#define set_CRTC_OFFSET_CNTL_crtc_gui_trig_offset(reg, crtc_gui_trig_offset) (reg)->bitfields.CRTC_GUI_TRIG_OFFSET = crtc_gui_trig_offset
#define set_CRTC_OFFSET_CNTL_crtc_offset_lock(reg, crtc_offset_lock) (reg)->bitfields.CRTC_OFFSET_LOCK = crtc_offset_lock

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC_PITCH regCRTC_PITCH;

#ifdef DEBUG
__inline void set_CRTC_PITCH_crtc_pitch(regCRTC_PITCH *reg, unsigned int crtc_pitch)
{
  reg->bitfields.CRTC_PITCH = crtc_pitch;
  if (reg->bitfields.CRTC_PITCH != crtc_pitch) HSLDPF(E_ERROR_MESSAGE,"CRTC_PITCH::CRTC_PITCH data too large\n");
}
__inline void set_CRTC_PITCH_crtc_pitch_right(regCRTC_PITCH *reg, unsigned int crtc_pitch_right)
{
  reg->bitfields.CRTC_PITCH_RIGHT = crtc_pitch_right;
  if (reg->bitfields.CRTC_PITCH_RIGHT != crtc_pitch_right) HSLDPF(E_ERROR_MESSAGE,"CRTC_PITCH::CRTC_PITCH_RIGHT data too large\n");
}
#else
#define set_CRTC_PITCH_crtc_pitch(reg, crtc_pitch) (reg)->bitfields.CRTC_PITCH = crtc_pitch
#define set_CRTC_PITCH_crtc_pitch_right(reg, crtc_pitch_right) (reg)->bitfields.CRTC_PITCH_RIGHT = crtc_pitch_right

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OVR_CLR regOVR_CLR;

#ifdef DEBUG
__inline void set_OVR_CLR_ovr_clr_b(regOVR_CLR *reg, unsigned int ovr_clr_b)
{
  reg->bitfields.OVR_CLR_B = ovr_clr_b;
  if (reg->bitfields.OVR_CLR_B != ovr_clr_b) HSLDPF(E_ERROR_MESSAGE,"OVR_CLR::OVR_CLR_B data too large\n");
}
__inline void set_OVR_CLR_ovr_clr_g(regOVR_CLR *reg, unsigned int ovr_clr_g)
{
  reg->bitfields.OVR_CLR_G = ovr_clr_g;
  if (reg->bitfields.OVR_CLR_G != ovr_clr_g) HSLDPF(E_ERROR_MESSAGE,"OVR_CLR::OVR_CLR_G data too large\n");
}
__inline void set_OVR_CLR_ovr_clr_r(regOVR_CLR *reg, unsigned int ovr_clr_r)
{
  reg->bitfields.OVR_CLR_R = ovr_clr_r;
  if (reg->bitfields.OVR_CLR_R != ovr_clr_r) HSLDPF(E_ERROR_MESSAGE,"OVR_CLR::OVR_CLR_R data too large\n");
}
#else
#define set_OVR_CLR_ovr_clr_b(reg, ovr_clr_b) (reg)->bitfields.OVR_CLR_B = ovr_clr_b
#define set_OVR_CLR_ovr_clr_g(reg, ovr_clr_g) (reg)->bitfields.OVR_CLR_G = ovr_clr_g
#define set_OVR_CLR_ovr_clr_r(reg, ovr_clr_r) (reg)->bitfields.OVR_CLR_R = ovr_clr_r

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OVR_WID_LEFT_RIGHT regOVR_WID_LEFT_RIGHT;

#ifdef DEBUG
__inline void set_OVR_WID_LEFT_RIGHT_ovr_wid_right(regOVR_WID_LEFT_RIGHT *reg, unsigned int ovr_wid_right)
{
  reg->bitfields.OVR_WID_RIGHT = ovr_wid_right;
  if (reg->bitfields.OVR_WID_RIGHT != ovr_wid_right) HSLDPF(E_ERROR_MESSAGE,"OVR_WID_LEFT_RIGHT::OVR_WID_RIGHT data too large\n");
}
__inline void set_OVR_WID_LEFT_RIGHT_ovr_wid_left(regOVR_WID_LEFT_RIGHT *reg, unsigned int ovr_wid_left)
{
  reg->bitfields.OVR_WID_LEFT = ovr_wid_left;
  if (reg->bitfields.OVR_WID_LEFT != ovr_wid_left) HSLDPF(E_ERROR_MESSAGE,"OVR_WID_LEFT_RIGHT::OVR_WID_LEFT data too large\n");
}
#else
#define set_OVR_WID_LEFT_RIGHT_ovr_wid_right(reg, ovr_wid_right) (reg)->bitfields.OVR_WID_RIGHT = ovr_wid_right
#define set_OVR_WID_LEFT_RIGHT_ovr_wid_left(reg, ovr_wid_left) (reg)->bitfields.OVR_WID_LEFT = ovr_wid_left

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OVR_WID_TOP_BOTTOM regOVR_WID_TOP_BOTTOM;

#ifdef DEBUG
__inline void set_OVR_WID_TOP_BOTTOM_ovr_wid_bottom(regOVR_WID_TOP_BOTTOM *reg, unsigned int ovr_wid_bottom)
{
  reg->bitfields.OVR_WID_BOTTOM = ovr_wid_bottom;
  if (reg->bitfields.OVR_WID_BOTTOM != ovr_wid_bottom) HSLDPF(E_ERROR_MESSAGE,"OVR_WID_TOP_BOTTOM::OVR_WID_BOTTOM data too large\n");
}
__inline void set_OVR_WID_TOP_BOTTOM_ovr_wid_top(regOVR_WID_TOP_BOTTOM *reg, unsigned int ovr_wid_top)
{
  reg->bitfields.OVR_WID_TOP = ovr_wid_top;
  if (reg->bitfields.OVR_WID_TOP != ovr_wid_top) HSLDPF(E_ERROR_MESSAGE,"OVR_WID_TOP_BOTTOM::OVR_WID_TOP data too large\n");
}
#else
#define set_OVR_WID_TOP_BOTTOM_ovr_wid_bottom(reg, ovr_wid_bottom) (reg)->bitfields.OVR_WID_BOTTOM = ovr_wid_bottom
#define set_OVR_WID_TOP_BOTTOM_ovr_wid_top(reg, ovr_wid_top) (reg)->bitfields.OVR_WID_TOP = ovr_wid_top

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISPLAY_BASE_ADDR regDISPLAY_BASE_ADDR;

#ifdef DEBUG
__inline void set_DISPLAY_BASE_ADDR_display_base_addr(regDISPLAY_BASE_ADDR *reg, unsigned int display_base_addr)
{
  reg->bitfields.DISPLAY_BASE_ADDR = display_base_addr;
  if (reg->bitfields.DISPLAY_BASE_ADDR != display_base_addr) HSLDPF(E_ERROR_MESSAGE,"DISPLAY_BASE_ADDR::DISPLAY_BASE_ADDR data too large\n");
}
#else
#define set_DISPLAY_BASE_ADDR_display_base_addr(reg, display_base_addr) (reg)->bitfields.DISPLAY_BASE_ADDR = display_base_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SNAPSHOT_VH_COUNTS regSNAPSHOT_VH_COUNTS;

#ifdef DEBUG
__inline void set_SNAPSHOT_VH_COUNTS_snapshot_hcount(regSNAPSHOT_VH_COUNTS *reg, unsigned int snapshot_hcount)
{
  reg->bitfields.SNAPSHOT_HCOUNT = snapshot_hcount;
  if (reg->bitfields.SNAPSHOT_HCOUNT != snapshot_hcount) HSLDPF(E_ERROR_MESSAGE,"SNAPSHOT_VH_COUNTS::SNAPSHOT_HCOUNT data too large\n");
}
__inline void set_SNAPSHOT_VH_COUNTS_snapshot_vcount(regSNAPSHOT_VH_COUNTS *reg, unsigned int snapshot_vcount)
{
  reg->bitfields.SNAPSHOT_VCOUNT = snapshot_vcount;
  if (reg->bitfields.SNAPSHOT_VCOUNT != snapshot_vcount) HSLDPF(E_ERROR_MESSAGE,"SNAPSHOT_VH_COUNTS::SNAPSHOT_VCOUNT data too large\n");
}
#else
#define set_SNAPSHOT_VH_COUNTS_snapshot_hcount(reg, snapshot_hcount) (reg)->bitfields.SNAPSHOT_HCOUNT = snapshot_hcount
#define set_SNAPSHOT_VH_COUNTS_snapshot_vcount(reg, snapshot_vcount) (reg)->bitfields.SNAPSHOT_VCOUNT = snapshot_vcount

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SNAPSHOT_F_COUNT regSNAPSHOT_F_COUNT;

#ifdef DEBUG
__inline void set_SNAPSHOT_F_COUNT_snapshot_f_count(regSNAPSHOT_F_COUNT *reg, unsigned int snapshot_f_count)
{
  reg->bitfields.SNAPSHOT_F_COUNT = snapshot_f_count;
  if (reg->bitfields.SNAPSHOT_F_COUNT != snapshot_f_count) HSLDPF(E_ERROR_MESSAGE,"SNAPSHOT_F_COUNT::SNAPSHOT_F_COUNT data too large\n");
}
#else
#define set_SNAPSHOT_F_COUNT_snapshot_f_count(reg, snapshot_f_count) (reg)->bitfields.SNAPSHOT_F_COUNT = snapshot_f_count

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union N_VIF_COUNT regN_VIF_COUNT;

#ifdef DEBUG
__inline void set_N_VIF_COUNT_n_vif_count_val(regN_VIF_COUNT *reg, unsigned int n_vif_count_val)
{
  reg->bitfields.N_VIF_COUNT_VAL = n_vif_count_val;
  if (reg->bitfields.N_VIF_COUNT_VAL != n_vif_count_val) HSLDPF(E_ERROR_MESSAGE,"N_VIF_COUNT::N_VIF_COUNT_VAL data too large\n");
}
__inline void set_N_VIF_COUNT_genlock_source_sel(regN_VIF_COUNT *reg, unsigned int genlock_source_sel)
{
  reg->bitfields.GENLOCK_SOURCE_SEL = genlock_source_sel;
  if (reg->bitfields.GENLOCK_SOURCE_SEL != genlock_source_sel) HSLDPF(E_ERROR_MESSAGE,"N_VIF_COUNT::GENLOCK_SOURCE_SEL data too large\n");
}
#else
#define set_N_VIF_COUNT_n_vif_count_val(reg, n_vif_count_val) (reg)->bitfields.N_VIF_COUNT_VAL = n_vif_count_val
#define set_N_VIF_COUNT_genlock_source_sel(reg, genlock_source_sel) (reg)->bitfields.GENLOCK_SOURCE_SEL = genlock_source_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SNAPSHOT_VIF_COUNT regSNAPSHOT_VIF_COUNT;

#ifdef DEBUG
__inline void set_SNAPSHOT_VIF_COUNT_lsnapshot_vif_count(regSNAPSHOT_VIF_COUNT *reg, unsigned int lsnapshot_vif_count)
{
  reg->bitfields.LSNAPSHOT_VIF_COUNT = lsnapshot_vif_count;
  if (reg->bitfields.LSNAPSHOT_VIF_COUNT != lsnapshot_vif_count) HSLDPF(E_ERROR_MESSAGE,"SNAPSHOT_VIF_COUNT::LSNAPSHOT_VIF_COUNT data too large\n");
}
__inline void set_SNAPSHOT_VIF_COUNT_usnapshot_vif_count(regSNAPSHOT_VIF_COUNT *reg, unsigned int usnapshot_vif_count)
{
  reg->bitfields.USNAPSHOT_VIF_COUNT = usnapshot_vif_count;
  if (reg->bitfields.USNAPSHOT_VIF_COUNT != usnapshot_vif_count) HSLDPF(E_ERROR_MESSAGE,"SNAPSHOT_VIF_COUNT::USNAPSHOT_VIF_COUNT data too large\n");
}
__inline void set_SNAPSHOT_VIF_COUNT_auto_snapshot_taken_rd(regSNAPSHOT_VIF_COUNT *reg, unsigned int auto_snapshot_taken_rd)
{
  reg->bitfields.AUTO_SNAPSHOT_TAKEN_RD = auto_snapshot_taken_rd;
  if (reg->bitfields.AUTO_SNAPSHOT_TAKEN_RD != auto_snapshot_taken_rd) HSLDPF(E_ERROR_MESSAGE,"SNAPSHOT_VIF_COUNT::AUTO_SNAPSHOT_TAKEN_RD data too large\n");
}
__inline void set_SNAPSHOT_VIF_COUNT_manual_snapshot_now(regSNAPSHOT_VIF_COUNT *reg, unsigned int manual_snapshot_now)
{
  reg->bitfields.MANUAL_SNAPSHOT_NOW = manual_snapshot_now;
  if (reg->bitfields.MANUAL_SNAPSHOT_NOW != manual_snapshot_now) HSLDPF(E_ERROR_MESSAGE,"SNAPSHOT_VIF_COUNT::MANUAL_SNAPSHOT_NOW data too large\n");
}
#else
#define set_SNAPSHOT_VIF_COUNT_lsnapshot_vif_count(reg, lsnapshot_vif_count) (reg)->bitfields.LSNAPSHOT_VIF_COUNT = lsnapshot_vif_count
#define set_SNAPSHOT_VIF_COUNT_usnapshot_vif_count(reg, usnapshot_vif_count) (reg)->bitfields.USNAPSHOT_VIF_COUNT = usnapshot_vif_count
#define set_SNAPSHOT_VIF_COUNT_auto_snapshot_taken_rd(reg, auto_snapshot_taken_rd) (reg)->bitfields.AUTO_SNAPSHOT_TAKEN_RD = auto_snapshot_taken_rd
#define set_SNAPSHOT_VIF_COUNT_manual_snapshot_now(reg, manual_snapshot_now) (reg)->bitfields.MANUAL_SNAPSHOT_NOW = manual_snapshot_now

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union FP_CRTC_H_TOTAL_DISP regFP_CRTC_H_TOTAL_DISP;

#ifdef DEBUG
__inline void set_FP_CRTC_H_TOTAL_DISP_fp_crtc_h_total(regFP_CRTC_H_TOTAL_DISP *reg, unsigned int fp_crtc_h_total)
{
  reg->bitfields.FP_CRTC_H_TOTAL = fp_crtc_h_total;
  if (reg->bitfields.FP_CRTC_H_TOTAL != fp_crtc_h_total) HSLDPF(E_ERROR_MESSAGE,"FP_CRTC_H_TOTAL_DISP::FP_CRTC_H_TOTAL data too large\n");
}
__inline void set_FP_CRTC_H_TOTAL_DISP_fp_crtc_h_disp(regFP_CRTC_H_TOTAL_DISP *reg, unsigned int fp_crtc_h_disp)
{
  reg->bitfields.FP_CRTC_H_DISP = fp_crtc_h_disp;
  if (reg->bitfields.FP_CRTC_H_DISP != fp_crtc_h_disp) HSLDPF(E_ERROR_MESSAGE,"FP_CRTC_H_TOTAL_DISP::FP_CRTC_H_DISP data too large\n");
}
#else
#define set_FP_CRTC_H_TOTAL_DISP_fp_crtc_h_total(reg, fp_crtc_h_total) (reg)->bitfields.FP_CRTC_H_TOTAL = fp_crtc_h_total
#define set_FP_CRTC_H_TOTAL_DISP_fp_crtc_h_disp(reg, fp_crtc_h_disp) (reg)->bitfields.FP_CRTC_H_DISP = fp_crtc_h_disp

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union FP_CRTC_V_TOTAL_DISP regFP_CRTC_V_TOTAL_DISP;

#ifdef DEBUG
__inline void set_FP_CRTC_V_TOTAL_DISP_fp_crtc_v_total(regFP_CRTC_V_TOTAL_DISP *reg, unsigned int fp_crtc_v_total)
{
  reg->bitfields.FP_CRTC_V_TOTAL = fp_crtc_v_total;
  if (reg->bitfields.FP_CRTC_V_TOTAL != fp_crtc_v_total) HSLDPF(E_ERROR_MESSAGE,"FP_CRTC_V_TOTAL_DISP::FP_CRTC_V_TOTAL data too large\n");
}
__inline void set_FP_CRTC_V_TOTAL_DISP_fp_crtc_v_disp(regFP_CRTC_V_TOTAL_DISP *reg, unsigned int fp_crtc_v_disp)
{
  reg->bitfields.FP_CRTC_V_DISP = fp_crtc_v_disp;
  if (reg->bitfields.FP_CRTC_V_DISP != fp_crtc_v_disp) HSLDPF(E_ERROR_MESSAGE,"FP_CRTC_V_TOTAL_DISP::FP_CRTC_V_DISP data too large\n");
}
#else
#define set_FP_CRTC_V_TOTAL_DISP_fp_crtc_v_total(reg, fp_crtc_v_total) (reg)->bitfields.FP_CRTC_V_TOTAL = fp_crtc_v_total
#define set_FP_CRTC_V_TOTAL_DISP_fp_crtc_v_disp(reg, fp_crtc_v_disp) (reg)->bitfields.FP_CRTC_V_DISP = fp_crtc_v_disp

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT_CRTC_H_SYNC_STRT_WID regCRT_CRTC_H_SYNC_STRT_WID;

#ifdef DEBUG
__inline void set_CRT_CRTC_H_SYNC_STRT_WID_crt_crtc_h_sync_strt_char(regCRT_CRTC_H_SYNC_STRT_WID *reg, unsigned int crt_crtc_h_sync_strt_char)
{
  reg->bitfields.CRT_CRTC_H_SYNC_STRT_CHAR = crt_crtc_h_sync_strt_char;
  if (reg->bitfields.CRT_CRTC_H_SYNC_STRT_CHAR != crt_crtc_h_sync_strt_char) HSLDPF(E_ERROR_MESSAGE,"CRT_CRTC_H_SYNC_STRT_WID::CRT_CRTC_H_SYNC_STRT_CHAR data too large\n");
}
__inline void set_CRT_CRTC_H_SYNC_STRT_WID_crt_crtc_h_sync_wid(regCRT_CRTC_H_SYNC_STRT_WID *reg, unsigned int crt_crtc_h_sync_wid)
{
  reg->bitfields.CRT_CRTC_H_SYNC_WID = crt_crtc_h_sync_wid;
  if (reg->bitfields.CRT_CRTC_H_SYNC_WID != crt_crtc_h_sync_wid) HSLDPF(E_ERROR_MESSAGE,"CRT_CRTC_H_SYNC_STRT_WID::CRT_CRTC_H_SYNC_WID data too large\n");
}
#else
#define set_CRT_CRTC_H_SYNC_STRT_WID_crt_crtc_h_sync_strt_char(reg, crt_crtc_h_sync_strt_char) (reg)->bitfields.CRT_CRTC_H_SYNC_STRT_CHAR = crt_crtc_h_sync_strt_char
#define set_CRT_CRTC_H_SYNC_STRT_WID_crt_crtc_h_sync_wid(reg, crt_crtc_h_sync_wid) (reg)->bitfields.CRT_CRTC_H_SYNC_WID = crt_crtc_h_sync_wid

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRT_CRTC_V_SYNC_STRT_WID regCRT_CRTC_V_SYNC_STRT_WID;

#ifdef DEBUG
__inline void set_CRT_CRTC_V_SYNC_STRT_WID_crt_crtc_v_sync_strt(regCRT_CRTC_V_SYNC_STRT_WID *reg, unsigned int crt_crtc_v_sync_strt)
{
  reg->bitfields.CRT_CRTC_V_SYNC_STRT = crt_crtc_v_sync_strt;
  if (reg->bitfields.CRT_CRTC_V_SYNC_STRT != crt_crtc_v_sync_strt) HSLDPF(E_ERROR_MESSAGE,"CRT_CRTC_V_SYNC_STRT_WID::CRT_CRTC_V_SYNC_STRT data too large\n");
}
__inline void set_CRT_CRTC_V_SYNC_STRT_WID_crt_crtc_v_sync_wid(regCRT_CRTC_V_SYNC_STRT_WID *reg, unsigned int crt_crtc_v_sync_wid)
{
  reg->bitfields.CRT_CRTC_V_SYNC_WID = crt_crtc_v_sync_wid;
  if (reg->bitfields.CRT_CRTC_V_SYNC_WID != crt_crtc_v_sync_wid) HSLDPF(E_ERROR_MESSAGE,"CRT_CRTC_V_SYNC_STRT_WID::CRT_CRTC_V_SYNC_WID data too large\n");
}
#else
#define set_CRT_CRTC_V_SYNC_STRT_WID_crt_crtc_v_sync_strt(reg, crt_crtc_v_sync_strt) (reg)->bitfields.CRT_CRTC_V_SYNC_STRT = crt_crtc_v_sync_strt
#define set_CRT_CRTC_V_SYNC_STRT_WID_crt_crtc_v_sync_wid(reg, crt_crtc_v_sync_wid) (reg)->bitfields.CRT_CRTC_V_SYNC_WID = crt_crtc_v_sync_wid

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CUR_OFFSET regCUR_OFFSET;

#ifdef DEBUG
__inline void set_CUR_OFFSET_cur_offset(regCUR_OFFSET *reg, unsigned int cur_offset)
{
  reg->bitfields.CUR_OFFSET = cur_offset;
  if (reg->bitfields.CUR_OFFSET != cur_offset) HSLDPF(E_ERROR_MESSAGE,"CUR_OFFSET::CUR_OFFSET data too large\n");
}
__inline void set_CUR_OFFSET_cur_lock(regCUR_OFFSET *reg, unsigned int cur_lock)
{
  reg->bitfields.CUR_LOCK = cur_lock;
  if (reg->bitfields.CUR_LOCK != cur_lock) HSLDPF(E_ERROR_MESSAGE,"CUR_OFFSET::CUR_LOCK data too large\n");
}
#else
#define set_CUR_OFFSET_cur_offset(reg, cur_offset) (reg)->bitfields.CUR_OFFSET = cur_offset
#define set_CUR_OFFSET_cur_lock(reg, cur_lock) (reg)->bitfields.CUR_LOCK = cur_lock

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CUR_HORZ_VERT_POSN regCUR_HORZ_VERT_POSN;

#ifdef DEBUG
__inline void set_CUR_HORZ_VERT_POSN_cur_vert_posn(regCUR_HORZ_VERT_POSN *reg, unsigned int cur_vert_posn)
{
  reg->bitfields.CUR_VERT_POSN = cur_vert_posn;
  if (reg->bitfields.CUR_VERT_POSN != cur_vert_posn) HSLDPF(E_ERROR_MESSAGE,"CUR_HORZ_VERT_POSN::CUR_VERT_POSN data too large\n");
}
__inline void set_CUR_HORZ_VERT_POSN_cur_horz_posn(regCUR_HORZ_VERT_POSN *reg, unsigned int cur_horz_posn)
{
  reg->bitfields.CUR_HORZ_POSN = cur_horz_posn;
  if (reg->bitfields.CUR_HORZ_POSN != cur_horz_posn) HSLDPF(E_ERROR_MESSAGE,"CUR_HORZ_VERT_POSN::CUR_HORZ_POSN data too large\n");
}
__inline void set_CUR_HORZ_VERT_POSN_cur_lock(regCUR_HORZ_VERT_POSN *reg, unsigned int cur_lock)
{
  reg->bitfields.CUR_LOCK = cur_lock;
  if (reg->bitfields.CUR_LOCK != cur_lock) HSLDPF(E_ERROR_MESSAGE,"CUR_HORZ_VERT_POSN::CUR_LOCK data too large\n");
}
#else
#define set_CUR_HORZ_VERT_POSN_cur_vert_posn(reg, cur_vert_posn) (reg)->bitfields.CUR_VERT_POSN = cur_vert_posn
#define set_CUR_HORZ_VERT_POSN_cur_horz_posn(reg, cur_horz_posn) (reg)->bitfields.CUR_HORZ_POSN = cur_horz_posn
#define set_CUR_HORZ_VERT_POSN_cur_lock(reg, cur_lock) (reg)->bitfields.CUR_LOCK = cur_lock

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CUR_HORZ_VERT_OFF regCUR_HORZ_VERT_OFF;

#ifdef DEBUG
__inline void set_CUR_HORZ_VERT_OFF_cur_vert_off(regCUR_HORZ_VERT_OFF *reg, unsigned int cur_vert_off)
{
  reg->bitfields.CUR_VERT_OFF = cur_vert_off;
  if (reg->bitfields.CUR_VERT_OFF != cur_vert_off) HSLDPF(E_ERROR_MESSAGE,"CUR_HORZ_VERT_OFF::CUR_VERT_OFF data too large\n");
}
__inline void set_CUR_HORZ_VERT_OFF_cur_horz_off(regCUR_HORZ_VERT_OFF *reg, unsigned int cur_horz_off)
{
  reg->bitfields.CUR_HORZ_OFF = cur_horz_off;
  if (reg->bitfields.CUR_HORZ_OFF != cur_horz_off) HSLDPF(E_ERROR_MESSAGE,"CUR_HORZ_VERT_OFF::CUR_HORZ_OFF data too large\n");
}
__inline void set_CUR_HORZ_VERT_OFF_cur_lock(regCUR_HORZ_VERT_OFF *reg, unsigned int cur_lock)
{
  reg->bitfields.CUR_LOCK = cur_lock;
  if (reg->bitfields.CUR_LOCK != cur_lock) HSLDPF(E_ERROR_MESSAGE,"CUR_HORZ_VERT_OFF::CUR_LOCK data too large\n");
}
#else
#define set_CUR_HORZ_VERT_OFF_cur_vert_off(reg, cur_vert_off) (reg)->bitfields.CUR_VERT_OFF = cur_vert_off
#define set_CUR_HORZ_VERT_OFF_cur_horz_off(reg, cur_horz_off) (reg)->bitfields.CUR_HORZ_OFF = cur_horz_off
#define set_CUR_HORZ_VERT_OFF_cur_lock(reg, cur_lock) (reg)->bitfields.CUR_LOCK = cur_lock

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CUR_CLR0 regCUR_CLR0;

#ifdef DEBUG
__inline void set_CUR_CLR0_cur_clr0_b(regCUR_CLR0 *reg, unsigned int cur_clr0_b)
{
  reg->bitfields.CUR_CLR0_B = cur_clr0_b;
  if (reg->bitfields.CUR_CLR0_B != cur_clr0_b) HSLDPF(E_ERROR_MESSAGE,"CUR_CLR0::CUR_CLR0_B data too large\n");
}
__inline void set_CUR_CLR0_cur_clr0_g(regCUR_CLR0 *reg, unsigned int cur_clr0_g)
{
  reg->bitfields.CUR_CLR0_G = cur_clr0_g;
  if (reg->bitfields.CUR_CLR0_G != cur_clr0_g) HSLDPF(E_ERROR_MESSAGE,"CUR_CLR0::CUR_CLR0_G data too large\n");
}
__inline void set_CUR_CLR0_cur_clr0_r(regCUR_CLR0 *reg, unsigned int cur_clr0_r)
{
  reg->bitfields.CUR_CLR0_R = cur_clr0_r;
  if (reg->bitfields.CUR_CLR0_R != cur_clr0_r) HSLDPF(E_ERROR_MESSAGE,"CUR_CLR0::CUR_CLR0_R data too large\n");
}
#else
#define set_CUR_CLR0_cur_clr0_b(reg, cur_clr0_b) (reg)->bitfields.CUR_CLR0_B = cur_clr0_b
#define set_CUR_CLR0_cur_clr0_g(reg, cur_clr0_g) (reg)->bitfields.CUR_CLR0_G = cur_clr0_g
#define set_CUR_CLR0_cur_clr0_r(reg, cur_clr0_r) (reg)->bitfields.CUR_CLR0_R = cur_clr0_r

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CUR_CLR1 regCUR_CLR1;

#ifdef DEBUG
__inline void set_CUR_CLR1_cur_clr1_b(regCUR_CLR1 *reg, unsigned int cur_clr1_b)
{
  reg->bitfields.CUR_CLR1_B = cur_clr1_b;
  if (reg->bitfields.CUR_CLR1_B != cur_clr1_b) HSLDPF(E_ERROR_MESSAGE,"CUR_CLR1::CUR_CLR1_B data too large\n");
}
__inline void set_CUR_CLR1_cur_clr1_g(regCUR_CLR1 *reg, unsigned int cur_clr1_g)
{
  reg->bitfields.CUR_CLR1_G = cur_clr1_g;
  if (reg->bitfields.CUR_CLR1_G != cur_clr1_g) HSLDPF(E_ERROR_MESSAGE,"CUR_CLR1::CUR_CLR1_G data too large\n");
}
__inline void set_CUR_CLR1_cur_clr1_r(regCUR_CLR1 *reg, unsigned int cur_clr1_r)
{
  reg->bitfields.CUR_CLR1_R = cur_clr1_r;
  if (reg->bitfields.CUR_CLR1_R != cur_clr1_r) HSLDPF(E_ERROR_MESSAGE,"CUR_CLR1::CUR_CLR1_R data too large\n");
}
#else
#define set_CUR_CLR1_cur_clr1_b(reg, cur_clr1_b) (reg)->bitfields.CUR_CLR1_B = cur_clr1_b
#define set_CUR_CLR1_cur_clr1_g(reg, cur_clr1_g) (reg)->bitfields.CUR_CLR1_G = cur_clr1_g
#define set_CUR_CLR1_cur_clr1_r(reg, cur_clr1_r) (reg)->bitfields.CUR_CLR1_R = cur_clr1_r

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union FP_HORZ_VERT_ACTIVE regFP_HORZ_VERT_ACTIVE;

#ifdef DEBUG
__inline void set_FP_HORZ_VERT_ACTIVE_fp_vert_active_size(regFP_HORZ_VERT_ACTIVE *reg, unsigned int fp_vert_active_size)
{
  reg->bitfields.FP_VERT_ACTIVE_SIZE = fp_vert_active_size;
  if (reg->bitfields.FP_VERT_ACTIVE_SIZE != fp_vert_active_size) HSLDPF(E_ERROR_MESSAGE,"FP_HORZ_VERT_ACTIVE::FP_VERT_ACTIVE_SIZE data too large\n");
}
__inline void set_FP_HORZ_VERT_ACTIVE_fp_horz_active_size(regFP_HORZ_VERT_ACTIVE *reg, unsigned int fp_horz_active_size)
{
  reg->bitfields.FP_HORZ_ACTIVE_SIZE = fp_horz_active_size;
  if (reg->bitfields.FP_HORZ_ACTIVE_SIZE != fp_horz_active_size) HSLDPF(E_ERROR_MESSAGE,"FP_HORZ_VERT_ACTIVE::FP_HORZ_ACTIVE_SIZE data too large\n");
}
#else
#define set_FP_HORZ_VERT_ACTIVE_fp_vert_active_size(reg, fp_vert_active_size) (reg)->bitfields.FP_VERT_ACTIVE_SIZE = fp_vert_active_size
#define set_FP_HORZ_VERT_ACTIVE_fp_horz_active_size(reg, fp_horz_active_size) (reg)->bitfields.FP_HORZ_ACTIVE_SIZE = fp_horz_active_size

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC_MORE_CNTL regCRTC_MORE_CNTL;

#ifdef DEBUG
__inline void set_CRTC_MORE_CNTL_crtc_horz_blank_mode_sel(regCRTC_MORE_CNTL *reg, unsigned int crtc_horz_blank_mode_sel)
{
  reg->bitfields.CRTC_HORZ_BLANK_MODE_SEL = crtc_horz_blank_mode_sel;
  if (reg->bitfields.CRTC_HORZ_BLANK_MODE_SEL != crtc_horz_blank_mode_sel) HSLDPF(E_ERROR_MESSAGE,"CRTC_MORE_CNTL::CRTC_HORZ_BLANK_MODE_SEL data too large\n");
}
__inline void set_CRTC_MORE_CNTL_crtc_vert_blank_mode_sel(regCRTC_MORE_CNTL *reg, unsigned int crtc_vert_blank_mode_sel)
{
  reg->bitfields.CRTC_VERT_BLANK_MODE_SEL = crtc_vert_blank_mode_sel;
  if (reg->bitfields.CRTC_VERT_BLANK_MODE_SEL != crtc_vert_blank_mode_sel) HSLDPF(E_ERROR_MESSAGE,"CRTC_MORE_CNTL::CRTC_VERT_BLANK_MODE_SEL data too large\n");
}
__inline void set_CRTC_MORE_CNTL_crtc_auto_horz_center_en(regCRTC_MORE_CNTL *reg, unsigned int crtc_auto_horz_center_en)
{
  reg->bitfields.CRTC_AUTO_HORZ_CENTER_EN = crtc_auto_horz_center_en;
  if (reg->bitfields.CRTC_AUTO_HORZ_CENTER_EN != crtc_auto_horz_center_en) HSLDPF(E_ERROR_MESSAGE,"CRTC_MORE_CNTL::CRTC_AUTO_HORZ_CENTER_EN data too large\n");
}
__inline void set_CRTC_MORE_CNTL_crtc_auto_vert_center_en(regCRTC_MORE_CNTL *reg, unsigned int crtc_auto_vert_center_en)
{
  reg->bitfields.CRTC_AUTO_VERT_CENTER_EN = crtc_auto_vert_center_en;
  if (reg->bitfields.CRTC_AUTO_VERT_CENTER_EN != crtc_auto_vert_center_en) HSLDPF(E_ERROR_MESSAGE,"CRTC_MORE_CNTL::CRTC_AUTO_VERT_CENTER_EN data too large\n");
}
__inline void set_CRTC_MORE_CNTL_crtc_h_cutoff_active_en(regCRTC_MORE_CNTL *reg, unsigned int crtc_h_cutoff_active_en)
{
  reg->bitfields.CRTC_H_CUTOFF_ACTIVE_EN = crtc_h_cutoff_active_en;
  if (reg->bitfields.CRTC_H_CUTOFF_ACTIVE_EN != crtc_h_cutoff_active_en) HSLDPF(E_ERROR_MESSAGE,"CRTC_MORE_CNTL::CRTC_H_CUTOFF_ACTIVE_EN data too large\n");
}
__inline void set_CRTC_MORE_CNTL_crtc_v_cutoff_active_en(regCRTC_MORE_CNTL *reg, unsigned int crtc_v_cutoff_active_en)
{
  reg->bitfields.CRTC_V_CUTOFF_ACTIVE_EN = crtc_v_cutoff_active_en;
  if (reg->bitfields.CRTC_V_CUTOFF_ACTIVE_EN != crtc_v_cutoff_active_en) HSLDPF(E_ERROR_MESSAGE,"CRTC_MORE_CNTL::CRTC_V_CUTOFF_ACTIVE_EN data too large\n");
}
__inline void set_CRTC_MORE_CNTL_force_h_even_pixel_count(regCRTC_MORE_CNTL *reg, unsigned int force_h_even_pixel_count)
{
  reg->bitfields.FORCE_H_EVEN_PIXEL_COUNT = force_h_even_pixel_count;
  if (reg->bitfields.FORCE_H_EVEN_PIXEL_COUNT != force_h_even_pixel_count) HSLDPF(E_ERROR_MESSAGE,"CRTC_MORE_CNTL::FORCE_H_EVEN_PIXEL_COUNT data too large\n");
}
__inline void set_CRTC_MORE_CNTL_crtc_rst_hcount(regCRTC_MORE_CNTL *reg, unsigned int crtc_rst_hcount)
{
  reg->bitfields.CRTC_RST_HCOUNT = crtc_rst_hcount;
  if (reg->bitfields.CRTC_RST_HCOUNT != crtc_rst_hcount) HSLDPF(E_ERROR_MESSAGE,"CRTC_MORE_CNTL::CRTC_RST_HCOUNT data too large\n");
}
__inline void set_CRTC_MORE_CNTL_crtc_rst_vcount(regCRTC_MORE_CNTL *reg, unsigned int crtc_rst_vcount)
{
  reg->bitfields.CRTC_RST_VCOUNT = crtc_rst_vcount;
  if (reg->bitfields.CRTC_RST_VCOUNT != crtc_rst_vcount) HSLDPF(E_ERROR_MESSAGE,"CRTC_MORE_CNTL::CRTC_RST_VCOUNT data too large\n");
}
__inline void set_CRTC_MORE_CNTL_hcount_rst_pos(regCRTC_MORE_CNTL *reg, unsigned int hcount_rst_pos)
{
  reg->bitfields.HCOUNT_RST_POS = hcount_rst_pos;
  if (reg->bitfields.HCOUNT_RST_POS != hcount_rst_pos) HSLDPF(E_ERROR_MESSAGE,"CRTC_MORE_CNTL::HCOUNT_RST_POS data too large\n");
}
__inline void set_CRTC_MORE_CNTL_vcount_rst_pos(regCRTC_MORE_CNTL *reg, unsigned int vcount_rst_pos)
{
  reg->bitfields.VCOUNT_RST_POS = vcount_rst_pos;
  if (reg->bitfields.VCOUNT_RST_POS != vcount_rst_pos) HSLDPF(E_ERROR_MESSAGE,"CRTC_MORE_CNTL::VCOUNT_RST_POS data too large\n");
}
__inline void set_CRTC_MORE_CNTL_rmx_h_filt_coefficient(regCRTC_MORE_CNTL *reg, unsigned int rmx_h_filt_coefficient)
{
  reg->bitfields.RMX_H_FILT_COEFFICIENT = rmx_h_filt_coefficient;
  if (reg->bitfields.RMX_H_FILT_COEFFICIENT != rmx_h_filt_coefficient) HSLDPF(E_ERROR_MESSAGE,"CRTC_MORE_CNTL::RMX_H_FILT_COEFFICIENT data too large\n");
}
__inline void set_CRTC_MORE_CNTL_rmx_h_filter_en(regCRTC_MORE_CNTL *reg, unsigned int rmx_h_filter_en)
{
  reg->bitfields.RMX_H_FILTER_EN = rmx_h_filter_en;
  if (reg->bitfields.RMX_H_FILTER_EN != rmx_h_filter_en) HSLDPF(E_ERROR_MESSAGE,"CRTC_MORE_CNTL::RMX_H_FILTER_EN data too large\n");
}
__inline void set_CRTC_MORE_CNTL_rmx_v_filt_coefficient(regCRTC_MORE_CNTL *reg, unsigned int rmx_v_filt_coefficient)
{
  reg->bitfields.RMX_V_FILT_COEFFICIENT = rmx_v_filt_coefficient;
  if (reg->bitfields.RMX_V_FILT_COEFFICIENT != rmx_v_filt_coefficient) HSLDPF(E_ERROR_MESSAGE,"CRTC_MORE_CNTL::RMX_V_FILT_COEFFICIENT data too large\n");
}
__inline void set_CRTC_MORE_CNTL_rmx_v_filter_en(regCRTC_MORE_CNTL *reg, unsigned int rmx_v_filter_en)
{
  reg->bitfields.RMX_V_FILTER_EN = rmx_v_filter_en;
  if (reg->bitfields.RMX_V_FILTER_EN != rmx_v_filter_en) HSLDPF(E_ERROR_MESSAGE,"CRTC_MORE_CNTL::RMX_V_FILTER_EN data too large\n");
}
#else
#define set_CRTC_MORE_CNTL_crtc_horz_blank_mode_sel(reg, crtc_horz_blank_mode_sel) (reg)->bitfields.CRTC_HORZ_BLANK_MODE_SEL = crtc_horz_blank_mode_sel
#define set_CRTC_MORE_CNTL_crtc_vert_blank_mode_sel(reg, crtc_vert_blank_mode_sel) (reg)->bitfields.CRTC_VERT_BLANK_MODE_SEL = crtc_vert_blank_mode_sel
#define set_CRTC_MORE_CNTL_crtc_auto_horz_center_en(reg, crtc_auto_horz_center_en) (reg)->bitfields.CRTC_AUTO_HORZ_CENTER_EN = crtc_auto_horz_center_en
#define set_CRTC_MORE_CNTL_crtc_auto_vert_center_en(reg, crtc_auto_vert_center_en) (reg)->bitfields.CRTC_AUTO_VERT_CENTER_EN = crtc_auto_vert_center_en
#define set_CRTC_MORE_CNTL_crtc_h_cutoff_active_en(reg, crtc_h_cutoff_active_en) (reg)->bitfields.CRTC_H_CUTOFF_ACTIVE_EN = crtc_h_cutoff_active_en
#define set_CRTC_MORE_CNTL_crtc_v_cutoff_active_en(reg, crtc_v_cutoff_active_en) (reg)->bitfields.CRTC_V_CUTOFF_ACTIVE_EN = crtc_v_cutoff_active_en
#define set_CRTC_MORE_CNTL_force_h_even_pixel_count(reg, force_h_even_pixel_count) (reg)->bitfields.FORCE_H_EVEN_PIXEL_COUNT = force_h_even_pixel_count
#define set_CRTC_MORE_CNTL_crtc_rst_hcount(reg, crtc_rst_hcount) (reg)->bitfields.CRTC_RST_HCOUNT = crtc_rst_hcount
#define set_CRTC_MORE_CNTL_crtc_rst_vcount(reg, crtc_rst_vcount) (reg)->bitfields.CRTC_RST_VCOUNT = crtc_rst_vcount
#define set_CRTC_MORE_CNTL_hcount_rst_pos(reg, hcount_rst_pos) (reg)->bitfields.HCOUNT_RST_POS = hcount_rst_pos
#define set_CRTC_MORE_CNTL_vcount_rst_pos(reg, vcount_rst_pos) (reg)->bitfields.VCOUNT_RST_POS = vcount_rst_pos
#define set_CRTC_MORE_CNTL_rmx_h_filt_coefficient(reg, rmx_h_filt_coefficient) (reg)->bitfields.RMX_H_FILT_COEFFICIENT = rmx_h_filt_coefficient
#define set_CRTC_MORE_CNTL_rmx_h_filter_en(reg, rmx_h_filter_en) (reg)->bitfields.RMX_H_FILTER_EN = rmx_h_filter_en
#define set_CRTC_MORE_CNTL_rmx_v_filt_coefficient(reg, rmx_v_filt_coefficient) (reg)->bitfields.RMX_V_FILT_COEFFICIENT = rmx_v_filt_coefficient
#define set_CRTC_MORE_CNTL_rmx_v_filter_en(reg, rmx_v_filter_en) (reg)->bitfields.RMX_V_FILTER_EN = rmx_v_filter_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_EXT_CNTL regDAC_EXT_CNTL;

#ifdef DEBUG
__inline void set_DAC_EXT_CNTL_dac2_force_blank_off_en(regDAC_EXT_CNTL *reg, unsigned int dac2_force_blank_off_en)
{
  reg->bitfields.DAC2_FORCE_BLANK_OFF_EN = dac2_force_blank_off_en;
  if (reg->bitfields.DAC2_FORCE_BLANK_OFF_EN != dac2_force_blank_off_en) HSLDPF(E_ERROR_MESSAGE,"DAC_EXT_CNTL::DAC2_FORCE_BLANK_OFF_EN data too large\n");
}
__inline void set_DAC_EXT_CNTL_dac2_force_data_en(regDAC_EXT_CNTL *reg, unsigned int dac2_force_data_en)
{
  reg->bitfields.DAC2_FORCE_DATA_EN = dac2_force_data_en;
  if (reg->bitfields.DAC2_FORCE_DATA_EN != dac2_force_data_en) HSLDPF(E_ERROR_MESSAGE,"DAC_EXT_CNTL::DAC2_FORCE_DATA_EN data too large\n");
}
__inline void set_DAC_EXT_CNTL_dac_force_blank_off_en(regDAC_EXT_CNTL *reg, unsigned int dac_force_blank_off_en)
{
  reg->bitfields.DAC_FORCE_BLANK_OFF_EN = dac_force_blank_off_en;
  if (reg->bitfields.DAC_FORCE_BLANK_OFF_EN != dac_force_blank_off_en) HSLDPF(E_ERROR_MESSAGE,"DAC_EXT_CNTL::DAC_FORCE_BLANK_OFF_EN data too large\n");
}
__inline void set_DAC_EXT_CNTL_dac_force_data_en(regDAC_EXT_CNTL *reg, unsigned int dac_force_data_en)
{
  reg->bitfields.DAC_FORCE_DATA_EN = dac_force_data_en;
  if (reg->bitfields.DAC_FORCE_DATA_EN != dac_force_data_en) HSLDPF(E_ERROR_MESSAGE,"DAC_EXT_CNTL::DAC_FORCE_DATA_EN data too large\n");
}
__inline void set_DAC_EXT_CNTL_dac_force_data_sel(regDAC_EXT_CNTL *reg, unsigned int dac_force_data_sel)
{
  reg->bitfields.DAC_FORCE_DATA_SEL = dac_force_data_sel;
  if (reg->bitfields.DAC_FORCE_DATA_SEL != dac_force_data_sel) HSLDPF(E_ERROR_MESSAGE,"DAC_EXT_CNTL::DAC_FORCE_DATA_SEL data too large\n");
}
__inline void set_DAC_EXT_CNTL_dac_force_data(regDAC_EXT_CNTL *reg, unsigned int dac_force_data)
{
  reg->bitfields.DAC_FORCE_DATA = dac_force_data;
  if (reg->bitfields.DAC_FORCE_DATA != dac_force_data) HSLDPF(E_ERROR_MESSAGE,"DAC_EXT_CNTL::DAC_FORCE_DATA data too large\n");
}
#else
#define set_DAC_EXT_CNTL_dac2_force_blank_off_en(reg, dac2_force_blank_off_en) (reg)->bitfields.DAC2_FORCE_BLANK_OFF_EN = dac2_force_blank_off_en
#define set_DAC_EXT_CNTL_dac2_force_data_en(reg, dac2_force_data_en) (reg)->bitfields.DAC2_FORCE_DATA_EN = dac2_force_data_en
#define set_DAC_EXT_CNTL_dac_force_blank_off_en(reg, dac_force_blank_off_en) (reg)->bitfields.DAC_FORCE_BLANK_OFF_EN = dac_force_blank_off_en
#define set_DAC_EXT_CNTL_dac_force_data_en(reg, dac_force_data_en) (reg)->bitfields.DAC_FORCE_DATA_EN = dac_force_data_en
#define set_DAC_EXT_CNTL_dac_force_data_sel(reg, dac_force_data_sel) (reg)->bitfields.DAC_FORCE_DATA_SEL = dac_force_data_sel
#define set_DAC_EXT_CNTL_dac_force_data(reg, dac_force_data) (reg)->bitfields.DAC_FORCE_DATA = dac_force_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250FP_GEN_CNTL regrv250FP_GEN_CNTL;

#ifdef DEBUG
__inline void set_rv250FP_GEN_CNTL_fp_on(regrv250FP_GEN_CNTL *reg, unsigned int fp_on)
{
  reg->bitfields.FP_ON = fp_on;
  if (reg->bitfields.FP_ON != fp_on) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::FP_ON data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_fp_blank_en(regrv250FP_GEN_CNTL *reg, unsigned int fp_blank_en)
{
  reg->bitfields.FP_BLANK_EN = fp_blank_en;
  if (reg->bitfields.FP_BLANK_EN != fp_blank_en) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::FP_BLANK_EN data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_tmds_en(regrv250FP_GEN_CNTL *reg, unsigned int tmds_en)
{
  reg->bitfields.TMDS_EN = tmds_en;
  if (reg->bitfields.TMDS_EN != tmds_en) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::TMDS_EN data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_panel_format(regrv250FP_GEN_CNTL *reg, unsigned int panel_format)
{
  reg->bitfields.PANEL_FORMAT = panel_format;
  if (reg->bitfields.PANEL_FORMAT != panel_format) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::PANEL_FORMAT data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_no_of_grey(regrv250FP_GEN_CNTL *reg, unsigned int no_of_grey)
{
  reg->bitfields.NO_OF_GREY = no_of_grey;
  if (reg->bitfields.NO_OF_GREY != no_of_grey) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::NO_OF_GREY data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_fp_rst_fm(regrv250FP_GEN_CNTL *reg, unsigned int fp_rst_fm)
{
  reg->bitfields.FP_RST_FM = fp_rst_fm;
  if (reg->bitfields.FP_RST_FM != fp_rst_fm) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::FP_RST_FM data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_fp_en_tmds(regrv250FP_GEN_CNTL *reg, unsigned int fp_en_tmds)
{
  reg->bitfields.FP_EN_TMDS = fp_en_tmds;
  if (reg->bitfields.FP_EN_TMDS != fp_en_tmds) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::FP_EN_TMDS data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_fp_detect_sense(regrv250FP_GEN_CNTL *reg, unsigned int fp_detect_sense)
{
  reg->bitfields.FP_DETECT_SENSE = fp_detect_sense;
  if (reg->bitfields.FP_DETECT_SENSE != fp_detect_sense) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::FP_DETECT_SENSE data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_fp_detect_int_pol(regrv250FP_GEN_CNTL *reg, unsigned int fp_detect_int_pol)
{
  reg->bitfields.FP_DETECT_INT_POL = fp_detect_int_pol;
  if (reg->bitfields.FP_DETECT_INT_POL != fp_detect_int_pol) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::FP_DETECT_INT_POL data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_fp_detect_en(regrv250FP_GEN_CNTL *reg, unsigned int fp_detect_en)
{
  reg->bitfields.FP_DETECT_EN = fp_detect_en;
  if (reg->bitfields.FP_DETECT_EN != fp_detect_en) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::FP_DETECT_EN data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_fp_src_sel(regrv250FP_GEN_CNTL *reg, unsigned int fp_src_sel)
{
  reg->bitfields.FP_SRC_SEL = fp_src_sel;
  if (reg->bitfields.FP_SRC_SEL != fp_src_sel) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::FP_SRC_SEL data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_fp_use_vga_hvsync(regrv250FP_GEN_CNTL *reg, unsigned int fp_use_vga_hvsync)
{
  reg->bitfields.FP_USE_VGA_HVSYNC = fp_use_vga_hvsync;
  if (reg->bitfields.FP_USE_VGA_HVSYNC != fp_use_vga_hvsync) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::FP_USE_VGA_HVSYNC data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_fp_use_vga_sync_polarity(regrv250FP_GEN_CNTL *reg, unsigned int fp_use_vga_sync_polarity)
{
  reg->bitfields.FP_USE_VGA_SYNC_POLARITY = fp_use_vga_sync_polarity;
  if (reg->bitfields.FP_USE_VGA_SYNC_POLARITY != fp_use_vga_sync_polarity) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::FP_USE_VGA_SYNC_POLARITY data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_crtc_dont_shadow_vpar(regrv250FP_GEN_CNTL *reg, unsigned int crtc_dont_shadow_vpar)
{
  reg->bitfields.CRTC_DONT_SHADOW_VPAR = crtc_dont_shadow_vpar;
  if (reg->bitfields.CRTC_DONT_SHADOW_VPAR != crtc_dont_shadow_vpar) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::CRTC_DONT_SHADOW_VPAR data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_crtc_dont_shadow_hend(regrv250FP_GEN_CNTL *reg, unsigned int crtc_dont_shadow_hend)
{
  reg->bitfields.CRTC_DONT_SHADOW_HEND = crtc_dont_shadow_hend;
  if (reg->bitfields.CRTC_DONT_SHADOW_HEND != crtc_dont_shadow_hend) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::CRTC_DONT_SHADOW_HEND data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_crtc_use_shadowed_vend(regrv250FP_GEN_CNTL *reg, unsigned int crtc_use_shadowed_vend)
{
  reg->bitfields.CRTC_USE_SHADOWED_VEND = crtc_use_shadowed_vend;
  if (reg->bitfields.CRTC_USE_SHADOWED_VEND != crtc_use_shadowed_vend) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::CRTC_USE_SHADOWED_VEND data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_crtc_use_shadowed_rowcur(regrv250FP_GEN_CNTL *reg, unsigned int crtc_use_shadowed_rowcur)
{
  reg->bitfields.CRTC_USE_SHADOWED_ROWCUR = crtc_use_shadowed_rowcur;
  if (reg->bitfields.CRTC_USE_SHADOWED_ROWCUR != crtc_use_shadowed_rowcur) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::CRTC_USE_SHADOWED_ROWCUR data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_rmx_hvsync_control_en(regrv250FP_GEN_CNTL *reg, unsigned int rmx_hvsync_control_en)
{
  reg->bitfields.RMX_HVSYNC_CONTROL_EN = rmx_hvsync_control_en;
  if (reg->bitfields.RMX_HVSYNC_CONTROL_EN != rmx_hvsync_control_en) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::RMX_HVSYNC_CONTROL_EN data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_dfp_sync_sel(regrv250FP_GEN_CNTL *reg, unsigned int dfp_sync_sel)
{
  reg->bitfields.DFP_SYNC_SEL = dfp_sync_sel;
  if (reg->bitfields.DFP_SYNC_SEL != dfp_sync_sel) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::DFP_SYNC_SEL data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_crtc_lock_8dot(regrv250FP_GEN_CNTL *reg, unsigned int crtc_lock_8dot)
{
  reg->bitfields.CRTC_LOCK_8DOT = crtc_lock_8dot;
  if (reg->bitfields.CRTC_LOCK_8DOT != crtc_lock_8dot) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::CRTC_LOCK_8DOT data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_crt_sync_sel(regrv250FP_GEN_CNTL *reg, unsigned int crt_sync_sel)
{
  reg->bitfields.CRT_SYNC_SEL = crt_sync_sel;
  if (reg->bitfields.CRT_SYNC_SEL != crt_sync_sel) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::CRT_SYNC_SEL data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_fp_use_shadow_en(regrv250FP_GEN_CNTL *reg, unsigned int fp_use_shadow_en)
{
  reg->bitfields.FP_USE_SHADOW_EN = fp_use_shadow_en;
  if (reg->bitfields.FP_USE_SHADOW_EN != fp_use_shadow_en) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::FP_USE_SHADOW_EN data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_dont_rst_charen(regrv250FP_GEN_CNTL *reg, unsigned int dont_rst_charen)
{
  reg->bitfields.DONT_RST_CHAREN = dont_rst_charen;
  if (reg->bitfields.DONT_RST_CHAREN != dont_rst_charen) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::DONT_RST_CHAREN data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_crt_sync_alt_sel(regrv250FP_GEN_CNTL *reg, unsigned int crt_sync_alt_sel)
{
  reg->bitfields.CRT_SYNC_ALT_SEL = crt_sync_alt_sel;
  if (reg->bitfields.CRT_SYNC_ALT_SEL != crt_sync_alt_sel) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::CRT_SYNC_ALT_SEL data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_crtc_use_nonshadow_hparams_for_blank(regrv250FP_GEN_CNTL *reg, unsigned int crtc_use_nonshadow_hparams_for_blank)
{
  reg->bitfields.CRTC_USE_NONSHADOW_HPARAMS_FOR_BLANK = crtc_use_nonshadow_hparams_for_blank;
  if (reg->bitfields.CRTC_USE_NONSHADOW_HPARAMS_FOR_BLANK != crtc_use_nonshadow_hparams_for_blank) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::CRTC_USE_NONSHADOW_HPARAMS_FOR_BLANK data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_crtc_use_nonshadow_vparams_for_blank(regrv250FP_GEN_CNTL *reg, unsigned int crtc_use_nonshadow_vparams_for_blank)
{
  reg->bitfields.CRTC_USE_NONSHADOW_VPARAMS_FOR_BLANK = crtc_use_nonshadow_vparams_for_blank;
  if (reg->bitfields.CRTC_USE_NONSHADOW_VPARAMS_FOR_BLANK != crtc_use_nonshadow_vparams_for_blank) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::CRTC_USE_NONSHADOW_VPARAMS_FOR_BLANK data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_crtc_vga_xoverscan_color(regrv250FP_GEN_CNTL *reg, unsigned int crtc_vga_xoverscan_color)
{
  reg->bitfields.CRTC_VGA_XOVERSCAN_COLOR = crtc_vga_xoverscan_color;
  if (reg->bitfields.CRTC_VGA_XOVERSCAN_COLOR != crtc_vga_xoverscan_color) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::CRTC_VGA_XOVERSCAN_COLOR data too large\n");
}
__inline void set_rv250FP_GEN_CNTL_crtc_vga_xoverscan_divby2_en(regrv250FP_GEN_CNTL *reg, unsigned int crtc_vga_xoverscan_divby2_en)
{
  reg->bitfields.CRTC_VGA_XOVERSCAN_DIVBY2_EN = crtc_vga_xoverscan_divby2_en;
  if (reg->bitfields.CRTC_VGA_XOVERSCAN_DIVBY2_EN != crtc_vga_xoverscan_divby2_en) HSLDPF(E_ERROR_MESSAGE,"rv250FP_GEN_CNTL::CRTC_VGA_XOVERSCAN_DIVBY2_EN data too large\n");
}
#else
#define set_rv250FP_GEN_CNTL_fp_on(reg, fp_on) (reg)->bitfields.FP_ON = fp_on
#define set_rv250FP_GEN_CNTL_fp_blank_en(reg, fp_blank_en) (reg)->bitfields.FP_BLANK_EN = fp_blank_en
#define set_rv250FP_GEN_CNTL_tmds_en(reg, tmds_en) (reg)->bitfields.TMDS_EN = tmds_en
#define set_rv250FP_GEN_CNTL_panel_format(reg, panel_format) (reg)->bitfields.PANEL_FORMAT = panel_format
#define set_rv250FP_GEN_CNTL_no_of_grey(reg, no_of_grey) (reg)->bitfields.NO_OF_GREY = no_of_grey
#define set_rv250FP_GEN_CNTL_fp_rst_fm(reg, fp_rst_fm) (reg)->bitfields.FP_RST_FM = fp_rst_fm
#define set_rv250FP_GEN_CNTL_fp_en_tmds(reg, fp_en_tmds) (reg)->bitfields.FP_EN_TMDS = fp_en_tmds
#define set_rv250FP_GEN_CNTL_fp_detect_sense(reg, fp_detect_sense) (reg)->bitfields.FP_DETECT_SENSE = fp_detect_sense
#define set_rv250FP_GEN_CNTL_fp_detect_int_pol(reg, fp_detect_int_pol) (reg)->bitfields.FP_DETECT_INT_POL = fp_detect_int_pol
#define set_rv250FP_GEN_CNTL_fp_detect_en(reg, fp_detect_en) (reg)->bitfields.FP_DETECT_EN = fp_detect_en
#define set_rv250FP_GEN_CNTL_fp_src_sel(reg, fp_src_sel) (reg)->bitfields.FP_SRC_SEL = fp_src_sel
#define set_rv250FP_GEN_CNTL_fp_use_vga_hvsync(reg, fp_use_vga_hvsync) (reg)->bitfields.FP_USE_VGA_HVSYNC = fp_use_vga_hvsync
#define set_rv250FP_GEN_CNTL_fp_use_vga_sync_polarity(reg, fp_use_vga_sync_polarity) (reg)->bitfields.FP_USE_VGA_SYNC_POLARITY = fp_use_vga_sync_polarity
#define set_rv250FP_GEN_CNTL_crtc_dont_shadow_vpar(reg, crtc_dont_shadow_vpar) (reg)->bitfields.CRTC_DONT_SHADOW_VPAR = crtc_dont_shadow_vpar
#define set_rv250FP_GEN_CNTL_crtc_dont_shadow_hend(reg, crtc_dont_shadow_hend) (reg)->bitfields.CRTC_DONT_SHADOW_HEND = crtc_dont_shadow_hend
#define set_rv250FP_GEN_CNTL_crtc_use_shadowed_vend(reg, crtc_use_shadowed_vend) (reg)->bitfields.CRTC_USE_SHADOWED_VEND = crtc_use_shadowed_vend
#define set_rv250FP_GEN_CNTL_crtc_use_shadowed_rowcur(reg, crtc_use_shadowed_rowcur) (reg)->bitfields.CRTC_USE_SHADOWED_ROWCUR = crtc_use_shadowed_rowcur
#define set_rv250FP_GEN_CNTL_rmx_hvsync_control_en(reg, rmx_hvsync_control_en) (reg)->bitfields.RMX_HVSYNC_CONTROL_EN = rmx_hvsync_control_en
#define set_rv250FP_GEN_CNTL_dfp_sync_sel(reg, dfp_sync_sel) (reg)->bitfields.DFP_SYNC_SEL = dfp_sync_sel
#define set_rv250FP_GEN_CNTL_crtc_lock_8dot(reg, crtc_lock_8dot) (reg)->bitfields.CRTC_LOCK_8DOT = crtc_lock_8dot
#define set_rv250FP_GEN_CNTL_crt_sync_sel(reg, crt_sync_sel) (reg)->bitfields.CRT_SYNC_SEL = crt_sync_sel
#define set_rv250FP_GEN_CNTL_fp_use_shadow_en(reg, fp_use_shadow_en) (reg)->bitfields.FP_USE_SHADOW_EN = fp_use_shadow_en
#define set_rv250FP_GEN_CNTL_dont_rst_charen(reg, dont_rst_charen) (reg)->bitfields.DONT_RST_CHAREN = dont_rst_charen
#define set_rv250FP_GEN_CNTL_crt_sync_alt_sel(reg, crt_sync_alt_sel) (reg)->bitfields.CRT_SYNC_ALT_SEL = crt_sync_alt_sel
#define set_rv250FP_GEN_CNTL_crtc_use_nonshadow_hparams_for_blank(reg, crtc_use_nonshadow_hparams_for_blank) (reg)->bitfields.CRTC_USE_NONSHADOW_HPARAMS_FOR_BLANK = crtc_use_nonshadow_hparams_for_blank
#define set_rv250FP_GEN_CNTL_crtc_use_nonshadow_vparams_for_blank(reg, crtc_use_nonshadow_vparams_for_blank) (reg)->bitfields.CRTC_USE_NONSHADOW_VPARAMS_FOR_BLANK = crtc_use_nonshadow_vparams_for_blank
#define set_rv250FP_GEN_CNTL_crtc_vga_xoverscan_color(reg, crtc_vga_xoverscan_color) (reg)->bitfields.CRTC_VGA_XOVERSCAN_COLOR = crtc_vga_xoverscan_color
#define set_rv250FP_GEN_CNTL_crtc_vga_xoverscan_divby2_en(reg, crtc_vga_xoverscan_divby2_en) (reg)->bitfields.CRTC_VGA_XOVERSCAN_DIVBY2_EN = crtc_vga_xoverscan_divby2_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250FP2_GEN_CNTL regrv250FP2_GEN_CNTL;

#ifdef DEBUG
__inline void set_rv250FP2_GEN_CNTL_fp2_blank_en(regrv250FP2_GEN_CNTL *reg, unsigned int fp2_blank_en)
{
  reg->bitfields.FP2_BLANK_EN = fp2_blank_en;
  if (reg->bitfields.FP2_BLANK_EN != fp2_blank_en) HSLDPF(E_ERROR_MESSAGE,"rv250FP2_GEN_CNTL::FP2_BLANK_EN data too large\n");
}
__inline void set_rv250FP2_GEN_CNTL_fp2_on(regrv250FP2_GEN_CNTL *reg, unsigned int fp2_on)
{
  reg->bitfields.FP2_ON = fp2_on;
  if (reg->bitfields.FP2_ON != fp2_on) HSLDPF(E_ERROR_MESSAGE,"rv250FP2_GEN_CNTL::FP2_ON data too large\n");
}
__inline void set_rv250FP2_GEN_CNTL_fp2_panel_format(regrv250FP2_GEN_CNTL *reg, unsigned int fp2_panel_format)
{
  reg->bitfields.FP2_PANEL_FORMAT = fp2_panel_format;
  if (reg->bitfields.FP2_PANEL_FORMAT != fp2_panel_format) HSLDPF(E_ERROR_MESSAGE,"rv250FP2_GEN_CNTL::FP2_PANEL_FORMAT data too large\n");
}
__inline void set_rv250FP2_GEN_CNTL_fp2_no_of_grey(regrv250FP2_GEN_CNTL *reg, unsigned int fp2_no_of_grey)
{
  reg->bitfields.FP2_NO_OF_GREY = fp2_no_of_grey;
  if (reg->bitfields.FP2_NO_OF_GREY != fp2_no_of_grey) HSLDPF(E_ERROR_MESSAGE,"rv250FP2_GEN_CNTL::FP2_NO_OF_GREY data too large\n");
}
__inline void set_rv250FP2_GEN_CNTL_fp2_rst_fm(regrv250FP2_GEN_CNTL *reg, unsigned int fp2_rst_fm)
{
  reg->bitfields.FP2_RST_FM = fp2_rst_fm;
  if (reg->bitfields.FP2_RST_FM != fp2_rst_fm) HSLDPF(E_ERROR_MESSAGE,"rv250FP2_GEN_CNTL::FP2_RST_FM data too large\n");
}
__inline void set_rv250FP2_GEN_CNTL_fp2_detect_sense(regrv250FP2_GEN_CNTL *reg, unsigned int fp2_detect_sense)
{
  reg->bitfields.FP2_DETECT_SENSE = fp2_detect_sense;
  if (reg->bitfields.FP2_DETECT_SENSE != fp2_detect_sense) HSLDPF(E_ERROR_MESSAGE,"rv250FP2_GEN_CNTL::FP2_DETECT_SENSE data too large\n");
}
__inline void set_rv250FP2_GEN_CNTL_fp2_detect_int_pol(regrv250FP2_GEN_CNTL *reg, unsigned int fp2_detect_int_pol)
{
  reg->bitfields.FP2_DETECT_INT_POL = fp2_detect_int_pol;
  if (reg->bitfields.FP2_DETECT_INT_POL != fp2_detect_int_pol) HSLDPF(E_ERROR_MESSAGE,"rv250FP2_GEN_CNTL::FP2_DETECT_INT_POL data too large\n");
}
__inline void set_rv250FP2_GEN_CNTL_fp2_src_sel(regrv250FP2_GEN_CNTL *reg, unsigned int fp2_src_sel)
{
  reg->bitfields.FP2_SRC_SEL = fp2_src_sel;
  if (reg->bitfields.FP2_SRC_SEL != fp2_src_sel) HSLDPF(E_ERROR_MESSAGE,"rv250FP2_GEN_CNTL::FP2_SRC_SEL data too large\n");
}
__inline void set_rv250FP2_GEN_CNTL_fp2_fp_pol(regrv250FP2_GEN_CNTL *reg, unsigned int fp2_fp_pol)
{
  reg->bitfields.FP2_FP_POL = fp2_fp_pol;
  if (reg->bitfields.FP2_FP_POL != fp2_fp_pol) HSLDPF(E_ERROR_MESSAGE,"rv250FP2_GEN_CNTL::FP2_FP_POL data too large\n");
}
__inline void set_rv250FP2_GEN_CNTL_fp2_lp_pol(regrv250FP2_GEN_CNTL *reg, unsigned int fp2_lp_pol)
{
  reg->bitfields.FP2_LP_POL = fp2_lp_pol;
  if (reg->bitfields.FP2_LP_POL != fp2_lp_pol) HSLDPF(E_ERROR_MESSAGE,"rv250FP2_GEN_CNTL::FP2_LP_POL data too large\n");
}
__inline void set_rv250FP2_GEN_CNTL_fp2_sck_pol(regrv250FP2_GEN_CNTL *reg, unsigned int fp2_sck_pol)
{
  reg->bitfields.FP2_SCK_POL = fp2_sck_pol;
  if (reg->bitfields.FP2_SCK_POL != fp2_sck_pol) HSLDPF(E_ERROR_MESSAGE,"rv250FP2_GEN_CNTL::FP2_SCK_POL data too large\n");
}
__inline void set_rv250FP2_GEN_CNTL_fp2_lcd_cntl(regrv250FP2_GEN_CNTL *reg, unsigned int fp2_lcd_cntl)
{
  reg->bitfields.FP2_LCD_CNTL = fp2_lcd_cntl;
  if (reg->bitfields.FP2_LCD_CNTL != fp2_lcd_cntl) HSLDPF(E_ERROR_MESSAGE,"rv250FP2_GEN_CNTL::FP2_LCD_CNTL data too large\n");
}
__inline void set_rv250FP2_GEN_CNTL_fp2_pad_flop_en(regrv250FP2_GEN_CNTL *reg, unsigned int fp2_pad_flop_en)
{
  reg->bitfields.FP2_PAD_FLOP_EN = fp2_pad_flop_en;
  if (reg->bitfields.FP2_PAD_FLOP_EN != fp2_pad_flop_en) HSLDPF(E_ERROR_MESSAGE,"rv250FP2_GEN_CNTL::FP2_PAD_FLOP_EN data too large\n");
}
__inline void set_rv250FP2_GEN_CNTL_fp2_crc_en(regrv250FP2_GEN_CNTL *reg, unsigned int fp2_crc_en)
{
  reg->bitfields.FP2_CRC_EN = fp2_crc_en;
  if (reg->bitfields.FP2_CRC_EN != fp2_crc_en) HSLDPF(E_ERROR_MESSAGE,"rv250FP2_GEN_CNTL::FP2_CRC_EN data too large\n");
}
__inline void set_rv250FP2_GEN_CNTL_fp2_crc_read_en(regrv250FP2_GEN_CNTL *reg, unsigned int fp2_crc_read_en)
{
  reg->bitfields.FP2_CRC_READ_EN = fp2_crc_read_en;
  if (reg->bitfields.FP2_CRC_READ_EN != fp2_crc_read_en) HSLDPF(E_ERROR_MESSAGE,"rv250FP2_GEN_CNTL::FP2_CRC_READ_EN data too large\n");
}
__inline void set_rv250FP2_GEN_CNTL_dvo_en(regrv250FP2_GEN_CNTL *reg, unsigned int dvo_en)
{
  reg->bitfields.DVO_EN = dvo_en;
  if (reg->bitfields.DVO_EN != dvo_en) HSLDPF(E_ERROR_MESSAGE,"rv250FP2_GEN_CNTL::DVO_EN data too large\n");
}
__inline void set_rv250FP2_GEN_CNTL_dvo_tmds_ctl3(regrv250FP2_GEN_CNTL *reg, unsigned int dvo_tmds_ctl3)
{
  reg->bitfields.DVO_TMDS_CTL3 = dvo_tmds_ctl3;
  if (reg->bitfields.DVO_TMDS_CTL3 != dvo_tmds_ctl3) HSLDPF(E_ERROR_MESSAGE,"rv250FP2_GEN_CNTL::DVO_TMDS_CTL3 data too large\n");
}
__inline void set_rv250FP2_GEN_CNTL_dvo_rate_sel(regrv250FP2_GEN_CNTL *reg, unsigned int dvo_rate_sel)
{
  reg->bitfields.DVO_RATE_SEL = dvo_rate_sel;
  if (reg->bitfields.DVO_RATE_SEL != dvo_rate_sel) HSLDPF(E_ERROR_MESSAGE,"rv250FP2_GEN_CNTL::DVO_RATE_SEL data too large\n");
}
__inline void set_rv250FP2_GEN_CNTL_dvo_clock_mode(regrv250FP2_GEN_CNTL *reg, unsigned int dvo_clock_mode)
{
  reg->bitfields.DVO_CLOCK_MODE = dvo_clock_mode;
  if (reg->bitfields.DVO_CLOCK_MODE != dvo_clock_mode) HSLDPF(E_ERROR_MESSAGE,"rv250FP2_GEN_CNTL::DVO_CLOCK_MODE data too large\n");
}
__inline void set_rv250FP2_GEN_CNTL_dvo_tmds_ctl3_sel(regrv250FP2_GEN_CNTL *reg, unsigned int dvo_tmds_ctl3_sel)
{
  reg->bitfields.DVO_TMDS_CTL3_SEL = dvo_tmds_ctl3_sel;
  if (reg->bitfields.DVO_TMDS_CTL3_SEL != dvo_tmds_ctl3_sel) HSLDPF(E_ERROR_MESSAGE,"rv250FP2_GEN_CNTL::DVO_TMDS_CTL3_SEL data too large\n");
}
#else
#define set_rv250FP2_GEN_CNTL_fp2_blank_en(reg, fp2_blank_en) (reg)->bitfields.FP2_BLANK_EN = fp2_blank_en
#define set_rv250FP2_GEN_CNTL_fp2_on(reg, fp2_on) (reg)->bitfields.FP2_ON = fp2_on
#define set_rv250FP2_GEN_CNTL_fp2_panel_format(reg, fp2_panel_format) (reg)->bitfields.FP2_PANEL_FORMAT = fp2_panel_format
#define set_rv250FP2_GEN_CNTL_fp2_no_of_grey(reg, fp2_no_of_grey) (reg)->bitfields.FP2_NO_OF_GREY = fp2_no_of_grey
#define set_rv250FP2_GEN_CNTL_fp2_rst_fm(reg, fp2_rst_fm) (reg)->bitfields.FP2_RST_FM = fp2_rst_fm
#define set_rv250FP2_GEN_CNTL_fp2_detect_sense(reg, fp2_detect_sense) (reg)->bitfields.FP2_DETECT_SENSE = fp2_detect_sense
#define set_rv250FP2_GEN_CNTL_fp2_detect_int_pol(reg, fp2_detect_int_pol) (reg)->bitfields.FP2_DETECT_INT_POL = fp2_detect_int_pol
#define set_rv250FP2_GEN_CNTL_fp2_src_sel(reg, fp2_src_sel) (reg)->bitfields.FP2_SRC_SEL = fp2_src_sel
#define set_rv250FP2_GEN_CNTL_fp2_fp_pol(reg, fp2_fp_pol) (reg)->bitfields.FP2_FP_POL = fp2_fp_pol
#define set_rv250FP2_GEN_CNTL_fp2_lp_pol(reg, fp2_lp_pol) (reg)->bitfields.FP2_LP_POL = fp2_lp_pol
#define set_rv250FP2_GEN_CNTL_fp2_sck_pol(reg, fp2_sck_pol) (reg)->bitfields.FP2_SCK_POL = fp2_sck_pol
#define set_rv250FP2_GEN_CNTL_fp2_lcd_cntl(reg, fp2_lcd_cntl) (reg)->bitfields.FP2_LCD_CNTL = fp2_lcd_cntl
#define set_rv250FP2_GEN_CNTL_fp2_pad_flop_en(reg, fp2_pad_flop_en) (reg)->bitfields.FP2_PAD_FLOP_EN = fp2_pad_flop_en
#define set_rv250FP2_GEN_CNTL_fp2_crc_en(reg, fp2_crc_en) (reg)->bitfields.FP2_CRC_EN = fp2_crc_en
#define set_rv250FP2_GEN_CNTL_fp2_crc_read_en(reg, fp2_crc_read_en) (reg)->bitfields.FP2_CRC_READ_EN = fp2_crc_read_en
#define set_rv250FP2_GEN_CNTL_dvo_en(reg, dvo_en) (reg)->bitfields.DVO_EN = dvo_en
#define set_rv250FP2_GEN_CNTL_dvo_tmds_ctl3(reg, dvo_tmds_ctl3) (reg)->bitfields.DVO_TMDS_CTL3 = dvo_tmds_ctl3
#define set_rv250FP2_GEN_CNTL_dvo_rate_sel(reg, dvo_rate_sel) (reg)->bitfields.DVO_RATE_SEL = dvo_rate_sel
#define set_rv250FP2_GEN_CNTL_dvo_clock_mode(reg, dvo_clock_mode) (reg)->bitfields.DVO_CLOCK_MODE = dvo_clock_mode
#define set_rv250FP2_GEN_CNTL_dvo_tmds_ctl3_sel(reg, dvo_tmds_ctl3_sel) (reg)->bitfields.DVO_TMDS_CTL3_SEL = dvo_tmds_ctl3_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union FP_HORZ_STRETCH regFP_HORZ_STRETCH;

#ifdef DEBUG
__inline void set_FP_HORZ_STRETCH_fp_horz_stretch_ratio(regFP_HORZ_STRETCH *reg, unsigned int fp_horz_stretch_ratio)
{
  reg->bitfields.FP_HORZ_STRETCH_RATIO = fp_horz_stretch_ratio;
  if (reg->bitfields.FP_HORZ_STRETCH_RATIO != fp_horz_stretch_ratio) HSLDPF(E_ERROR_MESSAGE,"FP_HORZ_STRETCH::FP_HORZ_STRETCH_RATIO data too large\n");
}
__inline void set_FP_HORZ_STRETCH_fp_horz_panel_size(regFP_HORZ_STRETCH *reg, unsigned int fp_horz_panel_size)
{
  reg->bitfields.FP_HORZ_PANEL_SIZE = fp_horz_panel_size;
  if (reg->bitfields.FP_HORZ_PANEL_SIZE != fp_horz_panel_size) HSLDPF(E_ERROR_MESSAGE,"FP_HORZ_STRETCH::FP_HORZ_PANEL_SIZE data too large\n");
}
__inline void set_FP_HORZ_STRETCH_fp_horz_stretch_en(regFP_HORZ_STRETCH *reg, unsigned int fp_horz_stretch_en)
{
  reg->bitfields.FP_HORZ_STRETCH_EN = fp_horz_stretch_en;
  if (reg->bitfields.FP_HORZ_STRETCH_EN != fp_horz_stretch_en) HSLDPF(E_ERROR_MESSAGE,"FP_HORZ_STRETCH::FP_HORZ_STRETCH_EN data too large\n");
}
__inline void set_FP_HORZ_STRETCH_fp_horz_stretch_mode(regFP_HORZ_STRETCH *reg, unsigned int fp_horz_stretch_mode)
{
  reg->bitfields.FP_HORZ_STRETCH_MODE = fp_horz_stretch_mode;
  if (reg->bitfields.FP_HORZ_STRETCH_MODE != fp_horz_stretch_mode) HSLDPF(E_ERROR_MESSAGE,"FP_HORZ_STRETCH::FP_HORZ_STRETCH_MODE data too large\n");
}
__inline void set_FP_HORZ_STRETCH_fp_auto_horz_ratio(regFP_HORZ_STRETCH *reg, unsigned int fp_auto_horz_ratio)
{
  reg->bitfields.FP_AUTO_HORZ_RATIO = fp_auto_horz_ratio;
  if (reg->bitfields.FP_AUTO_HORZ_RATIO != fp_auto_horz_ratio) HSLDPF(E_ERROR_MESSAGE,"FP_HORZ_STRETCH::FP_AUTO_HORZ_RATIO data too large\n");
}
__inline void set_FP_HORZ_STRETCH_fp_loop_stretch(regFP_HORZ_STRETCH *reg, unsigned int fp_loop_stretch)
{
  reg->bitfields.FP_LOOP_STRETCH = fp_loop_stretch;
  if (reg->bitfields.FP_LOOP_STRETCH != fp_loop_stretch) HSLDPF(E_ERROR_MESSAGE,"FP_HORZ_STRETCH::FP_LOOP_STRETCH data too large\n");
}
__inline void set_FP_HORZ_STRETCH_rmx_auto_ratio_horz_inc(regFP_HORZ_STRETCH *reg, unsigned int rmx_auto_ratio_horz_inc)
{
  reg->bitfields.RMX_AUTO_RATIO_HORZ_INC = rmx_auto_ratio_horz_inc;
  if (reg->bitfields.RMX_AUTO_RATIO_HORZ_INC != rmx_auto_ratio_horz_inc) HSLDPF(E_ERROR_MESSAGE,"FP_HORZ_STRETCH::RMX_AUTO_RATIO_HORZ_INC data too large\n");
}
#else
#define set_FP_HORZ_STRETCH_fp_horz_stretch_ratio(reg, fp_horz_stretch_ratio) (reg)->bitfields.FP_HORZ_STRETCH_RATIO = fp_horz_stretch_ratio
#define set_FP_HORZ_STRETCH_fp_horz_panel_size(reg, fp_horz_panel_size) (reg)->bitfields.FP_HORZ_PANEL_SIZE = fp_horz_panel_size
#define set_FP_HORZ_STRETCH_fp_horz_stretch_en(reg, fp_horz_stretch_en) (reg)->bitfields.FP_HORZ_STRETCH_EN = fp_horz_stretch_en
#define set_FP_HORZ_STRETCH_fp_horz_stretch_mode(reg, fp_horz_stretch_mode) (reg)->bitfields.FP_HORZ_STRETCH_MODE = fp_horz_stretch_mode
#define set_FP_HORZ_STRETCH_fp_auto_horz_ratio(reg, fp_auto_horz_ratio) (reg)->bitfields.FP_AUTO_HORZ_RATIO = fp_auto_horz_ratio
#define set_FP_HORZ_STRETCH_fp_loop_stretch(reg, fp_loop_stretch) (reg)->bitfields.FP_LOOP_STRETCH = fp_loop_stretch
#define set_FP_HORZ_STRETCH_rmx_auto_ratio_horz_inc(reg, rmx_auto_ratio_horz_inc) (reg)->bitfields.RMX_AUTO_RATIO_HORZ_INC = rmx_auto_ratio_horz_inc

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union FP_VERT_STRETCH regFP_VERT_STRETCH;

#ifdef DEBUG
__inline void set_FP_VERT_STRETCH_fp_vert_stretch_ratio(regFP_VERT_STRETCH *reg, unsigned int fp_vert_stretch_ratio)
{
  reg->bitfields.FP_VERT_STRETCH_RATIO = fp_vert_stretch_ratio;
  if (reg->bitfields.FP_VERT_STRETCH_RATIO != fp_vert_stretch_ratio) HSLDPF(E_ERROR_MESSAGE,"FP_VERT_STRETCH::FP_VERT_STRETCH_RATIO data too large\n");
}
__inline void set_FP_VERT_STRETCH_fp_vert_panel_size(regFP_VERT_STRETCH *reg, unsigned int fp_vert_panel_size)
{
  reg->bitfields.FP_VERT_PANEL_SIZE = fp_vert_panel_size;
  if (reg->bitfields.FP_VERT_PANEL_SIZE != fp_vert_panel_size) HSLDPF(E_ERROR_MESSAGE,"FP_VERT_STRETCH::FP_VERT_PANEL_SIZE data too large\n");
}
__inline void set_FP_VERT_STRETCH_fp_vert_stretch_en(regFP_VERT_STRETCH *reg, unsigned int fp_vert_stretch_en)
{
  reg->bitfields.FP_VERT_STRETCH_EN = fp_vert_stretch_en;
  if (reg->bitfields.FP_VERT_STRETCH_EN != fp_vert_stretch_en) HSLDPF(E_ERROR_MESSAGE,"FP_VERT_STRETCH::FP_VERT_STRETCH_EN data too large\n");
}
__inline void set_FP_VERT_STRETCH_fp_vert_stretch_mode(regFP_VERT_STRETCH *reg, unsigned int fp_vert_stretch_mode)
{
  reg->bitfields.FP_VERT_STRETCH_MODE = fp_vert_stretch_mode;
  if (reg->bitfields.FP_VERT_STRETCH_MODE != fp_vert_stretch_mode) HSLDPF(E_ERROR_MESSAGE,"FP_VERT_STRETCH::FP_VERT_STRETCH_MODE data too large\n");
}
__inline void set_FP_VERT_STRETCH_fp_auto_vert_ratio(regFP_VERT_STRETCH *reg, unsigned int fp_auto_vert_ratio)
{
  reg->bitfields.FP_AUTO_VERT_RATIO = fp_auto_vert_ratio;
  if (reg->bitfields.FP_AUTO_VERT_RATIO != fp_auto_vert_ratio) HSLDPF(E_ERROR_MESSAGE,"FP_VERT_STRETCH::FP_AUTO_VERT_RATIO data too large\n");
}
__inline void set_FP_VERT_STRETCH_rmx_h_filter_init(regFP_VERT_STRETCH *reg, unsigned int rmx_h_filter_init)
{
  reg->bitfields.RMX_H_FILTER_INIT = rmx_h_filter_init;
  if (reg->bitfields.RMX_H_FILTER_INIT != rmx_h_filter_init) HSLDPF(E_ERROR_MESSAGE,"FP_VERT_STRETCH::RMX_H_FILTER_INIT data too large\n");
}
__inline void set_FP_VERT_STRETCH_rmx_v_filter_init(regFP_VERT_STRETCH *reg, unsigned int rmx_v_filter_init)
{
  reg->bitfields.RMX_V_FILTER_INIT = rmx_v_filter_init;
  if (reg->bitfields.RMX_V_FILTER_INIT != rmx_v_filter_init) HSLDPF(E_ERROR_MESSAGE,"FP_VERT_STRETCH::RMX_V_FILTER_INIT data too large\n");
}
__inline void set_FP_VERT_STRETCH_rmx_auto_ratio_vert_inc(regFP_VERT_STRETCH *reg, unsigned int rmx_auto_ratio_vert_inc)
{
  reg->bitfields.RMX_AUTO_RATIO_VERT_INC = rmx_auto_ratio_vert_inc;
  if (reg->bitfields.RMX_AUTO_RATIO_VERT_INC != rmx_auto_ratio_vert_inc) HSLDPF(E_ERROR_MESSAGE,"FP_VERT_STRETCH::RMX_AUTO_RATIO_VERT_INC data too large\n");
}
#else
#define set_FP_VERT_STRETCH_fp_vert_stretch_ratio(reg, fp_vert_stretch_ratio) (reg)->bitfields.FP_VERT_STRETCH_RATIO = fp_vert_stretch_ratio
#define set_FP_VERT_STRETCH_fp_vert_panel_size(reg, fp_vert_panel_size) (reg)->bitfields.FP_VERT_PANEL_SIZE = fp_vert_panel_size
#define set_FP_VERT_STRETCH_fp_vert_stretch_en(reg, fp_vert_stretch_en) (reg)->bitfields.FP_VERT_STRETCH_EN = fp_vert_stretch_en
#define set_FP_VERT_STRETCH_fp_vert_stretch_mode(reg, fp_vert_stretch_mode) (reg)->bitfields.FP_VERT_STRETCH_MODE = fp_vert_stretch_mode
#define set_FP_VERT_STRETCH_fp_auto_vert_ratio(reg, fp_auto_vert_ratio) (reg)->bitfields.FP_AUTO_VERT_RATIO = fp_auto_vert_ratio
#define set_FP_VERT_STRETCH_rmx_h_filter_init(reg, rmx_h_filter_init) (reg)->bitfields.RMX_H_FILTER_INIT = rmx_h_filter_init
#define set_FP_VERT_STRETCH_rmx_v_filter_init(reg, rmx_v_filter_init) (reg)->bitfields.RMX_V_FILTER_INIT = rmx_v_filter_init
#define set_FP_VERT_STRETCH_rmx_auto_ratio_vert_inc(reg, rmx_auto_ratio_vert_inc) (reg)->bitfields.RMX_AUTO_RATIO_VERT_INC = rmx_auto_ratio_vert_inc

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TMDS_CNTL regTMDS_CNTL;

#ifdef DEBUG
__inline void set_TMDS_CNTL_tmds_ctl0(regTMDS_CNTL *reg, unsigned int tmds_ctl0)
{
  reg->bitfields.TMDS_CTL0 = tmds_ctl0;
  if (reg->bitfields.TMDS_CTL0 != tmds_ctl0) HSLDPF(E_ERROR_MESSAGE,"TMDS_CNTL::TMDS_CTL0 data too large\n");
}
__inline void set_TMDS_CNTL_tmds_ctl1(regTMDS_CNTL *reg, unsigned int tmds_ctl1)
{
  reg->bitfields.TMDS_CTL1 = tmds_ctl1;
  if (reg->bitfields.TMDS_CTL1 != tmds_ctl1) HSLDPF(E_ERROR_MESSAGE,"TMDS_CNTL::TMDS_CTL1 data too large\n");
}
__inline void set_TMDS_CNTL_tmds_ctl2(regTMDS_CNTL *reg, unsigned int tmds_ctl2)
{
  reg->bitfields.TMDS_CTL2 = tmds_ctl2;
  if (reg->bitfields.TMDS_CTL2 != tmds_ctl2) HSLDPF(E_ERROR_MESSAGE,"TMDS_CNTL::TMDS_CTL2 data too large\n");
}
__inline void set_TMDS_CNTL_tmds_ctl3(regTMDS_CNTL *reg, unsigned int tmds_ctl3)
{
  reg->bitfields.TMDS_CTL3 = tmds_ctl3;
  if (reg->bitfields.TMDS_CTL3 != tmds_ctl3) HSLDPF(E_ERROR_MESSAGE,"TMDS_CNTL::TMDS_CTL3 data too large\n");
}
__inline void set_TMDS_CNTL_tmds_debug_hsync(regTMDS_CNTL *reg, unsigned int tmds_debug_hsync)
{
  reg->bitfields.TMDS_DEBUG_HSYNC = tmds_debug_hsync;
  if (reg->bitfields.TMDS_DEBUG_HSYNC != tmds_debug_hsync) HSLDPF(E_ERROR_MESSAGE,"TMDS_CNTL::TMDS_DEBUG_HSYNC data too large\n");
}
__inline void set_TMDS_CNTL_tmds_debug_vsync(regTMDS_CNTL *reg, unsigned int tmds_debug_vsync)
{
  reg->bitfields.TMDS_DEBUG_VSYNC = tmds_debug_vsync;
  if (reg->bitfields.TMDS_DEBUG_VSYNC != tmds_debug_vsync) HSLDPF(E_ERROR_MESSAGE,"TMDS_CNTL::TMDS_DEBUG_VSYNC data too large\n");
}
__inline void set_TMDS_CNTL_tmds_debug_de(regTMDS_CNTL *reg, unsigned int tmds_debug_de)
{
  reg->bitfields.TMDS_DEBUG_DE = tmds_debug_de;
  if (reg->bitfields.TMDS_DEBUG_DE != tmds_debug_de) HSLDPF(E_ERROR_MESSAGE,"TMDS_CNTL::TMDS_DEBUG_DE data too large\n");
}
__inline void set_TMDS_CNTL_tmds_debug_en(regTMDS_CNTL *reg, unsigned int tmds_debug_en)
{
  reg->bitfields.TMDS_DEBUG_EN = tmds_debug_en;
  if (reg->bitfields.TMDS_DEBUG_EN != tmds_debug_en) HSLDPF(E_ERROR_MESSAGE,"TMDS_CNTL::TMDS_DEBUG_EN data too large\n");
}
__inline void set_TMDS_CNTL_tmds_ctl_fb_sel(regTMDS_CNTL *reg, unsigned int tmds_ctl_fb_sel)
{
  reg->bitfields.TMDS_CTL_FB_SEL = tmds_ctl_fb_sel;
  if (reg->bitfields.TMDS_CTL_FB_SEL != tmds_ctl_fb_sel) HSLDPF(E_ERROR_MESSAGE,"TMDS_CNTL::TMDS_CTL_FB_SEL data too large\n");
}
__inline void set_TMDS_CNTL_tmds_ctl_fb_del(regTMDS_CNTL *reg, unsigned int tmds_ctl_fb_del)
{
  reg->bitfields.TMDS_CTL_FB_DEL = tmds_ctl_fb_del;
  if (reg->bitfields.TMDS_CTL_FB_DEL != tmds_ctl_fb_del) HSLDPF(E_ERROR_MESSAGE,"TMDS_CNTL::TMDS_CTL_FB_DEL data too large\n");
}
__inline void set_TMDS_CNTL_tmds_stereosync_ctl_sel(regTMDS_CNTL *reg, unsigned int tmds_stereosync_ctl_sel)
{
  reg->bitfields.TMDS_STEREOSYNC_CTL_SEL = tmds_stereosync_ctl_sel;
  if (reg->bitfields.TMDS_STEREOSYNC_CTL_SEL != tmds_stereosync_ctl_sel) HSLDPF(E_ERROR_MESSAGE,"TMDS_CNTL::TMDS_STEREOSYNC_CTL_SEL data too large\n");
}
__inline void set_TMDS_CNTL_tmds_sync_char_en(regTMDS_CNTL *reg, unsigned int tmds_sync_char_en)
{
  reg->bitfields.TMDS_SYNC_CHAR_EN = tmds_sync_char_en;
  if (reg->bitfields.TMDS_SYNC_CHAR_EN != tmds_sync_char_en) HSLDPF(E_ERROR_MESSAGE,"TMDS_CNTL::TMDS_SYNC_CHAR_EN data too large\n");
}
__inline void set_TMDS_CNTL_tmds_sync_cont(regTMDS_CNTL *reg, unsigned int tmds_sync_cont)
{
  reg->bitfields.TMDS_SYNC_CONT = tmds_sync_cont;
  if (reg->bitfields.TMDS_SYNC_CONT != tmds_sync_cont) HSLDPF(E_ERROR_MESSAGE,"TMDS_CNTL::TMDS_SYNC_CONT data too large\n");
}
__inline void set_TMDS_CNTL_tmds_dpcum_tst(regTMDS_CNTL *reg, unsigned int tmds_dpcum_tst)
{
  reg->bitfields.TMDS_DPCUM_TST = tmds_dpcum_tst;
  if (reg->bitfields.TMDS_DPCUM_TST != tmds_dpcum_tst) HSLDPF(E_ERROR_MESSAGE,"TMDS_CNTL::TMDS_DPCUM_TST data too large\n");
}
__inline void set_TMDS_CNTL_tmds_dpcum_in(regTMDS_CNTL *reg, unsigned int tmds_dpcum_in)
{
  reg->bitfields.TMDS_DPCUM_IN = tmds_dpcum_in;
  if (reg->bitfields.TMDS_DPCUM_IN != tmds_dpcum_in) HSLDPF(E_ERROR_MESSAGE,"TMDS_CNTL::TMDS_DPCUM_IN data too large\n");
}
__inline void set_TMDS_CNTL_tmds_crc_en(regTMDS_CNTL *reg, unsigned int tmds_crc_en)
{
  reg->bitfields.TMDS_CRC_EN = tmds_crc_en;
  if (reg->bitfields.TMDS_CRC_EN != tmds_crc_en) HSLDPF(E_ERROR_MESSAGE,"TMDS_CNTL::TMDS_CRC_EN data too large\n");
}
__inline void set_TMDS_CNTL_tmds_rb_switch_en(regTMDS_CNTL *reg, unsigned int tmds_rb_switch_en)
{
  reg->bitfields.TMDS_RB_SWITCH_EN = tmds_rb_switch_en;
  if (reg->bitfields.TMDS_RB_SWITCH_EN != tmds_rb_switch_en) HSLDPF(E_ERROR_MESSAGE,"TMDS_CNTL::TMDS_RB_SWITCH_EN data too large\n");
}
#else
#define set_TMDS_CNTL_tmds_ctl0(reg, tmds_ctl0) (reg)->bitfields.TMDS_CTL0 = tmds_ctl0
#define set_TMDS_CNTL_tmds_ctl1(reg, tmds_ctl1) (reg)->bitfields.TMDS_CTL1 = tmds_ctl1
#define set_TMDS_CNTL_tmds_ctl2(reg, tmds_ctl2) (reg)->bitfields.TMDS_CTL2 = tmds_ctl2
#define set_TMDS_CNTL_tmds_ctl3(reg, tmds_ctl3) (reg)->bitfields.TMDS_CTL3 = tmds_ctl3
#define set_TMDS_CNTL_tmds_debug_hsync(reg, tmds_debug_hsync) (reg)->bitfields.TMDS_DEBUG_HSYNC = tmds_debug_hsync
#define set_TMDS_CNTL_tmds_debug_vsync(reg, tmds_debug_vsync) (reg)->bitfields.TMDS_DEBUG_VSYNC = tmds_debug_vsync
#define set_TMDS_CNTL_tmds_debug_de(reg, tmds_debug_de) (reg)->bitfields.TMDS_DEBUG_DE = tmds_debug_de
#define set_TMDS_CNTL_tmds_debug_en(reg, tmds_debug_en) (reg)->bitfields.TMDS_DEBUG_EN = tmds_debug_en
#define set_TMDS_CNTL_tmds_ctl_fb_sel(reg, tmds_ctl_fb_sel) (reg)->bitfields.TMDS_CTL_FB_SEL = tmds_ctl_fb_sel
#define set_TMDS_CNTL_tmds_ctl_fb_del(reg, tmds_ctl_fb_del) (reg)->bitfields.TMDS_CTL_FB_DEL = tmds_ctl_fb_del
#define set_TMDS_CNTL_tmds_stereosync_ctl_sel(reg, tmds_stereosync_ctl_sel) (reg)->bitfields.TMDS_STEREOSYNC_CTL_SEL = tmds_stereosync_ctl_sel
#define set_TMDS_CNTL_tmds_sync_char_en(reg, tmds_sync_char_en) (reg)->bitfields.TMDS_SYNC_CHAR_EN = tmds_sync_char_en
#define set_TMDS_CNTL_tmds_sync_cont(reg, tmds_sync_cont) (reg)->bitfields.TMDS_SYNC_CONT = tmds_sync_cont
#define set_TMDS_CNTL_tmds_dpcum_tst(reg, tmds_dpcum_tst) (reg)->bitfields.TMDS_DPCUM_TST = tmds_dpcum_tst
#define set_TMDS_CNTL_tmds_dpcum_in(reg, tmds_dpcum_in) (reg)->bitfields.TMDS_DPCUM_IN = tmds_dpcum_in
#define set_TMDS_CNTL_tmds_crc_en(reg, tmds_crc_en) (reg)->bitfields.TMDS_CRC_EN = tmds_crc_en
#define set_TMDS_CNTL_tmds_rb_switch_en(reg, tmds_rb_switch_en) (reg)->bitfields.TMDS_RB_SWITCH_EN = tmds_rb_switch_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TMDS_SYNC_CHAR_SETA regTMDS_SYNC_CHAR_SETA;

#ifdef DEBUG
__inline void set_TMDS_SYNC_CHAR_SETA_tmds_sync_char0(regTMDS_SYNC_CHAR_SETA *reg, unsigned int tmds_sync_char0)
{
  reg->bitfields.TMDS_SYNC_CHAR0 = tmds_sync_char0;
  if (reg->bitfields.TMDS_SYNC_CHAR0 != tmds_sync_char0) HSLDPF(E_ERROR_MESSAGE,"TMDS_SYNC_CHAR_SETA::TMDS_SYNC_CHAR0 data too large\n");
}
__inline void set_TMDS_SYNC_CHAR_SETA_tmds_sync_char1(regTMDS_SYNC_CHAR_SETA *reg, unsigned int tmds_sync_char1)
{
  reg->bitfields.TMDS_SYNC_CHAR1 = tmds_sync_char1;
  if (reg->bitfields.TMDS_SYNC_CHAR1 != tmds_sync_char1) HSLDPF(E_ERROR_MESSAGE,"TMDS_SYNC_CHAR_SETA::TMDS_SYNC_CHAR1 data too large\n");
}
#else
#define set_TMDS_SYNC_CHAR_SETA_tmds_sync_char0(reg, tmds_sync_char0) (reg)->bitfields.TMDS_SYNC_CHAR0 = tmds_sync_char0
#define set_TMDS_SYNC_CHAR_SETA_tmds_sync_char1(reg, tmds_sync_char1) (reg)->bitfields.TMDS_SYNC_CHAR1 = tmds_sync_char1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TMDS_SYNC_CHAR_SETB regTMDS_SYNC_CHAR_SETB;

#ifdef DEBUG
__inline void set_TMDS_SYNC_CHAR_SETB_tmds_sync_char2(regTMDS_SYNC_CHAR_SETB *reg, unsigned int tmds_sync_char2)
{
  reg->bitfields.TMDS_SYNC_CHAR2 = tmds_sync_char2;
  if (reg->bitfields.TMDS_SYNC_CHAR2 != tmds_sync_char2) HSLDPF(E_ERROR_MESSAGE,"TMDS_SYNC_CHAR_SETB::TMDS_SYNC_CHAR2 data too large\n");
}
__inline void set_TMDS_SYNC_CHAR_SETB_tmds_sync_char3(regTMDS_SYNC_CHAR_SETB *reg, unsigned int tmds_sync_char3)
{
  reg->bitfields.TMDS_SYNC_CHAR3 = tmds_sync_char3;
  if (reg->bitfields.TMDS_SYNC_CHAR3 != tmds_sync_char3) HSLDPF(E_ERROR_MESSAGE,"TMDS_SYNC_CHAR_SETB::TMDS_SYNC_CHAR3 data too large\n");
}
#else
#define set_TMDS_SYNC_CHAR_SETB_tmds_sync_char2(reg, tmds_sync_char2) (reg)->bitfields.TMDS_SYNC_CHAR2 = tmds_sync_char2
#define set_TMDS_SYNC_CHAR_SETB_tmds_sync_char3(reg, tmds_sync_char3) (reg)->bitfields.TMDS_SYNC_CHAR3 = tmds_sync_char3

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TMDS_CRC regTMDS_CRC;

#ifdef DEBUG
__inline void set_TMDS_CRC_tmds_crcrgb(regTMDS_CRC *reg, unsigned int tmds_crcrgb)
{
  reg->bitfields.TMDS_CRCRGB = tmds_crcrgb;
  if (reg->bitfields.TMDS_CRCRGB != tmds_crcrgb) HSLDPF(E_ERROR_MESSAGE,"TMDS_CRC::TMDS_CRCRGB data too large\n");
}
#else
#define set_TMDS_CRC_tmds_crcrgb(reg, tmds_crcrgb) (reg)->bitfields.TMDS_CRCRGB = tmds_crcrgb

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TMDS_TRANSMITTER_CNTL regTMDS_TRANSMITTER_CNTL;

#ifdef DEBUG
__inline void set_TMDS_TRANSMITTER_CNTL_tmds_pllen(regTMDS_TRANSMITTER_CNTL *reg, unsigned int tmds_pllen)
{
  reg->bitfields.TMDS_PLLEN = tmds_pllen;
  if (reg->bitfields.TMDS_PLLEN != tmds_pllen) HSLDPF(E_ERROR_MESSAGE,"TMDS_TRANSMITTER_CNTL::TMDS_PLLEN data too large\n");
}
__inline void set_TMDS_TRANSMITTER_CNTL_tmds_pllrst(regTMDS_TRANSMITTER_CNTL *reg, unsigned int tmds_pllrst)
{
  reg->bitfields.TMDS_PLLRST = tmds_pllrst;
  if (reg->bitfields.TMDS_PLLRST != tmds_pllrst) HSLDPF(E_ERROR_MESSAGE,"TMDS_TRANSMITTER_CNTL::TMDS_PLLRST data too large\n");
}
__inline void set_TMDS_TRANSMITTER_CNTL_tmds_mode_sel(regTMDS_TRANSMITTER_CNTL *reg, unsigned int tmds_mode_sel)
{
  reg->bitfields.TMDS_MODE_SEL = tmds_mode_sel;
  if (reg->bitfields.TMDS_MODE_SEL != tmds_mode_sel) HSLDPF(E_ERROR_MESSAGE,"TMDS_TRANSMITTER_CNTL::TMDS_MODE_SEL data too large\n");
}
__inline void set_TMDS_TRANSMITTER_CNTL_tmds_regsel(regTMDS_TRANSMITTER_CNTL *reg, unsigned int tmds_regsel)
{
  reg->bitfields.TMDS_REGSEL = tmds_regsel;
  if (reg->bitfields.TMDS_REGSEL != tmds_regsel) HSLDPF(E_ERROR_MESSAGE,"TMDS_TRANSMITTER_CNTL::TMDS_REGSEL data too large\n");
}
__inline void set_TMDS_TRANSMITTER_CNTL_tmds_half_clk_rst(regTMDS_TRANSMITTER_CNTL *reg, unsigned int tmds_half_clk_rst)
{
  reg->bitfields.TMDS_HALF_CLK_RST = tmds_half_clk_rst;
  if (reg->bitfields.TMDS_HALF_CLK_RST != tmds_half_clk_rst) HSLDPF(E_ERROR_MESSAGE,"TMDS_TRANSMITTER_CNTL::TMDS_HALF_CLK_RST data too large\n");
}
__inline void set_TMDS_TRANSMITTER_CNTL_tmds_ran_pat_rst(regTMDS_TRANSMITTER_CNTL *reg, unsigned int tmds_ran_pat_rst)
{
  reg->bitfields.TMDS_RAN_PAT_RST = tmds_ran_pat_rst;
  if (reg->bitfields.TMDS_RAN_PAT_RST != tmds_ran_pat_rst) HSLDPF(E_ERROR_MESSAGE,"TMDS_TRANSMITTER_CNTL::TMDS_RAN_PAT_RST data too large\n");
}
__inline void set_TMDS_TRANSMITTER_CNTL_tmds_tstpix(regTMDS_TRANSMITTER_CNTL *reg, unsigned int tmds_tstpix)
{
  reg->bitfields.TMDS_TSTPIX = tmds_tstpix;
  if (reg->bitfields.TMDS_TSTPIX != tmds_tstpix) HSLDPF(E_ERROR_MESSAGE,"TMDS_TRANSMITTER_CNTL::TMDS_TSTPIX data too large\n");
}
__inline void set_TMDS_TRANSMITTER_CNTL_tmds_reg(regTMDS_TRANSMITTER_CNTL *reg, unsigned int tmds_reg)
{
  reg->bitfields.TMDS_REG = tmds_reg;
  if (reg->bitfields.TMDS_REG != tmds_reg) HSLDPF(E_ERROR_MESSAGE,"TMDS_TRANSMITTER_CNTL::TMDS_REG data too large\n");
}
__inline void set_TMDS_TRANSMITTER_CNTL_ichcsel(regTMDS_TRANSMITTER_CNTL *reg, unsigned int ichcsel)
{
  reg->bitfields.ICHCSEL = ichcsel;
  if (reg->bitfields.ICHCSEL != ichcsel) HSLDPF(E_ERROR_MESSAGE,"TMDS_TRANSMITTER_CNTL::ICHCSEL data too large\n");
}
__inline void set_TMDS_TRANSMITTER_CNTL_itclksel(regTMDS_TRANSMITTER_CNTL *reg, unsigned int itclksel)
{
  reg->bitfields.ITCLKSEL = itclksel;
  if (reg->bitfields.ITCLKSEL != itclksel) HSLDPF(E_ERROR_MESSAGE,"TMDS_TRANSMITTER_CNTL::ITCLKSEL data too large\n");
}
__inline void set_TMDS_TRANSMITTER_CNTL_tmds_ran_pat_sel(regTMDS_TRANSMITTER_CNTL *reg, unsigned int tmds_ran_pat_sel)
{
  reg->bitfields.TMDS_RAN_PAT_SEL = tmds_ran_pat_sel;
  if (reg->bitfields.TMDS_RAN_PAT_SEL != tmds_ran_pat_sel) HSLDPF(E_ERROR_MESSAGE,"TMDS_TRANSMITTER_CNTL::TMDS_RAN_PAT_SEL data too large\n");
}
#else
#define set_TMDS_TRANSMITTER_CNTL_tmds_pllen(reg, tmds_pllen) (reg)->bitfields.TMDS_PLLEN = tmds_pllen
#define set_TMDS_TRANSMITTER_CNTL_tmds_pllrst(reg, tmds_pllrst) (reg)->bitfields.TMDS_PLLRST = tmds_pllrst
#define set_TMDS_TRANSMITTER_CNTL_tmds_mode_sel(reg, tmds_mode_sel) (reg)->bitfields.TMDS_MODE_SEL = tmds_mode_sel
#define set_TMDS_TRANSMITTER_CNTL_tmds_regsel(reg, tmds_regsel) (reg)->bitfields.TMDS_REGSEL = tmds_regsel
#define set_TMDS_TRANSMITTER_CNTL_tmds_half_clk_rst(reg, tmds_half_clk_rst) (reg)->bitfields.TMDS_HALF_CLK_RST = tmds_half_clk_rst
#define set_TMDS_TRANSMITTER_CNTL_tmds_ran_pat_rst(reg, tmds_ran_pat_rst) (reg)->bitfields.TMDS_RAN_PAT_RST = tmds_ran_pat_rst
#define set_TMDS_TRANSMITTER_CNTL_tmds_tstpix(reg, tmds_tstpix) (reg)->bitfields.TMDS_TSTPIX = tmds_tstpix
#define set_TMDS_TRANSMITTER_CNTL_tmds_reg(reg, tmds_reg) (reg)->bitfields.TMDS_REG = tmds_reg
#define set_TMDS_TRANSMITTER_CNTL_ichcsel(reg, ichcsel) (reg)->bitfields.ICHCSEL = ichcsel
#define set_TMDS_TRANSMITTER_CNTL_itclksel(reg, itclksel) (reg)->bitfields.ITCLKSEL = itclksel
#define set_TMDS_TRANSMITTER_CNTL_tmds_ran_pat_sel(reg, tmds_ran_pat_sel) (reg)->bitfields.TMDS_RAN_PAT_SEL = tmds_ran_pat_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TMDS_PLL_CNTL regTMDS_PLL_CNTL;

#ifdef DEBUG
__inline void set_TMDS_PLL_CNTL_tmds_pllpcp(regTMDS_PLL_CNTL *reg, unsigned int tmds_pllpcp)
{
  reg->bitfields.TMDS_PLLPCP = tmds_pllpcp;
  if (reg->bitfields.TMDS_PLLPCP != tmds_pllpcp) HSLDPF(E_ERROR_MESSAGE,"TMDS_PLL_CNTL::TMDS_PLLPCP data too large\n");
}
__inline void set_TMDS_PLL_CNTL_tmds_pllpvg(regTMDS_PLL_CNTL *reg, unsigned int tmds_pllpvg)
{
  reg->bitfields.TMDS_PLLPVG = tmds_pllpvg;
  if (reg->bitfields.TMDS_PLLPVG != tmds_pllpvg) HSLDPF(E_ERROR_MESSAGE,"TMDS_PLL_CNTL::TMDS_PLLPVG data too large\n");
}
__inline void set_TMDS_PLL_CNTL_tmds_pllpdc(regTMDS_PLL_CNTL *reg, unsigned int tmds_pllpdc)
{
  reg->bitfields.TMDS_PLLPDC = tmds_pllpdc;
  if (reg->bitfields.TMDS_PLLPDC != tmds_pllpdc) HSLDPF(E_ERROR_MESSAGE,"TMDS_PLL_CNTL::TMDS_PLLPDC data too large\n");
}
__inline void set_TMDS_PLL_CNTL_tmds_pllpvs(regTMDS_PLL_CNTL *reg, unsigned int tmds_pllpvs)
{
  reg->bitfields.TMDS_PLLPVS = tmds_pllpvs;
  if (reg->bitfields.TMDS_PLLPVS != tmds_pllpvs) HSLDPF(E_ERROR_MESSAGE,"TMDS_PLL_CNTL::TMDS_PLLPVS data too large\n");
}
#else
#define set_TMDS_PLL_CNTL_tmds_pllpcp(reg, tmds_pllpcp) (reg)->bitfields.TMDS_PLLPCP = tmds_pllpcp
#define set_TMDS_PLL_CNTL_tmds_pllpvg(reg, tmds_pllpvg) (reg)->bitfields.TMDS_PLLPVG = tmds_pllpvg
#define set_TMDS_PLL_CNTL_tmds_pllpdc(reg, tmds_pllpdc) (reg)->bitfields.TMDS_PLLPDC = tmds_pllpdc
#define set_TMDS_PLL_CNTL_tmds_pllpvs(reg, tmds_pllpvs) (reg)->bitfields.TMDS_PLLPVS = tmds_pllpvs

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TMDS_PATTERN_GEN_SEED regTMDS_PATTERN_GEN_SEED;

#ifdef DEBUG
__inline void set_TMDS_PATTERN_GEN_SEED_pattern_seed(regTMDS_PATTERN_GEN_SEED *reg, unsigned int pattern_seed)
{
  reg->bitfields.PATTERN_SEED = pattern_seed;
  if (reg->bitfields.PATTERN_SEED != pattern_seed) HSLDPF(E_ERROR_MESSAGE,"TMDS_PATTERN_GEN_SEED::PATTERN_SEED data too large\n");
}
#else
#define set_TMDS_PATTERN_GEN_SEED_pattern_seed(reg, pattern_seed) (reg)->bitfields.PATTERN_SEED = pattern_seed

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ICON_OFFSET regICON_OFFSET;

#ifdef DEBUG
__inline void set_ICON_OFFSET_icon_offset(regICON_OFFSET *reg, unsigned int icon_offset)
{
  reg->bitfields.ICON_OFFSET = icon_offset;
  if (reg->bitfields.ICON_OFFSET != icon_offset) HSLDPF(E_ERROR_MESSAGE,"ICON_OFFSET::ICON_OFFSET data too large\n");
}
__inline void set_ICON_OFFSET_blank_screen1(regICON_OFFSET *reg, unsigned int blank_screen1)
{
  reg->bitfields.BLANK_SCREEN1 = blank_screen1;
  if (reg->bitfields.BLANK_SCREEN1 != blank_screen1) HSLDPF(E_ERROR_MESSAGE,"ICON_OFFSET::BLANK_SCREEN1 data too large\n");
}
__inline void set_ICON_OFFSET_dont_ds_icon(regICON_OFFSET *reg, unsigned int dont_ds_icon)
{
  reg->bitfields.DONT_DS_ICON = dont_ds_icon;
  if (reg->bitfields.DONT_DS_ICON != dont_ds_icon) HSLDPF(E_ERROR_MESSAGE,"ICON_OFFSET::DONT_DS_ICON data too large\n");
}
__inline void set_ICON_OFFSET_icon_lock(regICON_OFFSET *reg, unsigned int icon_lock)
{
  reg->bitfields.ICON_LOCK = icon_lock;
  if (reg->bitfields.ICON_LOCK != icon_lock) HSLDPF(E_ERROR_MESSAGE,"ICON_OFFSET::ICON_LOCK data too large\n");
}
#else
#define set_ICON_OFFSET_icon_offset(reg, icon_offset) (reg)->bitfields.ICON_OFFSET = icon_offset
#define set_ICON_OFFSET_blank_screen1(reg, blank_screen1) (reg)->bitfields.BLANK_SCREEN1 = blank_screen1
#define set_ICON_OFFSET_dont_ds_icon(reg, dont_ds_icon) (reg)->bitfields.DONT_DS_ICON = dont_ds_icon
#define set_ICON_OFFSET_icon_lock(reg, icon_lock) (reg)->bitfields.ICON_LOCK = icon_lock

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ICON_HORZ_VERT_POSN regICON_HORZ_VERT_POSN;

#ifdef DEBUG
__inline void set_ICON_HORZ_VERT_POSN_icon_vert_posn(regICON_HORZ_VERT_POSN *reg, unsigned int icon_vert_posn)
{
  reg->bitfields.ICON_VERT_POSN = icon_vert_posn;
  if (reg->bitfields.ICON_VERT_POSN != icon_vert_posn) HSLDPF(E_ERROR_MESSAGE,"ICON_HORZ_VERT_POSN::ICON_VERT_POSN data too large\n");
}
__inline void set_ICON_HORZ_VERT_POSN_icon_horz_posn(regICON_HORZ_VERT_POSN *reg, unsigned int icon_horz_posn)
{
  reg->bitfields.ICON_HORZ_POSN = icon_horz_posn;
  if (reg->bitfields.ICON_HORZ_POSN != icon_horz_posn) HSLDPF(E_ERROR_MESSAGE,"ICON_HORZ_VERT_POSN::ICON_HORZ_POSN data too large\n");
}
__inline void set_ICON_HORZ_VERT_POSN_icon_lock(regICON_HORZ_VERT_POSN *reg, unsigned int icon_lock)
{
  reg->bitfields.ICON_LOCK = icon_lock;
  if (reg->bitfields.ICON_LOCK != icon_lock) HSLDPF(E_ERROR_MESSAGE,"ICON_HORZ_VERT_POSN::ICON_LOCK data too large\n");
}
#else
#define set_ICON_HORZ_VERT_POSN_icon_vert_posn(reg, icon_vert_posn) (reg)->bitfields.ICON_VERT_POSN = icon_vert_posn
#define set_ICON_HORZ_VERT_POSN_icon_horz_posn(reg, icon_horz_posn) (reg)->bitfields.ICON_HORZ_POSN = icon_horz_posn
#define set_ICON_HORZ_VERT_POSN_icon_lock(reg, icon_lock) (reg)->bitfields.ICON_LOCK = icon_lock

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ICON_HORZ_VERT_OFF regICON_HORZ_VERT_OFF;

#ifdef DEBUG
__inline void set_ICON_HORZ_VERT_OFF_icon_vert_off(regICON_HORZ_VERT_OFF *reg, unsigned int icon_vert_off)
{
  reg->bitfields.ICON_VERT_OFF = icon_vert_off;
  if (reg->bitfields.ICON_VERT_OFF != icon_vert_off) HSLDPF(E_ERROR_MESSAGE,"ICON_HORZ_VERT_OFF::ICON_VERT_OFF data too large\n");
}
__inline void set_ICON_HORZ_VERT_OFF_icon_horz_off(regICON_HORZ_VERT_OFF *reg, unsigned int icon_horz_off)
{
  reg->bitfields.ICON_HORZ_OFF = icon_horz_off;
  if (reg->bitfields.ICON_HORZ_OFF != icon_horz_off) HSLDPF(E_ERROR_MESSAGE,"ICON_HORZ_VERT_OFF::ICON_HORZ_OFF data too large\n");
}
__inline void set_ICON_HORZ_VERT_OFF_icon_lock(regICON_HORZ_VERT_OFF *reg, unsigned int icon_lock)
{
  reg->bitfields.ICON_LOCK = icon_lock;
  if (reg->bitfields.ICON_LOCK != icon_lock) HSLDPF(E_ERROR_MESSAGE,"ICON_HORZ_VERT_OFF::ICON_LOCK data too large\n");
}
#else
#define set_ICON_HORZ_VERT_OFF_icon_vert_off(reg, icon_vert_off) (reg)->bitfields.ICON_VERT_OFF = icon_vert_off
#define set_ICON_HORZ_VERT_OFF_icon_horz_off(reg, icon_horz_off) (reg)->bitfields.ICON_HORZ_OFF = icon_horz_off
#define set_ICON_HORZ_VERT_OFF_icon_lock(reg, icon_lock) (reg)->bitfields.ICON_LOCK = icon_lock

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ICON_CLR0 regICON_CLR0;

#ifdef DEBUG
__inline void set_ICON_CLR0_icon_clr0_b(regICON_CLR0 *reg, unsigned int icon_clr0_b)
{
  reg->bitfields.ICON_CLR0_B = icon_clr0_b;
  if (reg->bitfields.ICON_CLR0_B != icon_clr0_b) HSLDPF(E_ERROR_MESSAGE,"ICON_CLR0::ICON_CLR0_B data too large\n");
}
__inline void set_ICON_CLR0_icon_clr0_g(regICON_CLR0 *reg, unsigned int icon_clr0_g)
{
  reg->bitfields.ICON_CLR0_G = icon_clr0_g;
  if (reg->bitfields.ICON_CLR0_G != icon_clr0_g) HSLDPF(E_ERROR_MESSAGE,"ICON_CLR0::ICON_CLR0_G data too large\n");
}
__inline void set_ICON_CLR0_icon_clr0_r(regICON_CLR0 *reg, unsigned int icon_clr0_r)
{
  reg->bitfields.ICON_CLR0_R = icon_clr0_r;
  if (reg->bitfields.ICON_CLR0_R != icon_clr0_r) HSLDPF(E_ERROR_MESSAGE,"ICON_CLR0::ICON_CLR0_R data too large\n");
}
#else
#define set_ICON_CLR0_icon_clr0_b(reg, icon_clr0_b) (reg)->bitfields.ICON_CLR0_B = icon_clr0_b
#define set_ICON_CLR0_icon_clr0_g(reg, icon_clr0_g) (reg)->bitfields.ICON_CLR0_G = icon_clr0_g
#define set_ICON_CLR0_icon_clr0_r(reg, icon_clr0_r) (reg)->bitfields.ICON_CLR0_R = icon_clr0_r

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ICON_CLR1 regICON_CLR1;

#ifdef DEBUG
__inline void set_ICON_CLR1_icon_clr1_b(regICON_CLR1 *reg, unsigned int icon_clr1_b)
{
  reg->bitfields.ICON_CLR1_B = icon_clr1_b;
  if (reg->bitfields.ICON_CLR1_B != icon_clr1_b) HSLDPF(E_ERROR_MESSAGE,"ICON_CLR1::ICON_CLR1_B data too large\n");
}
__inline void set_ICON_CLR1_icon_clr1_g(regICON_CLR1 *reg, unsigned int icon_clr1_g)
{
  reg->bitfields.ICON_CLR1_G = icon_clr1_g;
  if (reg->bitfields.ICON_CLR1_G != icon_clr1_g) HSLDPF(E_ERROR_MESSAGE,"ICON_CLR1::ICON_CLR1_G data too large\n");
}
__inline void set_ICON_CLR1_icon_clr1_r(regICON_CLR1 *reg, unsigned int icon_clr1_r)
{
  reg->bitfields.ICON_CLR1_R = icon_clr1_r;
  if (reg->bitfields.ICON_CLR1_R != icon_clr1_r) HSLDPF(E_ERROR_MESSAGE,"ICON_CLR1::ICON_CLR1_R data too large\n");
}
#else
#define set_ICON_CLR1_icon_clr1_b(reg, icon_clr1_b) (reg)->bitfields.ICON_CLR1_B = icon_clr1_b
#define set_ICON_CLR1_icon_clr1_g(reg, icon_clr1_g) (reg)->bitfields.ICON_CLR1_G = icon_clr1_g
#define set_ICON_CLR1_icon_clr1_r(reg, icon_clr1_r) (reg)->bitfields.ICON_CLR1_R = icon_clr1_r

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union FP_H_SYNC_STRT_WID regFP_H_SYNC_STRT_WID;

#ifdef DEBUG
__inline void set_FP_H_SYNC_STRT_WID_fp_h_sync_strt_pix(regFP_H_SYNC_STRT_WID *reg, unsigned int fp_h_sync_strt_pix)
{
  reg->bitfields.FP_H_SYNC_STRT_PIX = fp_h_sync_strt_pix;
  if (reg->bitfields.FP_H_SYNC_STRT_PIX != fp_h_sync_strt_pix) HSLDPF(E_ERROR_MESSAGE,"FP_H_SYNC_STRT_WID::FP_H_SYNC_STRT_PIX data too large\n");
}
__inline void set_FP_H_SYNC_STRT_WID_fp_h_sync_strt_char(regFP_H_SYNC_STRT_WID *reg, unsigned int fp_h_sync_strt_char)
{
  reg->bitfields.FP_H_SYNC_STRT_CHAR = fp_h_sync_strt_char;
  if (reg->bitfields.FP_H_SYNC_STRT_CHAR != fp_h_sync_strt_char) HSLDPF(E_ERROR_MESSAGE,"FP_H_SYNC_STRT_WID::FP_H_SYNC_STRT_CHAR data too large\n");
}
__inline void set_FP_H_SYNC_STRT_WID_fp_h_sync_wid(regFP_H_SYNC_STRT_WID *reg, unsigned int fp_h_sync_wid)
{
  reg->bitfields.FP_H_SYNC_WID = fp_h_sync_wid;
  if (reg->bitfields.FP_H_SYNC_WID != fp_h_sync_wid) HSLDPF(E_ERROR_MESSAGE,"FP_H_SYNC_STRT_WID::FP_H_SYNC_WID data too large\n");
}
__inline void set_FP_H_SYNC_STRT_WID_fp_h_sync_pol(regFP_H_SYNC_STRT_WID *reg, unsigned int fp_h_sync_pol)
{
  reg->bitfields.FP_H_SYNC_POL = fp_h_sync_pol;
  if (reg->bitfields.FP_H_SYNC_POL != fp_h_sync_pol) HSLDPF(E_ERROR_MESSAGE,"FP_H_SYNC_STRT_WID::FP_H_SYNC_POL data too large\n");
}
#else
#define set_FP_H_SYNC_STRT_WID_fp_h_sync_strt_pix(reg, fp_h_sync_strt_pix) (reg)->bitfields.FP_H_SYNC_STRT_PIX = fp_h_sync_strt_pix
#define set_FP_H_SYNC_STRT_WID_fp_h_sync_strt_char(reg, fp_h_sync_strt_char) (reg)->bitfields.FP_H_SYNC_STRT_CHAR = fp_h_sync_strt_char
#define set_FP_H_SYNC_STRT_WID_fp_h_sync_wid(reg, fp_h_sync_wid) (reg)->bitfields.FP_H_SYNC_WID = fp_h_sync_wid
#define set_FP_H_SYNC_STRT_WID_fp_h_sync_pol(reg, fp_h_sync_pol) (reg)->bitfields.FP_H_SYNC_POL = fp_h_sync_pol

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union FP_V_SYNC_STRT_WID regFP_V_SYNC_STRT_WID;

#ifdef DEBUG
__inline void set_FP_V_SYNC_STRT_WID_fp_v_sync_strt(regFP_V_SYNC_STRT_WID *reg, unsigned int fp_v_sync_strt)
{
  reg->bitfields.FP_V_SYNC_STRT = fp_v_sync_strt;
  if (reg->bitfields.FP_V_SYNC_STRT != fp_v_sync_strt) HSLDPF(E_ERROR_MESSAGE,"FP_V_SYNC_STRT_WID::FP_V_SYNC_STRT data too large\n");
}
__inline void set_FP_V_SYNC_STRT_WID_fp_v_sync_wid(regFP_V_SYNC_STRT_WID *reg, unsigned int fp_v_sync_wid)
{
  reg->bitfields.FP_V_SYNC_WID = fp_v_sync_wid;
  if (reg->bitfields.FP_V_SYNC_WID != fp_v_sync_wid) HSLDPF(E_ERROR_MESSAGE,"FP_V_SYNC_STRT_WID::FP_V_SYNC_WID data too large\n");
}
__inline void set_FP_V_SYNC_STRT_WID_fp_v_sync_pol(regFP_V_SYNC_STRT_WID *reg, unsigned int fp_v_sync_pol)
{
  reg->bitfields.FP_V_SYNC_POL = fp_v_sync_pol;
  if (reg->bitfields.FP_V_SYNC_POL != fp_v_sync_pol) HSLDPF(E_ERROR_MESSAGE,"FP_V_SYNC_STRT_WID::FP_V_SYNC_POL data too large\n");
}
#else
#define set_FP_V_SYNC_STRT_WID_fp_v_sync_strt(reg, fp_v_sync_strt) (reg)->bitfields.FP_V_SYNC_STRT = fp_v_sync_strt
#define set_FP_V_SYNC_STRT_WID_fp_v_sync_wid(reg, fp_v_sync_wid) (reg)->bitfields.FP_V_SYNC_WID = fp_v_sync_wid
#define set_FP_V_SYNC_STRT_WID_fp_v_sync_pol(reg, fp_v_sync_pol) (reg)->bitfields.FP_V_SYNC_POL = fp_v_sync_pol

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union LVDS_DIGTMDS_CRC regLVDS_DIGTMDS_CRC;

#ifdef DEBUG
__inline void set_LVDS_DIGTMDS_CRC_lvds_crc_sig_rgb(regLVDS_DIGTMDS_CRC *reg, unsigned int lvds_crc_sig_rgb)
{
  reg->bitfields.LVDS_CRC_SIG_RGB = lvds_crc_sig_rgb;
  if (reg->bitfields.LVDS_CRC_SIG_RGB != lvds_crc_sig_rgb) HSLDPF(E_ERROR_MESSAGE,"LVDS_DIGTMDS_CRC::LVDS_CRC_SIG_RGB data too large\n");
}
__inline void set_LVDS_DIGTMDS_CRC_lvds_crc_sig_c(regLVDS_DIGTMDS_CRC *reg, unsigned int lvds_crc_sig_c)
{
  reg->bitfields.LVDS_CRC_SIG_C = lvds_crc_sig_c;
  if (reg->bitfields.LVDS_CRC_SIG_C != lvds_crc_sig_c) HSLDPF(E_ERROR_MESSAGE,"LVDS_DIGTMDS_CRC::LVDS_CRC_SIG_C data too large\n");
}
#else
#define set_LVDS_DIGTMDS_CRC_lvds_crc_sig_rgb(reg, lvds_crc_sig_rgb) (reg)->bitfields.LVDS_CRC_SIG_RGB = lvds_crc_sig_rgb
#define set_LVDS_DIGTMDS_CRC_lvds_crc_sig_c(reg, lvds_crc_sig_c) (reg)->bitfields.LVDS_CRC_SIG_C = lvds_crc_sig_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union LVDS_GEN_CNTL regLVDS_GEN_CNTL;

#ifdef DEBUG
__inline void set_LVDS_GEN_CNTL_lvds_on(regLVDS_GEN_CNTL *reg, unsigned int lvds_on)
{
  reg->bitfields.LVDS_ON = lvds_on;
  if (reg->bitfields.LVDS_ON != lvds_on) HSLDPF(E_ERROR_MESSAGE,"LVDS_GEN_CNTL::LVDS_ON data too large\n");
}
__inline void set_LVDS_GEN_CNTL_lvds_display_dis(regLVDS_GEN_CNTL *reg, unsigned int lvds_display_dis)
{
  reg->bitfields.LVDS_DISPLAY_DIS = lvds_display_dis;
  if (reg->bitfields.LVDS_DISPLAY_DIS != lvds_display_dis) HSLDPF(E_ERROR_MESSAGE,"LVDS_GEN_CNTL::LVDS_DISPLAY_DIS data too large\n");
}
__inline void set_LVDS_GEN_CNTL_lvds_panel_type(regLVDS_GEN_CNTL *reg, unsigned int lvds_panel_type)
{
  reg->bitfields.LVDS_PANEL_TYPE = lvds_panel_type;
  if (reg->bitfields.LVDS_PANEL_TYPE != lvds_panel_type) HSLDPF(E_ERROR_MESSAGE,"LVDS_GEN_CNTL::LVDS_PANEL_TYPE data too large\n");
}
__inline void set_LVDS_GEN_CNTL_lvds_panel_format(regLVDS_GEN_CNTL *reg, unsigned int lvds_panel_format)
{
  reg->bitfields.LVDS_PANEL_FORMAT = lvds_panel_format;
  if (reg->bitfields.LVDS_PANEL_FORMAT != lvds_panel_format) HSLDPF(E_ERROR_MESSAGE,"LVDS_GEN_CNTL::LVDS_PANEL_FORMAT data too large\n");
}
__inline void set_LVDS_GEN_CNTL_lvds_no_of_grey(regLVDS_GEN_CNTL *reg, unsigned int lvds_no_of_grey)
{
  reg->bitfields.LVDS_NO_OF_GREY = lvds_no_of_grey;
  if (reg->bitfields.LVDS_NO_OF_GREY != lvds_no_of_grey) HSLDPF(E_ERROR_MESSAGE,"LVDS_GEN_CNTL::LVDS_NO_OF_GREY data too large\n");
}
__inline void set_LVDS_GEN_CNTL_lvds_rst_fm(regLVDS_GEN_CNTL *reg, unsigned int lvds_rst_fm)
{
  reg->bitfields.LVDS_RST_FM = lvds_rst_fm;
  if (reg->bitfields.LVDS_RST_FM != lvds_rst_fm) HSLDPF(E_ERROR_MESSAGE,"LVDS_GEN_CNTL::LVDS_RST_FM data too large\n");
}
__inline void set_LVDS_GEN_CNTL_lvds_en(regLVDS_GEN_CNTL *reg, unsigned int lvds_en)
{
  reg->bitfields.LVDS_EN = lvds_en;
  if (reg->bitfields.LVDS_EN != lvds_en) HSLDPF(E_ERROR_MESSAGE,"LVDS_GEN_CNTL::LVDS_EN data too large\n");
}
__inline void set_LVDS_GEN_CNTL_lvds_bl_mod_level(regLVDS_GEN_CNTL *reg, unsigned int lvds_bl_mod_level)
{
  reg->bitfields.LVDS_BL_MOD_LEVEL = lvds_bl_mod_level;
  if (reg->bitfields.LVDS_BL_MOD_LEVEL != lvds_bl_mod_level) HSLDPF(E_ERROR_MESSAGE,"LVDS_GEN_CNTL::LVDS_BL_MOD_LEVEL data too large\n");
}
__inline void set_LVDS_GEN_CNTL_lvds_bl_mod_en(regLVDS_GEN_CNTL *reg, unsigned int lvds_bl_mod_en)
{
  reg->bitfields.LVDS_BL_MOD_EN = lvds_bl_mod_en;
  if (reg->bitfields.LVDS_BL_MOD_EN != lvds_bl_mod_en) HSLDPF(E_ERROR_MESSAGE,"LVDS_GEN_CNTL::LVDS_BL_MOD_EN data too large\n");
}
__inline void set_LVDS_GEN_CNTL_lvds_bl_clk_sel(regLVDS_GEN_CNTL *reg, unsigned int lvds_bl_clk_sel)
{
  reg->bitfields.LVDS_BL_CLK_SEL = lvds_bl_clk_sel;
  if (reg->bitfields.LVDS_BL_CLK_SEL != lvds_bl_clk_sel) HSLDPF(E_ERROR_MESSAGE,"LVDS_GEN_CNTL::LVDS_BL_CLK_SEL data too large\n");
}
__inline void set_LVDS_GEN_CNTL_lvds_digon(regLVDS_GEN_CNTL *reg, unsigned int lvds_digon)
{
  reg->bitfields.LVDS_DIGON = lvds_digon;
  if (reg->bitfields.LVDS_DIGON != lvds_digon) HSLDPF(E_ERROR_MESSAGE,"LVDS_GEN_CNTL::LVDS_DIGON data too large\n");
}
__inline void set_LVDS_GEN_CNTL_lvds_blon(regLVDS_GEN_CNTL *reg, unsigned int lvds_blon)
{
  reg->bitfields.LVDS_BLON = lvds_blon;
  if (reg->bitfields.LVDS_BLON != lvds_blon) HSLDPF(E_ERROR_MESSAGE,"LVDS_GEN_CNTL::LVDS_BLON data too large\n");
}
__inline void set_LVDS_GEN_CNTL_lvds_fp_pol(regLVDS_GEN_CNTL *reg, unsigned int lvds_fp_pol)
{
  reg->bitfields.LVDS_FP_POL = lvds_fp_pol;
  if (reg->bitfields.LVDS_FP_POL != lvds_fp_pol) HSLDPF(E_ERROR_MESSAGE,"LVDS_GEN_CNTL::LVDS_FP_POL data too large\n");
}
__inline void set_LVDS_GEN_CNTL_lvds_lp_pol(regLVDS_GEN_CNTL *reg, unsigned int lvds_lp_pol)
{
  reg->bitfields.LVDS_LP_POL = lvds_lp_pol;
  if (reg->bitfields.LVDS_LP_POL != lvds_lp_pol) HSLDPF(E_ERROR_MESSAGE,"LVDS_GEN_CNTL::LVDS_LP_POL data too large\n");
}
__inline void set_LVDS_GEN_CNTL_lvds_dtm_pol(regLVDS_GEN_CNTL *reg, unsigned int lvds_dtm_pol)
{
  reg->bitfields.LVDS_DTM_POL = lvds_dtm_pol;
  if (reg->bitfields.LVDS_DTM_POL != lvds_dtm_pol) HSLDPF(E_ERROR_MESSAGE,"LVDS_GEN_CNTL::LVDS_DTM_POL data too large\n");
}
__inline void set_LVDS_GEN_CNTL_lvds_src_sel(regLVDS_GEN_CNTL *reg, unsigned int lvds_src_sel)
{
  reg->bitfields.LVDS_SRC_SEL = lvds_src_sel;
  if (reg->bitfields.LVDS_SRC_SEL != lvds_src_sel) HSLDPF(E_ERROR_MESSAGE,"LVDS_GEN_CNTL::LVDS_SRC_SEL data too large\n");
}
__inline void set_LVDS_GEN_CNTL_lvds_reserved_bits(regLVDS_GEN_CNTL *reg, unsigned int lvds_reserved_bits)
{
  reg->bitfields.LVDS_RESERVED_BITS = lvds_reserved_bits;
  if (reg->bitfields.LVDS_RESERVED_BITS != lvds_reserved_bits) HSLDPF(E_ERROR_MESSAGE,"LVDS_GEN_CNTL::LVDS_RESERVED_BITS data too large\n");
}
__inline void set_LVDS_GEN_CNTL_lvds_fpdi_en(regLVDS_GEN_CNTL *reg, unsigned int lvds_fpdi_en)
{
  reg->bitfields.LVDS_FPDI_EN = lvds_fpdi_en;
  if (reg->bitfields.LVDS_FPDI_EN != lvds_fpdi_en) HSLDPF(E_ERROR_MESSAGE,"LVDS_GEN_CNTL::LVDS_FPDI_EN data too large\n");
}
__inline void set_LVDS_GEN_CNTL_lvds_hsync_delay(regLVDS_GEN_CNTL *reg, unsigned int lvds_hsync_delay)
{
  reg->bitfields.LVDS_HSYNC_DELAY = lvds_hsync_delay;
  if (reg->bitfields.LVDS_HSYNC_DELAY != lvds_hsync_delay) HSLDPF(E_ERROR_MESSAGE,"LVDS_GEN_CNTL::LVDS_HSYNC_DELAY data too large\n");
}
#else
#define set_LVDS_GEN_CNTL_lvds_on(reg, lvds_on) (reg)->bitfields.LVDS_ON = lvds_on
#define set_LVDS_GEN_CNTL_lvds_display_dis(reg, lvds_display_dis) (reg)->bitfields.LVDS_DISPLAY_DIS = lvds_display_dis
#define set_LVDS_GEN_CNTL_lvds_panel_type(reg, lvds_panel_type) (reg)->bitfields.LVDS_PANEL_TYPE = lvds_panel_type
#define set_LVDS_GEN_CNTL_lvds_panel_format(reg, lvds_panel_format) (reg)->bitfields.LVDS_PANEL_FORMAT = lvds_panel_format
#define set_LVDS_GEN_CNTL_lvds_no_of_grey(reg, lvds_no_of_grey) (reg)->bitfields.LVDS_NO_OF_GREY = lvds_no_of_grey
#define set_LVDS_GEN_CNTL_lvds_rst_fm(reg, lvds_rst_fm) (reg)->bitfields.LVDS_RST_FM = lvds_rst_fm
#define set_LVDS_GEN_CNTL_lvds_en(reg, lvds_en) (reg)->bitfields.LVDS_EN = lvds_en
#define set_LVDS_GEN_CNTL_lvds_bl_mod_level(reg, lvds_bl_mod_level) (reg)->bitfields.LVDS_BL_MOD_LEVEL = lvds_bl_mod_level
#define set_LVDS_GEN_CNTL_lvds_bl_mod_en(reg, lvds_bl_mod_en) (reg)->bitfields.LVDS_BL_MOD_EN = lvds_bl_mod_en
#define set_LVDS_GEN_CNTL_lvds_bl_clk_sel(reg, lvds_bl_clk_sel) (reg)->bitfields.LVDS_BL_CLK_SEL = lvds_bl_clk_sel
#define set_LVDS_GEN_CNTL_lvds_digon(reg, lvds_digon) (reg)->bitfields.LVDS_DIGON = lvds_digon
#define set_LVDS_GEN_CNTL_lvds_blon(reg, lvds_blon) (reg)->bitfields.LVDS_BLON = lvds_blon
#define set_LVDS_GEN_CNTL_lvds_fp_pol(reg, lvds_fp_pol) (reg)->bitfields.LVDS_FP_POL = lvds_fp_pol
#define set_LVDS_GEN_CNTL_lvds_lp_pol(reg, lvds_lp_pol) (reg)->bitfields.LVDS_LP_POL = lvds_lp_pol
#define set_LVDS_GEN_CNTL_lvds_dtm_pol(reg, lvds_dtm_pol) (reg)->bitfields.LVDS_DTM_POL = lvds_dtm_pol
#define set_LVDS_GEN_CNTL_lvds_src_sel(reg, lvds_src_sel) (reg)->bitfields.LVDS_SRC_SEL = lvds_src_sel
#define set_LVDS_GEN_CNTL_lvds_reserved_bits(reg, lvds_reserved_bits) (reg)->bitfields.LVDS_RESERVED_BITS = lvds_reserved_bits
#define set_LVDS_GEN_CNTL_lvds_fpdi_en(reg, lvds_fpdi_en) (reg)->bitfields.LVDS_FPDI_EN = lvds_fpdi_en
#define set_LVDS_GEN_CNTL_lvds_hsync_delay(reg, lvds_hsync_delay) (reg)->bitfields.LVDS_HSYNC_DELAY = lvds_hsync_delay

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union LVDS_PLL_CNTL regLVDS_PLL_CNTL;

#ifdef DEBUG
__inline void set_LVDS_PLL_CNTL_lvds_crc_de_only(regLVDS_PLL_CNTL *reg, unsigned int lvds_crc_de_only)
{
  reg->bitfields.LVDS_CRC_DE_ONLY = lvds_crc_de_only;
  if (reg->bitfields.LVDS_CRC_DE_ONLY != lvds_crc_de_only) HSLDPF(E_ERROR_MESSAGE,"LVDS_PLL_CNTL::LVDS_CRC_DE_ONLY data too large\n");
}
__inline void set_LVDS_PLL_CNTL_lvds_lvpvs(regLVDS_PLL_CNTL *reg, unsigned int lvds_lvpvs)
{
  reg->bitfields.LVDS_LVPVS = lvds_lvpvs;
  if (reg->bitfields.LVDS_LVPVS != lvds_lvpvs) HSLDPF(E_ERROR_MESSAGE,"LVDS_PLL_CNTL::LVDS_LVPVS data too large\n");
}
__inline void set_LVDS_PLL_CNTL_lvds_lppvg(regLVDS_PLL_CNTL *reg, unsigned int lvds_lppvg)
{
  reg->bitfields.LVDS_LPPVG = lvds_lppvg;
  if (reg->bitfields.LVDS_LPPVG != lvds_lppvg) HSLDPF(E_ERROR_MESSAGE,"LVDS_PLL_CNTL::LVDS_LPPVG data too large\n");
}
__inline void set_LVDS_PLL_CNTL_lvds_lppdc(regLVDS_PLL_CNTL *reg, unsigned int lvds_lppdc)
{
  reg->bitfields.LVDS_LPPDC = lvds_lppdc;
  if (reg->bitfields.LVDS_LPPDC != lvds_lppdc) HSLDPF(E_ERROR_MESSAGE,"LVDS_PLL_CNTL::LVDS_LPPDC data too large\n");
}
__inline void set_LVDS_PLL_CNTL_lvds_lppcp(regLVDS_PLL_CNTL *reg, unsigned int lvds_lppcp)
{
  reg->bitfields.LVDS_LPPCP = lvds_lppcp;
  if (reg->bitfields.LVDS_LPPCP != lvds_lppcp) HSLDPF(E_ERROR_MESSAGE,"LVDS_PLL_CNTL::LVDS_LPPCP data too large\n");
}
__inline void set_LVDS_PLL_CNTL_lvds_ss_disp_en(regLVDS_PLL_CNTL *reg, unsigned int lvds_ss_disp_en)
{
  reg->bitfields.LVDS_SS_DISP_EN = lvds_ss_disp_en;
  if (reg->bitfields.LVDS_SS_DISP_EN != lvds_ss_disp_en) HSLDPF(E_ERROR_MESSAGE,"LVDS_PLL_CNTL::LVDS_SS_DISP_EN data too large\n");
}
__inline void set_LVDS_PLL_CNTL_lvds_prg(regLVDS_PLL_CNTL *reg, unsigned int lvds_prg)
{
  reg->bitfields.LVDS_PRG = lvds_prg;
  if (reg->bitfields.LVDS_PRG != lvds_prg) HSLDPF(E_ERROR_MESSAGE,"LVDS_PLL_CNTL::LVDS_PRG data too large\n");
}
__inline void set_LVDS_PLL_CNTL_lvds_pll_en(regLVDS_PLL_CNTL *reg, unsigned int lvds_pll_en)
{
  reg->bitfields.LVDS_PLL_EN = lvds_pll_en;
  if (reg->bitfields.LVDS_PLL_EN != lvds_pll_en) HSLDPF(E_ERROR_MESSAGE,"LVDS_PLL_CNTL::LVDS_PLL_EN data too large\n");
}
__inline void set_LVDS_PLL_CNTL_lvds_pll_reset(regLVDS_PLL_CNTL *reg, unsigned int lvds_pll_reset)
{
  reg->bitfields.LVDS_PLL_RESET = lvds_pll_reset;
  if (reg->bitfields.LVDS_PLL_RESET != lvds_pll_reset) HSLDPF(E_ERROR_MESSAGE,"LVDS_PLL_CNTL::LVDS_PLL_RESET data too large\n");
}
__inline void set_LVDS_PLL_CNTL_lvds_preamph_en(regLVDS_PLL_CNTL *reg, unsigned int lvds_preamph_en)
{
  reg->bitfields.LVDS_PREAMPH_EN = lvds_preamph_en;
  if (reg->bitfields.LVDS_PREAMPH_EN != lvds_preamph_en) HSLDPF(E_ERROR_MESSAGE,"LVDS_PLL_CNTL::LVDS_PREAMPH_EN data too large\n");
}
__inline void set_LVDS_PLL_CNTL_lvds_crc_en(regLVDS_PLL_CNTL *reg, unsigned int lvds_crc_en)
{
  reg->bitfields.LVDS_CRC_EN = lvds_crc_en;
  if (reg->bitfields.LVDS_CRC_EN != lvds_crc_en) HSLDPF(E_ERROR_MESSAGE,"LVDS_PLL_CNTL::LVDS_CRC_EN data too large\n");
}
__inline void set_LVDS_PLL_CNTL_lvds_crc_up24(regLVDS_PLL_CNTL *reg, unsigned int lvds_crc_up24)
{
  reg->bitfields.LVDS_CRC_UP24 = lvds_crc_up24;
  if (reg->bitfields.LVDS_CRC_UP24 != lvds_crc_up24) HSLDPF(E_ERROR_MESSAGE,"LVDS_PLL_CNTL::LVDS_CRC_UP24 data too large\n");
}
__inline void set_LVDS_PLL_CNTL_lvds_test_data_out(regLVDS_PLL_CNTL *reg, unsigned int lvds_test_data_out)
{
  reg->bitfields.LVDS_TEST_DATA_OUT = lvds_test_data_out;
  if (reg->bitfields.LVDS_TEST_DATA_OUT != lvds_test_data_out) HSLDPF(E_ERROR_MESSAGE,"LVDS_PLL_CNTL::LVDS_TEST_DATA_OUT data too large\n");
}
__inline void set_LVDS_PLL_CNTL_lvds_test_data_sel(regLVDS_PLL_CNTL *reg, unsigned int lvds_test_data_sel)
{
  reg->bitfields.LVDS_TEST_DATA_SEL = lvds_test_data_sel;
  if (reg->bitfields.LVDS_TEST_DATA_SEL != lvds_test_data_sel) HSLDPF(E_ERROR_MESSAGE,"LVDS_PLL_CNTL::LVDS_TEST_DATA_SEL data too large\n");
}
__inline void set_LVDS_PLL_CNTL_lcdeng_test_mode(regLVDS_PLL_CNTL *reg, unsigned int lcdeng_test_mode)
{
  reg->bitfields.LCDENG_TEST_MODE = lcdeng_test_mode;
  if (reg->bitfields.LCDENG_TEST_MODE != lcdeng_test_mode) HSLDPF(E_ERROR_MESSAGE,"LVDS_PLL_CNTL::LCDENG_TEST_MODE data too large\n");
}
#else
#define set_LVDS_PLL_CNTL_lvds_crc_de_only(reg, lvds_crc_de_only) (reg)->bitfields.LVDS_CRC_DE_ONLY = lvds_crc_de_only
#define set_LVDS_PLL_CNTL_lvds_lvpvs(reg, lvds_lvpvs) (reg)->bitfields.LVDS_LVPVS = lvds_lvpvs
#define set_LVDS_PLL_CNTL_lvds_lppvg(reg, lvds_lppvg) (reg)->bitfields.LVDS_LPPVG = lvds_lppvg
#define set_LVDS_PLL_CNTL_lvds_lppdc(reg, lvds_lppdc) (reg)->bitfields.LVDS_LPPDC = lvds_lppdc
#define set_LVDS_PLL_CNTL_lvds_lppcp(reg, lvds_lppcp) (reg)->bitfields.LVDS_LPPCP = lvds_lppcp
#define set_LVDS_PLL_CNTL_lvds_ss_disp_en(reg, lvds_ss_disp_en) (reg)->bitfields.LVDS_SS_DISP_EN = lvds_ss_disp_en
#define set_LVDS_PLL_CNTL_lvds_prg(reg, lvds_prg) (reg)->bitfields.LVDS_PRG = lvds_prg
#define set_LVDS_PLL_CNTL_lvds_pll_en(reg, lvds_pll_en) (reg)->bitfields.LVDS_PLL_EN = lvds_pll_en
#define set_LVDS_PLL_CNTL_lvds_pll_reset(reg, lvds_pll_reset) (reg)->bitfields.LVDS_PLL_RESET = lvds_pll_reset
#define set_LVDS_PLL_CNTL_lvds_preamph_en(reg, lvds_preamph_en) (reg)->bitfields.LVDS_PREAMPH_EN = lvds_preamph_en
#define set_LVDS_PLL_CNTL_lvds_crc_en(reg, lvds_crc_en) (reg)->bitfields.LVDS_CRC_EN = lvds_crc_en
#define set_LVDS_PLL_CNTL_lvds_crc_up24(reg, lvds_crc_up24) (reg)->bitfields.LVDS_CRC_UP24 = lvds_crc_up24
#define set_LVDS_PLL_CNTL_lvds_test_data_out(reg, lvds_test_data_out) (reg)->bitfields.LVDS_TEST_DATA_OUT = lvds_test_data_out
#define set_LVDS_PLL_CNTL_lvds_test_data_sel(reg, lvds_test_data_sel) (reg)->bitfields.LVDS_TEST_DATA_SEL = lvds_test_data_sel
#define set_LVDS_PLL_CNTL_lcdeng_test_mode(reg, lcdeng_test_mode) (reg)->bitfields.LCDENG_TEST_MODE = lcdeng_test_mode

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250AUX_WINDOW_HORZ_CNTL regrv250AUX_WINDOW_HORZ_CNTL;

#ifdef DEBUG
__inline void set_rv250AUX_WINDOW_HORZ_CNTL_aux_win_horz_start(regrv250AUX_WINDOW_HORZ_CNTL *reg, unsigned int aux_win_horz_start)
{
  reg->bitfields.AUX_WIN_HORZ_START = aux_win_horz_start;
  if (reg->bitfields.AUX_WIN_HORZ_START != aux_win_horz_start) HSLDPF(E_ERROR_MESSAGE,"rv250AUX_WINDOW_HORZ_CNTL::AUX_WIN_HORZ_START data too large\n");
}
__inline void set_rv250AUX_WINDOW_HORZ_CNTL_aux_win_horz_end(regrv250AUX_WINDOW_HORZ_CNTL *reg, unsigned int aux_win_horz_end)
{
  reg->bitfields.AUX_WIN_HORZ_END = aux_win_horz_end;
  if (reg->bitfields.AUX_WIN_HORZ_END != aux_win_horz_end) HSLDPF(E_ERROR_MESSAGE,"rv250AUX_WINDOW_HORZ_CNTL::AUX_WIN_HORZ_END data too large\n");
}
__inline void set_rv250AUX_WINDOW_HORZ_CNTL_aux_win_en(regrv250AUX_WINDOW_HORZ_CNTL *reg, unsigned int aux_win_en)
{
  reg->bitfields.AUX_WIN_EN = aux_win_en;
  if (reg->bitfields.AUX_WIN_EN != aux_win_en) HSLDPF(E_ERROR_MESSAGE,"rv250AUX_WINDOW_HORZ_CNTL::AUX_WIN_EN data too large\n");
}
__inline void set_rv250AUX_WINDOW_HORZ_CNTL_aux_win_out_delay(regrv250AUX_WINDOW_HORZ_CNTL *reg, unsigned int aux_win_out_delay)
{
  reg->bitfields.AUX_WIN_OUT_DELAY = aux_win_out_delay;
  if (reg->bitfields.AUX_WIN_OUT_DELAY != aux_win_out_delay) HSLDPF(E_ERROR_MESSAGE,"rv250AUX_WINDOW_HORZ_CNTL::AUX_WIN_OUT_DELAY data too large\n");
}
__inline void set_rv250AUX_WINDOW_HORZ_CNTL_reserved(regrv250AUX_WINDOW_HORZ_CNTL *reg, unsigned int reserved)
{
  reg->bitfields.RESERVED = reserved;
  if (reg->bitfields.RESERVED != reserved) HSLDPF(E_ERROR_MESSAGE,"rv250AUX_WINDOW_HORZ_CNTL::RESERVED data too large\n");
}
__inline void set_rv250AUX_WINDOW_HORZ_CNTL_aux_win_lock(regrv250AUX_WINDOW_HORZ_CNTL *reg, unsigned int aux_win_lock)
{
  reg->bitfields.AUX_WIN_LOCK = aux_win_lock;
  if (reg->bitfields.AUX_WIN_LOCK != aux_win_lock) HSLDPF(E_ERROR_MESSAGE,"rv250AUX_WINDOW_HORZ_CNTL::AUX_WIN_LOCK data too large\n");
}
#else
#define set_rv250AUX_WINDOW_HORZ_CNTL_aux_win_horz_start(reg, aux_win_horz_start) (reg)->bitfields.AUX_WIN_HORZ_START = aux_win_horz_start
#define set_rv250AUX_WINDOW_HORZ_CNTL_aux_win_horz_end(reg, aux_win_horz_end) (reg)->bitfields.AUX_WIN_HORZ_END = aux_win_horz_end
#define set_rv250AUX_WINDOW_HORZ_CNTL_aux_win_en(reg, aux_win_en) (reg)->bitfields.AUX_WIN_EN = aux_win_en
#define set_rv250AUX_WINDOW_HORZ_CNTL_aux_win_out_delay(reg, aux_win_out_delay) (reg)->bitfields.AUX_WIN_OUT_DELAY = aux_win_out_delay
#define set_rv250AUX_WINDOW_HORZ_CNTL_reserved(reg, reserved) (reg)->bitfields.RESERVED = reserved
#define set_rv250AUX_WINDOW_HORZ_CNTL_aux_win_lock(reg, aux_win_lock) (reg)->bitfields.AUX_WIN_LOCK = aux_win_lock

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union AUX_WINDOW_VERT_CNTL regAUX_WINDOW_VERT_CNTL;

#ifdef DEBUG
__inline void set_AUX_WINDOW_VERT_CNTL_aux_win_vert_start(regAUX_WINDOW_VERT_CNTL *reg, unsigned int aux_win_vert_start)
{
  reg->bitfields.AUX_WIN_VERT_START = aux_win_vert_start;
  if (reg->bitfields.AUX_WIN_VERT_START != aux_win_vert_start) HSLDPF(E_ERROR_MESSAGE,"AUX_WINDOW_VERT_CNTL::AUX_WIN_VERT_START data too large\n");
}
__inline void set_AUX_WINDOW_VERT_CNTL_aux_win_vert_end(regAUX_WINDOW_VERT_CNTL *reg, unsigned int aux_win_vert_end)
{
  reg->bitfields.AUX_WIN_VERT_END = aux_win_vert_end;
  if (reg->bitfields.AUX_WIN_VERT_END != aux_win_vert_end) HSLDPF(E_ERROR_MESSAGE,"AUX_WINDOW_VERT_CNTL::AUX_WIN_VERT_END data too large\n");
}
__inline void set_AUX_WINDOW_VERT_CNTL_aux_window_pol(regAUX_WINDOW_VERT_CNTL *reg, unsigned int aux_window_pol)
{
  reg->bitfields.AUX_WINDOW_POL = aux_window_pol;
  if (reg->bitfields.AUX_WINDOW_POL != aux_window_pol) HSLDPF(E_ERROR_MESSAGE,"AUX_WINDOW_VERT_CNTL::AUX_WINDOW_POL data too large\n");
}
__inline void set_AUX_WINDOW_VERT_CNTL_aux_win_lock(regAUX_WINDOW_VERT_CNTL *reg, unsigned int aux_win_lock)
{
  reg->bitfields.AUX_WIN_LOCK = aux_win_lock;
  if (reg->bitfields.AUX_WIN_LOCK != aux_win_lock) HSLDPF(E_ERROR_MESSAGE,"AUX_WINDOW_VERT_CNTL::AUX_WIN_LOCK data too large\n");
}
#else
#define set_AUX_WINDOW_VERT_CNTL_aux_win_vert_start(reg, aux_win_vert_start) (reg)->bitfields.AUX_WIN_VERT_START = aux_win_vert_start
#define set_AUX_WINDOW_VERT_CNTL_aux_win_vert_end(reg, aux_win_vert_end) (reg)->bitfields.AUX_WIN_VERT_END = aux_win_vert_end
#define set_AUX_WINDOW_VERT_CNTL_aux_window_pol(reg, aux_window_pol) (reg)->bitfields.AUX_WINDOW_POL = aux_window_pol
#define set_AUX_WINDOW_VERT_CNTL_aux_win_lock(reg, aux_win_lock) (reg)->bitfields.AUX_WIN_LOCK = aux_win_lock

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250DVI_I2C_CNTL_0 regrv250DVI_I2C_CNTL_0;

#ifdef DEBUG
__inline void set_rv250DVI_I2C_CNTL_0_i2c_done(regrv250DVI_I2C_CNTL_0 *reg, unsigned int i2c_done)
{
  reg->bitfields.I2C_DONE = i2c_done;
  if (reg->bitfields.I2C_DONE != i2c_done) HSLDPF(E_ERROR_MESSAGE,"rv250DVI_I2C_CNTL_0::I2C_DONE data too large\n");
}
__inline void set_rv250DVI_I2C_CNTL_0_i2c_nack(regrv250DVI_I2C_CNTL_0 *reg, unsigned int i2c_nack)
{
  reg->bitfields.I2C_NACK = i2c_nack;
  if (reg->bitfields.I2C_NACK != i2c_nack) HSLDPF(E_ERROR_MESSAGE,"rv250DVI_I2C_CNTL_0::I2C_NACK data too large\n");
}
__inline void set_rv250DVI_I2C_CNTL_0_i2c_halt(regrv250DVI_I2C_CNTL_0 *reg, unsigned int i2c_halt)
{
  reg->bitfields.I2C_HALT = i2c_halt;
  if (reg->bitfields.I2C_HALT != i2c_halt) HSLDPF(E_ERROR_MESSAGE,"rv250DVI_I2C_CNTL_0::I2C_HALT data too large\n");
}
__inline void set_rv250DVI_I2C_CNTL_0_dvi_i2c_pin_sel(regrv250DVI_I2C_CNTL_0 *reg, unsigned int dvi_i2c_pin_sel)
{
  reg->bitfields.DVI_I2C_PIN_SEL = dvi_i2c_pin_sel;
  if (reg->bitfields.DVI_I2C_PIN_SEL != dvi_i2c_pin_sel) HSLDPF(E_ERROR_MESSAGE,"rv250DVI_I2C_CNTL_0::DVI_I2C_PIN_SEL data too large\n");
}
__inline void set_rv250DVI_I2C_CNTL_0_i2c_soft_rst(regrv250DVI_I2C_CNTL_0 *reg, unsigned int i2c_soft_rst)
{
  reg->bitfields.I2C_SOFT_RST = i2c_soft_rst;
  if (reg->bitfields.I2C_SOFT_RST != i2c_soft_rst) HSLDPF(E_ERROR_MESSAGE,"rv250DVI_I2C_CNTL_0::I2C_SOFT_RST data too large\n");
}
__inline void set_rv250DVI_I2C_CNTL_0_i2c_drive_en(regrv250DVI_I2C_CNTL_0 *reg, unsigned int i2c_drive_en)
{
  reg->bitfields.I2C_DRIVE_EN = i2c_drive_en;
  if (reg->bitfields.I2C_DRIVE_EN != i2c_drive_en) HSLDPF(E_ERROR_MESSAGE,"rv250DVI_I2C_CNTL_0::I2C_DRIVE_EN data too large\n");
}
__inline void set_rv250DVI_I2C_CNTL_0_i2c_drive_sel(regrv250DVI_I2C_CNTL_0 *reg, unsigned int i2c_drive_sel)
{
  reg->bitfields.I2C_DRIVE_SEL = i2c_drive_sel;
  if (reg->bitfields.I2C_DRIVE_SEL != i2c_drive_sel) HSLDPF(E_ERROR_MESSAGE,"rv250DVI_I2C_CNTL_0::I2C_DRIVE_SEL data too large\n");
}
__inline void set_rv250DVI_I2C_CNTL_0_i2c_start(regrv250DVI_I2C_CNTL_0 *reg, unsigned int i2c_start)
{
  reg->bitfields.I2C_START = i2c_start;
  if (reg->bitfields.I2C_START != i2c_start) HSLDPF(E_ERROR_MESSAGE,"rv250DVI_I2C_CNTL_0::I2C_START data too large\n");
}
__inline void set_rv250DVI_I2C_CNTL_0_i2c_stop(regrv250DVI_I2C_CNTL_0 *reg, unsigned int i2c_stop)
{
  reg->bitfields.I2C_STOP = i2c_stop;
  if (reg->bitfields.I2C_STOP != i2c_stop) HSLDPF(E_ERROR_MESSAGE,"rv250DVI_I2C_CNTL_0::I2C_STOP data too large\n");
}
__inline void set_rv250DVI_I2C_CNTL_0_i2c_receive(regrv250DVI_I2C_CNTL_0 *reg, unsigned int i2c_receive)
{
  reg->bitfields.I2C_RECEIVE = i2c_receive;
  if (reg->bitfields.I2C_RECEIVE != i2c_receive) HSLDPF(E_ERROR_MESSAGE,"rv250DVI_I2C_CNTL_0::I2C_RECEIVE data too large\n");
}
__inline void set_rv250DVI_I2C_CNTL_0_i2c_abort(regrv250DVI_I2C_CNTL_0 *reg, unsigned int i2c_abort)
{
  reg->bitfields.I2C_ABORT = i2c_abort;
  if (reg->bitfields.I2C_ABORT != i2c_abort) HSLDPF(E_ERROR_MESSAGE,"rv250DVI_I2C_CNTL_0::I2C_ABORT data too large\n");
}
__inline void set_rv250DVI_I2C_CNTL_0_i2c_go(regrv250DVI_I2C_CNTL_0 *reg, unsigned int i2c_go)
{
  reg->bitfields.I2C_GO = i2c_go;
  if (reg->bitfields.I2C_GO != i2c_go) HSLDPF(E_ERROR_MESSAGE,"rv250DVI_I2C_CNTL_0::I2C_GO data too large\n");
}
__inline void set_rv250DVI_I2C_CNTL_0_sw_wants_to_use_dvi_i2c(regrv250DVI_I2C_CNTL_0 *reg, unsigned int sw_wants_to_use_dvi_i2c)
{
  reg->bitfields.SW_WANTS_TO_USE_DVI_I2C = sw_wants_to_use_dvi_i2c;
  if (reg->bitfields.SW_WANTS_TO_USE_DVI_I2C != sw_wants_to_use_dvi_i2c) HSLDPF(E_ERROR_MESSAGE,"rv250DVI_I2C_CNTL_0::SW_WANTS_TO_USE_DVI_I2C data too large\n");
}
__inline void set_rv250DVI_I2C_CNTL_0_sw_done_using_dvi_i2c(regrv250DVI_I2C_CNTL_0 *reg, unsigned int sw_done_using_dvi_i2c)
{
  reg->bitfields.SW_DONE_USING_DVI_I2C = sw_done_using_dvi_i2c;
  if (reg->bitfields.SW_DONE_USING_DVI_I2C != sw_done_using_dvi_i2c) HSLDPF(E_ERROR_MESSAGE,"rv250DVI_I2C_CNTL_0::SW_DONE_USING_DVI_I2C data too large\n");
}
__inline void set_rv250DVI_I2C_CNTL_0_abort_hw_dvi_i2c(regrv250DVI_I2C_CNTL_0 *reg, unsigned int abort_hw_dvi_i2c)
{
  reg->bitfields.ABORT_HW_DVI_I2C = abort_hw_dvi_i2c;
  if (reg->bitfields.ABORT_HW_DVI_I2C != abort_hw_dvi_i2c) HSLDPF(E_ERROR_MESSAGE,"rv250DVI_I2C_CNTL_0::ABORT_HW_DVI_I2C data too large\n");
}
__inline void set_rv250DVI_I2C_CNTL_0_i2c_prescale(regrv250DVI_I2C_CNTL_0 *reg, unsigned int i2c_prescale)
{
  reg->bitfields.I2C_PRESCALE = i2c_prescale;
  if (reg->bitfields.I2C_PRESCALE != i2c_prescale) HSLDPF(E_ERROR_MESSAGE,"rv250DVI_I2C_CNTL_0::I2C_PRESCALE data too large\n");
}
#else
#define set_rv250DVI_I2C_CNTL_0_i2c_done(reg, i2c_done) (reg)->bitfields.I2C_DONE = i2c_done
#define set_rv250DVI_I2C_CNTL_0_i2c_nack(reg, i2c_nack) (reg)->bitfields.I2C_NACK = i2c_nack
#define set_rv250DVI_I2C_CNTL_0_i2c_halt(reg, i2c_halt) (reg)->bitfields.I2C_HALT = i2c_halt
#define set_rv250DVI_I2C_CNTL_0_dvi_i2c_pin_sel(reg, dvi_i2c_pin_sel) (reg)->bitfields.DVI_I2C_PIN_SEL = dvi_i2c_pin_sel
#define set_rv250DVI_I2C_CNTL_0_i2c_soft_rst(reg, i2c_soft_rst) (reg)->bitfields.I2C_SOFT_RST = i2c_soft_rst
#define set_rv250DVI_I2C_CNTL_0_i2c_drive_en(reg, i2c_drive_en) (reg)->bitfields.I2C_DRIVE_EN = i2c_drive_en
#define set_rv250DVI_I2C_CNTL_0_i2c_drive_sel(reg, i2c_drive_sel) (reg)->bitfields.I2C_DRIVE_SEL = i2c_drive_sel
#define set_rv250DVI_I2C_CNTL_0_i2c_start(reg, i2c_start) (reg)->bitfields.I2C_START = i2c_start
#define set_rv250DVI_I2C_CNTL_0_i2c_stop(reg, i2c_stop) (reg)->bitfields.I2C_STOP = i2c_stop
#define set_rv250DVI_I2C_CNTL_0_i2c_receive(reg, i2c_receive) (reg)->bitfields.I2C_RECEIVE = i2c_receive
#define set_rv250DVI_I2C_CNTL_0_i2c_abort(reg, i2c_abort) (reg)->bitfields.I2C_ABORT = i2c_abort
#define set_rv250DVI_I2C_CNTL_0_i2c_go(reg, i2c_go) (reg)->bitfields.I2C_GO = i2c_go
#define set_rv250DVI_I2C_CNTL_0_sw_wants_to_use_dvi_i2c(reg, sw_wants_to_use_dvi_i2c) (reg)->bitfields.SW_WANTS_TO_USE_DVI_I2C = sw_wants_to_use_dvi_i2c
#define set_rv250DVI_I2C_CNTL_0_sw_done_using_dvi_i2c(reg, sw_done_using_dvi_i2c) (reg)->bitfields.SW_DONE_USING_DVI_I2C = sw_done_using_dvi_i2c
#define set_rv250DVI_I2C_CNTL_0_abort_hw_dvi_i2c(reg, abort_hw_dvi_i2c) (reg)->bitfields.ABORT_HW_DVI_I2C = abort_hw_dvi_i2c
#define set_rv250DVI_I2C_CNTL_0_i2c_prescale(reg, i2c_prescale) (reg)->bitfields.I2C_PRESCALE = i2c_prescale

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250DVI_I2C_CNTL_1 regrv250DVI_I2C_CNTL_1;

#ifdef DEBUG
__inline void set_rv250DVI_I2C_CNTL_1_i2c_data_count(regrv250DVI_I2C_CNTL_1 *reg, unsigned int i2c_data_count)
{
  reg->bitfields.I2C_DATA_COUNT = i2c_data_count;
  if (reg->bitfields.I2C_DATA_COUNT != i2c_data_count) HSLDPF(E_ERROR_MESSAGE,"rv250DVI_I2C_CNTL_1::I2C_DATA_COUNT data too large\n");
}
__inline void set_rv250DVI_I2C_CNTL_1_i2c_addr_count(regrv250DVI_I2C_CNTL_1 *reg, unsigned int i2c_addr_count)
{
  reg->bitfields.I2C_ADDR_COUNT = i2c_addr_count;
  if (reg->bitfields.I2C_ADDR_COUNT != i2c_addr_count) HSLDPF(E_ERROR_MESSAGE,"rv250DVI_I2C_CNTL_1::I2C_ADDR_COUNT data too large\n");
}
__inline void set_rv250DVI_I2C_CNTL_1_i2c_sel(regrv250DVI_I2C_CNTL_1 *reg, unsigned int i2c_sel)
{
  reg->bitfields.I2C_SEL = i2c_sel;
  if (reg->bitfields.I2C_SEL != i2c_sel) HSLDPF(E_ERROR_MESSAGE,"rv250DVI_I2C_CNTL_1::I2C_SEL data too large\n");
}
__inline void set_rv250DVI_I2C_CNTL_1_i2c_en(regrv250DVI_I2C_CNTL_1 *reg, unsigned int i2c_en)
{
  reg->bitfields.I2C_EN = i2c_en;
  if (reg->bitfields.I2C_EN != i2c_en) HSLDPF(E_ERROR_MESSAGE,"rv250DVI_I2C_CNTL_1::I2C_EN data too large\n");
}
__inline void set_rv250DVI_I2C_CNTL_1_i2c_time_limit(regrv250DVI_I2C_CNTL_1 *reg, unsigned int i2c_time_limit)
{
  reg->bitfields.I2C_TIME_LIMIT = i2c_time_limit;
  if (reg->bitfields.I2C_TIME_LIMIT != i2c_time_limit) HSLDPF(E_ERROR_MESSAGE,"rv250DVI_I2C_CNTL_1::I2C_TIME_LIMIT data too large\n");
}
#else
#define set_rv250DVI_I2C_CNTL_1_i2c_data_count(reg, i2c_data_count) (reg)->bitfields.I2C_DATA_COUNT = i2c_data_count
#define set_rv250DVI_I2C_CNTL_1_i2c_addr_count(reg, i2c_addr_count) (reg)->bitfields.I2C_ADDR_COUNT = i2c_addr_count
#define set_rv250DVI_I2C_CNTL_1_i2c_sel(reg, i2c_sel) (reg)->bitfields.I2C_SEL = i2c_sel
#define set_rv250DVI_I2C_CNTL_1_i2c_en(reg, i2c_en) (reg)->bitfields.I2C_EN = i2c_en
#define set_rv250DVI_I2C_CNTL_1_i2c_time_limit(reg, i2c_time_limit) (reg)->bitfields.I2C_TIME_LIMIT = i2c_time_limit

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DVI_I2C_DATA regDVI_I2C_DATA;

#ifdef DEBUG
__inline void set_DVI_I2C_DATA_i2c_data(regDVI_I2C_DATA *reg, unsigned int i2c_data)
{
  reg->bitfields.I2C_DATA = i2c_data;
  if (reg->bitfields.I2C_DATA != i2c_data) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_DATA::I2C_DATA data too large\n");
}
#else
#define set_DVI_I2C_DATA_i2c_data(reg, i2c_data) (reg)->bitfields.I2C_DATA = i2c_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union LVDS_SS_GEN_CNTL regLVDS_SS_GEN_CNTL;

#ifdef DEBUG
__inline void set_LVDS_SS_GEN_CNTL_ss_ext_en(regLVDS_SS_GEN_CNTL *reg, unsigned int ss_ext_en)
{
  reg->bitfields.SS_EXT_EN = ss_ext_en;
  if (reg->bitfields.SS_EXT_EN != ss_ext_en) HSLDPF(E_ERROR_MESSAGE,"LVDS_SS_GEN_CNTL::SS_EXT_EN data too large\n");
}
__inline void set_LVDS_SS_GEN_CNTL_ss_ext_sel(regLVDS_SS_GEN_CNTL *reg, unsigned int ss_ext_sel)
{
  reg->bitfields.SS_EXT_SEL = ss_ext_sel;
  if (reg->bitfields.SS_EXT_SEL != ss_ext_sel) HSLDPF(E_ERROR_MESSAGE,"LVDS_SS_GEN_CNTL::SS_EXT_SEL data too large\n");
}
__inline void set_LVDS_SS_GEN_CNTL_ss_buf_en(regLVDS_SS_GEN_CNTL *reg, unsigned int ss_buf_en)
{
  reg->bitfields.SS_BUF_EN = ss_buf_en;
  if (reg->bitfields.SS_BUF_EN != ss_buf_en) HSLDPF(E_ERROR_MESSAGE,"LVDS_SS_GEN_CNTL::SS_BUF_EN data too large\n");
}
__inline void set_LVDS_SS_GEN_CNTL_ss_buf_offset(regLVDS_SS_GEN_CNTL *reg, unsigned int ss_buf_offset)
{
  reg->bitfields.SS_BUF_OFFSET = ss_buf_offset;
  if (reg->bitfields.SS_BUF_OFFSET != ss_buf_offset) HSLDPF(E_ERROR_MESSAGE,"LVDS_SS_GEN_CNTL::SS_BUF_OFFSET data too large\n");
}
__inline void set_LVDS_SS_GEN_CNTL_ss_buf_reset_en(regLVDS_SS_GEN_CNTL *reg, unsigned int ss_buf_reset_en)
{
  reg->bitfields.SS_BUF_RESET_EN = ss_buf_reset_en;
  if (reg->bitfields.SS_BUF_RESET_EN != ss_buf_reset_en) HSLDPF(E_ERROR_MESSAGE,"LVDS_SS_GEN_CNTL::SS_BUF_RESET_EN data too large\n");
}
__inline void set_LVDS_SS_GEN_CNTL_ss_buf_strength(regLVDS_SS_GEN_CNTL *reg, unsigned int ss_buf_strength)
{
  reg->bitfields.SS_BUF_STRENGTH = ss_buf_strength;
  if (reg->bitfields.SS_BUF_STRENGTH != ss_buf_strength) HSLDPF(E_ERROR_MESSAGE,"LVDS_SS_GEN_CNTL::SS_BUF_STRENGTH data too large\n");
}
__inline void set_LVDS_SS_GEN_CNTL_lvdspwr_strength(regLVDS_SS_GEN_CNTL *reg, unsigned int lvdspwr_strength)
{
  reg->bitfields.LVDSPWR_STRENGTH = lvdspwr_strength;
  if (reg->bitfields.LVDSPWR_STRENGTH != lvdspwr_strength) HSLDPF(E_ERROR_MESSAGE,"LVDS_SS_GEN_CNTL::LVDSPWR_STRENGTH data too large\n");
}
__inline void set_LVDS_SS_GEN_CNTL_lvds_pwrseq_delay1(regLVDS_SS_GEN_CNTL *reg, unsigned int lvds_pwrseq_delay1)
{
  reg->bitfields.LVDS_PWRSEQ_DELAY1 = lvds_pwrseq_delay1;
  if (reg->bitfields.LVDS_PWRSEQ_DELAY1 != lvds_pwrseq_delay1) HSLDPF(E_ERROR_MESSAGE,"LVDS_SS_GEN_CNTL::LVDS_PWRSEQ_DELAY1 data too large\n");
}
__inline void set_LVDS_SS_GEN_CNTL_lvds_pwrseq_delay2(regLVDS_SS_GEN_CNTL *reg, unsigned int lvds_pwrseq_delay2)
{
  reg->bitfields.LVDS_PWRSEQ_DELAY2 = lvds_pwrseq_delay2;
  if (reg->bitfields.LVDS_PWRSEQ_DELAY2 != lvds_pwrseq_delay2) HSLDPF(E_ERROR_MESSAGE,"LVDS_SS_GEN_CNTL::LVDS_PWRSEQ_DELAY2 data too large\n");
}
__inline void set_LVDS_SS_GEN_CNTL_lvds_clk_pattern(regLVDS_SS_GEN_CNTL *reg, unsigned int lvds_clk_pattern)
{
  reg->bitfields.LVDS_CLK_PATTERN = lvds_clk_pattern;
  if (reg->bitfields.LVDS_CLK_PATTERN != lvds_clk_pattern) HSLDPF(E_ERROR_MESSAGE,"LVDS_SS_GEN_CNTL::LVDS_CLK_PATTERN data too large\n");
}
#else
#define set_LVDS_SS_GEN_CNTL_ss_ext_en(reg, ss_ext_en) (reg)->bitfields.SS_EXT_EN = ss_ext_en
#define set_LVDS_SS_GEN_CNTL_ss_ext_sel(reg, ss_ext_sel) (reg)->bitfields.SS_EXT_SEL = ss_ext_sel
#define set_LVDS_SS_GEN_CNTL_ss_buf_en(reg, ss_buf_en) (reg)->bitfields.SS_BUF_EN = ss_buf_en
#define set_LVDS_SS_GEN_CNTL_ss_buf_offset(reg, ss_buf_offset) (reg)->bitfields.SS_BUF_OFFSET = ss_buf_offset
#define set_LVDS_SS_GEN_CNTL_ss_buf_reset_en(reg, ss_buf_reset_en) (reg)->bitfields.SS_BUF_RESET_EN = ss_buf_reset_en
#define set_LVDS_SS_GEN_CNTL_ss_buf_strength(reg, ss_buf_strength) (reg)->bitfields.SS_BUF_STRENGTH = ss_buf_strength
#define set_LVDS_SS_GEN_CNTL_lvdspwr_strength(reg, lvdspwr_strength) (reg)->bitfields.LVDSPWR_STRENGTH = lvdspwr_strength
#define set_LVDS_SS_GEN_CNTL_lvds_pwrseq_delay1(reg, lvds_pwrseq_delay1) (reg)->bitfields.LVDS_PWRSEQ_DELAY1 = lvds_pwrseq_delay1
#define set_LVDS_SS_GEN_CNTL_lvds_pwrseq_delay2(reg, lvds_pwrseq_delay2) (reg)->bitfields.LVDS_PWRSEQ_DELAY2 = lvds_pwrseq_delay2
#define set_LVDS_SS_GEN_CNTL_lvds_clk_pattern(reg, lvds_clk_pattern) (reg)->bitfields.LVDS_CLK_PATTERN = lvds_clk_pattern

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GRPH_BUFFER_CNTL_M6 regGRPH_BUFFER_CNTL_M6;

#ifdef DEBUG
__inline void set_GRPH_BUFFER_CNTL_M6_grph_start_req(regGRPH_BUFFER_CNTL_M6 *reg, unsigned int grph_start_req)
{
  reg->bitfields.GRPH_START_REQ = grph_start_req;
  if (reg->bitfields.GRPH_START_REQ != grph_start_req) HSLDPF(E_ERROR_MESSAGE,"GRPH_BUFFER_CNTL_M6::GRPH_START_REQ data too large\n");
}
__inline void set_GRPH_BUFFER_CNTL_M6_grph_stop_req(regGRPH_BUFFER_CNTL_M6 *reg, unsigned int grph_stop_req)
{
  reg->bitfields.GRPH_STOP_REQ = grph_stop_req;
  if (reg->bitfields.GRPH_STOP_REQ != grph_stop_req) HSLDPF(E_ERROR_MESSAGE,"GRPH_BUFFER_CNTL_M6::GRPH_STOP_REQ data too large\n");
}
__inline void set_GRPH_BUFFER_CNTL_M6_grph_critical_point(regGRPH_BUFFER_CNTL_M6 *reg, unsigned int grph_critical_point)
{
  reg->bitfields.GRPH_CRITICAL_POINT = grph_critical_point;
  if (reg->bitfields.GRPH_CRITICAL_POINT != grph_critical_point) HSLDPF(E_ERROR_MESSAGE,"GRPH_BUFFER_CNTL_M6::GRPH_CRITICAL_POINT data too large\n");
}
__inline void set_GRPH_BUFFER_CNTL_M6_grph_critical_cntl(regGRPH_BUFFER_CNTL_M6 *reg, unsigned int grph_critical_cntl)
{
  reg->bitfields.GRPH_CRITICAL_CNTL = grph_critical_cntl;
  if (reg->bitfields.GRPH_CRITICAL_CNTL != grph_critical_cntl) HSLDPF(E_ERROR_MESSAGE,"GRPH_BUFFER_CNTL_M6::GRPH_CRITICAL_CNTL data too large\n");
}
__inline void set_GRPH_BUFFER_CNTL_M6_grph_buffer_size(regGRPH_BUFFER_CNTL_M6 *reg, unsigned int grph_buffer_size)
{
  reg->bitfields.GRPH_BUFFER_SIZE = grph_buffer_size;
  if (reg->bitfields.GRPH_BUFFER_SIZE != grph_buffer_size) HSLDPF(E_ERROR_MESSAGE,"GRPH_BUFFER_CNTL_M6::GRPH_BUFFER_SIZE data too large\n");
}
__inline void set_GRPH_BUFFER_CNTL_M6_grph_critical_at_sof(regGRPH_BUFFER_CNTL_M6 *reg, unsigned int grph_critical_at_sof)
{
  reg->bitfields.GRPH_CRITICAL_AT_SOF = grph_critical_at_sof;
  if (reg->bitfields.GRPH_CRITICAL_AT_SOF != grph_critical_at_sof) HSLDPF(E_ERROR_MESSAGE,"GRPH_BUFFER_CNTL_M6::GRPH_CRITICAL_AT_SOF data too large\n");
}
__inline void set_GRPH_BUFFER_CNTL_M6_grph_stop_cntl(regGRPH_BUFFER_CNTL_M6 *reg, unsigned int grph_stop_cntl)
{
  reg->bitfields.GRPH_STOP_CNTL = grph_stop_cntl;
  if (reg->bitfields.GRPH_STOP_CNTL != grph_stop_cntl) HSLDPF(E_ERROR_MESSAGE,"GRPH_BUFFER_CNTL_M6::GRPH_STOP_CNTL data too large\n");
}
#else
#define set_GRPH_BUFFER_CNTL_M6_grph_start_req(reg, grph_start_req) (reg)->bitfields.GRPH_START_REQ = grph_start_req
#define set_GRPH_BUFFER_CNTL_M6_grph_stop_req(reg, grph_stop_req) (reg)->bitfields.GRPH_STOP_REQ = grph_stop_req
#define set_GRPH_BUFFER_CNTL_M6_grph_critical_point(reg, grph_critical_point) (reg)->bitfields.GRPH_CRITICAL_POINT = grph_critical_point
#define set_GRPH_BUFFER_CNTL_M6_grph_critical_cntl(reg, grph_critical_cntl) (reg)->bitfields.GRPH_CRITICAL_CNTL = grph_critical_cntl
#define set_GRPH_BUFFER_CNTL_M6_grph_buffer_size(reg, grph_buffer_size) (reg)->bitfields.GRPH_BUFFER_SIZE = grph_buffer_size
#define set_GRPH_BUFFER_CNTL_M6_grph_critical_at_sof(reg, grph_critical_at_sof) (reg)->bitfields.GRPH_CRITICAL_AT_SOF = grph_critical_at_sof
#define set_GRPH_BUFFER_CNTL_M6_grph_stop_cntl(reg, grph_stop_cntl) (reg)->bitfields.GRPH_STOP_CNTL = grph_stop_cntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VGA_BUFFER_CNTL regVGA_BUFFER_CNTL;

#ifdef DEBUG
__inline void set_VGA_BUFFER_CNTL_vga_start_req(regVGA_BUFFER_CNTL *reg, unsigned int vga_start_req)
{
  reg->bitfields.VGA_START_REQ = vga_start_req;
  if (reg->bitfields.VGA_START_REQ != vga_start_req) HSLDPF(E_ERROR_MESSAGE,"VGA_BUFFER_CNTL::VGA_START_REQ data too large\n");
}
__inline void set_VGA_BUFFER_CNTL_vga_stop_req(regVGA_BUFFER_CNTL *reg, unsigned int vga_stop_req)
{
  reg->bitfields.VGA_STOP_REQ = vga_stop_req;
  if (reg->bitfields.VGA_STOP_REQ != vga_stop_req) HSLDPF(E_ERROR_MESSAGE,"VGA_BUFFER_CNTL::VGA_STOP_REQ data too large\n");
}
__inline void set_VGA_BUFFER_CNTL_vga_critical_point(regVGA_BUFFER_CNTL *reg, unsigned int vga_critical_point)
{
  reg->bitfields.VGA_CRITICAL_POINT = vga_critical_point;
  if (reg->bitfields.VGA_CRITICAL_POINT != vga_critical_point) HSLDPF(E_ERROR_MESSAGE,"VGA_BUFFER_CNTL::VGA_CRITICAL_POINT data too large\n");
}
#else
#define set_VGA_BUFFER_CNTL_vga_start_req(reg, vga_start_req) (reg)->bitfields.VGA_START_REQ = vga_start_req
#define set_VGA_BUFFER_CNTL_vga_stop_req(reg, vga_stop_req) (reg)->bitfields.VGA_STOP_REQ = vga_stop_req
#define set_VGA_BUFFER_CNTL_vga_critical_point(reg, vga_critical_point) (reg)->bitfields.VGA_CRITICAL_POINT = vga_critical_point

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC2_H_TOTAL_DISP regCRTC2_H_TOTAL_DISP;

#ifdef DEBUG
__inline void set_CRTC2_H_TOTAL_DISP_crtc2_h_total(regCRTC2_H_TOTAL_DISP *reg, unsigned int crtc2_h_total)
{
  reg->bitfields.CRTC2_H_TOTAL = crtc2_h_total;
  if (reg->bitfields.CRTC2_H_TOTAL != crtc2_h_total) HSLDPF(E_ERROR_MESSAGE,"CRTC2_H_TOTAL_DISP::CRTC2_H_TOTAL data too large\n");
}
__inline void set_CRTC2_H_TOTAL_DISP_crtc2_h_disp(regCRTC2_H_TOTAL_DISP *reg, unsigned int crtc2_h_disp)
{
  reg->bitfields.CRTC2_H_DISP = crtc2_h_disp;
  if (reg->bitfields.CRTC2_H_DISP != crtc2_h_disp) HSLDPF(E_ERROR_MESSAGE,"CRTC2_H_TOTAL_DISP::CRTC2_H_DISP data too large\n");
}
#else
#define set_CRTC2_H_TOTAL_DISP_crtc2_h_total(reg, crtc2_h_total) (reg)->bitfields.CRTC2_H_TOTAL = crtc2_h_total
#define set_CRTC2_H_TOTAL_DISP_crtc2_h_disp(reg, crtc2_h_disp) (reg)->bitfields.CRTC2_H_DISP = crtc2_h_disp

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC2_H_SYNC_STRT_WID regCRTC2_H_SYNC_STRT_WID;

#ifdef DEBUG
__inline void set_CRTC2_H_SYNC_STRT_WID_crtc2_h_sync_strt_pix(regCRTC2_H_SYNC_STRT_WID *reg, unsigned int crtc2_h_sync_strt_pix)
{
  reg->bitfields.CRTC2_H_SYNC_STRT_PIX = crtc2_h_sync_strt_pix;
  if (reg->bitfields.CRTC2_H_SYNC_STRT_PIX != crtc2_h_sync_strt_pix) HSLDPF(E_ERROR_MESSAGE,"CRTC2_H_SYNC_STRT_WID::CRTC2_H_SYNC_STRT_PIX data too large\n");
}
__inline void set_CRTC2_H_SYNC_STRT_WID_crtc2_h_sync_strt_char(regCRTC2_H_SYNC_STRT_WID *reg, unsigned int crtc2_h_sync_strt_char)
{
  reg->bitfields.CRTC2_H_SYNC_STRT_CHAR = crtc2_h_sync_strt_char;
  if (reg->bitfields.CRTC2_H_SYNC_STRT_CHAR != crtc2_h_sync_strt_char) HSLDPF(E_ERROR_MESSAGE,"CRTC2_H_SYNC_STRT_WID::CRTC2_H_SYNC_STRT_CHAR data too large\n");
}
__inline void set_CRTC2_H_SYNC_STRT_WID_crtc2_h_sync_wid(regCRTC2_H_SYNC_STRT_WID *reg, unsigned int crtc2_h_sync_wid)
{
  reg->bitfields.CRTC2_H_SYNC_WID = crtc2_h_sync_wid;
  if (reg->bitfields.CRTC2_H_SYNC_WID != crtc2_h_sync_wid) HSLDPF(E_ERROR_MESSAGE,"CRTC2_H_SYNC_STRT_WID::CRTC2_H_SYNC_WID data too large\n");
}
__inline void set_CRTC2_H_SYNC_STRT_WID_crtc2_h_sync_pol(regCRTC2_H_SYNC_STRT_WID *reg, unsigned int crtc2_h_sync_pol)
{
  reg->bitfields.CRTC2_H_SYNC_POL = crtc2_h_sync_pol;
  if (reg->bitfields.CRTC2_H_SYNC_POL != crtc2_h_sync_pol) HSLDPF(E_ERROR_MESSAGE,"CRTC2_H_SYNC_STRT_WID::CRTC2_H_SYNC_POL data too large\n");
}
#else
#define set_CRTC2_H_SYNC_STRT_WID_crtc2_h_sync_strt_pix(reg, crtc2_h_sync_strt_pix) (reg)->bitfields.CRTC2_H_SYNC_STRT_PIX = crtc2_h_sync_strt_pix
#define set_CRTC2_H_SYNC_STRT_WID_crtc2_h_sync_strt_char(reg, crtc2_h_sync_strt_char) (reg)->bitfields.CRTC2_H_SYNC_STRT_CHAR = crtc2_h_sync_strt_char
#define set_CRTC2_H_SYNC_STRT_WID_crtc2_h_sync_wid(reg, crtc2_h_sync_wid) (reg)->bitfields.CRTC2_H_SYNC_WID = crtc2_h_sync_wid
#define set_CRTC2_H_SYNC_STRT_WID_crtc2_h_sync_pol(reg, crtc2_h_sync_pol) (reg)->bitfields.CRTC2_H_SYNC_POL = crtc2_h_sync_pol

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC2_V_TOTAL_DISP regCRTC2_V_TOTAL_DISP;

#ifdef DEBUG
__inline void set_CRTC2_V_TOTAL_DISP_crtc2_v_total(regCRTC2_V_TOTAL_DISP *reg, unsigned int crtc2_v_total)
{
  reg->bitfields.CRTC2_V_TOTAL = crtc2_v_total;
  if (reg->bitfields.CRTC2_V_TOTAL != crtc2_v_total) HSLDPF(E_ERROR_MESSAGE,"CRTC2_V_TOTAL_DISP::CRTC2_V_TOTAL data too large\n");
}
__inline void set_CRTC2_V_TOTAL_DISP_crtc2_v_disp(regCRTC2_V_TOTAL_DISP *reg, unsigned int crtc2_v_disp)
{
  reg->bitfields.CRTC2_V_DISP = crtc2_v_disp;
  if (reg->bitfields.CRTC2_V_DISP != crtc2_v_disp) HSLDPF(E_ERROR_MESSAGE,"CRTC2_V_TOTAL_DISP::CRTC2_V_DISP data too large\n");
}
#else
#define set_CRTC2_V_TOTAL_DISP_crtc2_v_total(reg, crtc2_v_total) (reg)->bitfields.CRTC2_V_TOTAL = crtc2_v_total
#define set_CRTC2_V_TOTAL_DISP_crtc2_v_disp(reg, crtc2_v_disp) (reg)->bitfields.CRTC2_V_DISP = crtc2_v_disp

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC2_V_SYNC_STRT_WID regCRTC2_V_SYNC_STRT_WID;

#ifdef DEBUG
__inline void set_CRTC2_V_SYNC_STRT_WID_crtc2_v_sync_strt(regCRTC2_V_SYNC_STRT_WID *reg, unsigned int crtc2_v_sync_strt)
{
  reg->bitfields.CRTC2_V_SYNC_STRT = crtc2_v_sync_strt;
  if (reg->bitfields.CRTC2_V_SYNC_STRT != crtc2_v_sync_strt) HSLDPF(E_ERROR_MESSAGE,"CRTC2_V_SYNC_STRT_WID::CRTC2_V_SYNC_STRT data too large\n");
}
__inline void set_CRTC2_V_SYNC_STRT_WID_crtc2_v_sync_wid(regCRTC2_V_SYNC_STRT_WID *reg, unsigned int crtc2_v_sync_wid)
{
  reg->bitfields.CRTC2_V_SYNC_WID = crtc2_v_sync_wid;
  if (reg->bitfields.CRTC2_V_SYNC_WID != crtc2_v_sync_wid) HSLDPF(E_ERROR_MESSAGE,"CRTC2_V_SYNC_STRT_WID::CRTC2_V_SYNC_WID data too large\n");
}
__inline void set_CRTC2_V_SYNC_STRT_WID_crtc2_v_sync_pol(regCRTC2_V_SYNC_STRT_WID *reg, unsigned int crtc2_v_sync_pol)
{
  reg->bitfields.CRTC2_V_SYNC_POL = crtc2_v_sync_pol;
  if (reg->bitfields.CRTC2_V_SYNC_POL != crtc2_v_sync_pol) HSLDPF(E_ERROR_MESSAGE,"CRTC2_V_SYNC_STRT_WID::CRTC2_V_SYNC_POL data too large\n");
}
#else
#define set_CRTC2_V_SYNC_STRT_WID_crtc2_v_sync_strt(reg, crtc2_v_sync_strt) (reg)->bitfields.CRTC2_V_SYNC_STRT = crtc2_v_sync_strt
#define set_CRTC2_V_SYNC_STRT_WID_crtc2_v_sync_wid(reg, crtc2_v_sync_wid) (reg)->bitfields.CRTC2_V_SYNC_WID = crtc2_v_sync_wid
#define set_CRTC2_V_SYNC_STRT_WID_crtc2_v_sync_pol(reg, crtc2_v_sync_pol) (reg)->bitfields.CRTC2_V_SYNC_POL = crtc2_v_sync_pol

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC2_VLINE_CRNT_VLINE regCRTC2_VLINE_CRNT_VLINE;

#ifdef DEBUG
__inline void set_CRTC2_VLINE_CRNT_VLINE_crtc2_vline(regCRTC2_VLINE_CRNT_VLINE *reg, unsigned int crtc2_vline)
{
  reg->bitfields.CRTC2_VLINE = crtc2_vline;
  if (reg->bitfields.CRTC2_VLINE != crtc2_vline) HSLDPF(E_ERROR_MESSAGE,"CRTC2_VLINE_CRNT_VLINE::CRTC2_VLINE data too large\n");
}
__inline void set_CRTC2_VLINE_CRNT_VLINE_crtc2_crnt_vline(regCRTC2_VLINE_CRNT_VLINE *reg, unsigned int crtc2_crnt_vline)
{
  reg->bitfields.CRTC2_CRNT_VLINE = crtc2_crnt_vline;
  if (reg->bitfields.CRTC2_CRNT_VLINE != crtc2_crnt_vline) HSLDPF(E_ERROR_MESSAGE,"CRTC2_VLINE_CRNT_VLINE::CRTC2_CRNT_VLINE data too large\n");
}
#else
#define set_CRTC2_VLINE_CRNT_VLINE_crtc2_vline(reg, crtc2_vline) (reg)->bitfields.CRTC2_VLINE = crtc2_vline
#define set_CRTC2_VLINE_CRNT_VLINE_crtc2_crnt_vline(reg, crtc2_crnt_vline) (reg)->bitfields.CRTC2_CRNT_VLINE = crtc2_crnt_vline

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC2_CRNT_FRAME regCRTC2_CRNT_FRAME;

#ifdef DEBUG
__inline void set_CRTC2_CRNT_FRAME_crtc2_crnt_frame(regCRTC2_CRNT_FRAME *reg, unsigned int crtc2_crnt_frame)
{
  reg->bitfields.CRTC2_CRNT_FRAME = crtc2_crnt_frame;
  if (reg->bitfields.CRTC2_CRNT_FRAME != crtc2_crnt_frame) HSLDPF(E_ERROR_MESSAGE,"CRTC2_CRNT_FRAME::CRTC2_CRNT_FRAME data too large\n");
}
#else
#define set_CRTC2_CRNT_FRAME_crtc2_crnt_frame(reg, crtc2_crnt_frame) (reg)->bitfields.CRTC2_CRNT_FRAME = crtc2_crnt_frame

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC2_GUI_TRIG_VLINE regCRTC2_GUI_TRIG_VLINE;

#ifdef DEBUG
__inline void set_CRTC2_GUI_TRIG_VLINE_crtc2_gui_trig_vline_start(regCRTC2_GUI_TRIG_VLINE *reg, unsigned int crtc2_gui_trig_vline_start)
{
  reg->bitfields.CRTC2_GUI_TRIG_VLINE_START = crtc2_gui_trig_vline_start;
  if (reg->bitfields.CRTC2_GUI_TRIG_VLINE_START != crtc2_gui_trig_vline_start) HSLDPF(E_ERROR_MESSAGE,"CRTC2_GUI_TRIG_VLINE::CRTC2_GUI_TRIG_VLINE_START data too large\n");
}
__inline void set_CRTC2_GUI_TRIG_VLINE_crtc2_gui_trig_vline_inv(regCRTC2_GUI_TRIG_VLINE *reg, unsigned int crtc2_gui_trig_vline_inv)
{
  reg->bitfields.CRTC2_GUI_TRIG_VLINE_INV = crtc2_gui_trig_vline_inv;
  if (reg->bitfields.CRTC2_GUI_TRIG_VLINE_INV != crtc2_gui_trig_vline_inv) HSLDPF(E_ERROR_MESSAGE,"CRTC2_GUI_TRIG_VLINE::CRTC2_GUI_TRIG_VLINE_INV data too large\n");
}
__inline void set_CRTC2_GUI_TRIG_VLINE_crtc2_gui_trig_vline_end(regCRTC2_GUI_TRIG_VLINE *reg, unsigned int crtc2_gui_trig_vline_end)
{
  reg->bitfields.CRTC2_GUI_TRIG_VLINE_END = crtc2_gui_trig_vline_end;
  if (reg->bitfields.CRTC2_GUI_TRIG_VLINE_END != crtc2_gui_trig_vline_end) HSLDPF(E_ERROR_MESSAGE,"CRTC2_GUI_TRIG_VLINE::CRTC2_GUI_TRIG_VLINE_END data too large\n");
}
__inline void set_CRTC2_GUI_TRIG_VLINE_crtc2_gui_trig_vline_stall(regCRTC2_GUI_TRIG_VLINE *reg, unsigned int crtc2_gui_trig_vline_stall)
{
  reg->bitfields.CRTC2_GUI_TRIG_VLINE_STALL = crtc2_gui_trig_vline_stall;
  if (reg->bitfields.CRTC2_GUI_TRIG_VLINE_STALL != crtc2_gui_trig_vline_stall) HSLDPF(E_ERROR_MESSAGE,"CRTC2_GUI_TRIG_VLINE::CRTC2_GUI_TRIG_VLINE_STALL data too large\n");
}
__inline void set_CRTC2_GUI_TRIG_VLINE_crtc2_gui_trig_vline(regCRTC2_GUI_TRIG_VLINE *reg, unsigned int crtc2_gui_trig_vline)
{
  reg->bitfields.CRTC2_GUI_TRIG_VLINE = crtc2_gui_trig_vline;
  if (reg->bitfields.CRTC2_GUI_TRIG_VLINE != crtc2_gui_trig_vline) HSLDPF(E_ERROR_MESSAGE,"CRTC2_GUI_TRIG_VLINE::CRTC2_GUI_TRIG_VLINE data too large\n");
}
#else
#define set_CRTC2_GUI_TRIG_VLINE_crtc2_gui_trig_vline_start(reg, crtc2_gui_trig_vline_start) (reg)->bitfields.CRTC2_GUI_TRIG_VLINE_START = crtc2_gui_trig_vline_start
#define set_CRTC2_GUI_TRIG_VLINE_crtc2_gui_trig_vline_inv(reg, crtc2_gui_trig_vline_inv) (reg)->bitfields.CRTC2_GUI_TRIG_VLINE_INV = crtc2_gui_trig_vline_inv
#define set_CRTC2_GUI_TRIG_VLINE_crtc2_gui_trig_vline_end(reg, crtc2_gui_trig_vline_end) (reg)->bitfields.CRTC2_GUI_TRIG_VLINE_END = crtc2_gui_trig_vline_end
#define set_CRTC2_GUI_TRIG_VLINE_crtc2_gui_trig_vline_stall(reg, crtc2_gui_trig_vline_stall) (reg)->bitfields.CRTC2_GUI_TRIG_VLINE_STALL = crtc2_gui_trig_vline_stall
#define set_CRTC2_GUI_TRIG_VLINE_crtc2_gui_trig_vline(reg, crtc2_gui_trig_vline) (reg)->bitfields.CRTC2_GUI_TRIG_VLINE = crtc2_gui_trig_vline

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC2_DEBUG regCRTC2_DEBUG;

#ifdef DEBUG
__inline void set_CRTC2_DEBUG_crtc2_gui_trig_bypass_en(regCRTC2_DEBUG *reg, unsigned int crtc2_gui_trig_bypass_en)
{
  reg->bitfields.CRTC2_GUI_TRIG_BYPASS_EN = crtc2_gui_trig_bypass_en;
  if (reg->bitfields.CRTC2_GUI_TRIG_BYPASS_EN != crtc2_gui_trig_bypass_en) HSLDPF(E_ERROR_MESSAGE,"CRTC2_DEBUG::CRTC2_GUI_TRIG_BYPASS_EN data too large\n");
}
__inline void set_CRTC2_DEBUG_crtc2_gui_trig_vline_bypass(regCRTC2_DEBUG *reg, unsigned int crtc2_gui_trig_vline_bypass)
{
  reg->bitfields.CRTC2_GUI_TRIG_VLINE_BYPASS = crtc2_gui_trig_vline_bypass;
  if (reg->bitfields.CRTC2_GUI_TRIG_VLINE_BYPASS != crtc2_gui_trig_vline_bypass) HSLDPF(E_ERROR_MESSAGE,"CRTC2_DEBUG::CRTC2_GUI_TRIG_VLINE_BYPASS data too large\n");
}
__inline void set_CRTC2_DEBUG_crtc2_gui_trig_offset_bypass(regCRTC2_DEBUG *reg, unsigned int crtc2_gui_trig_offset_bypass)
{
  reg->bitfields.CRTC2_GUI_TRIG_OFFSET_BYPASS = crtc2_gui_trig_offset_bypass;
  if (reg->bitfields.CRTC2_GUI_TRIG_OFFSET_BYPASS != crtc2_gui_trig_offset_bypass) HSLDPF(E_ERROR_MESSAGE,"CRTC2_DEBUG::CRTC2_GUI_TRIG_OFFSET_BYPASS data too large\n");
}
__inline void set_CRTC2_DEBUG_crtc2_gui_trig_pitch_add_bypass(regCRTC2_DEBUG *reg, unsigned int crtc2_gui_trig_pitch_add_bypass)
{
  reg->bitfields.CRTC2_GUI_TRIG_PITCH_ADD_BYPASS = crtc2_gui_trig_pitch_add_bypass;
  if (reg->bitfields.CRTC2_GUI_TRIG_PITCH_ADD_BYPASS != crtc2_gui_trig_pitch_add_bypass) HSLDPF(E_ERROR_MESSAGE,"CRTC2_DEBUG::CRTC2_GUI_TRIG_PITCH_ADD_BYPASS data too large\n");
}
#else
#define set_CRTC2_DEBUG_crtc2_gui_trig_bypass_en(reg, crtc2_gui_trig_bypass_en) (reg)->bitfields.CRTC2_GUI_TRIG_BYPASS_EN = crtc2_gui_trig_bypass_en
#define set_CRTC2_DEBUG_crtc2_gui_trig_vline_bypass(reg, crtc2_gui_trig_vline_bypass) (reg)->bitfields.CRTC2_GUI_TRIG_VLINE_BYPASS = crtc2_gui_trig_vline_bypass
#define set_CRTC2_DEBUG_crtc2_gui_trig_offset_bypass(reg, crtc2_gui_trig_offset_bypass) (reg)->bitfields.CRTC2_GUI_TRIG_OFFSET_BYPASS = crtc2_gui_trig_offset_bypass
#define set_CRTC2_DEBUG_crtc2_gui_trig_pitch_add_bypass(reg, crtc2_gui_trig_pitch_add_bypass) (reg)->bitfields.CRTC2_GUI_TRIG_PITCH_ADD_BYPASS = crtc2_gui_trig_pitch_add_bypass

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC2_OFFSET regCRTC2_OFFSET;

#ifdef DEBUG
__inline void set_CRTC2_OFFSET_crtc2_offset(regCRTC2_OFFSET *reg, unsigned int crtc2_offset)
{
  reg->bitfields.CRTC2_OFFSET = crtc2_offset;
  if (reg->bitfields.CRTC2_OFFSET != crtc2_offset) HSLDPF(E_ERROR_MESSAGE,"CRTC2_OFFSET::CRTC2_OFFSET data too large\n");
}
__inline void set_CRTC2_OFFSET_crtc2_gui_trig_offset(regCRTC2_OFFSET *reg, unsigned int crtc2_gui_trig_offset)
{
  reg->bitfields.CRTC2_GUI_TRIG_OFFSET = crtc2_gui_trig_offset;
  if (reg->bitfields.CRTC2_GUI_TRIG_OFFSET != crtc2_gui_trig_offset) HSLDPF(E_ERROR_MESSAGE,"CRTC2_OFFSET::CRTC2_GUI_TRIG_OFFSET data too large\n");
}
__inline void set_CRTC2_OFFSET_crtc2_offset_lock(regCRTC2_OFFSET *reg, unsigned int crtc2_offset_lock)
{
  reg->bitfields.CRTC2_OFFSET_LOCK = crtc2_offset_lock;
  if (reg->bitfields.CRTC2_OFFSET_LOCK != crtc2_offset_lock) HSLDPF(E_ERROR_MESSAGE,"CRTC2_OFFSET::CRTC2_OFFSET_LOCK data too large\n");
}
#else
#define set_CRTC2_OFFSET_crtc2_offset(reg, crtc2_offset) (reg)->bitfields.CRTC2_OFFSET = crtc2_offset
#define set_CRTC2_OFFSET_crtc2_gui_trig_offset(reg, crtc2_gui_trig_offset) (reg)->bitfields.CRTC2_GUI_TRIG_OFFSET = crtc2_gui_trig_offset
#define set_CRTC2_OFFSET_crtc2_offset_lock(reg, crtc2_offset_lock) (reg)->bitfields.CRTC2_OFFSET_LOCK = crtc2_offset_lock

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OVR2_CLR regOVR2_CLR;

#ifdef DEBUG
__inline void set_OVR2_CLR_ovr2_clr_b(regOVR2_CLR *reg, unsigned int ovr2_clr_b)
{
  reg->bitfields.OVR2_CLR_B = ovr2_clr_b;
  if (reg->bitfields.OVR2_CLR_B != ovr2_clr_b) HSLDPF(E_ERROR_MESSAGE,"OVR2_CLR::OVR2_CLR_B data too large\n");
}
__inline void set_OVR2_CLR_ovr2_clr_g(regOVR2_CLR *reg, unsigned int ovr2_clr_g)
{
  reg->bitfields.OVR2_CLR_G = ovr2_clr_g;
  if (reg->bitfields.OVR2_CLR_G != ovr2_clr_g) HSLDPF(E_ERROR_MESSAGE,"OVR2_CLR::OVR2_CLR_G data too large\n");
}
__inline void set_OVR2_CLR_ovr2_clr_r(regOVR2_CLR *reg, unsigned int ovr2_clr_r)
{
  reg->bitfields.OVR2_CLR_R = ovr2_clr_r;
  if (reg->bitfields.OVR2_CLR_R != ovr2_clr_r) HSLDPF(E_ERROR_MESSAGE,"OVR2_CLR::OVR2_CLR_R data too large\n");
}
#else
#define set_OVR2_CLR_ovr2_clr_b(reg, ovr2_clr_b) (reg)->bitfields.OVR2_CLR_B = ovr2_clr_b
#define set_OVR2_CLR_ovr2_clr_g(reg, ovr2_clr_g) (reg)->bitfields.OVR2_CLR_G = ovr2_clr_g
#define set_OVR2_CLR_ovr2_clr_r(reg, ovr2_clr_r) (reg)->bitfields.OVR2_CLR_R = ovr2_clr_r

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OVR2_WID_LEFT_RIGHT regOVR2_WID_LEFT_RIGHT;

#ifdef DEBUG
__inline void set_OVR2_WID_LEFT_RIGHT_ovr2_wid_right(regOVR2_WID_LEFT_RIGHT *reg, unsigned int ovr2_wid_right)
{
  reg->bitfields.OVR2_WID_RIGHT = ovr2_wid_right;
  if (reg->bitfields.OVR2_WID_RIGHT != ovr2_wid_right) HSLDPF(E_ERROR_MESSAGE,"OVR2_WID_LEFT_RIGHT::OVR2_WID_RIGHT data too large\n");
}
__inline void set_OVR2_WID_LEFT_RIGHT_ovr2_wid_left(regOVR2_WID_LEFT_RIGHT *reg, unsigned int ovr2_wid_left)
{
  reg->bitfields.OVR2_WID_LEFT = ovr2_wid_left;
  if (reg->bitfields.OVR2_WID_LEFT != ovr2_wid_left) HSLDPF(E_ERROR_MESSAGE,"OVR2_WID_LEFT_RIGHT::OVR2_WID_LEFT data too large\n");
}
#else
#define set_OVR2_WID_LEFT_RIGHT_ovr2_wid_right(reg, ovr2_wid_right) (reg)->bitfields.OVR2_WID_RIGHT = ovr2_wid_right
#define set_OVR2_WID_LEFT_RIGHT_ovr2_wid_left(reg, ovr2_wid_left) (reg)->bitfields.OVR2_WID_LEFT = ovr2_wid_left

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OVR2_WID_TOP_BOTTOM regOVR2_WID_TOP_BOTTOM;

#ifdef DEBUG
__inline void set_OVR2_WID_TOP_BOTTOM_ovr2_wid_bottom(regOVR2_WID_TOP_BOTTOM *reg, unsigned int ovr2_wid_bottom)
{
  reg->bitfields.OVR2_WID_BOTTOM = ovr2_wid_bottom;
  if (reg->bitfields.OVR2_WID_BOTTOM != ovr2_wid_bottom) HSLDPF(E_ERROR_MESSAGE,"OVR2_WID_TOP_BOTTOM::OVR2_WID_BOTTOM data too large\n");
}
__inline void set_OVR2_WID_TOP_BOTTOM_ovr2_wid_top(regOVR2_WID_TOP_BOTTOM *reg, unsigned int ovr2_wid_top)
{
  reg->bitfields.OVR2_WID_TOP = ovr2_wid_top;
  if (reg->bitfields.OVR2_WID_TOP != ovr2_wid_top) HSLDPF(E_ERROR_MESSAGE,"OVR2_WID_TOP_BOTTOM::OVR2_WID_TOP data too large\n");
}
#else
#define set_OVR2_WID_TOP_BOTTOM_ovr2_wid_bottom(reg, ovr2_wid_bottom) (reg)->bitfields.OVR2_WID_BOTTOM = ovr2_wid_bottom
#define set_OVR2_WID_TOP_BOTTOM_ovr2_wid_top(reg, ovr2_wid_top) (reg)->bitfields.OVR2_WID_TOP = ovr2_wid_top

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC2_DISPLAY_BASE_ADDR regCRTC2_DISPLAY_BASE_ADDR;

#ifdef DEBUG
__inline void set_CRTC2_DISPLAY_BASE_ADDR_crtc2_display_base_addr(regCRTC2_DISPLAY_BASE_ADDR *reg, unsigned int crtc2_display_base_addr)
{
  reg->bitfields.CRTC2_DISPLAY_BASE_ADDR = crtc2_display_base_addr;
  if (reg->bitfields.CRTC2_DISPLAY_BASE_ADDR != crtc2_display_base_addr) HSLDPF(E_ERROR_MESSAGE,"CRTC2_DISPLAY_BASE_ADDR::CRTC2_DISPLAY_BASE_ADDR data too large\n");
}
#else
#define set_CRTC2_DISPLAY_BASE_ADDR_crtc2_display_base_addr(reg, crtc2_display_base_addr) (reg)->bitfields.CRTC2_DISPLAY_BASE_ADDR = crtc2_display_base_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SNAPSHOT2_VH_COUNTS regSNAPSHOT2_VH_COUNTS;

#ifdef DEBUG
__inline void set_SNAPSHOT2_VH_COUNTS_snapshot2_hcount(regSNAPSHOT2_VH_COUNTS *reg, unsigned int snapshot2_hcount)
{
  reg->bitfields.SNAPSHOT2_HCOUNT = snapshot2_hcount;
  if (reg->bitfields.SNAPSHOT2_HCOUNT != snapshot2_hcount) HSLDPF(E_ERROR_MESSAGE,"SNAPSHOT2_VH_COUNTS::SNAPSHOT2_HCOUNT data too large\n");
}
__inline void set_SNAPSHOT2_VH_COUNTS_snapshot2_vcount(regSNAPSHOT2_VH_COUNTS *reg, unsigned int snapshot2_vcount)
{
  reg->bitfields.SNAPSHOT2_VCOUNT = snapshot2_vcount;
  if (reg->bitfields.SNAPSHOT2_VCOUNT != snapshot2_vcount) HSLDPF(E_ERROR_MESSAGE,"SNAPSHOT2_VH_COUNTS::SNAPSHOT2_VCOUNT data too large\n");
}
#else
#define set_SNAPSHOT2_VH_COUNTS_snapshot2_hcount(reg, snapshot2_hcount) (reg)->bitfields.SNAPSHOT2_HCOUNT = snapshot2_hcount
#define set_SNAPSHOT2_VH_COUNTS_snapshot2_vcount(reg, snapshot2_vcount) (reg)->bitfields.SNAPSHOT2_VCOUNT = snapshot2_vcount

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SNAPSHOT2_F_COUNT regSNAPSHOT2_F_COUNT;

#ifdef DEBUG
__inline void set_SNAPSHOT2_F_COUNT_snapshot2_f_count(regSNAPSHOT2_F_COUNT *reg, unsigned int snapshot2_f_count)
{
  reg->bitfields.SNAPSHOT2_F_COUNT = snapshot2_f_count;
  if (reg->bitfields.SNAPSHOT2_F_COUNT != snapshot2_f_count) HSLDPF(E_ERROR_MESSAGE,"SNAPSHOT2_F_COUNT::SNAPSHOT2_F_COUNT data too large\n");
}
#else
#define set_SNAPSHOT2_F_COUNT_snapshot2_f_count(reg, snapshot2_f_count) (reg)->bitfields.SNAPSHOT2_F_COUNT = snapshot2_f_count

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union N_VIF2_COUNT regN_VIF2_COUNT;

#ifdef DEBUG
__inline void set_N_VIF2_COUNT_n_vif2_count_val(regN_VIF2_COUNT *reg, unsigned int n_vif2_count_val)
{
  reg->bitfields.N_VIF2_COUNT_VAL = n_vif2_count_val;
  if (reg->bitfields.N_VIF2_COUNT_VAL != n_vif2_count_val) HSLDPF(E_ERROR_MESSAGE,"N_VIF2_COUNT::N_VIF2_COUNT_VAL data too large\n");
}
__inline void set_N_VIF2_COUNT_genlock2_source_sel(regN_VIF2_COUNT *reg, unsigned int genlock2_source_sel)
{
  reg->bitfields.GENLOCK2_SOURCE_SEL = genlock2_source_sel;
  if (reg->bitfields.GENLOCK2_SOURCE_SEL != genlock2_source_sel) HSLDPF(E_ERROR_MESSAGE,"N_VIF2_COUNT::GENLOCK2_SOURCE_SEL data too large\n");
}
#else
#define set_N_VIF2_COUNT_n_vif2_count_val(reg, n_vif2_count_val) (reg)->bitfields.N_VIF2_COUNT_VAL = n_vif2_count_val
#define set_N_VIF2_COUNT_genlock2_source_sel(reg, genlock2_source_sel) (reg)->bitfields.GENLOCK2_SOURCE_SEL = genlock2_source_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SNAPSHOT2_VIF_COUNT regSNAPSHOT2_VIF_COUNT;

#ifdef DEBUG
__inline void set_SNAPSHOT2_VIF_COUNT_lsnapshot2_vif_count(regSNAPSHOT2_VIF_COUNT *reg, unsigned int lsnapshot2_vif_count)
{
  reg->bitfields.LSNAPSHOT2_VIF_COUNT = lsnapshot2_vif_count;
  if (reg->bitfields.LSNAPSHOT2_VIF_COUNT != lsnapshot2_vif_count) HSLDPF(E_ERROR_MESSAGE,"SNAPSHOT2_VIF_COUNT::LSNAPSHOT2_VIF_COUNT data too large\n");
}
__inline void set_SNAPSHOT2_VIF_COUNT_usnapshot2_vif_count(regSNAPSHOT2_VIF_COUNT *reg, unsigned int usnapshot2_vif_count)
{
  reg->bitfields.USNAPSHOT2_VIF_COUNT = usnapshot2_vif_count;
  if (reg->bitfields.USNAPSHOT2_VIF_COUNT != usnapshot2_vif_count) HSLDPF(E_ERROR_MESSAGE,"SNAPSHOT2_VIF_COUNT::USNAPSHOT2_VIF_COUNT data too large\n");
}
__inline void set_SNAPSHOT2_VIF_COUNT_auto_snapshot2_taken_rd(regSNAPSHOT2_VIF_COUNT *reg, unsigned int auto_snapshot2_taken_rd)
{
  reg->bitfields.AUTO_SNAPSHOT2_TAKEN_RD = auto_snapshot2_taken_rd;
  if (reg->bitfields.AUTO_SNAPSHOT2_TAKEN_RD != auto_snapshot2_taken_rd) HSLDPF(E_ERROR_MESSAGE,"SNAPSHOT2_VIF_COUNT::AUTO_SNAPSHOT2_TAKEN_RD data too large\n");
}
__inline void set_SNAPSHOT2_VIF_COUNT_manual_snapshot2_now(regSNAPSHOT2_VIF_COUNT *reg, unsigned int manual_snapshot2_now)
{
  reg->bitfields.MANUAL_SNAPSHOT2_NOW = manual_snapshot2_now;
  if (reg->bitfields.MANUAL_SNAPSHOT2_NOW != manual_snapshot2_now) HSLDPF(E_ERROR_MESSAGE,"SNAPSHOT2_VIF_COUNT::MANUAL_SNAPSHOT2_NOW data too large\n");
}
#else
#define set_SNAPSHOT2_VIF_COUNT_lsnapshot2_vif_count(reg, lsnapshot2_vif_count) (reg)->bitfields.LSNAPSHOT2_VIF_COUNT = lsnapshot2_vif_count
#define set_SNAPSHOT2_VIF_COUNT_usnapshot2_vif_count(reg, usnapshot2_vif_count) (reg)->bitfields.USNAPSHOT2_VIF_COUNT = usnapshot2_vif_count
#define set_SNAPSHOT2_VIF_COUNT_auto_snapshot2_taken_rd(reg, auto_snapshot2_taken_rd) (reg)->bitfields.AUTO_SNAPSHOT2_TAKEN_RD = auto_snapshot2_taken_rd
#define set_SNAPSHOT2_VIF_COUNT_manual_snapshot2_now(reg, manual_snapshot2_now) (reg)->bitfields.MANUAL_SNAPSHOT2_NOW = manual_snapshot2_now

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CUR2_OFFSET regCUR2_OFFSET;

#ifdef DEBUG
__inline void set_CUR2_OFFSET_cur2_offset(regCUR2_OFFSET *reg, unsigned int cur2_offset)
{
  reg->bitfields.CUR2_OFFSET = cur2_offset;
  if (reg->bitfields.CUR2_OFFSET != cur2_offset) HSLDPF(E_ERROR_MESSAGE,"CUR2_OFFSET::CUR2_OFFSET data too large\n");
}
__inline void set_CUR2_OFFSET_cur2_lock(regCUR2_OFFSET *reg, unsigned int cur2_lock)
{
  reg->bitfields.CUR2_LOCK = cur2_lock;
  if (reg->bitfields.CUR2_LOCK != cur2_lock) HSLDPF(E_ERROR_MESSAGE,"CUR2_OFFSET::CUR2_LOCK data too large\n");
}
#else
#define set_CUR2_OFFSET_cur2_offset(reg, cur2_offset) (reg)->bitfields.CUR2_OFFSET = cur2_offset
#define set_CUR2_OFFSET_cur2_lock(reg, cur2_lock) (reg)->bitfields.CUR2_LOCK = cur2_lock

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CUR2_HORZ_VERT_POSN regCUR2_HORZ_VERT_POSN;

#ifdef DEBUG
__inline void set_CUR2_HORZ_VERT_POSN_cur2_vert_posn(regCUR2_HORZ_VERT_POSN *reg, unsigned int cur2_vert_posn)
{
  reg->bitfields.CUR2_VERT_POSN = cur2_vert_posn;
  if (reg->bitfields.CUR2_VERT_POSN != cur2_vert_posn) HSLDPF(E_ERROR_MESSAGE,"CUR2_HORZ_VERT_POSN::CUR2_VERT_POSN data too large\n");
}
__inline void set_CUR2_HORZ_VERT_POSN_cur2_horz_posn(regCUR2_HORZ_VERT_POSN *reg, unsigned int cur2_horz_posn)
{
  reg->bitfields.CUR2_HORZ_POSN = cur2_horz_posn;
  if (reg->bitfields.CUR2_HORZ_POSN != cur2_horz_posn) HSLDPF(E_ERROR_MESSAGE,"CUR2_HORZ_VERT_POSN::CUR2_HORZ_POSN data too large\n");
}
__inline void set_CUR2_HORZ_VERT_POSN_cur2_lock(regCUR2_HORZ_VERT_POSN *reg, unsigned int cur2_lock)
{
  reg->bitfields.CUR2_LOCK = cur2_lock;
  if (reg->bitfields.CUR2_LOCK != cur2_lock) HSLDPF(E_ERROR_MESSAGE,"CUR2_HORZ_VERT_POSN::CUR2_LOCK data too large\n");
}
#else
#define set_CUR2_HORZ_VERT_POSN_cur2_vert_posn(reg, cur2_vert_posn) (reg)->bitfields.CUR2_VERT_POSN = cur2_vert_posn
#define set_CUR2_HORZ_VERT_POSN_cur2_horz_posn(reg, cur2_horz_posn) (reg)->bitfields.CUR2_HORZ_POSN = cur2_horz_posn
#define set_CUR2_HORZ_VERT_POSN_cur2_lock(reg, cur2_lock) (reg)->bitfields.CUR2_LOCK = cur2_lock

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CUR2_HORZ_VERT_OFF regCUR2_HORZ_VERT_OFF;

#ifdef DEBUG
__inline void set_CUR2_HORZ_VERT_OFF_cur2_vert_off(regCUR2_HORZ_VERT_OFF *reg, unsigned int cur2_vert_off)
{
  reg->bitfields.CUR2_VERT_OFF = cur2_vert_off;
  if (reg->bitfields.CUR2_VERT_OFF != cur2_vert_off) HSLDPF(E_ERROR_MESSAGE,"CUR2_HORZ_VERT_OFF::CUR2_VERT_OFF data too large\n");
}
__inline void set_CUR2_HORZ_VERT_OFF_cur2_horz_off(regCUR2_HORZ_VERT_OFF *reg, unsigned int cur2_horz_off)
{
  reg->bitfields.CUR2_HORZ_OFF = cur2_horz_off;
  if (reg->bitfields.CUR2_HORZ_OFF != cur2_horz_off) HSLDPF(E_ERROR_MESSAGE,"CUR2_HORZ_VERT_OFF::CUR2_HORZ_OFF data too large\n");
}
__inline void set_CUR2_HORZ_VERT_OFF_cur2_lock(regCUR2_HORZ_VERT_OFF *reg, unsigned int cur2_lock)
{
  reg->bitfields.CUR2_LOCK = cur2_lock;
  if (reg->bitfields.CUR2_LOCK != cur2_lock) HSLDPF(E_ERROR_MESSAGE,"CUR2_HORZ_VERT_OFF::CUR2_LOCK data too large\n");
}
#else
#define set_CUR2_HORZ_VERT_OFF_cur2_vert_off(reg, cur2_vert_off) (reg)->bitfields.CUR2_VERT_OFF = cur2_vert_off
#define set_CUR2_HORZ_VERT_OFF_cur2_horz_off(reg, cur2_horz_off) (reg)->bitfields.CUR2_HORZ_OFF = cur2_horz_off
#define set_CUR2_HORZ_VERT_OFF_cur2_lock(reg, cur2_lock) (reg)->bitfields.CUR2_LOCK = cur2_lock

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CUR2_CLR0 regCUR2_CLR0;

#ifdef DEBUG
__inline void set_CUR2_CLR0_cur2_clr0_b(regCUR2_CLR0 *reg, unsigned int cur2_clr0_b)
{
  reg->bitfields.CUR2_CLR0_B = cur2_clr0_b;
  if (reg->bitfields.CUR2_CLR0_B != cur2_clr0_b) HSLDPF(E_ERROR_MESSAGE,"CUR2_CLR0::CUR2_CLR0_B data too large\n");
}
__inline void set_CUR2_CLR0_cur2_clr0_g(regCUR2_CLR0 *reg, unsigned int cur2_clr0_g)
{
  reg->bitfields.CUR2_CLR0_G = cur2_clr0_g;
  if (reg->bitfields.CUR2_CLR0_G != cur2_clr0_g) HSLDPF(E_ERROR_MESSAGE,"CUR2_CLR0::CUR2_CLR0_G data too large\n");
}
__inline void set_CUR2_CLR0_cur2_clr0_r(regCUR2_CLR0 *reg, unsigned int cur2_clr0_r)
{
  reg->bitfields.CUR2_CLR0_R = cur2_clr0_r;
  if (reg->bitfields.CUR2_CLR0_R != cur2_clr0_r) HSLDPF(E_ERROR_MESSAGE,"CUR2_CLR0::CUR2_CLR0_R data too large\n");
}
#else
#define set_CUR2_CLR0_cur2_clr0_b(reg, cur2_clr0_b) (reg)->bitfields.CUR2_CLR0_B = cur2_clr0_b
#define set_CUR2_CLR0_cur2_clr0_g(reg, cur2_clr0_g) (reg)->bitfields.CUR2_CLR0_G = cur2_clr0_g
#define set_CUR2_CLR0_cur2_clr0_r(reg, cur2_clr0_r) (reg)->bitfields.CUR2_CLR0_R = cur2_clr0_r

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CUR2_CLR1 regCUR2_CLR1;

#ifdef DEBUG
__inline void set_CUR2_CLR1_cur2_clr1_b(regCUR2_CLR1 *reg, unsigned int cur2_clr1_b)
{
  reg->bitfields.CUR2_CLR1_B = cur2_clr1_b;
  if (reg->bitfields.CUR2_CLR1_B != cur2_clr1_b) HSLDPF(E_ERROR_MESSAGE,"CUR2_CLR1::CUR2_CLR1_B data too large\n");
}
__inline void set_CUR2_CLR1_cur2_clr1_g(regCUR2_CLR1 *reg, unsigned int cur2_clr1_g)
{
  reg->bitfields.CUR2_CLR1_G = cur2_clr1_g;
  if (reg->bitfields.CUR2_CLR1_G != cur2_clr1_g) HSLDPF(E_ERROR_MESSAGE,"CUR2_CLR1::CUR2_CLR1_G data too large\n");
}
__inline void set_CUR2_CLR1_cur2_clr1_r(regCUR2_CLR1 *reg, unsigned int cur2_clr1_r)
{
  reg->bitfields.CUR2_CLR1_R = cur2_clr1_r;
  if (reg->bitfields.CUR2_CLR1_R != cur2_clr1_r) HSLDPF(E_ERROR_MESSAGE,"CUR2_CLR1::CUR2_CLR1_R data too large\n");
}
#else
#define set_CUR2_CLR1_cur2_clr1_b(reg, cur2_clr1_b) (reg)->bitfields.CUR2_CLR1_B = cur2_clr1_b
#define set_CUR2_CLR1_cur2_clr1_g(reg, cur2_clr1_g) (reg)->bitfields.CUR2_CLR1_G = cur2_clr1_g
#define set_CUR2_CLR1_cur2_clr1_r(reg, cur2_clr1_r) (reg)->bitfields.CUR2_CLR1_R = cur2_clr1_r

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union FP_H2_SYNC_STRT_WID regFP_H2_SYNC_STRT_WID;

#ifdef DEBUG
__inline void set_FP_H2_SYNC_STRT_WID_fp_h2_sync_strt_pix(regFP_H2_SYNC_STRT_WID *reg, unsigned int fp_h2_sync_strt_pix)
{
  reg->bitfields.FP_H2_SYNC_STRT_PIX = fp_h2_sync_strt_pix;
  if (reg->bitfields.FP_H2_SYNC_STRT_PIX != fp_h2_sync_strt_pix) HSLDPF(E_ERROR_MESSAGE,"FP_H2_SYNC_STRT_WID::FP_H2_SYNC_STRT_PIX data too large\n");
}
__inline void set_FP_H2_SYNC_STRT_WID_fp_h2_sync_strt_char(regFP_H2_SYNC_STRT_WID *reg, unsigned int fp_h2_sync_strt_char)
{
  reg->bitfields.FP_H2_SYNC_STRT_CHAR = fp_h2_sync_strt_char;
  if (reg->bitfields.FP_H2_SYNC_STRT_CHAR != fp_h2_sync_strt_char) HSLDPF(E_ERROR_MESSAGE,"FP_H2_SYNC_STRT_WID::FP_H2_SYNC_STRT_CHAR data too large\n");
}
__inline void set_FP_H2_SYNC_STRT_WID_fp_h2_sync_wid(regFP_H2_SYNC_STRT_WID *reg, unsigned int fp_h2_sync_wid)
{
  reg->bitfields.FP_H2_SYNC_WID = fp_h2_sync_wid;
  if (reg->bitfields.FP_H2_SYNC_WID != fp_h2_sync_wid) HSLDPF(E_ERROR_MESSAGE,"FP_H2_SYNC_STRT_WID::FP_H2_SYNC_WID data too large\n");
}
__inline void set_FP_H2_SYNC_STRT_WID_fp_h2_sync_pol(regFP_H2_SYNC_STRT_WID *reg, unsigned int fp_h2_sync_pol)
{
  reg->bitfields.FP_H2_SYNC_POL = fp_h2_sync_pol;
  if (reg->bitfields.FP_H2_SYNC_POL != fp_h2_sync_pol) HSLDPF(E_ERROR_MESSAGE,"FP_H2_SYNC_STRT_WID::FP_H2_SYNC_POL data too large\n");
}
#else
#define set_FP_H2_SYNC_STRT_WID_fp_h2_sync_strt_pix(reg, fp_h2_sync_strt_pix) (reg)->bitfields.FP_H2_SYNC_STRT_PIX = fp_h2_sync_strt_pix
#define set_FP_H2_SYNC_STRT_WID_fp_h2_sync_strt_char(reg, fp_h2_sync_strt_char) (reg)->bitfields.FP_H2_SYNC_STRT_CHAR = fp_h2_sync_strt_char
#define set_FP_H2_SYNC_STRT_WID_fp_h2_sync_wid(reg, fp_h2_sync_wid) (reg)->bitfields.FP_H2_SYNC_WID = fp_h2_sync_wid
#define set_FP_H2_SYNC_STRT_WID_fp_h2_sync_pol(reg, fp_h2_sync_pol) (reg)->bitfields.FP_H2_SYNC_POL = fp_h2_sync_pol

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union FP_V2_SYNC_STRT_WID regFP_V2_SYNC_STRT_WID;

#ifdef DEBUG
__inline void set_FP_V2_SYNC_STRT_WID_fp_v2_sync_strt(regFP_V2_SYNC_STRT_WID *reg, unsigned int fp_v2_sync_strt)
{
  reg->bitfields.FP_V2_SYNC_STRT = fp_v2_sync_strt;
  if (reg->bitfields.FP_V2_SYNC_STRT != fp_v2_sync_strt) HSLDPF(E_ERROR_MESSAGE,"FP_V2_SYNC_STRT_WID::FP_V2_SYNC_STRT data too large\n");
}
__inline void set_FP_V2_SYNC_STRT_WID_fp_v2_sync_wid(regFP_V2_SYNC_STRT_WID *reg, unsigned int fp_v2_sync_wid)
{
  reg->bitfields.FP_V2_SYNC_WID = fp_v2_sync_wid;
  if (reg->bitfields.FP_V2_SYNC_WID != fp_v2_sync_wid) HSLDPF(E_ERROR_MESSAGE,"FP_V2_SYNC_STRT_WID::FP_V2_SYNC_WID data too large\n");
}
__inline void set_FP_V2_SYNC_STRT_WID_fp_v2_sync_pol(regFP_V2_SYNC_STRT_WID *reg, unsigned int fp_v2_sync_pol)
{
  reg->bitfields.FP_V2_SYNC_POL = fp_v2_sync_pol;
  if (reg->bitfields.FP_V2_SYNC_POL != fp_v2_sync_pol) HSLDPF(E_ERROR_MESSAGE,"FP_V2_SYNC_STRT_WID::FP_V2_SYNC_POL data too large\n");
}
#else
#define set_FP_V2_SYNC_STRT_WID_fp_v2_sync_strt(reg, fp_v2_sync_strt) (reg)->bitfields.FP_V2_SYNC_STRT = fp_v2_sync_strt
#define set_FP_V2_SYNC_STRT_WID_fp_v2_sync_wid(reg, fp_v2_sync_wid) (reg)->bitfields.FP_V2_SYNC_WID = fp_v2_sync_wid
#define set_FP_V2_SYNC_STRT_WID_fp_v2_sync_pol(reg, fp_v2_sync_pol) (reg)->bitfields.FP_V2_SYNC_POL = fp_v2_sync_pol

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ICON2_OFFSET regICON2_OFFSET;

#ifdef DEBUG
__inline void set_ICON2_OFFSET_icon2_offset(regICON2_OFFSET *reg, unsigned int icon2_offset)
{
  reg->bitfields.ICON2_OFFSET = icon2_offset;
  if (reg->bitfields.ICON2_OFFSET != icon2_offset) HSLDPF(E_ERROR_MESSAGE,"ICON2_OFFSET::ICON2_OFFSET data too large\n");
}
__inline void set_ICON2_OFFSET_blank_screen2(regICON2_OFFSET *reg, unsigned int blank_screen2)
{
  reg->bitfields.BLANK_SCREEN2 = blank_screen2;
  if (reg->bitfields.BLANK_SCREEN2 != blank_screen2) HSLDPF(E_ERROR_MESSAGE,"ICON2_OFFSET::BLANK_SCREEN2 data too large\n");
}
__inline void set_ICON2_OFFSET_dont_ds_icon2(regICON2_OFFSET *reg, unsigned int dont_ds_icon2)
{
  reg->bitfields.DONT_DS_ICON2 = dont_ds_icon2;
  if (reg->bitfields.DONT_DS_ICON2 != dont_ds_icon2) HSLDPF(E_ERROR_MESSAGE,"ICON2_OFFSET::DONT_DS_ICON2 data too large\n");
}
__inline void set_ICON2_OFFSET_icon2_lock(regICON2_OFFSET *reg, unsigned int icon2_lock)
{
  reg->bitfields.ICON2_LOCK = icon2_lock;
  if (reg->bitfields.ICON2_LOCK != icon2_lock) HSLDPF(E_ERROR_MESSAGE,"ICON2_OFFSET::ICON2_LOCK data too large\n");
}
#else
#define set_ICON2_OFFSET_icon2_offset(reg, icon2_offset) (reg)->bitfields.ICON2_OFFSET = icon2_offset
#define set_ICON2_OFFSET_blank_screen2(reg, blank_screen2) (reg)->bitfields.BLANK_SCREEN2 = blank_screen2
#define set_ICON2_OFFSET_dont_ds_icon2(reg, dont_ds_icon2) (reg)->bitfields.DONT_DS_ICON2 = dont_ds_icon2
#define set_ICON2_OFFSET_icon2_lock(reg, icon2_lock) (reg)->bitfields.ICON2_LOCK = icon2_lock

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ICON2_HORZ_VERT_POSN regICON2_HORZ_VERT_POSN;

#ifdef DEBUG
__inline void set_ICON2_HORZ_VERT_POSN_icon2_vert_posn(regICON2_HORZ_VERT_POSN *reg, unsigned int icon2_vert_posn)
{
  reg->bitfields.ICON2_VERT_POSN = icon2_vert_posn;
  if (reg->bitfields.ICON2_VERT_POSN != icon2_vert_posn) HSLDPF(E_ERROR_MESSAGE,"ICON2_HORZ_VERT_POSN::ICON2_VERT_POSN data too large\n");
}
__inline void set_ICON2_HORZ_VERT_POSN_icon2_horz_posn(regICON2_HORZ_VERT_POSN *reg, unsigned int icon2_horz_posn)
{
  reg->bitfields.ICON2_HORZ_POSN = icon2_horz_posn;
  if (reg->bitfields.ICON2_HORZ_POSN != icon2_horz_posn) HSLDPF(E_ERROR_MESSAGE,"ICON2_HORZ_VERT_POSN::ICON2_HORZ_POSN data too large\n");
}
__inline void set_ICON2_HORZ_VERT_POSN_icon2_lock(regICON2_HORZ_VERT_POSN *reg, unsigned int icon2_lock)
{
  reg->bitfields.ICON2_LOCK = icon2_lock;
  if (reg->bitfields.ICON2_LOCK != icon2_lock) HSLDPF(E_ERROR_MESSAGE,"ICON2_HORZ_VERT_POSN::ICON2_LOCK data too large\n");
}
#else
#define set_ICON2_HORZ_VERT_POSN_icon2_vert_posn(reg, icon2_vert_posn) (reg)->bitfields.ICON2_VERT_POSN = icon2_vert_posn
#define set_ICON2_HORZ_VERT_POSN_icon2_horz_posn(reg, icon2_horz_posn) (reg)->bitfields.ICON2_HORZ_POSN = icon2_horz_posn
#define set_ICON2_HORZ_VERT_POSN_icon2_lock(reg, icon2_lock) (reg)->bitfields.ICON2_LOCK = icon2_lock

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ICON2_HORZ_VERT_OFF regICON2_HORZ_VERT_OFF;

#ifdef DEBUG
__inline void set_ICON2_HORZ_VERT_OFF_icon2_vert_off(regICON2_HORZ_VERT_OFF *reg, unsigned int icon2_vert_off)
{
  reg->bitfields.ICON2_VERT_OFF = icon2_vert_off;
  if (reg->bitfields.ICON2_VERT_OFF != icon2_vert_off) HSLDPF(E_ERROR_MESSAGE,"ICON2_HORZ_VERT_OFF::ICON2_VERT_OFF data too large\n");
}
__inline void set_ICON2_HORZ_VERT_OFF_icon2_horz_off(regICON2_HORZ_VERT_OFF *reg, unsigned int icon2_horz_off)
{
  reg->bitfields.ICON2_HORZ_OFF = icon2_horz_off;
  if (reg->bitfields.ICON2_HORZ_OFF != icon2_horz_off) HSLDPF(E_ERROR_MESSAGE,"ICON2_HORZ_VERT_OFF::ICON2_HORZ_OFF data too large\n");
}
__inline void set_ICON2_HORZ_VERT_OFF_icon2_lock(regICON2_HORZ_VERT_OFF *reg, unsigned int icon2_lock)
{
  reg->bitfields.ICON2_LOCK = icon2_lock;
  if (reg->bitfields.ICON2_LOCK != icon2_lock) HSLDPF(E_ERROR_MESSAGE,"ICON2_HORZ_VERT_OFF::ICON2_LOCK data too large\n");
}
#else
#define set_ICON2_HORZ_VERT_OFF_icon2_vert_off(reg, icon2_vert_off) (reg)->bitfields.ICON2_VERT_OFF = icon2_vert_off
#define set_ICON2_HORZ_VERT_OFF_icon2_horz_off(reg, icon2_horz_off) (reg)->bitfields.ICON2_HORZ_OFF = icon2_horz_off
#define set_ICON2_HORZ_VERT_OFF_icon2_lock(reg, icon2_lock) (reg)->bitfields.ICON2_LOCK = icon2_lock

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ICON2_CLR0 regICON2_CLR0;

#ifdef DEBUG
__inline void set_ICON2_CLR0_icon2_clr0_b(regICON2_CLR0 *reg, unsigned int icon2_clr0_b)
{
  reg->bitfields.ICON2_CLR0_B = icon2_clr0_b;
  if (reg->bitfields.ICON2_CLR0_B != icon2_clr0_b) HSLDPF(E_ERROR_MESSAGE,"ICON2_CLR0::ICON2_CLR0_B data too large\n");
}
__inline void set_ICON2_CLR0_icon2_clr0_g(regICON2_CLR0 *reg, unsigned int icon2_clr0_g)
{
  reg->bitfields.ICON2_CLR0_G = icon2_clr0_g;
  if (reg->bitfields.ICON2_CLR0_G != icon2_clr0_g) HSLDPF(E_ERROR_MESSAGE,"ICON2_CLR0::ICON2_CLR0_G data too large\n");
}
__inline void set_ICON2_CLR0_icon2_clr0_r(regICON2_CLR0 *reg, unsigned int icon2_clr0_r)
{
  reg->bitfields.ICON2_CLR0_R = icon2_clr0_r;
  if (reg->bitfields.ICON2_CLR0_R != icon2_clr0_r) HSLDPF(E_ERROR_MESSAGE,"ICON2_CLR0::ICON2_CLR0_R data too large\n");
}
#else
#define set_ICON2_CLR0_icon2_clr0_b(reg, icon2_clr0_b) (reg)->bitfields.ICON2_CLR0_B = icon2_clr0_b
#define set_ICON2_CLR0_icon2_clr0_g(reg, icon2_clr0_g) (reg)->bitfields.ICON2_CLR0_G = icon2_clr0_g
#define set_ICON2_CLR0_icon2_clr0_r(reg, icon2_clr0_r) (reg)->bitfields.ICON2_CLR0_R = icon2_clr0_r

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ICON2_CLR1 regICON2_CLR1;

#ifdef DEBUG
__inline void set_ICON2_CLR1_icon2_clr1_b(regICON2_CLR1 *reg, unsigned int icon2_clr1_b)
{
  reg->bitfields.ICON2_CLR1_B = icon2_clr1_b;
  if (reg->bitfields.ICON2_CLR1_B != icon2_clr1_b) HSLDPF(E_ERROR_MESSAGE,"ICON2_CLR1::ICON2_CLR1_B data too large\n");
}
__inline void set_ICON2_CLR1_icon2_clr1_g(regICON2_CLR1 *reg, unsigned int icon2_clr1_g)
{
  reg->bitfields.ICON2_CLR1_G = icon2_clr1_g;
  if (reg->bitfields.ICON2_CLR1_G != icon2_clr1_g) HSLDPF(E_ERROR_MESSAGE,"ICON2_CLR1::ICON2_CLR1_G data too large\n");
}
__inline void set_ICON2_CLR1_icon2_clr1_r(regICON2_CLR1 *reg, unsigned int icon2_clr1_r)
{
  reg->bitfields.ICON2_CLR1_R = icon2_clr1_r;
  if (reg->bitfields.ICON2_CLR1_R != icon2_clr1_r) HSLDPF(E_ERROR_MESSAGE,"ICON2_CLR1::ICON2_CLR1_R data too large\n");
}
#else
#define set_ICON2_CLR1_icon2_clr1_b(reg, icon2_clr1_b) (reg)->bitfields.ICON2_CLR1_B = icon2_clr1_b
#define set_ICON2_CLR1_icon2_clr1_g(reg, icon2_clr1_g) (reg)->bitfields.ICON2_CLR1_G = icon2_clr1_g
#define set_ICON2_CLR1_icon2_clr1_r(reg, icon2_clr1_r) (reg)->bitfields.ICON2_CLR1_R = icon2_clr1_r

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GRPH2_BUFFER_CNTL regGRPH2_BUFFER_CNTL;

#ifdef DEBUG
__inline void set_GRPH2_BUFFER_CNTL_grph2_start_req(regGRPH2_BUFFER_CNTL *reg, unsigned int grph2_start_req)
{
  reg->bitfields.GRPH2_START_REQ = grph2_start_req;
  if (reg->bitfields.GRPH2_START_REQ != grph2_start_req) HSLDPF(E_ERROR_MESSAGE,"GRPH2_BUFFER_CNTL::GRPH2_START_REQ data too large\n");
}
__inline void set_GRPH2_BUFFER_CNTL_grph2_stop_req(regGRPH2_BUFFER_CNTL *reg, unsigned int grph2_stop_req)
{
  reg->bitfields.GRPH2_STOP_REQ = grph2_stop_req;
  if (reg->bitfields.GRPH2_STOP_REQ != grph2_stop_req) HSLDPF(E_ERROR_MESSAGE,"GRPH2_BUFFER_CNTL::GRPH2_STOP_REQ data too large\n");
}
__inline void set_GRPH2_BUFFER_CNTL_grph2_critical_point(regGRPH2_BUFFER_CNTL *reg, unsigned int grph2_critical_point)
{
  reg->bitfields.GRPH2_CRITICAL_POINT = grph2_critical_point;
  if (reg->bitfields.GRPH2_CRITICAL_POINT != grph2_critical_point) HSLDPF(E_ERROR_MESSAGE,"GRPH2_BUFFER_CNTL::GRPH2_CRITICAL_POINT data too large\n");
}
__inline void set_GRPH2_BUFFER_CNTL_grph2_critical_cntl(regGRPH2_BUFFER_CNTL *reg, unsigned int grph2_critical_cntl)
{
  reg->bitfields.GRPH2_CRITICAL_CNTL = grph2_critical_cntl;
  if (reg->bitfields.GRPH2_CRITICAL_CNTL != grph2_critical_cntl) HSLDPF(E_ERROR_MESSAGE,"GRPH2_BUFFER_CNTL::GRPH2_CRITICAL_CNTL data too large\n");
}
__inline void set_GRPH2_BUFFER_CNTL_grph2_buffer_size(regGRPH2_BUFFER_CNTL *reg, unsigned int grph2_buffer_size)
{
  reg->bitfields.GRPH2_BUFFER_SIZE = grph2_buffer_size;
  if (reg->bitfields.GRPH2_BUFFER_SIZE != grph2_buffer_size) HSLDPF(E_ERROR_MESSAGE,"GRPH2_BUFFER_CNTL::GRPH2_BUFFER_SIZE data too large\n");
}
__inline void set_GRPH2_BUFFER_CNTL_grph2_critical_at_sof(regGRPH2_BUFFER_CNTL *reg, unsigned int grph2_critical_at_sof)
{
  reg->bitfields.GRPH2_CRITICAL_AT_SOF = grph2_critical_at_sof;
  if (reg->bitfields.GRPH2_CRITICAL_AT_SOF != grph2_critical_at_sof) HSLDPF(E_ERROR_MESSAGE,"GRPH2_BUFFER_CNTL::GRPH2_CRITICAL_AT_SOF data too large\n");
}
__inline void set_GRPH2_BUFFER_CNTL_grph2_stop_cntl(regGRPH2_BUFFER_CNTL *reg, unsigned int grph2_stop_cntl)
{
  reg->bitfields.GRPH2_STOP_CNTL = grph2_stop_cntl;
  if (reg->bitfields.GRPH2_STOP_CNTL != grph2_stop_cntl) HSLDPF(E_ERROR_MESSAGE,"GRPH2_BUFFER_CNTL::GRPH2_STOP_CNTL data too large\n");
}
#else
#define set_GRPH2_BUFFER_CNTL_grph2_start_req(reg, grph2_start_req) (reg)->bitfields.GRPH2_START_REQ = grph2_start_req
#define set_GRPH2_BUFFER_CNTL_grph2_stop_req(reg, grph2_stop_req) (reg)->bitfields.GRPH2_STOP_REQ = grph2_stop_req
#define set_GRPH2_BUFFER_CNTL_grph2_critical_point(reg, grph2_critical_point) (reg)->bitfields.GRPH2_CRITICAL_POINT = grph2_critical_point
#define set_GRPH2_BUFFER_CNTL_grph2_critical_cntl(reg, grph2_critical_cntl) (reg)->bitfields.GRPH2_CRITICAL_CNTL = grph2_critical_cntl
#define set_GRPH2_BUFFER_CNTL_grph2_buffer_size(reg, grph2_buffer_size) (reg)->bitfields.GRPH2_BUFFER_SIZE = grph2_buffer_size
#define set_GRPH2_BUFFER_CNTL_grph2_critical_at_sof(reg, grph2_critical_at_sof) (reg)->bitfields.GRPH2_CRITICAL_AT_SOF = grph2_critical_at_sof
#define set_GRPH2_BUFFER_CNTL_grph2_stop_cntl(reg, grph2_stop_cntl) (reg)->bitfields.GRPH2_STOP_CNTL = grph2_stop_cntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250CRTC2_GEN_CNTL regrv250CRTC2_GEN_CNTL;

#ifdef DEBUG
__inline void set_rv250CRTC2_GEN_CNTL_crtc2_dbl_scan_en(regrv250CRTC2_GEN_CNTL *reg, unsigned int crtc2_dbl_scan_en)
{
  reg->bitfields.CRTC2_DBL_SCAN_EN = crtc2_dbl_scan_en;
  if (reg->bitfields.CRTC2_DBL_SCAN_EN != crtc2_dbl_scan_en) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC2_GEN_CNTL::CRTC2_DBL_SCAN_EN data too large\n");
}
__inline void set_rv250CRTC2_GEN_CNTL_crtc2_interlace_en(regrv250CRTC2_GEN_CNTL *reg, unsigned int crtc2_interlace_en)
{
  reg->bitfields.CRTC2_INTERLACE_EN = crtc2_interlace_en;
  if (reg->bitfields.CRTC2_INTERLACE_EN != crtc2_interlace_en) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC2_GEN_CNTL::CRTC2_INTERLACE_EN data too large\n");
}
__inline void set_rv250CRTC2_GEN_CNTL_crtc2_sync_tristate(regrv250CRTC2_GEN_CNTL *reg, unsigned int crtc2_sync_tristate)
{
  reg->bitfields.CRTC2_SYNC_TRISTATE = crtc2_sync_tristate;
  if (reg->bitfields.CRTC2_SYNC_TRISTATE != crtc2_sync_tristate) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC2_GEN_CNTL::CRTC2_SYNC_TRISTATE data too large\n");
}
__inline void set_rv250CRTC2_GEN_CNTL_crtc2_hsync_tristate(regrv250CRTC2_GEN_CNTL *reg, unsigned int crtc2_hsync_tristate)
{
  reg->bitfields.CRTC2_HSYNC_TRISTATE = crtc2_hsync_tristate;
  if (reg->bitfields.CRTC2_HSYNC_TRISTATE != crtc2_hsync_tristate) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC2_GEN_CNTL::CRTC2_HSYNC_TRISTATE data too large\n");
}
__inline void set_rv250CRTC2_GEN_CNTL_crtc2_vsync_tristate(regrv250CRTC2_GEN_CNTL *reg, unsigned int crtc2_vsync_tristate)
{
  reg->bitfields.CRTC2_VSYNC_TRISTATE = crtc2_vsync_tristate;
  if (reg->bitfields.CRTC2_VSYNC_TRISTATE != crtc2_vsync_tristate) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC2_GEN_CNTL::CRTC2_VSYNC_TRISTATE data too large\n");
}
__inline void set_rv250CRTC2_GEN_CNTL_crt2_on(regrv250CRTC2_GEN_CNTL *reg, unsigned int crt2_on)
{
  reg->bitfields.CRT2_ON = crt2_on;
  if (reg->bitfields.CRT2_ON != crt2_on) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC2_GEN_CNTL::CRT2_ON data too large\n");
}
__inline void set_rv250CRTC2_GEN_CNTL_crtc2_pix_width(regrv250CRTC2_GEN_CNTL *reg, unsigned int crtc2_pix_width)
{
  reg->bitfields.CRTC2_PIX_WIDTH = crtc2_pix_width;
  if (reg->bitfields.CRTC2_PIX_WIDTH != crtc2_pix_width) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC2_GEN_CNTL::CRTC2_PIX_WIDTH data too large\n");
}
__inline void set_rv250CRTC2_GEN_CNTL_crtc2_mode9_color_order(regrv250CRTC2_GEN_CNTL *reg, unsigned int crtc2_mode9_color_order)
{
  reg->bitfields.CRTC2_MODE9_COLOR_ORDER = crtc2_mode9_color_order;
  if (reg->bitfields.CRTC2_MODE9_COLOR_ORDER != crtc2_mode9_color_order) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC2_GEN_CNTL::CRTC2_MODE9_COLOR_ORDER data too large\n");
}
__inline void set_rv250CRTC2_GEN_CNTL_crtc2_bypass_lut_en(regrv250CRTC2_GEN_CNTL *reg, unsigned int crtc2_bypass_lut_en)
{
  reg->bitfields.CRTC2_BYPASS_LUT_EN = crtc2_bypass_lut_en;
  if (reg->bitfields.CRTC2_BYPASS_LUT_EN != crtc2_bypass_lut_en) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC2_GEN_CNTL::CRTC2_BYPASS_LUT_EN data too large\n");
}
__inline void set_rv250CRTC2_GEN_CNTL_crtc2_icon_en(regrv250CRTC2_GEN_CNTL *reg, unsigned int crtc2_icon_en)
{
  reg->bitfields.CRTC2_ICON_EN = crtc2_icon_en;
  if (reg->bitfields.CRTC2_ICON_EN != crtc2_icon_en) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC2_GEN_CNTL::CRTC2_ICON_EN data too large\n");
}
__inline void set_rv250CRTC2_GEN_CNTL_crtc2_cur_en(regrv250CRTC2_GEN_CNTL *reg, unsigned int crtc2_cur_en)
{
  reg->bitfields.CRTC2_CUR_EN = crtc2_cur_en;
  if (reg->bitfields.CRTC2_CUR_EN != crtc2_cur_en) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC2_GEN_CNTL::CRTC2_CUR_EN data too large\n");
}
__inline void set_rv250CRTC2_GEN_CNTL_crtc2_cur_mode(regrv250CRTC2_GEN_CNTL *reg, unsigned int crtc2_cur_mode)
{
  reg->bitfields.CRTC2_CUR_MODE = crtc2_cur_mode;
  if (reg->bitfields.CRTC2_CUR_MODE != crtc2_cur_mode) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC2_GEN_CNTL::CRTC2_CUR_MODE data too large\n");
}
__inline void set_rv250CRTC2_GEN_CNTL_crtc2_display_dis(regrv250CRTC2_GEN_CNTL *reg, unsigned int crtc2_display_dis)
{
  reg->bitfields.CRTC2_DISPLAY_DIS = crtc2_display_dis;
  if (reg->bitfields.CRTC2_DISPLAY_DIS != crtc2_display_dis) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC2_GEN_CNTL::CRTC2_DISPLAY_DIS data too large\n");
}
__inline void set_rv250CRTC2_GEN_CNTL_crtc2_en(regrv250CRTC2_GEN_CNTL *reg, unsigned int crtc2_en)
{
  reg->bitfields.CRTC2_EN = crtc2_en;
  if (reg->bitfields.CRTC2_EN != crtc2_en) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC2_GEN_CNTL::CRTC2_EN data too large\n");
}
__inline void set_rv250CRTC2_GEN_CNTL_crtc2_disp_req_en_b(regrv250CRTC2_GEN_CNTL *reg, unsigned int crtc2_disp_req_en_b)
{
  reg->bitfields.CRTC2_DISP_REQ_EN_B = crtc2_disp_req_en_b;
  if (reg->bitfields.CRTC2_DISP_REQ_EN_B != crtc2_disp_req_en_b) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC2_GEN_CNTL::CRTC2_DISP_REQ_EN_B data too large\n");
}
__inline void set_rv250CRTC2_GEN_CNTL_crtc2_c_sync_en(regrv250CRTC2_GEN_CNTL *reg, unsigned int crtc2_c_sync_en)
{
  reg->bitfields.CRTC2_C_SYNC_EN = crtc2_c_sync_en;
  if (reg->bitfields.CRTC2_C_SYNC_EN != crtc2_c_sync_en) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC2_GEN_CNTL::CRTC2_C_SYNC_EN data too large\n");
}
__inline void set_rv250CRTC2_GEN_CNTL_crtc2_hsync_dis(regrv250CRTC2_GEN_CNTL *reg, unsigned int crtc2_hsync_dis)
{
  reg->bitfields.CRTC2_HSYNC_DIS = crtc2_hsync_dis;
  if (reg->bitfields.CRTC2_HSYNC_DIS != crtc2_hsync_dis) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC2_GEN_CNTL::CRTC2_HSYNC_DIS data too large\n");
}
__inline void set_rv250CRTC2_GEN_CNTL_crtc2_vsync_dis(regrv250CRTC2_GEN_CNTL *reg, unsigned int crtc2_vsync_dis)
{
  reg->bitfields.CRTC2_VSYNC_DIS = crtc2_vsync_dis;
  if (reg->bitfields.CRTC2_VSYNC_DIS != crtc2_vsync_dis) HSLDPF(E_ERROR_MESSAGE,"rv250CRTC2_GEN_CNTL::CRTC2_VSYNC_DIS data too large\n");
}
#else
#define set_rv250CRTC2_GEN_CNTL_crtc2_dbl_scan_en(reg, crtc2_dbl_scan_en) (reg)->bitfields.CRTC2_DBL_SCAN_EN = crtc2_dbl_scan_en
#define set_rv250CRTC2_GEN_CNTL_crtc2_interlace_en(reg, crtc2_interlace_en) (reg)->bitfields.CRTC2_INTERLACE_EN = crtc2_interlace_en
#define set_rv250CRTC2_GEN_CNTL_crtc2_sync_tristate(reg, crtc2_sync_tristate) (reg)->bitfields.CRTC2_SYNC_TRISTATE = crtc2_sync_tristate
#define set_rv250CRTC2_GEN_CNTL_crtc2_hsync_tristate(reg, crtc2_hsync_tristate) (reg)->bitfields.CRTC2_HSYNC_TRISTATE = crtc2_hsync_tristate
#define set_rv250CRTC2_GEN_CNTL_crtc2_vsync_tristate(reg, crtc2_vsync_tristate) (reg)->bitfields.CRTC2_VSYNC_TRISTATE = crtc2_vsync_tristate
#define set_rv250CRTC2_GEN_CNTL_crt2_on(reg, crt2_on) (reg)->bitfields.CRT2_ON = crt2_on
#define set_rv250CRTC2_GEN_CNTL_crtc2_pix_width(reg, crtc2_pix_width) (reg)->bitfields.CRTC2_PIX_WIDTH = crtc2_pix_width
#define set_rv250CRTC2_GEN_CNTL_crtc2_mode9_color_order(reg, crtc2_mode9_color_order) (reg)->bitfields.CRTC2_MODE9_COLOR_ORDER = crtc2_mode9_color_order
#define set_rv250CRTC2_GEN_CNTL_crtc2_bypass_lut_en(reg, crtc2_bypass_lut_en) (reg)->bitfields.CRTC2_BYPASS_LUT_EN = crtc2_bypass_lut_en
#define set_rv250CRTC2_GEN_CNTL_crtc2_icon_en(reg, crtc2_icon_en) (reg)->bitfields.CRTC2_ICON_EN = crtc2_icon_en
#define set_rv250CRTC2_GEN_CNTL_crtc2_cur_en(reg, crtc2_cur_en) (reg)->bitfields.CRTC2_CUR_EN = crtc2_cur_en
#define set_rv250CRTC2_GEN_CNTL_crtc2_cur_mode(reg, crtc2_cur_mode) (reg)->bitfields.CRTC2_CUR_MODE = crtc2_cur_mode
#define set_rv250CRTC2_GEN_CNTL_crtc2_display_dis(reg, crtc2_display_dis) (reg)->bitfields.CRTC2_DISPLAY_DIS = crtc2_display_dis
#define set_rv250CRTC2_GEN_CNTL_crtc2_en(reg, crtc2_en) (reg)->bitfields.CRTC2_EN = crtc2_en
#define set_rv250CRTC2_GEN_CNTL_crtc2_disp_req_en_b(reg, crtc2_disp_req_en_b) (reg)->bitfields.CRTC2_DISP_REQ_EN_B = crtc2_disp_req_en_b
#define set_rv250CRTC2_GEN_CNTL_crtc2_c_sync_en(reg, crtc2_c_sync_en) (reg)->bitfields.CRTC2_C_SYNC_EN = crtc2_c_sync_en
#define set_rv250CRTC2_GEN_CNTL_crtc2_hsync_dis(reg, crtc2_hsync_dis) (reg)->bitfields.CRTC2_HSYNC_DIS = crtc2_hsync_dis
#define set_rv250CRTC2_GEN_CNTL_crtc2_vsync_dis(reg, crtc2_vsync_dis) (reg)->bitfields.CRTC2_VSYNC_DIS = crtc2_vsync_dis

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC2_STATUS regCRTC2_STATUS;

#ifdef DEBUG
__inline void set_CRTC2_STATUS_crtc2_vblank_cur(regCRTC2_STATUS *reg, unsigned int crtc2_vblank_cur)
{
  reg->bitfields.CRTC2_VBLANK_CUR = crtc2_vblank_cur;
  if (reg->bitfields.CRTC2_VBLANK_CUR != crtc2_vblank_cur) HSLDPF(E_ERROR_MESSAGE,"CRTC2_STATUS::CRTC2_VBLANK_CUR data too large\n");
}
__inline void set_CRTC2_STATUS_crtc2_vblank_save(regCRTC2_STATUS *reg, unsigned int crtc2_vblank_save)
{
  reg->bitfields.CRTC2_VBLANK_SAVE = crtc2_vblank_save;
  if (reg->bitfields.CRTC2_VBLANK_SAVE != crtc2_vblank_save) HSLDPF(E_ERROR_MESSAGE,"CRTC2_STATUS::CRTC2_VBLANK_SAVE data too large\n");
}
__inline void set_CRTC2_STATUS_crtc2_vline_sync(regCRTC2_STATUS *reg, unsigned int crtc2_vline_sync)
{
  reg->bitfields.CRTC2_VLINE_SYNC = crtc2_vline_sync;
  if (reg->bitfields.CRTC2_VLINE_SYNC != crtc2_vline_sync) HSLDPF(E_ERROR_MESSAGE,"CRTC2_STATUS::CRTC2_VLINE_SYNC data too large\n");
}
__inline void set_CRTC2_STATUS_crtc2_frame(regCRTC2_STATUS *reg, unsigned int crtc2_frame)
{
  reg->bitfields.CRTC2_FRAME = crtc2_frame;
  if (reg->bitfields.CRTC2_FRAME != crtc2_frame) HSLDPF(E_ERROR_MESSAGE,"CRTC2_STATUS::CRTC2_FRAME data too large\n");
}
#else
#define set_CRTC2_STATUS_crtc2_vblank_cur(reg, crtc2_vblank_cur) (reg)->bitfields.CRTC2_VBLANK_CUR = crtc2_vblank_cur
#define set_CRTC2_STATUS_crtc2_vblank_save(reg, crtc2_vblank_save) (reg)->bitfields.CRTC2_VBLANK_SAVE = crtc2_vblank_save
#define set_CRTC2_STATUS_crtc2_vline_sync(reg, crtc2_vline_sync) (reg)->bitfields.CRTC2_VLINE_SYNC = crtc2_vline_sync
#define set_CRTC2_STATUS_crtc2_frame(reg, crtc2_frame) (reg)->bitfields.CRTC2_FRAME = crtc2_frame

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_Y_X_START regOV0_Y_X_START;

#ifdef DEBUG
__inline void set_OV0_Y_X_START_ov0_x_start(regOV0_Y_X_START *reg, unsigned int ov0_x_start)
{
  reg->bitfields.OV0_X_START = ov0_x_start;
  if (reg->bitfields.OV0_X_START != ov0_x_start) HSLDPF(E_ERROR_MESSAGE,"OV0_Y_X_START::OV0_X_START data too large\n");
}
__inline void set_OV0_Y_X_START_ov0_y_start(regOV0_Y_X_START *reg, unsigned int ov0_y_start)
{
  reg->bitfields.OV0_Y_START = ov0_y_start;
  if (reg->bitfields.OV0_Y_START != ov0_y_start) HSLDPF(E_ERROR_MESSAGE,"OV0_Y_X_START::OV0_Y_START data too large\n");
}
#else
#define set_OV0_Y_X_START_ov0_x_start(reg, ov0_x_start) (reg)->bitfields.OV0_X_START = ov0_x_start
#define set_OV0_Y_X_START_ov0_y_start(reg, ov0_y_start) (reg)->bitfields.OV0_Y_START = ov0_y_start

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_Y_X_END regOV0_Y_X_END;

#ifdef DEBUG
__inline void set_OV0_Y_X_END_ov0_x_end(regOV0_Y_X_END *reg, unsigned int ov0_x_end)
{
  reg->bitfields.OV0_X_END = ov0_x_end;
  if (reg->bitfields.OV0_X_END != ov0_x_end) HSLDPF(E_ERROR_MESSAGE,"OV0_Y_X_END::OV0_X_END data too large\n");
}
__inline void set_OV0_Y_X_END_ov0_y_end(regOV0_Y_X_END *reg, unsigned int ov0_y_end)
{
  reg->bitfields.OV0_Y_END = ov0_y_end;
  if (reg->bitfields.OV0_Y_END != ov0_y_end) HSLDPF(E_ERROR_MESSAGE,"OV0_Y_X_END::OV0_Y_END data too large\n");
}
#else
#define set_OV0_Y_X_END_ov0_x_end(reg, ov0_x_end) (reg)->bitfields.OV0_X_END = ov0_x_end
#define set_OV0_Y_X_END_ov0_y_end(reg, ov0_y_end) (reg)->bitfields.OV0_Y_END = ov0_y_end

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_PIPELINE_CNTL regOV0_PIPELINE_CNTL;

#ifdef DEBUG
__inline void set_OV0_PIPELINE_CNTL_ov0_disp_pipe_delay(regOV0_PIPELINE_CNTL *reg, unsigned int ov0_disp_pipe_delay)
{
  reg->bitfields.OV0_DISP_PIPE_DELAY = ov0_disp_pipe_delay;
  if (reg->bitfields.OV0_DISP_PIPE_DELAY != ov0_disp_pipe_delay) HSLDPF(E_ERROR_MESSAGE,"OV0_PIPELINE_CNTL::OV0_DISP_PIPE_DELAY data too large\n");
}
#else
#define set_OV0_PIPELINE_CNTL_ov0_disp_pipe_delay(reg, ov0_disp_pipe_delay) (reg)->bitfields.OV0_DISP_PIPE_DELAY = ov0_disp_pipe_delay

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_REG_LOAD_CNTL regOV0_REG_LOAD_CNTL;

#ifdef DEBUG
__inline void set_OV0_REG_LOAD_CNTL_ov0_lock(regOV0_REG_LOAD_CNTL *reg, unsigned int ov0_lock)
{
  reg->bitfields.OV0_LOCK = ov0_lock;
  if (reg->bitfields.OV0_LOCK != ov0_lock) HSLDPF(E_ERROR_MESSAGE,"OV0_REG_LOAD_CNTL::OV0_LOCK data too large\n");
}
__inline void set_OV0_REG_LOAD_CNTL_ov0_vblank_during_lock(regOV0_REG_LOAD_CNTL *reg, unsigned int ov0_vblank_during_lock)
{
  reg->bitfields.OV0_VBLANK_DURING_LOCK = ov0_vblank_during_lock;
  if (reg->bitfields.OV0_VBLANK_DURING_LOCK != ov0_vblank_during_lock) HSLDPF(E_ERROR_MESSAGE,"OV0_REG_LOAD_CNTL::OV0_VBLANK_DURING_LOCK data too large\n");
}
__inline void set_OV0_REG_LOAD_CNTL_ov0_stall_gui_until_flip(regOV0_REG_LOAD_CNTL *reg, unsigned int ov0_stall_gui_until_flip)
{
  reg->bitfields.OV0_STALL_GUI_UNTIL_FLIP = ov0_stall_gui_until_flip;
  if (reg->bitfields.OV0_STALL_GUI_UNTIL_FLIP != ov0_stall_gui_until_flip) HSLDPF(E_ERROR_MESSAGE,"OV0_REG_LOAD_CNTL::OV0_STALL_GUI_UNTIL_FLIP data too large\n");
}
__inline void set_OV0_REG_LOAD_CNTL_ov0_lock_readback(regOV0_REG_LOAD_CNTL *reg, unsigned int ov0_lock_readback)
{
  reg->bitfields.OV0_LOCK_READBACK = ov0_lock_readback;
  if (reg->bitfields.OV0_LOCK_READBACK != ov0_lock_readback) HSLDPF(E_ERROR_MESSAGE,"OV0_REG_LOAD_CNTL::OV0_LOCK_READBACK data too large\n");
}
__inline void set_OV0_REG_LOAD_CNTL_ov0_flip_readback(regOV0_REG_LOAD_CNTL *reg, unsigned int ov0_flip_readback)
{
  reg->bitfields.OV0_FLIP_READBACK = ov0_flip_readback;
  if (reg->bitfields.OV0_FLIP_READBACK != ov0_flip_readback) HSLDPF(E_ERROR_MESSAGE,"OV0_REG_LOAD_CNTL::OV0_FLIP_READBACK data too large\n");
}
#else
#define set_OV0_REG_LOAD_CNTL_ov0_lock(reg, ov0_lock) (reg)->bitfields.OV0_LOCK = ov0_lock
#define set_OV0_REG_LOAD_CNTL_ov0_vblank_during_lock(reg, ov0_vblank_during_lock) (reg)->bitfields.OV0_VBLANK_DURING_LOCK = ov0_vblank_during_lock
#define set_OV0_REG_LOAD_CNTL_ov0_stall_gui_until_flip(reg, ov0_stall_gui_until_flip) (reg)->bitfields.OV0_STALL_GUI_UNTIL_FLIP = ov0_stall_gui_until_flip
#define set_OV0_REG_LOAD_CNTL_ov0_lock_readback(reg, ov0_lock_readback) (reg)->bitfields.OV0_LOCK_READBACK = ov0_lock_readback
#define set_OV0_REG_LOAD_CNTL_ov0_flip_readback(reg, ov0_flip_readback) (reg)->bitfields.OV0_FLIP_READBACK = ov0_flip_readback

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250OV0_SCALE_CNTL regrv250OV0_SCALE_CNTL;

#ifdef DEBUG
__inline void set_rv250OV0_SCALE_CNTL_ov0_no_read_behind_scan(regrv250OV0_SCALE_CNTL *reg, unsigned int ov0_no_read_behind_scan)
{
  reg->bitfields.OV0_NO_READ_BEHIND_SCAN = ov0_no_read_behind_scan;
  if (reg->bitfields.OV0_NO_READ_BEHIND_SCAN != ov0_no_read_behind_scan) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_SCALE_CNTL::OV0_NO_READ_BEHIND_SCAN data too large\n");
}
__inline void set_rv250OV0_SCALE_CNTL_ov0_horz_pick_nearest(regrv250OV0_SCALE_CNTL *reg, unsigned int ov0_horz_pick_nearest)
{
  reg->bitfields.OV0_HORZ_PICK_NEAREST = ov0_horz_pick_nearest;
  if (reg->bitfields.OV0_HORZ_PICK_NEAREST != ov0_horz_pick_nearest) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_SCALE_CNTL::OV0_HORZ_PICK_NEAREST data too large\n");
}
__inline void set_rv250OV0_SCALE_CNTL_ov0_vert_pick_nearest(regrv250OV0_SCALE_CNTL *reg, unsigned int ov0_vert_pick_nearest)
{
  reg->bitfields.OV0_VERT_PICK_NEAREST = ov0_vert_pick_nearest;
  if (reg->bitfields.OV0_VERT_PICK_NEAREST != ov0_vert_pick_nearest) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_SCALE_CNTL::OV0_VERT_PICK_NEAREST data too large\n");
}
__inline void set_rv250OV0_SCALE_CNTL_ov0_signed_uv(regrv250OV0_SCALE_CNTL *reg, unsigned int ov0_signed_uv)
{
  reg->bitfields.OV0_SIGNED_UV = ov0_signed_uv;
  if (reg->bitfields.OV0_SIGNED_UV != ov0_signed_uv) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_SCALE_CNTL::OV0_SIGNED_UV data too large\n");
}
__inline void set_rv250OV0_SCALE_CNTL_ov0_gamma_sel(regrv250OV0_SCALE_CNTL *reg, unsigned int ov0_gamma_sel)
{
  reg->bitfields.OV0_GAMMA_SEL = ov0_gamma_sel;
  if (reg->bitfields.OV0_GAMMA_SEL != ov0_gamma_sel) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_SCALE_CNTL::OV0_GAMMA_SEL data too large\n");
}
__inline void set_rv250OV0_SCALE_CNTL_ov0_surface_format(regrv250OV0_SCALE_CNTL *reg, unsigned int ov0_surface_format)
{
  reg->bitfields.OV0_SURFACE_FORMAT = ov0_surface_format;
  if (reg->bitfields.OV0_SURFACE_FORMAT != ov0_surface_format) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_SCALE_CNTL::OV0_SURFACE_FORMAT data too large\n");
}
__inline void set_rv250OV0_SCALE_CNTL_ov0_adaptive_deint(regrv250OV0_SCALE_CNTL *reg, unsigned int ov0_adaptive_deint)
{
  reg->bitfields.OV0_ADAPTIVE_DEINT = ov0_adaptive_deint;
  if (reg->bitfields.OV0_ADAPTIVE_DEINT != ov0_adaptive_deint) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_SCALE_CNTL::OV0_ADAPTIVE_DEINT data too large\n");
}
__inline void set_rv250OV0_SCALE_CNTL_ov0_crtc_sel(regrv250OV0_SCALE_CNTL *reg, unsigned int ov0_crtc_sel)
{
  reg->bitfields.OV0_CRTC_SEL = ov0_crtc_sel;
  if (reg->bitfields.OV0_CRTC_SEL != ov0_crtc_sel) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_SCALE_CNTL::OV0_CRTC_SEL data too large\n");
}
__inline void set_rv250OV0_SCALE_CNTL_ov0_burst_per_plane(regrv250OV0_SCALE_CNTL *reg, unsigned int ov0_burst_per_plane)
{
  reg->bitfields.OV0_BURST_PER_PLANE = ov0_burst_per_plane;
  if (reg->bitfields.OV0_BURST_PER_PLANE != ov0_burst_per_plane) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_SCALE_CNTL::OV0_BURST_PER_PLANE data too large\n");
}
__inline void set_rv250OV0_SCALE_CNTL_ov0_double_buffer_regs(regrv250OV0_SCALE_CNTL *reg, unsigned int ov0_double_buffer_regs)
{
  reg->bitfields.OV0_DOUBLE_BUFFER_REGS = ov0_double_buffer_regs;
  if (reg->bitfields.OV0_DOUBLE_BUFFER_REGS != ov0_double_buffer_regs) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_SCALE_CNTL::OV0_DOUBLE_BUFFER_REGS data too large\n");
}
__inline void set_rv250OV0_SCALE_CNTL_ov0_bandwidth(regrv250OV0_SCALE_CNTL *reg, unsigned int ov0_bandwidth)
{
  reg->bitfields.OV0_BANDWIDTH = ov0_bandwidth;
  if (reg->bitfields.OV0_BANDWIDTH != ov0_bandwidth) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_SCALE_CNTL::OV0_BANDWIDTH data too large\n");
}
__inline void set_rv250OV0_SCALE_CNTL_ov0_lin_trans_bypass(regrv250OV0_SCALE_CNTL *reg, unsigned int ov0_lin_trans_bypass)
{
  reg->bitfields.OV0_LIN_TRANS_BYPASS = ov0_lin_trans_bypass;
  if (reg->bitfields.OV0_LIN_TRANS_BYPASS != ov0_lin_trans_bypass) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_SCALE_CNTL::OV0_LIN_TRANS_BYPASS data too large\n");
}
__inline void set_rv250OV0_SCALE_CNTL_ov0_int_emu(regrv250OV0_SCALE_CNTL *reg, unsigned int ov0_int_emu)
{
  reg->bitfields.OV0_INT_EMU = ov0_int_emu;
  if (reg->bitfields.OV0_INT_EMU != ov0_int_emu) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_SCALE_CNTL::OV0_INT_EMU data too large\n");
}
__inline void set_rv250OV0_SCALE_CNTL_ov0_overlay_en(regrv250OV0_SCALE_CNTL *reg, unsigned int ov0_overlay_en)
{
  reg->bitfields.OV0_OVERLAY_EN = ov0_overlay_en;
  if (reg->bitfields.OV0_OVERLAY_EN != ov0_overlay_en) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_SCALE_CNTL::OV0_OVERLAY_EN data too large\n");
}
__inline void set_rv250OV0_SCALE_CNTL_ov0_soft_reset(regrv250OV0_SCALE_CNTL *reg, unsigned int ov0_soft_reset)
{
  reg->bitfields.OV0_SOFT_RESET = ov0_soft_reset;
  if (reg->bitfields.OV0_SOFT_RESET != ov0_soft_reset) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_SCALE_CNTL::OV0_SOFT_RESET data too large\n");
}
#else
#define set_rv250OV0_SCALE_CNTL_ov0_no_read_behind_scan(reg, ov0_no_read_behind_scan) (reg)->bitfields.OV0_NO_READ_BEHIND_SCAN = ov0_no_read_behind_scan
#define set_rv250OV0_SCALE_CNTL_ov0_horz_pick_nearest(reg, ov0_horz_pick_nearest) (reg)->bitfields.OV0_HORZ_PICK_NEAREST = ov0_horz_pick_nearest
#define set_rv250OV0_SCALE_CNTL_ov0_vert_pick_nearest(reg, ov0_vert_pick_nearest) (reg)->bitfields.OV0_VERT_PICK_NEAREST = ov0_vert_pick_nearest
#define set_rv250OV0_SCALE_CNTL_ov0_signed_uv(reg, ov0_signed_uv) (reg)->bitfields.OV0_SIGNED_UV = ov0_signed_uv
#define set_rv250OV0_SCALE_CNTL_ov0_gamma_sel(reg, ov0_gamma_sel) (reg)->bitfields.OV0_GAMMA_SEL = ov0_gamma_sel
#define set_rv250OV0_SCALE_CNTL_ov0_surface_format(reg, ov0_surface_format) (reg)->bitfields.OV0_SURFACE_FORMAT = ov0_surface_format
#define set_rv250OV0_SCALE_CNTL_ov0_adaptive_deint(reg, ov0_adaptive_deint) (reg)->bitfields.OV0_ADAPTIVE_DEINT = ov0_adaptive_deint
#define set_rv250OV0_SCALE_CNTL_ov0_crtc_sel(reg, ov0_crtc_sel) (reg)->bitfields.OV0_CRTC_SEL = ov0_crtc_sel
#define set_rv250OV0_SCALE_CNTL_ov0_burst_per_plane(reg, ov0_burst_per_plane) (reg)->bitfields.OV0_BURST_PER_PLANE = ov0_burst_per_plane
#define set_rv250OV0_SCALE_CNTL_ov0_double_buffer_regs(reg, ov0_double_buffer_regs) (reg)->bitfields.OV0_DOUBLE_BUFFER_REGS = ov0_double_buffer_regs
#define set_rv250OV0_SCALE_CNTL_ov0_bandwidth(reg, ov0_bandwidth) (reg)->bitfields.OV0_BANDWIDTH = ov0_bandwidth
#define set_rv250OV0_SCALE_CNTL_ov0_lin_trans_bypass(reg, ov0_lin_trans_bypass) (reg)->bitfields.OV0_LIN_TRANS_BYPASS = ov0_lin_trans_bypass
#define set_rv250OV0_SCALE_CNTL_ov0_int_emu(reg, ov0_int_emu) (reg)->bitfields.OV0_INT_EMU = ov0_int_emu
#define set_rv250OV0_SCALE_CNTL_ov0_overlay_en(reg, ov0_overlay_en) (reg)->bitfields.OV0_OVERLAY_EN = ov0_overlay_en
#define set_rv250OV0_SCALE_CNTL_ov0_soft_reset(reg, ov0_soft_reset) (reg)->bitfields.OV0_SOFT_RESET = ov0_soft_reset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_V_INC regOV0_V_INC;

#ifdef DEBUG
__inline void set_OV0_V_INC_ov0_v_inc(regOV0_V_INC *reg, unsigned int ov0_v_inc)
{
  reg->bitfields.OV0_V_INC = ov0_v_inc;
  if (reg->bitfields.OV0_V_INC != ov0_v_inc) HSLDPF(E_ERROR_MESSAGE,"OV0_V_INC::OV0_V_INC data too large\n");
}
#else
#define set_OV0_V_INC_ov0_v_inc(reg, ov0_v_inc) (reg)->bitfields.OV0_V_INC = ov0_v_inc

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_P1_V_ACCUM_INIT regOV0_P1_V_ACCUM_INIT;

#ifdef DEBUG
__inline void set_OV0_P1_V_ACCUM_INIT_ov0_p1_max_ln_in_per_ln_out(regOV0_P1_V_ACCUM_INIT *reg, unsigned int ov0_p1_max_ln_in_per_ln_out)
{
  reg->bitfields.OV0_P1_MAX_LN_IN_PER_LN_OUT = ov0_p1_max_ln_in_per_ln_out;
  if (reg->bitfields.OV0_P1_MAX_LN_IN_PER_LN_OUT != ov0_p1_max_ln_in_per_ln_out) HSLDPF(E_ERROR_MESSAGE,"OV0_P1_V_ACCUM_INIT::OV0_P1_MAX_LN_IN_PER_LN_OUT data too large\n");
}
__inline void set_OV0_P1_V_ACCUM_INIT_ov0_p1_v_accum_init(regOV0_P1_V_ACCUM_INIT *reg, unsigned int ov0_p1_v_accum_init)
{
  reg->bitfields.OV0_P1_V_ACCUM_INIT = ov0_p1_v_accum_init;
  if (reg->bitfields.OV0_P1_V_ACCUM_INIT != ov0_p1_v_accum_init) HSLDPF(E_ERROR_MESSAGE,"OV0_P1_V_ACCUM_INIT::OV0_P1_V_ACCUM_INIT data too large\n");
}
#else
#define set_OV0_P1_V_ACCUM_INIT_ov0_p1_max_ln_in_per_ln_out(reg, ov0_p1_max_ln_in_per_ln_out) (reg)->bitfields.OV0_P1_MAX_LN_IN_PER_LN_OUT = ov0_p1_max_ln_in_per_ln_out
#define set_OV0_P1_V_ACCUM_INIT_ov0_p1_v_accum_init(reg, ov0_p1_v_accum_init) (reg)->bitfields.OV0_P1_V_ACCUM_INIT = ov0_p1_v_accum_init

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_P23_V_ACCUM_INIT regOV0_P23_V_ACCUM_INIT;

#ifdef DEBUG
__inline void set_OV0_P23_V_ACCUM_INIT_ov0_p23_max_ln_in_per_ln_out(regOV0_P23_V_ACCUM_INIT *reg, unsigned int ov0_p23_max_ln_in_per_ln_out)
{
  reg->bitfields.OV0_P23_MAX_LN_IN_PER_LN_OUT = ov0_p23_max_ln_in_per_ln_out;
  if (reg->bitfields.OV0_P23_MAX_LN_IN_PER_LN_OUT != ov0_p23_max_ln_in_per_ln_out) HSLDPF(E_ERROR_MESSAGE,"OV0_P23_V_ACCUM_INIT::OV0_P23_MAX_LN_IN_PER_LN_OUT data too large\n");
}
__inline void set_OV0_P23_V_ACCUM_INIT_ov0_p23_v_accum_init(regOV0_P23_V_ACCUM_INIT *reg, unsigned int ov0_p23_v_accum_init)
{
  reg->bitfields.OV0_P23_V_ACCUM_INIT = ov0_p23_v_accum_init;
  if (reg->bitfields.OV0_P23_V_ACCUM_INIT != ov0_p23_v_accum_init) HSLDPF(E_ERROR_MESSAGE,"OV0_P23_V_ACCUM_INIT::OV0_P23_V_ACCUM_INIT data too large\n");
}
#else
#define set_OV0_P23_V_ACCUM_INIT_ov0_p23_max_ln_in_per_ln_out(reg, ov0_p23_max_ln_in_per_ln_out) (reg)->bitfields.OV0_P23_MAX_LN_IN_PER_LN_OUT = ov0_p23_max_ln_in_per_ln_out
#define set_OV0_P23_V_ACCUM_INIT_ov0_p23_v_accum_init(reg, ov0_p23_v_accum_init) (reg)->bitfields.OV0_P23_V_ACCUM_INIT = ov0_p23_v_accum_init

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_P1_BLANK_LINES_AT_TOP regOV0_P1_BLANK_LINES_AT_TOP;

#ifdef DEBUG
__inline void set_OV0_P1_BLANK_LINES_AT_TOP_ov0_p1_blnk_ln_at_top_m1(regOV0_P1_BLANK_LINES_AT_TOP *reg, unsigned int ov0_p1_blnk_ln_at_top_m1)
{
  reg->bitfields.OV0_P1_BLNK_LN_AT_TOP_M1 = ov0_p1_blnk_ln_at_top_m1;
  if (reg->bitfields.OV0_P1_BLNK_LN_AT_TOP_M1 != ov0_p1_blnk_ln_at_top_m1) HSLDPF(E_ERROR_MESSAGE,"OV0_P1_BLANK_LINES_AT_TOP::OV0_P1_BLNK_LN_AT_TOP_M1 data too large\n");
}
__inline void set_OV0_P1_BLANK_LINES_AT_TOP_ov0_p1_active_lines_m1(regOV0_P1_BLANK_LINES_AT_TOP *reg, unsigned int ov0_p1_active_lines_m1)
{
  reg->bitfields.OV0_P1_ACTIVE_LINES_M1 = ov0_p1_active_lines_m1;
  if (reg->bitfields.OV0_P1_ACTIVE_LINES_M1 != ov0_p1_active_lines_m1) HSLDPF(E_ERROR_MESSAGE,"OV0_P1_BLANK_LINES_AT_TOP::OV0_P1_ACTIVE_LINES_M1 data too large\n");
}
#else
#define set_OV0_P1_BLANK_LINES_AT_TOP_ov0_p1_blnk_ln_at_top_m1(reg, ov0_p1_blnk_ln_at_top_m1) (reg)->bitfields.OV0_P1_BLNK_LN_AT_TOP_M1 = ov0_p1_blnk_ln_at_top_m1
#define set_OV0_P1_BLANK_LINES_AT_TOP_ov0_p1_active_lines_m1(reg, ov0_p1_active_lines_m1) (reg)->bitfields.OV0_P1_ACTIVE_LINES_M1 = ov0_p1_active_lines_m1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_P23_BLANK_LINES_AT_TOP regOV0_P23_BLANK_LINES_AT_TOP;

#ifdef DEBUG
__inline void set_OV0_P23_BLANK_LINES_AT_TOP_ov0_p23_blnk_ln_at_top_m1(regOV0_P23_BLANK_LINES_AT_TOP *reg, unsigned int ov0_p23_blnk_ln_at_top_m1)
{
  reg->bitfields.OV0_P23_BLNK_LN_AT_TOP_M1 = ov0_p23_blnk_ln_at_top_m1;
  if (reg->bitfields.OV0_P23_BLNK_LN_AT_TOP_M1 != ov0_p23_blnk_ln_at_top_m1) HSLDPF(E_ERROR_MESSAGE,"OV0_P23_BLANK_LINES_AT_TOP::OV0_P23_BLNK_LN_AT_TOP_M1 data too large\n");
}
__inline void set_OV0_P23_BLANK_LINES_AT_TOP_ov0_p23_active_lines_m1(regOV0_P23_BLANK_LINES_AT_TOP *reg, unsigned int ov0_p23_active_lines_m1)
{
  reg->bitfields.OV0_P23_ACTIVE_LINES_M1 = ov0_p23_active_lines_m1;
  if (reg->bitfields.OV0_P23_ACTIVE_LINES_M1 != ov0_p23_active_lines_m1) HSLDPF(E_ERROR_MESSAGE,"OV0_P23_BLANK_LINES_AT_TOP::OV0_P23_ACTIVE_LINES_M1 data too large\n");
}
#else
#define set_OV0_P23_BLANK_LINES_AT_TOP_ov0_p23_blnk_ln_at_top_m1(reg, ov0_p23_blnk_ln_at_top_m1) (reg)->bitfields.OV0_P23_BLNK_LN_AT_TOP_M1 = ov0_p23_blnk_ln_at_top_m1
#define set_OV0_P23_BLANK_LINES_AT_TOP_ov0_p23_active_lines_m1(reg, ov0_p23_active_lines_m1) (reg)->bitfields.OV0_P23_ACTIVE_LINES_M1 = ov0_p23_active_lines_m1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_BASE_ADDR regOV0_BASE_ADDR;

#ifdef DEBUG
__inline void set_OV0_BASE_ADDR_ov0_base_addr(regOV0_BASE_ADDR *reg, unsigned int ov0_base_addr)
{
  reg->bitfields.OV0_BASE_ADDR = ov0_base_addr;
  if (reg->bitfields.OV0_BASE_ADDR != ov0_base_addr) HSLDPF(E_ERROR_MESSAGE,"OV0_BASE_ADDR::OV0_BASE_ADDR data too large\n");
}
#else
#define set_OV0_BASE_ADDR_ov0_base_addr(reg, ov0_base_addr) (reg)->bitfields.OV0_BASE_ADDR = ov0_base_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_VID_BUF0_BASE_ADRS regOV0_VID_BUF0_BASE_ADRS;

#ifdef DEBUG
__inline void set_OV0_VID_BUF0_BASE_ADRS_ov0_vid_buf_pitch_sel(regOV0_VID_BUF0_BASE_ADRS *reg, unsigned int ov0_vid_buf_pitch_sel)
{
  reg->bitfields.OV0_VID_BUF_PITCH_SEL = ov0_vid_buf_pitch_sel;
  if (reg->bitfields.OV0_VID_BUF_PITCH_SEL != ov0_vid_buf_pitch_sel) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF0_BASE_ADRS::OV0_VID_BUF_PITCH_SEL data too large\n");
}
__inline void set_OV0_VID_BUF0_BASE_ADRS_reserved_bit1(regOV0_VID_BUF0_BASE_ADRS *reg, unsigned int reserved_bit1)
{
  reg->bitfields.RESERVED_BIT1 = reserved_bit1;
  if (reg->bitfields.RESERVED_BIT1 != reserved_bit1) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF0_BASE_ADRS::RESERVED_BIT1 data too large\n");
}
__inline void set_OV0_VID_BUF0_BASE_ADRS_ov0_vid_buf_base_adrs(regOV0_VID_BUF0_BASE_ADRS *reg, unsigned int ov0_vid_buf_base_adrs)
{
  reg->bitfields.OV0_VID_BUF_BASE_ADRS = ov0_vid_buf_base_adrs;
  if (reg->bitfields.OV0_VID_BUF_BASE_ADRS != ov0_vid_buf_base_adrs) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF0_BASE_ADRS::OV0_VID_BUF_BASE_ADRS data too large\n");
}
__inline void set_OV0_VID_BUF0_BASE_ADRS_reserved_bit31_28(regOV0_VID_BUF0_BASE_ADRS *reg, unsigned int reserved_bit31_28)
{
  reg->bitfields.RESERVED_BIT31_28 = reserved_bit31_28;
  if (reg->bitfields.RESERVED_BIT31_28 != reserved_bit31_28) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF0_BASE_ADRS::RESERVED_BIT31_28 data too large\n");
}
#else
#define set_OV0_VID_BUF0_BASE_ADRS_ov0_vid_buf_pitch_sel(reg, ov0_vid_buf_pitch_sel) (reg)->bitfields.OV0_VID_BUF_PITCH_SEL = ov0_vid_buf_pitch_sel
#define set_OV0_VID_BUF0_BASE_ADRS_reserved_bit1(reg, reserved_bit1) (reg)->bitfields.RESERVED_BIT1 = reserved_bit1
#define set_OV0_VID_BUF0_BASE_ADRS_ov0_vid_buf_base_adrs(reg, ov0_vid_buf_base_adrs) (reg)->bitfields.OV0_VID_BUF_BASE_ADRS = ov0_vid_buf_base_adrs
#define set_OV0_VID_BUF0_BASE_ADRS_reserved_bit31_28(reg, reserved_bit31_28) (reg)->bitfields.RESERVED_BIT31_28 = reserved_bit31_28

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_VID_BUF1_BASE_ADRS regOV0_VID_BUF1_BASE_ADRS;

#ifdef DEBUG
__inline void set_OV0_VID_BUF1_BASE_ADRS_ov0_vid_buf_pitch_sel(regOV0_VID_BUF1_BASE_ADRS *reg, unsigned int ov0_vid_buf_pitch_sel)
{
  reg->bitfields.OV0_VID_BUF_PITCH_SEL = ov0_vid_buf_pitch_sel;
  if (reg->bitfields.OV0_VID_BUF_PITCH_SEL != ov0_vid_buf_pitch_sel) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF1_BASE_ADRS::OV0_VID_BUF_PITCH_SEL data too large\n");
}
__inline void set_OV0_VID_BUF1_BASE_ADRS_reserved_bit1(regOV0_VID_BUF1_BASE_ADRS *reg, unsigned int reserved_bit1)
{
  reg->bitfields.RESERVED_BIT1 = reserved_bit1;
  if (reg->bitfields.RESERVED_BIT1 != reserved_bit1) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF1_BASE_ADRS::RESERVED_BIT1 data too large\n");
}
__inline void set_OV0_VID_BUF1_BASE_ADRS_ov0_vid_buf_base_adrs(regOV0_VID_BUF1_BASE_ADRS *reg, unsigned int ov0_vid_buf_base_adrs)
{
  reg->bitfields.OV0_VID_BUF_BASE_ADRS = ov0_vid_buf_base_adrs;
  if (reg->bitfields.OV0_VID_BUF_BASE_ADRS != ov0_vid_buf_base_adrs) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF1_BASE_ADRS::OV0_VID_BUF_BASE_ADRS data too large\n");
}
__inline void set_OV0_VID_BUF1_BASE_ADRS_reserved_bit31_28(regOV0_VID_BUF1_BASE_ADRS *reg, unsigned int reserved_bit31_28)
{
  reg->bitfields.RESERVED_BIT31_28 = reserved_bit31_28;
  if (reg->bitfields.RESERVED_BIT31_28 != reserved_bit31_28) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF1_BASE_ADRS::RESERVED_BIT31_28 data too large\n");
}
#else
#define set_OV0_VID_BUF1_BASE_ADRS_ov0_vid_buf_pitch_sel(reg, ov0_vid_buf_pitch_sel) (reg)->bitfields.OV0_VID_BUF_PITCH_SEL = ov0_vid_buf_pitch_sel
#define set_OV0_VID_BUF1_BASE_ADRS_reserved_bit1(reg, reserved_bit1) (reg)->bitfields.RESERVED_BIT1 = reserved_bit1
#define set_OV0_VID_BUF1_BASE_ADRS_ov0_vid_buf_base_adrs(reg, ov0_vid_buf_base_adrs) (reg)->bitfields.OV0_VID_BUF_BASE_ADRS = ov0_vid_buf_base_adrs
#define set_OV0_VID_BUF1_BASE_ADRS_reserved_bit31_28(reg, reserved_bit31_28) (reg)->bitfields.RESERVED_BIT31_28 = reserved_bit31_28

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_VID_BUF2_BASE_ADRS regOV0_VID_BUF2_BASE_ADRS;

#ifdef DEBUG
__inline void set_OV0_VID_BUF2_BASE_ADRS_ov0_vid_buf_pitch_sel(regOV0_VID_BUF2_BASE_ADRS *reg, unsigned int ov0_vid_buf_pitch_sel)
{
  reg->bitfields.OV0_VID_BUF_PITCH_SEL = ov0_vid_buf_pitch_sel;
  if (reg->bitfields.OV0_VID_BUF_PITCH_SEL != ov0_vid_buf_pitch_sel) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF2_BASE_ADRS::OV0_VID_BUF_PITCH_SEL data too large\n");
}
__inline void set_OV0_VID_BUF2_BASE_ADRS_reserved_bit1(regOV0_VID_BUF2_BASE_ADRS *reg, unsigned int reserved_bit1)
{
  reg->bitfields.RESERVED_BIT1 = reserved_bit1;
  if (reg->bitfields.RESERVED_BIT1 != reserved_bit1) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF2_BASE_ADRS::RESERVED_BIT1 data too large\n");
}
__inline void set_OV0_VID_BUF2_BASE_ADRS_ov0_vid_buf_base_adrs(regOV0_VID_BUF2_BASE_ADRS *reg, unsigned int ov0_vid_buf_base_adrs)
{
  reg->bitfields.OV0_VID_BUF_BASE_ADRS = ov0_vid_buf_base_adrs;
  if (reg->bitfields.OV0_VID_BUF_BASE_ADRS != ov0_vid_buf_base_adrs) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF2_BASE_ADRS::OV0_VID_BUF_BASE_ADRS data too large\n");
}
__inline void set_OV0_VID_BUF2_BASE_ADRS_reserved_bit31_28(regOV0_VID_BUF2_BASE_ADRS *reg, unsigned int reserved_bit31_28)
{
  reg->bitfields.RESERVED_BIT31_28 = reserved_bit31_28;
  if (reg->bitfields.RESERVED_BIT31_28 != reserved_bit31_28) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF2_BASE_ADRS::RESERVED_BIT31_28 data too large\n");
}
#else
#define set_OV0_VID_BUF2_BASE_ADRS_ov0_vid_buf_pitch_sel(reg, ov0_vid_buf_pitch_sel) (reg)->bitfields.OV0_VID_BUF_PITCH_SEL = ov0_vid_buf_pitch_sel
#define set_OV0_VID_BUF2_BASE_ADRS_reserved_bit1(reg, reserved_bit1) (reg)->bitfields.RESERVED_BIT1 = reserved_bit1
#define set_OV0_VID_BUF2_BASE_ADRS_ov0_vid_buf_base_adrs(reg, ov0_vid_buf_base_adrs) (reg)->bitfields.OV0_VID_BUF_BASE_ADRS = ov0_vid_buf_base_adrs
#define set_OV0_VID_BUF2_BASE_ADRS_reserved_bit31_28(reg, reserved_bit31_28) (reg)->bitfields.RESERVED_BIT31_28 = reserved_bit31_28

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_VID_BUF3_BASE_ADRS regOV0_VID_BUF3_BASE_ADRS;

#ifdef DEBUG
__inline void set_OV0_VID_BUF3_BASE_ADRS_ov0_vid_buf_pitch_sel(regOV0_VID_BUF3_BASE_ADRS *reg, unsigned int ov0_vid_buf_pitch_sel)
{
  reg->bitfields.OV0_VID_BUF_PITCH_SEL = ov0_vid_buf_pitch_sel;
  if (reg->bitfields.OV0_VID_BUF_PITCH_SEL != ov0_vid_buf_pitch_sel) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF3_BASE_ADRS::OV0_VID_BUF_PITCH_SEL data too large\n");
}
__inline void set_OV0_VID_BUF3_BASE_ADRS_reserved_bit1(regOV0_VID_BUF3_BASE_ADRS *reg, unsigned int reserved_bit1)
{
  reg->bitfields.RESERVED_BIT1 = reserved_bit1;
  if (reg->bitfields.RESERVED_BIT1 != reserved_bit1) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF3_BASE_ADRS::RESERVED_BIT1 data too large\n");
}
__inline void set_OV0_VID_BUF3_BASE_ADRS_ov0_vid_buf_base_adrs(regOV0_VID_BUF3_BASE_ADRS *reg, unsigned int ov0_vid_buf_base_adrs)
{
  reg->bitfields.OV0_VID_BUF_BASE_ADRS = ov0_vid_buf_base_adrs;
  if (reg->bitfields.OV0_VID_BUF_BASE_ADRS != ov0_vid_buf_base_adrs) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF3_BASE_ADRS::OV0_VID_BUF_BASE_ADRS data too large\n");
}
__inline void set_OV0_VID_BUF3_BASE_ADRS_reserved_bit31_28(regOV0_VID_BUF3_BASE_ADRS *reg, unsigned int reserved_bit31_28)
{
  reg->bitfields.RESERVED_BIT31_28 = reserved_bit31_28;
  if (reg->bitfields.RESERVED_BIT31_28 != reserved_bit31_28) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF3_BASE_ADRS::RESERVED_BIT31_28 data too large\n");
}
#else
#define set_OV0_VID_BUF3_BASE_ADRS_ov0_vid_buf_pitch_sel(reg, ov0_vid_buf_pitch_sel) (reg)->bitfields.OV0_VID_BUF_PITCH_SEL = ov0_vid_buf_pitch_sel
#define set_OV0_VID_BUF3_BASE_ADRS_reserved_bit1(reg, reserved_bit1) (reg)->bitfields.RESERVED_BIT1 = reserved_bit1
#define set_OV0_VID_BUF3_BASE_ADRS_ov0_vid_buf_base_adrs(reg, ov0_vid_buf_base_adrs) (reg)->bitfields.OV0_VID_BUF_BASE_ADRS = ov0_vid_buf_base_adrs
#define set_OV0_VID_BUF3_BASE_ADRS_reserved_bit31_28(reg, reserved_bit31_28) (reg)->bitfields.RESERVED_BIT31_28 = reserved_bit31_28

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_VID_BUF4_BASE_ADRS regOV0_VID_BUF4_BASE_ADRS;

#ifdef DEBUG
__inline void set_OV0_VID_BUF4_BASE_ADRS_ov0_vid_buf_pitch_sel(regOV0_VID_BUF4_BASE_ADRS *reg, unsigned int ov0_vid_buf_pitch_sel)
{
  reg->bitfields.OV0_VID_BUF_PITCH_SEL = ov0_vid_buf_pitch_sel;
  if (reg->bitfields.OV0_VID_BUF_PITCH_SEL != ov0_vid_buf_pitch_sel) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF4_BASE_ADRS::OV0_VID_BUF_PITCH_SEL data too large\n");
}
__inline void set_OV0_VID_BUF4_BASE_ADRS_reserved_bit1(regOV0_VID_BUF4_BASE_ADRS *reg, unsigned int reserved_bit1)
{
  reg->bitfields.RESERVED_BIT1 = reserved_bit1;
  if (reg->bitfields.RESERVED_BIT1 != reserved_bit1) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF4_BASE_ADRS::RESERVED_BIT1 data too large\n");
}
__inline void set_OV0_VID_BUF4_BASE_ADRS_ov0_vid_buf_base_adrs(regOV0_VID_BUF4_BASE_ADRS *reg, unsigned int ov0_vid_buf_base_adrs)
{
  reg->bitfields.OV0_VID_BUF_BASE_ADRS = ov0_vid_buf_base_adrs;
  if (reg->bitfields.OV0_VID_BUF_BASE_ADRS != ov0_vid_buf_base_adrs) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF4_BASE_ADRS::OV0_VID_BUF_BASE_ADRS data too large\n");
}
__inline void set_OV0_VID_BUF4_BASE_ADRS_reserved_bit31_28(regOV0_VID_BUF4_BASE_ADRS *reg, unsigned int reserved_bit31_28)
{
  reg->bitfields.RESERVED_BIT31_28 = reserved_bit31_28;
  if (reg->bitfields.RESERVED_BIT31_28 != reserved_bit31_28) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF4_BASE_ADRS::RESERVED_BIT31_28 data too large\n");
}
#else
#define set_OV0_VID_BUF4_BASE_ADRS_ov0_vid_buf_pitch_sel(reg, ov0_vid_buf_pitch_sel) (reg)->bitfields.OV0_VID_BUF_PITCH_SEL = ov0_vid_buf_pitch_sel
#define set_OV0_VID_BUF4_BASE_ADRS_reserved_bit1(reg, reserved_bit1) (reg)->bitfields.RESERVED_BIT1 = reserved_bit1
#define set_OV0_VID_BUF4_BASE_ADRS_ov0_vid_buf_base_adrs(reg, ov0_vid_buf_base_adrs) (reg)->bitfields.OV0_VID_BUF_BASE_ADRS = ov0_vid_buf_base_adrs
#define set_OV0_VID_BUF4_BASE_ADRS_reserved_bit31_28(reg, reserved_bit31_28) (reg)->bitfields.RESERVED_BIT31_28 = reserved_bit31_28

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_VID_BUF5_BASE_ADRS regOV0_VID_BUF5_BASE_ADRS;

#ifdef DEBUG
__inline void set_OV0_VID_BUF5_BASE_ADRS_ov0_vid_buf_pitch_sel(regOV0_VID_BUF5_BASE_ADRS *reg, unsigned int ov0_vid_buf_pitch_sel)
{
  reg->bitfields.OV0_VID_BUF_PITCH_SEL = ov0_vid_buf_pitch_sel;
  if (reg->bitfields.OV0_VID_BUF_PITCH_SEL != ov0_vid_buf_pitch_sel) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF5_BASE_ADRS::OV0_VID_BUF_PITCH_SEL data too large\n");
}
__inline void set_OV0_VID_BUF5_BASE_ADRS_reserved_bit1(regOV0_VID_BUF5_BASE_ADRS *reg, unsigned int reserved_bit1)
{
  reg->bitfields.RESERVED_BIT1 = reserved_bit1;
  if (reg->bitfields.RESERVED_BIT1 != reserved_bit1) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF5_BASE_ADRS::RESERVED_BIT1 data too large\n");
}
__inline void set_OV0_VID_BUF5_BASE_ADRS_ov0_vid_buf_base_adrs(regOV0_VID_BUF5_BASE_ADRS *reg, unsigned int ov0_vid_buf_base_adrs)
{
  reg->bitfields.OV0_VID_BUF_BASE_ADRS = ov0_vid_buf_base_adrs;
  if (reg->bitfields.OV0_VID_BUF_BASE_ADRS != ov0_vid_buf_base_adrs) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF5_BASE_ADRS::OV0_VID_BUF_BASE_ADRS data too large\n");
}
__inline void set_OV0_VID_BUF5_BASE_ADRS_reserved_bit31_28(regOV0_VID_BUF5_BASE_ADRS *reg, unsigned int reserved_bit31_28)
{
  reg->bitfields.RESERVED_BIT31_28 = reserved_bit31_28;
  if (reg->bitfields.RESERVED_BIT31_28 != reserved_bit31_28) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF5_BASE_ADRS::RESERVED_BIT31_28 data too large\n");
}
#else
#define set_OV0_VID_BUF5_BASE_ADRS_ov0_vid_buf_pitch_sel(reg, ov0_vid_buf_pitch_sel) (reg)->bitfields.OV0_VID_BUF_PITCH_SEL = ov0_vid_buf_pitch_sel
#define set_OV0_VID_BUF5_BASE_ADRS_reserved_bit1(reg, reserved_bit1) (reg)->bitfields.RESERVED_BIT1 = reserved_bit1
#define set_OV0_VID_BUF5_BASE_ADRS_ov0_vid_buf_base_adrs(reg, ov0_vid_buf_base_adrs) (reg)->bitfields.OV0_VID_BUF_BASE_ADRS = ov0_vid_buf_base_adrs
#define set_OV0_VID_BUF5_BASE_ADRS_reserved_bit31_28(reg, reserved_bit31_28) (reg)->bitfields.RESERVED_BIT31_28 = reserved_bit31_28

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_VID_BUF_PITCH0_VALUE regOV0_VID_BUF_PITCH0_VALUE;

#ifdef DEBUG
__inline void set_OV0_VID_BUF_PITCH0_VALUE_ov0_pitch_value(regOV0_VID_BUF_PITCH0_VALUE *reg, unsigned int ov0_pitch_value)
{
  reg->bitfields.OV0_PITCH_VALUE = ov0_pitch_value;
  if (reg->bitfields.OV0_PITCH_VALUE != ov0_pitch_value) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF_PITCH0_VALUE::OV0_PITCH_VALUE data too large\n");
}
__inline void set_OV0_VID_BUF_PITCH0_VALUE_ov0_pitch_skip_lines(regOV0_VID_BUF_PITCH0_VALUE *reg, unsigned int ov0_pitch_skip_lines)
{
  reg->bitfields.OV0_PITCH_SKIP_LINES = ov0_pitch_skip_lines;
  if (reg->bitfields.OV0_PITCH_SKIP_LINES != ov0_pitch_skip_lines) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF_PITCH0_VALUE::OV0_PITCH_SKIP_LINES data too large\n");
}
__inline void set_OV0_VID_BUF_PITCH0_VALUE_ov0_pitch_in_tiles_lsbs(regOV0_VID_BUF_PITCH0_VALUE *reg, unsigned int ov0_pitch_in_tiles_lsbs)
{
  reg->bitfields.OV0_PITCH_IN_TILES_LSBS = ov0_pitch_in_tiles_lsbs;
  if (reg->bitfields.OV0_PITCH_IN_TILES_LSBS != ov0_pitch_in_tiles_lsbs) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF_PITCH0_VALUE::OV0_PITCH_IN_TILES_LSBS data too large\n");
}
#else
#define set_OV0_VID_BUF_PITCH0_VALUE_ov0_pitch_value(reg, ov0_pitch_value) (reg)->bitfields.OV0_PITCH_VALUE = ov0_pitch_value
#define set_OV0_VID_BUF_PITCH0_VALUE_ov0_pitch_skip_lines(reg, ov0_pitch_skip_lines) (reg)->bitfields.OV0_PITCH_SKIP_LINES = ov0_pitch_skip_lines
#define set_OV0_VID_BUF_PITCH0_VALUE_ov0_pitch_in_tiles_lsbs(reg, ov0_pitch_in_tiles_lsbs) (reg)->bitfields.OV0_PITCH_IN_TILES_LSBS = ov0_pitch_in_tiles_lsbs

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_VID_BUF_PITCH1_VALUE regOV0_VID_BUF_PITCH1_VALUE;

#ifdef DEBUG
__inline void set_OV0_VID_BUF_PITCH1_VALUE_ov0_pitch_value(regOV0_VID_BUF_PITCH1_VALUE *reg, unsigned int ov0_pitch_value)
{
  reg->bitfields.OV0_PITCH_VALUE = ov0_pitch_value;
  if (reg->bitfields.OV0_PITCH_VALUE != ov0_pitch_value) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF_PITCH1_VALUE::OV0_PITCH_VALUE data too large\n");
}
__inline void set_OV0_VID_BUF_PITCH1_VALUE_ov0_pitch_skip_lines(regOV0_VID_BUF_PITCH1_VALUE *reg, unsigned int ov0_pitch_skip_lines)
{
  reg->bitfields.OV0_PITCH_SKIP_LINES = ov0_pitch_skip_lines;
  if (reg->bitfields.OV0_PITCH_SKIP_LINES != ov0_pitch_skip_lines) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF_PITCH1_VALUE::OV0_PITCH_SKIP_LINES data too large\n");
}
__inline void set_OV0_VID_BUF_PITCH1_VALUE_ov0_pitch_in_tiles_lsbs(regOV0_VID_BUF_PITCH1_VALUE *reg, unsigned int ov0_pitch_in_tiles_lsbs)
{
  reg->bitfields.OV0_PITCH_IN_TILES_LSBS = ov0_pitch_in_tiles_lsbs;
  if (reg->bitfields.OV0_PITCH_IN_TILES_LSBS != ov0_pitch_in_tiles_lsbs) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_BUF_PITCH1_VALUE::OV0_PITCH_IN_TILES_LSBS data too large\n");
}
#else
#define set_OV0_VID_BUF_PITCH1_VALUE_ov0_pitch_value(reg, ov0_pitch_value) (reg)->bitfields.OV0_PITCH_VALUE = ov0_pitch_value
#define set_OV0_VID_BUF_PITCH1_VALUE_ov0_pitch_skip_lines(reg, ov0_pitch_skip_lines) (reg)->bitfields.OV0_PITCH_SKIP_LINES = ov0_pitch_skip_lines
#define set_OV0_VID_BUF_PITCH1_VALUE_ov0_pitch_in_tiles_lsbs(reg, ov0_pitch_in_tiles_lsbs) (reg)->bitfields.OV0_PITCH_IN_TILES_LSBS = ov0_pitch_in_tiles_lsbs

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_AUTO_FLIP_CNTRL regOV0_AUTO_FLIP_CNTRL;

#ifdef DEBUG
__inline void set_OV0_AUTO_FLIP_CNTRL_ov0_soft_buf_num(regOV0_AUTO_FLIP_CNTRL *reg, unsigned int ov0_soft_buf_num)
{
  reg->bitfields.OV0_SOFT_BUF_NUM = ov0_soft_buf_num;
  if (reg->bitfields.OV0_SOFT_BUF_NUM != ov0_soft_buf_num) HSLDPF(E_ERROR_MESSAGE,"OV0_AUTO_FLIP_CNTRL::OV0_SOFT_BUF_NUM data too large\n");
}
__inline void set_OV0_AUTO_FLIP_CNTRL_ov0_soft_repeat_field(regOV0_AUTO_FLIP_CNTRL *reg, unsigned int ov0_soft_repeat_field)
{
  reg->bitfields.OV0_SOFT_REPEAT_FIELD = ov0_soft_repeat_field;
  if (reg->bitfields.OV0_SOFT_REPEAT_FIELD != ov0_soft_repeat_field) HSLDPF(E_ERROR_MESSAGE,"OV0_AUTO_FLIP_CNTRL::OV0_SOFT_REPEAT_FIELD data too large\n");
}
__inline void set_OV0_AUTO_FLIP_CNTRL_ov0_soft_buf_odd(regOV0_AUTO_FLIP_CNTRL *reg, unsigned int ov0_soft_buf_odd)
{
  reg->bitfields.OV0_SOFT_BUF_ODD = ov0_soft_buf_odd;
  if (reg->bitfields.OV0_SOFT_BUF_ODD != ov0_soft_buf_odd) HSLDPF(E_ERROR_MESSAGE,"OV0_AUTO_FLIP_CNTRL::OV0_SOFT_BUF_ODD data too large\n");
}
__inline void set_OV0_AUTO_FLIP_CNTRL_ov0_ignore_repeat_field(regOV0_AUTO_FLIP_CNTRL *reg, unsigned int ov0_ignore_repeat_field)
{
  reg->bitfields.OV0_IGNORE_REPEAT_FIELD = ov0_ignore_repeat_field;
  if (reg->bitfields.OV0_IGNORE_REPEAT_FIELD != ov0_ignore_repeat_field) HSLDPF(E_ERROR_MESSAGE,"OV0_AUTO_FLIP_CNTRL::OV0_IGNORE_REPEAT_FIELD data too large\n");
}
__inline void set_OV0_AUTO_FLIP_CNTRL_ov0_soft_eof_toggle(regOV0_AUTO_FLIP_CNTRL *reg, unsigned int ov0_soft_eof_toggle)
{
  reg->bitfields.OV0_SOFT_EOF_TOGGLE = ov0_soft_eof_toggle;
  if (reg->bitfields.OV0_SOFT_EOF_TOGGLE != ov0_soft_eof_toggle) HSLDPF(E_ERROR_MESSAGE,"OV0_AUTO_FLIP_CNTRL::OV0_SOFT_EOF_TOGGLE data too large\n");
}
__inline void set_OV0_AUTO_FLIP_CNTRL_ov0_vid_port_select(regOV0_AUTO_FLIP_CNTRL *reg, unsigned int ov0_vid_port_select)
{
  reg->bitfields.OV0_VID_PORT_SELECT = ov0_vid_port_select;
  if (reg->bitfields.OV0_VID_PORT_SELECT != ov0_vid_port_select) HSLDPF(E_ERROR_MESSAGE,"OV0_AUTO_FLIP_CNTRL::OV0_VID_PORT_SELECT data too large\n");
}
__inline void set_OV0_AUTO_FLIP_CNTRL_ov0_p1_first_line_even(regOV0_AUTO_FLIP_CNTRL *reg, unsigned int ov0_p1_first_line_even)
{
  reg->bitfields.OV0_P1_FIRST_LINE_EVEN = ov0_p1_first_line_even;
  if (reg->bitfields.OV0_P1_FIRST_LINE_EVEN != ov0_p1_first_line_even) HSLDPF(E_ERROR_MESSAGE,"OV0_AUTO_FLIP_CNTRL::OV0_P1_FIRST_LINE_EVEN data too large\n");
}
__inline void set_OV0_AUTO_FLIP_CNTRL_ov0_shift_even_down(regOV0_AUTO_FLIP_CNTRL *reg, unsigned int ov0_shift_even_down)
{
  reg->bitfields.OV0_SHIFT_EVEN_DOWN = ov0_shift_even_down;
  if (reg->bitfields.OV0_SHIFT_EVEN_DOWN != ov0_shift_even_down) HSLDPF(E_ERROR_MESSAGE,"OV0_AUTO_FLIP_CNTRL::OV0_SHIFT_EVEN_DOWN data too large\n");
}
__inline void set_OV0_AUTO_FLIP_CNTRL_ov0_shift_odd_down(regOV0_AUTO_FLIP_CNTRL *reg, unsigned int ov0_shift_odd_down)
{
  reg->bitfields.OV0_SHIFT_ODD_DOWN = ov0_shift_odd_down;
  if (reg->bitfields.OV0_SHIFT_ODD_DOWN != ov0_shift_odd_down) HSLDPF(E_ERROR_MESSAGE,"OV0_AUTO_FLIP_CNTRL::OV0_SHIFT_ODD_DOWN data too large\n");
}
__inline void set_OV0_AUTO_FLIP_CNTRL_ov0_field_pol_source(regOV0_AUTO_FLIP_CNTRL *reg, unsigned int ov0_field_pol_source)
{
  reg->bitfields.OV0_FIELD_POL_SOURCE = ov0_field_pol_source;
  if (reg->bitfields.OV0_FIELD_POL_SOURCE != ov0_field_pol_source) HSLDPF(E_ERROR_MESSAGE,"OV0_AUTO_FLIP_CNTRL::OV0_FIELD_POL_SOURCE data too large\n");
}
#else
#define set_OV0_AUTO_FLIP_CNTRL_ov0_soft_buf_num(reg, ov0_soft_buf_num) (reg)->bitfields.OV0_SOFT_BUF_NUM = ov0_soft_buf_num
#define set_OV0_AUTO_FLIP_CNTRL_ov0_soft_repeat_field(reg, ov0_soft_repeat_field) (reg)->bitfields.OV0_SOFT_REPEAT_FIELD = ov0_soft_repeat_field
#define set_OV0_AUTO_FLIP_CNTRL_ov0_soft_buf_odd(reg, ov0_soft_buf_odd) (reg)->bitfields.OV0_SOFT_BUF_ODD = ov0_soft_buf_odd
#define set_OV0_AUTO_FLIP_CNTRL_ov0_ignore_repeat_field(reg, ov0_ignore_repeat_field) (reg)->bitfields.OV0_IGNORE_REPEAT_FIELD = ov0_ignore_repeat_field
#define set_OV0_AUTO_FLIP_CNTRL_ov0_soft_eof_toggle(reg, ov0_soft_eof_toggle) (reg)->bitfields.OV0_SOFT_EOF_TOGGLE = ov0_soft_eof_toggle
#define set_OV0_AUTO_FLIP_CNTRL_ov0_vid_port_select(reg, ov0_vid_port_select) (reg)->bitfields.OV0_VID_PORT_SELECT = ov0_vid_port_select
#define set_OV0_AUTO_FLIP_CNTRL_ov0_p1_first_line_even(reg, ov0_p1_first_line_even) (reg)->bitfields.OV0_P1_FIRST_LINE_EVEN = ov0_p1_first_line_even
#define set_OV0_AUTO_FLIP_CNTRL_ov0_shift_even_down(reg, ov0_shift_even_down) (reg)->bitfields.OV0_SHIFT_EVEN_DOWN = ov0_shift_even_down
#define set_OV0_AUTO_FLIP_CNTRL_ov0_shift_odd_down(reg, ov0_shift_odd_down) (reg)->bitfields.OV0_SHIFT_ODD_DOWN = ov0_shift_odd_down
#define set_OV0_AUTO_FLIP_CNTRL_ov0_field_pol_source(reg, ov0_field_pol_source) (reg)->bitfields.OV0_FIELD_POL_SOURCE = ov0_field_pol_source

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250OV0_DEINTERLACE_PATTERN regrv250OV0_DEINTERLACE_PATTERN;

#ifdef DEBUG
__inline void set_rv250OV0_DEINTERLACE_PATTERN_ov0_deint_pat(regrv250OV0_DEINTERLACE_PATTERN *reg, unsigned int ov0_deint_pat)
{
  reg->bitfields.OV0_DEINT_PAT = ov0_deint_pat;
  if (reg->bitfields.OV0_DEINT_PAT != ov0_deint_pat) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_DEINTERLACE_PATTERN::OV0_DEINT_PAT data too large\n");
}
__inline void set_rv250OV0_DEINTERLACE_PATTERN_ov0_deint_pat_pntr(regrv250OV0_DEINTERLACE_PATTERN *reg, unsigned int ov0_deint_pat_pntr)
{
  reg->bitfields.OV0_DEINT_PAT_PNTR = ov0_deint_pat_pntr;
  if (reg->bitfields.OV0_DEINT_PAT_PNTR != ov0_deint_pat_pntr) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_DEINTERLACE_PATTERN::OV0_DEINT_PAT_PNTR data too large\n");
}
__inline void set_rv250OV0_DEINTERLACE_PATTERN_ov0_deint_pat_len_m1(regrv250OV0_DEINTERLACE_PATTERN *reg, unsigned int ov0_deint_pat_len_m1)
{
  reg->bitfields.OV0_DEINT_PAT_LEN_M1 = ov0_deint_pat_len_m1;
  if (reg->bitfields.OV0_DEINT_PAT_LEN_M1 != ov0_deint_pat_len_m1) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_DEINTERLACE_PATTERN::OV0_DEINT_PAT_LEN_M1 data too large\n");
}
#else
#define set_rv250OV0_DEINTERLACE_PATTERN_ov0_deint_pat(reg, ov0_deint_pat) (reg)->bitfields.OV0_DEINT_PAT = ov0_deint_pat
#define set_rv250OV0_DEINTERLACE_PATTERN_ov0_deint_pat_pntr(reg, ov0_deint_pat_pntr) (reg)->bitfields.OV0_DEINT_PAT_PNTR = ov0_deint_pat_pntr
#define set_rv250OV0_DEINTERLACE_PATTERN_ov0_deint_pat_len_m1(reg, ov0_deint_pat_len_m1) (reg)->bitfields.OV0_DEINT_PAT_LEN_M1 = ov0_deint_pat_len_m1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_SUBMIT_HISTORY regOV0_SUBMIT_HISTORY;

#ifdef DEBUG
__inline void set_OV0_SUBMIT_HISTORY_ov0_next_buf_num(regOV0_SUBMIT_HISTORY *reg, unsigned int ov0_next_buf_num)
{
  reg->bitfields.OV0_NEXT_BUF_NUM = ov0_next_buf_num;
  if (reg->bitfields.OV0_NEXT_BUF_NUM != ov0_next_buf_num) HSLDPF(E_ERROR_MESSAGE,"OV0_SUBMIT_HISTORY::OV0_NEXT_BUF_NUM data too large\n");
}
__inline void set_OV0_SUBMIT_HISTORY_ov0_next_is_odd(regOV0_SUBMIT_HISTORY *reg, unsigned int ov0_next_is_odd)
{
  reg->bitfields.OV0_NEXT_IS_ODD = ov0_next_is_odd;
  if (reg->bitfields.OV0_NEXT_IS_ODD != ov0_next_is_odd) HSLDPF(E_ERROR_MESSAGE,"OV0_SUBMIT_HISTORY::OV0_NEXT_IS_ODD data too large\n");
}
__inline void set_OV0_SUBMIT_HISTORY_ov0_curr_buf_num(regOV0_SUBMIT_HISTORY *reg, unsigned int ov0_curr_buf_num)
{
  reg->bitfields.OV0_CURR_BUF_NUM = ov0_curr_buf_num;
  if (reg->bitfields.OV0_CURR_BUF_NUM != ov0_curr_buf_num) HSLDPF(E_ERROR_MESSAGE,"OV0_SUBMIT_HISTORY::OV0_CURR_BUF_NUM data too large\n");
}
__inline void set_OV0_SUBMIT_HISTORY_ov0_curr_is_odd(regOV0_SUBMIT_HISTORY *reg, unsigned int ov0_curr_is_odd)
{
  reg->bitfields.OV0_CURR_IS_ODD = ov0_curr_is_odd;
  if (reg->bitfields.OV0_CURR_IS_ODD != ov0_curr_is_odd) HSLDPF(E_ERROR_MESSAGE,"OV0_SUBMIT_HISTORY::OV0_CURR_IS_ODD data too large\n");
}
__inline void set_OV0_SUBMIT_HISTORY_ov0_prev_buf_num(regOV0_SUBMIT_HISTORY *reg, unsigned int ov0_prev_buf_num)
{
  reg->bitfields.OV0_PREV_BUF_NUM = ov0_prev_buf_num;
  if (reg->bitfields.OV0_PREV_BUF_NUM != ov0_prev_buf_num) HSLDPF(E_ERROR_MESSAGE,"OV0_SUBMIT_HISTORY::OV0_PREV_BUF_NUM data too large\n");
}
__inline void set_OV0_SUBMIT_HISTORY_ov0_prev_is_odd(regOV0_SUBMIT_HISTORY *reg, unsigned int ov0_prev_is_odd)
{
  reg->bitfields.OV0_PREV_IS_ODD = ov0_prev_is_odd;
  if (reg->bitfields.OV0_PREV_IS_ODD != ov0_prev_is_odd) HSLDPF(E_ERROR_MESSAGE,"OV0_SUBMIT_HISTORY::OV0_PREV_IS_ODD data too large\n");
}
#else
#define set_OV0_SUBMIT_HISTORY_ov0_next_buf_num(reg, ov0_next_buf_num) (reg)->bitfields.OV0_NEXT_BUF_NUM = ov0_next_buf_num
#define set_OV0_SUBMIT_HISTORY_ov0_next_is_odd(reg, ov0_next_is_odd) (reg)->bitfields.OV0_NEXT_IS_ODD = ov0_next_is_odd
#define set_OV0_SUBMIT_HISTORY_ov0_curr_buf_num(reg, ov0_curr_buf_num) (reg)->bitfields.OV0_CURR_BUF_NUM = ov0_curr_buf_num
#define set_OV0_SUBMIT_HISTORY_ov0_curr_is_odd(reg, ov0_curr_is_odd) (reg)->bitfields.OV0_CURR_IS_ODD = ov0_curr_is_odd
#define set_OV0_SUBMIT_HISTORY_ov0_prev_buf_num(reg, ov0_prev_buf_num) (reg)->bitfields.OV0_PREV_BUF_NUM = ov0_prev_buf_num
#define set_OV0_SUBMIT_HISTORY_ov0_prev_is_odd(reg, ov0_prev_is_odd) (reg)->bitfields.OV0_PREV_IS_ODD = ov0_prev_is_odd

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_H_INC regOV0_H_INC;

#ifdef DEBUG
__inline void set_OV0_H_INC_ov0_p1_h_inc(regOV0_H_INC *reg, unsigned int ov0_p1_h_inc)
{
  reg->bitfields.OV0_P1_H_INC = ov0_p1_h_inc;
  if (reg->bitfields.OV0_P1_H_INC != ov0_p1_h_inc) HSLDPF(E_ERROR_MESSAGE,"OV0_H_INC::OV0_P1_H_INC data too large\n");
}
__inline void set_OV0_H_INC_ov0_p23_h_inc(regOV0_H_INC *reg, unsigned int ov0_p23_h_inc)
{
  reg->bitfields.OV0_P23_H_INC = ov0_p23_h_inc;
  if (reg->bitfields.OV0_P23_H_INC != ov0_p23_h_inc) HSLDPF(E_ERROR_MESSAGE,"OV0_H_INC::OV0_P23_H_INC data too large\n");
}
#else
#define set_OV0_H_INC_ov0_p1_h_inc(reg, ov0_p1_h_inc) (reg)->bitfields.OV0_P1_H_INC = ov0_p1_h_inc
#define set_OV0_H_INC_ov0_p23_h_inc(reg, ov0_p23_h_inc) (reg)->bitfields.OV0_P23_H_INC = ov0_p23_h_inc

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_STEP_BY regOV0_STEP_BY;

#ifdef DEBUG
__inline void set_OV0_STEP_BY_ov0_p1_h_step_by(regOV0_STEP_BY *reg, unsigned int ov0_p1_h_step_by)
{
  reg->bitfields.OV0_P1_H_STEP_BY = ov0_p1_h_step_by;
  if (reg->bitfields.OV0_P1_H_STEP_BY != ov0_p1_h_step_by) HSLDPF(E_ERROR_MESSAGE,"OV0_STEP_BY::OV0_P1_H_STEP_BY data too large\n");
}
__inline void set_OV0_STEP_BY_ov0_p1_predwnsc_ratio(regOV0_STEP_BY *reg, unsigned int ov0_p1_predwnsc_ratio)
{
  reg->bitfields.OV0_P1_PREDWNSC_RATIO = ov0_p1_predwnsc_ratio;
  if (reg->bitfields.OV0_P1_PREDWNSC_RATIO != ov0_p1_predwnsc_ratio) HSLDPF(E_ERROR_MESSAGE,"OV0_STEP_BY::OV0_P1_PREDWNSC_RATIO data too large\n");
}
__inline void set_OV0_STEP_BY_ov0_p23_h_step_by(regOV0_STEP_BY *reg, unsigned int ov0_p23_h_step_by)
{
  reg->bitfields.OV0_P23_H_STEP_BY = ov0_p23_h_step_by;
  if (reg->bitfields.OV0_P23_H_STEP_BY != ov0_p23_h_step_by) HSLDPF(E_ERROR_MESSAGE,"OV0_STEP_BY::OV0_P23_H_STEP_BY data too large\n");
}
__inline void set_OV0_STEP_BY_ov0_p23_predwnsc_ratio(regOV0_STEP_BY *reg, unsigned int ov0_p23_predwnsc_ratio)
{
  reg->bitfields.OV0_P23_PREDWNSC_RATIO = ov0_p23_predwnsc_ratio;
  if (reg->bitfields.OV0_P23_PREDWNSC_RATIO != ov0_p23_predwnsc_ratio) HSLDPF(E_ERROR_MESSAGE,"OV0_STEP_BY::OV0_P23_PREDWNSC_RATIO data too large\n");
}
#else
#define set_OV0_STEP_BY_ov0_p1_h_step_by(reg, ov0_p1_h_step_by) (reg)->bitfields.OV0_P1_H_STEP_BY = ov0_p1_h_step_by
#define set_OV0_STEP_BY_ov0_p1_predwnsc_ratio(reg, ov0_p1_predwnsc_ratio) (reg)->bitfields.OV0_P1_PREDWNSC_RATIO = ov0_p1_predwnsc_ratio
#define set_OV0_STEP_BY_ov0_p23_h_step_by(reg, ov0_p23_h_step_by) (reg)->bitfields.OV0_P23_H_STEP_BY = ov0_p23_h_step_by
#define set_OV0_STEP_BY_ov0_p23_predwnsc_ratio(reg, ov0_p23_predwnsc_ratio) (reg)->bitfields.OV0_P23_PREDWNSC_RATIO = ov0_p23_predwnsc_ratio

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_P1_H_ACCUM_INIT regOV0_P1_H_ACCUM_INIT;

#ifdef DEBUG
__inline void set_OV0_P1_H_ACCUM_INIT_ov0_p1_h_accum_init(regOV0_P1_H_ACCUM_INIT *reg, unsigned int ov0_p1_h_accum_init)
{
  reg->bitfields.OV0_P1_H_ACCUM_INIT = ov0_p1_h_accum_init;
  if (reg->bitfields.OV0_P1_H_ACCUM_INIT != ov0_p1_h_accum_init) HSLDPF(E_ERROR_MESSAGE,"OV0_P1_H_ACCUM_INIT::OV0_P1_H_ACCUM_INIT data too large\n");
}
__inline void set_OV0_P1_H_ACCUM_INIT_ov0_preshift_p1_to(regOV0_P1_H_ACCUM_INIT *reg, unsigned int ov0_preshift_p1_to)
{
  reg->bitfields.OV0_PRESHIFT_P1_TO = ov0_preshift_p1_to;
  if (reg->bitfields.OV0_PRESHIFT_P1_TO != ov0_preshift_p1_to) HSLDPF(E_ERROR_MESSAGE,"OV0_P1_H_ACCUM_INIT::OV0_PRESHIFT_P1_TO data too large\n");
}
#else
#define set_OV0_P1_H_ACCUM_INIT_ov0_p1_h_accum_init(reg, ov0_p1_h_accum_init) (reg)->bitfields.OV0_P1_H_ACCUM_INIT = ov0_p1_h_accum_init
#define set_OV0_P1_H_ACCUM_INIT_ov0_preshift_p1_to(reg, ov0_preshift_p1_to) (reg)->bitfields.OV0_PRESHIFT_P1_TO = ov0_preshift_p1_to

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_P23_H_ACCUM_INIT regOV0_P23_H_ACCUM_INIT;

#ifdef DEBUG
__inline void set_OV0_P23_H_ACCUM_INIT_ov0_p23_h_accum_init(regOV0_P23_H_ACCUM_INIT *reg, unsigned int ov0_p23_h_accum_init)
{
  reg->bitfields.OV0_P23_H_ACCUM_INIT = ov0_p23_h_accum_init;
  if (reg->bitfields.OV0_P23_H_ACCUM_INIT != ov0_p23_h_accum_init) HSLDPF(E_ERROR_MESSAGE,"OV0_P23_H_ACCUM_INIT::OV0_P23_H_ACCUM_INIT data too large\n");
}
__inline void set_OV0_P23_H_ACCUM_INIT_ov0_preshift_p23_to(regOV0_P23_H_ACCUM_INIT *reg, unsigned int ov0_preshift_p23_to)
{
  reg->bitfields.OV0_PRESHIFT_P23_TO = ov0_preshift_p23_to;
  if (reg->bitfields.OV0_PRESHIFT_P23_TO != ov0_preshift_p23_to) HSLDPF(E_ERROR_MESSAGE,"OV0_P23_H_ACCUM_INIT::OV0_PRESHIFT_P23_TO data too large\n");
}
#else
#define set_OV0_P23_H_ACCUM_INIT_ov0_p23_h_accum_init(reg, ov0_p23_h_accum_init) (reg)->bitfields.OV0_P23_H_ACCUM_INIT = ov0_p23_h_accum_init
#define set_OV0_P23_H_ACCUM_INIT_ov0_preshift_p23_to(reg, ov0_preshift_p23_to) (reg)->bitfields.OV0_PRESHIFT_P23_TO = ov0_preshift_p23_to

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_P1_X_START_END regOV0_P1_X_START_END;

#ifdef DEBUG
__inline void set_OV0_P1_X_START_END_ov0_p1_x_end(regOV0_P1_X_START_END *reg, unsigned int ov0_p1_x_end)
{
  reg->bitfields.OV0_P1_X_END = ov0_p1_x_end;
  if (reg->bitfields.OV0_P1_X_END != ov0_p1_x_end) HSLDPF(E_ERROR_MESSAGE,"OV0_P1_X_START_END::OV0_P1_X_END data too large\n");
}
__inline void set_OV0_P1_X_START_END_ov0_p1_x_start(regOV0_P1_X_START_END *reg, unsigned int ov0_p1_x_start)
{
  reg->bitfields.OV0_P1_X_START = ov0_p1_x_start;
  if (reg->bitfields.OV0_P1_X_START != ov0_p1_x_start) HSLDPF(E_ERROR_MESSAGE,"OV0_P1_X_START_END::OV0_P1_X_START data too large\n");
}
#else
#define set_OV0_P1_X_START_END_ov0_p1_x_end(reg, ov0_p1_x_end) (reg)->bitfields.OV0_P1_X_END = ov0_p1_x_end
#define set_OV0_P1_X_START_END_ov0_p1_x_start(reg, ov0_p1_x_start) (reg)->bitfields.OV0_P1_X_START = ov0_p1_x_start

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_P2_X_START_END regOV0_P2_X_START_END;

#ifdef DEBUG
__inline void set_OV0_P2_X_START_END_ov0_p2_x_end(regOV0_P2_X_START_END *reg, unsigned int ov0_p2_x_end)
{
  reg->bitfields.OV0_P2_X_END = ov0_p2_x_end;
  if (reg->bitfields.OV0_P2_X_END != ov0_p2_x_end) HSLDPF(E_ERROR_MESSAGE,"OV0_P2_X_START_END::OV0_P2_X_END data too large\n");
}
__inline void set_OV0_P2_X_START_END_ov0_p2_x_start(regOV0_P2_X_START_END *reg, unsigned int ov0_p2_x_start)
{
  reg->bitfields.OV0_P2_X_START = ov0_p2_x_start;
  if (reg->bitfields.OV0_P2_X_START != ov0_p2_x_start) HSLDPF(E_ERROR_MESSAGE,"OV0_P2_X_START_END::OV0_P2_X_START data too large\n");
}
#else
#define set_OV0_P2_X_START_END_ov0_p2_x_end(reg, ov0_p2_x_end) (reg)->bitfields.OV0_P2_X_END = ov0_p2_x_end
#define set_OV0_P2_X_START_END_ov0_p2_x_start(reg, ov0_p2_x_start) (reg)->bitfields.OV0_P2_X_START = ov0_p2_x_start

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_P3_X_START_END regOV0_P3_X_START_END;

#ifdef DEBUG
__inline void set_OV0_P3_X_START_END_ov0_p3_x_end(regOV0_P3_X_START_END *reg, unsigned int ov0_p3_x_end)
{
  reg->bitfields.OV0_P3_X_END = ov0_p3_x_end;
  if (reg->bitfields.OV0_P3_X_END != ov0_p3_x_end) HSLDPF(E_ERROR_MESSAGE,"OV0_P3_X_START_END::OV0_P3_X_END data too large\n");
}
__inline void set_OV0_P3_X_START_END_ov0_p3_x_start(regOV0_P3_X_START_END *reg, unsigned int ov0_p3_x_start)
{
  reg->bitfields.OV0_P3_X_START = ov0_p3_x_start;
  if (reg->bitfields.OV0_P3_X_START != ov0_p3_x_start) HSLDPF(E_ERROR_MESSAGE,"OV0_P3_X_START_END::OV0_P3_X_START data too large\n");
}
#else
#define set_OV0_P3_X_START_END_ov0_p3_x_end(reg, ov0_p3_x_end) (reg)->bitfields.OV0_P3_X_END = ov0_p3_x_end
#define set_OV0_P3_X_START_END_ov0_p3_x_start(reg, ov0_p3_x_start) (reg)->bitfields.OV0_P3_X_START = ov0_p3_x_start

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_FILTER_CNTL regOV0_FILTER_CNTL;

#ifdef DEBUG
__inline void set_OV0_FILTER_CNTL_ov0_hc_coef_on_horz_y(regOV0_FILTER_CNTL *reg, unsigned int ov0_hc_coef_on_horz_y)
{
  reg->bitfields.OV0_HC_COEF_ON_HORZ_Y = ov0_hc_coef_on_horz_y;
  if (reg->bitfields.OV0_HC_COEF_ON_HORZ_Y != ov0_hc_coef_on_horz_y) HSLDPF(E_ERROR_MESSAGE,"OV0_FILTER_CNTL::OV0_HC_COEF_ON_HORZ_Y data too large\n");
}
__inline void set_OV0_FILTER_CNTL_ov0_hc_coef_on_horz_uv(regOV0_FILTER_CNTL *reg, unsigned int ov0_hc_coef_on_horz_uv)
{
  reg->bitfields.OV0_HC_COEF_ON_HORZ_UV = ov0_hc_coef_on_horz_uv;
  if (reg->bitfields.OV0_HC_COEF_ON_HORZ_UV != ov0_hc_coef_on_horz_uv) HSLDPF(E_ERROR_MESSAGE,"OV0_FILTER_CNTL::OV0_HC_COEF_ON_HORZ_UV data too large\n");
}
__inline void set_OV0_FILTER_CNTL_ov0_hc_coef_on_vert_y(regOV0_FILTER_CNTL *reg, unsigned int ov0_hc_coef_on_vert_y)
{
  reg->bitfields.OV0_HC_COEF_ON_VERT_Y = ov0_hc_coef_on_vert_y;
  if (reg->bitfields.OV0_HC_COEF_ON_VERT_Y != ov0_hc_coef_on_vert_y) HSLDPF(E_ERROR_MESSAGE,"OV0_FILTER_CNTL::OV0_HC_COEF_ON_VERT_Y data too large\n");
}
__inline void set_OV0_FILTER_CNTL_ov0_hc_coef_on_vert_uv(regOV0_FILTER_CNTL *reg, unsigned int ov0_hc_coef_on_vert_uv)
{
  reg->bitfields.OV0_HC_COEF_ON_VERT_UV = ov0_hc_coef_on_vert_uv;
  if (reg->bitfields.OV0_HC_COEF_ON_VERT_UV != ov0_hc_coef_on_vert_uv) HSLDPF(E_ERROR_MESSAGE,"OV0_FILTER_CNTL::OV0_HC_COEF_ON_VERT_UV data too large\n");
}
#else
#define set_OV0_FILTER_CNTL_ov0_hc_coef_on_horz_y(reg, ov0_hc_coef_on_horz_y) (reg)->bitfields.OV0_HC_COEF_ON_HORZ_Y = ov0_hc_coef_on_horz_y
#define set_OV0_FILTER_CNTL_ov0_hc_coef_on_horz_uv(reg, ov0_hc_coef_on_horz_uv) (reg)->bitfields.OV0_HC_COEF_ON_HORZ_UV = ov0_hc_coef_on_horz_uv
#define set_OV0_FILTER_CNTL_ov0_hc_coef_on_vert_y(reg, ov0_hc_coef_on_vert_y) (reg)->bitfields.OV0_HC_COEF_ON_VERT_Y = ov0_hc_coef_on_vert_y
#define set_OV0_FILTER_CNTL_ov0_hc_coef_on_vert_uv(reg, ov0_hc_coef_on_vert_uv) (reg)->bitfields.OV0_HC_COEF_ON_VERT_UV = ov0_hc_coef_on_vert_uv

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_FOUR_TAP_COEF_0 regOV0_FOUR_TAP_COEF_0;

#ifdef DEBUG
__inline void set_OV0_FOUR_TAP_COEF_0_ov0_coef__0th_tap(regOV0_FOUR_TAP_COEF_0 *reg, unsigned int ov0_coef__0th_tap)
{
  reg->bitfields.OV0_COEF__0TH_TAP = ov0_coef__0th_tap;
  if (reg->bitfields.OV0_COEF__0TH_TAP != ov0_coef__0th_tap) HSLDPF(E_ERROR_MESSAGE,"OV0_FOUR_TAP_COEF_0::OV0_COEF__0TH_TAP data too large\n");
}
__inline void set_OV0_FOUR_TAP_COEF_0_ov0_coef__1st_tap(regOV0_FOUR_TAP_COEF_0 *reg, unsigned int ov0_coef__1st_tap)
{
  reg->bitfields.OV0_COEF__1ST_TAP = ov0_coef__1st_tap;
  if (reg->bitfields.OV0_COEF__1ST_TAP != ov0_coef__1st_tap) HSLDPF(E_ERROR_MESSAGE,"OV0_FOUR_TAP_COEF_0::OV0_COEF__1ST_TAP data too large\n");
}
__inline void set_OV0_FOUR_TAP_COEF_0_ov0_coef__2nd_tap(regOV0_FOUR_TAP_COEF_0 *reg, unsigned int ov0_coef__2nd_tap)
{
  reg->bitfields.OV0_COEF__2ND_TAP = ov0_coef__2nd_tap;
  if (reg->bitfields.OV0_COEF__2ND_TAP != ov0_coef__2nd_tap) HSLDPF(E_ERROR_MESSAGE,"OV0_FOUR_TAP_COEF_0::OV0_COEF__2ND_TAP data too large\n");
}
__inline void set_OV0_FOUR_TAP_COEF_0_ov0_coef__3rd_tap(regOV0_FOUR_TAP_COEF_0 *reg, unsigned int ov0_coef__3rd_tap)
{
  reg->bitfields.OV0_COEF__3RD_TAP = ov0_coef__3rd_tap;
  if (reg->bitfields.OV0_COEF__3RD_TAP != ov0_coef__3rd_tap) HSLDPF(E_ERROR_MESSAGE,"OV0_FOUR_TAP_COEF_0::OV0_COEF__3RD_TAP data too large\n");
}
#else
#define set_OV0_FOUR_TAP_COEF_0_ov0_coef__0th_tap(reg, ov0_coef__0th_tap) (reg)->bitfields.OV0_COEF__0TH_TAP = ov0_coef__0th_tap
#define set_OV0_FOUR_TAP_COEF_0_ov0_coef__1st_tap(reg, ov0_coef__1st_tap) (reg)->bitfields.OV0_COEF__1ST_TAP = ov0_coef__1st_tap
#define set_OV0_FOUR_TAP_COEF_0_ov0_coef__2nd_tap(reg, ov0_coef__2nd_tap) (reg)->bitfields.OV0_COEF__2ND_TAP = ov0_coef__2nd_tap
#define set_OV0_FOUR_TAP_COEF_0_ov0_coef__3rd_tap(reg, ov0_coef__3rd_tap) (reg)->bitfields.OV0_COEF__3RD_TAP = ov0_coef__3rd_tap

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_FOUR_TAP_COEF_1 regOV0_FOUR_TAP_COEF_1;

#ifdef DEBUG
__inline void set_OV0_FOUR_TAP_COEF_1_ov0_coef__0th_tap(regOV0_FOUR_TAP_COEF_1 *reg, unsigned int ov0_coef__0th_tap)
{
  reg->bitfields.OV0_COEF__0TH_TAP = ov0_coef__0th_tap;
  if (reg->bitfields.OV0_COEF__0TH_TAP != ov0_coef__0th_tap) HSLDPF(E_ERROR_MESSAGE,"OV0_FOUR_TAP_COEF_1::OV0_COEF__0TH_TAP data too large\n");
}
__inline void set_OV0_FOUR_TAP_COEF_1_ov0_coef__1st_tap(regOV0_FOUR_TAP_COEF_1 *reg, unsigned int ov0_coef__1st_tap)
{
  reg->bitfields.OV0_COEF__1ST_TAP = ov0_coef__1st_tap;
  if (reg->bitfields.OV0_COEF__1ST_TAP != ov0_coef__1st_tap) HSLDPF(E_ERROR_MESSAGE,"OV0_FOUR_TAP_COEF_1::OV0_COEF__1ST_TAP data too large\n");
}
__inline void set_OV0_FOUR_TAP_COEF_1_ov0_coef__2nd_tap(regOV0_FOUR_TAP_COEF_1 *reg, unsigned int ov0_coef__2nd_tap)
{
  reg->bitfields.OV0_COEF__2ND_TAP = ov0_coef__2nd_tap;
  if (reg->bitfields.OV0_COEF__2ND_TAP != ov0_coef__2nd_tap) HSLDPF(E_ERROR_MESSAGE,"OV0_FOUR_TAP_COEF_1::OV0_COEF__2ND_TAP data too large\n");
}
__inline void set_OV0_FOUR_TAP_COEF_1_ov0_coef__3rd_tap(regOV0_FOUR_TAP_COEF_1 *reg, unsigned int ov0_coef__3rd_tap)
{
  reg->bitfields.OV0_COEF__3RD_TAP = ov0_coef__3rd_tap;
  if (reg->bitfields.OV0_COEF__3RD_TAP != ov0_coef__3rd_tap) HSLDPF(E_ERROR_MESSAGE,"OV0_FOUR_TAP_COEF_1::OV0_COEF__3RD_TAP data too large\n");
}
#else
#define set_OV0_FOUR_TAP_COEF_1_ov0_coef__0th_tap(reg, ov0_coef__0th_tap) (reg)->bitfields.OV0_COEF__0TH_TAP = ov0_coef__0th_tap
#define set_OV0_FOUR_TAP_COEF_1_ov0_coef__1st_tap(reg, ov0_coef__1st_tap) (reg)->bitfields.OV0_COEF__1ST_TAP = ov0_coef__1st_tap
#define set_OV0_FOUR_TAP_COEF_1_ov0_coef__2nd_tap(reg, ov0_coef__2nd_tap) (reg)->bitfields.OV0_COEF__2ND_TAP = ov0_coef__2nd_tap
#define set_OV0_FOUR_TAP_COEF_1_ov0_coef__3rd_tap(reg, ov0_coef__3rd_tap) (reg)->bitfields.OV0_COEF__3RD_TAP = ov0_coef__3rd_tap

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_FOUR_TAP_COEF_2 regOV0_FOUR_TAP_COEF_2;

#ifdef DEBUG
__inline void set_OV0_FOUR_TAP_COEF_2_ov0_coef__0th_tap(regOV0_FOUR_TAP_COEF_2 *reg, unsigned int ov0_coef__0th_tap)
{
  reg->bitfields.OV0_COEF__0TH_TAP = ov0_coef__0th_tap;
  if (reg->bitfields.OV0_COEF__0TH_TAP != ov0_coef__0th_tap) HSLDPF(E_ERROR_MESSAGE,"OV0_FOUR_TAP_COEF_2::OV0_COEF__0TH_TAP data too large\n");
}
__inline void set_OV0_FOUR_TAP_COEF_2_ov0_coef__1st_tap(regOV0_FOUR_TAP_COEF_2 *reg, unsigned int ov0_coef__1st_tap)
{
  reg->bitfields.OV0_COEF__1ST_TAP = ov0_coef__1st_tap;
  if (reg->bitfields.OV0_COEF__1ST_TAP != ov0_coef__1st_tap) HSLDPF(E_ERROR_MESSAGE,"OV0_FOUR_TAP_COEF_2::OV0_COEF__1ST_TAP data too large\n");
}
__inline void set_OV0_FOUR_TAP_COEF_2_ov0_coef__2nd_tap(regOV0_FOUR_TAP_COEF_2 *reg, unsigned int ov0_coef__2nd_tap)
{
  reg->bitfields.OV0_COEF__2ND_TAP = ov0_coef__2nd_tap;
  if (reg->bitfields.OV0_COEF__2ND_TAP != ov0_coef__2nd_tap) HSLDPF(E_ERROR_MESSAGE,"OV0_FOUR_TAP_COEF_2::OV0_COEF__2ND_TAP data too large\n");
}
__inline void set_OV0_FOUR_TAP_COEF_2_ov0_coef__3rd_tap(regOV0_FOUR_TAP_COEF_2 *reg, unsigned int ov0_coef__3rd_tap)
{
  reg->bitfields.OV0_COEF__3RD_TAP = ov0_coef__3rd_tap;
  if (reg->bitfields.OV0_COEF__3RD_TAP != ov0_coef__3rd_tap) HSLDPF(E_ERROR_MESSAGE,"OV0_FOUR_TAP_COEF_2::OV0_COEF__3RD_TAP data too large\n");
}
#else
#define set_OV0_FOUR_TAP_COEF_2_ov0_coef__0th_tap(reg, ov0_coef__0th_tap) (reg)->bitfields.OV0_COEF__0TH_TAP = ov0_coef__0th_tap
#define set_OV0_FOUR_TAP_COEF_2_ov0_coef__1st_tap(reg, ov0_coef__1st_tap) (reg)->bitfields.OV0_COEF__1ST_TAP = ov0_coef__1st_tap
#define set_OV0_FOUR_TAP_COEF_2_ov0_coef__2nd_tap(reg, ov0_coef__2nd_tap) (reg)->bitfields.OV0_COEF__2ND_TAP = ov0_coef__2nd_tap
#define set_OV0_FOUR_TAP_COEF_2_ov0_coef__3rd_tap(reg, ov0_coef__3rd_tap) (reg)->bitfields.OV0_COEF__3RD_TAP = ov0_coef__3rd_tap

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_FOUR_TAP_COEF_3 regOV0_FOUR_TAP_COEF_3;

#ifdef DEBUG
__inline void set_OV0_FOUR_TAP_COEF_3_ov0_coef__0th_tap(regOV0_FOUR_TAP_COEF_3 *reg, unsigned int ov0_coef__0th_tap)
{
  reg->bitfields.OV0_COEF__0TH_TAP = ov0_coef__0th_tap;
  if (reg->bitfields.OV0_COEF__0TH_TAP != ov0_coef__0th_tap) HSLDPF(E_ERROR_MESSAGE,"OV0_FOUR_TAP_COEF_3::OV0_COEF__0TH_TAP data too large\n");
}
__inline void set_OV0_FOUR_TAP_COEF_3_ov0_coef__1st_tap(regOV0_FOUR_TAP_COEF_3 *reg, unsigned int ov0_coef__1st_tap)
{
  reg->bitfields.OV0_COEF__1ST_TAP = ov0_coef__1st_tap;
  if (reg->bitfields.OV0_COEF__1ST_TAP != ov0_coef__1st_tap) HSLDPF(E_ERROR_MESSAGE,"OV0_FOUR_TAP_COEF_3::OV0_COEF__1ST_TAP data too large\n");
}
__inline void set_OV0_FOUR_TAP_COEF_3_ov0_coef__2nd_tap(regOV0_FOUR_TAP_COEF_3 *reg, unsigned int ov0_coef__2nd_tap)
{
  reg->bitfields.OV0_COEF__2ND_TAP = ov0_coef__2nd_tap;
  if (reg->bitfields.OV0_COEF__2ND_TAP != ov0_coef__2nd_tap) HSLDPF(E_ERROR_MESSAGE,"OV0_FOUR_TAP_COEF_3::OV0_COEF__2ND_TAP data too large\n");
}
__inline void set_OV0_FOUR_TAP_COEF_3_ov0_coef__3rd_tap(regOV0_FOUR_TAP_COEF_3 *reg, unsigned int ov0_coef__3rd_tap)
{
  reg->bitfields.OV0_COEF__3RD_TAP = ov0_coef__3rd_tap;
  if (reg->bitfields.OV0_COEF__3RD_TAP != ov0_coef__3rd_tap) HSLDPF(E_ERROR_MESSAGE,"OV0_FOUR_TAP_COEF_3::OV0_COEF__3RD_TAP data too large\n");
}
#else
#define set_OV0_FOUR_TAP_COEF_3_ov0_coef__0th_tap(reg, ov0_coef__0th_tap) (reg)->bitfields.OV0_COEF__0TH_TAP = ov0_coef__0th_tap
#define set_OV0_FOUR_TAP_COEF_3_ov0_coef__1st_tap(reg, ov0_coef__1st_tap) (reg)->bitfields.OV0_COEF__1ST_TAP = ov0_coef__1st_tap
#define set_OV0_FOUR_TAP_COEF_3_ov0_coef__2nd_tap(reg, ov0_coef__2nd_tap) (reg)->bitfields.OV0_COEF__2ND_TAP = ov0_coef__2nd_tap
#define set_OV0_FOUR_TAP_COEF_3_ov0_coef__3rd_tap(reg, ov0_coef__3rd_tap) (reg)->bitfields.OV0_COEF__3RD_TAP = ov0_coef__3rd_tap

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_FOUR_TAP_COEF_4 regOV0_FOUR_TAP_COEF_4;

#ifdef DEBUG
__inline void set_OV0_FOUR_TAP_COEF_4_ov0_coef__0th_tap(regOV0_FOUR_TAP_COEF_4 *reg, unsigned int ov0_coef__0th_tap)
{
  reg->bitfields.OV0_COEF__0TH_TAP = ov0_coef__0th_tap;
  if (reg->bitfields.OV0_COEF__0TH_TAP != ov0_coef__0th_tap) HSLDPF(E_ERROR_MESSAGE,"OV0_FOUR_TAP_COEF_4::OV0_COEF__0TH_TAP data too large\n");
}
__inline void set_OV0_FOUR_TAP_COEF_4_ov0_coef__1st_tap(regOV0_FOUR_TAP_COEF_4 *reg, unsigned int ov0_coef__1st_tap)
{
  reg->bitfields.OV0_COEF__1ST_TAP = ov0_coef__1st_tap;
  if (reg->bitfields.OV0_COEF__1ST_TAP != ov0_coef__1st_tap) HSLDPF(E_ERROR_MESSAGE,"OV0_FOUR_TAP_COEF_4::OV0_COEF__1ST_TAP data too large\n");
}
__inline void set_OV0_FOUR_TAP_COEF_4_ov0_coef__2nd_tap(regOV0_FOUR_TAP_COEF_4 *reg, unsigned int ov0_coef__2nd_tap)
{
  reg->bitfields.OV0_COEF__2ND_TAP = ov0_coef__2nd_tap;
  if (reg->bitfields.OV0_COEF__2ND_TAP != ov0_coef__2nd_tap) HSLDPF(E_ERROR_MESSAGE,"OV0_FOUR_TAP_COEF_4::OV0_COEF__2ND_TAP data too large\n");
}
__inline void set_OV0_FOUR_TAP_COEF_4_ov0_coef__3rd_tap(regOV0_FOUR_TAP_COEF_4 *reg, unsigned int ov0_coef__3rd_tap)
{
  reg->bitfields.OV0_COEF__3RD_TAP = ov0_coef__3rd_tap;
  if (reg->bitfields.OV0_COEF__3RD_TAP != ov0_coef__3rd_tap) HSLDPF(E_ERROR_MESSAGE,"OV0_FOUR_TAP_COEF_4::OV0_COEF__3RD_TAP data too large\n");
}
#else
#define set_OV0_FOUR_TAP_COEF_4_ov0_coef__0th_tap(reg, ov0_coef__0th_tap) (reg)->bitfields.OV0_COEF__0TH_TAP = ov0_coef__0th_tap
#define set_OV0_FOUR_TAP_COEF_4_ov0_coef__1st_tap(reg, ov0_coef__1st_tap) (reg)->bitfields.OV0_COEF__1ST_TAP = ov0_coef__1st_tap
#define set_OV0_FOUR_TAP_COEF_4_ov0_coef__2nd_tap(reg, ov0_coef__2nd_tap) (reg)->bitfields.OV0_COEF__2ND_TAP = ov0_coef__2nd_tap
#define set_OV0_FOUR_TAP_COEF_4_ov0_coef__3rd_tap(reg, ov0_coef__3rd_tap) (reg)->bitfields.OV0_COEF__3RD_TAP = ov0_coef__3rd_tap

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_FLAG_CNTRL regOV0_FLAG_CNTRL;

#ifdef DEBUG
__inline void set_OV0_FLAG_CNTRL_ov0_hi_pri_mcreq(regOV0_FLAG_CNTRL *reg, unsigned int ov0_hi_pri_mcreq)
{
  reg->bitfields.OV0_HI_PRI_MCREQ = ov0_hi_pri_mcreq;
  if (reg->bitfields.OV0_HI_PRI_MCREQ != ov0_hi_pri_mcreq) HSLDPF(E_ERROR_MESSAGE,"OV0_FLAG_CNTRL::OV0_HI_PRI_MCREQ data too large\n");
}
__inline void set_OV0_FLAG_CNTRL_ov0_hi_pri_force(regOV0_FLAG_CNTRL *reg, unsigned int ov0_hi_pri_force)
{
  reg->bitfields.OV0_HI_PRI_FORCE = ov0_hi_pri_force;
  if (reg->bitfields.OV0_HI_PRI_FORCE != ov0_hi_pri_force) HSLDPF(E_ERROR_MESSAGE,"OV0_FLAG_CNTRL::OV0_HI_PRI_FORCE data too large\n");
}
__inline void set_OV0_FLAG_CNTRL_ov0_luma_10bit_en(regOV0_FLAG_CNTRL *reg, unsigned int ov0_luma_10bit_en)
{
  reg->bitfields.OV0_LUMA_10BIT_EN = ov0_luma_10bit_en;
  if (reg->bitfields.OV0_LUMA_10BIT_EN != ov0_luma_10bit_en) HSLDPF(E_ERROR_MESSAGE,"OV0_FLAG_CNTRL::OV0_LUMA_10BIT_EN data too large\n");
}
__inline void set_OV0_FLAG_CNTRL_ov0_chroma_10bit_en(regOV0_FLAG_CNTRL *reg, unsigned int ov0_chroma_10bit_en)
{
  reg->bitfields.OV0_CHROMA_10BIT_EN = ov0_chroma_10bit_en;
  if (reg->bitfields.OV0_CHROMA_10BIT_EN != ov0_chroma_10bit_en) HSLDPF(E_ERROR_MESSAGE,"OV0_FLAG_CNTRL::OV0_CHROMA_10BIT_EN data too large\n");
}
#else
#define set_OV0_FLAG_CNTRL_ov0_hi_pri_mcreq(reg, ov0_hi_pri_mcreq) (reg)->bitfields.OV0_HI_PRI_MCREQ = ov0_hi_pri_mcreq
#define set_OV0_FLAG_CNTRL_ov0_hi_pri_force(reg, ov0_hi_pri_force) (reg)->bitfields.OV0_HI_PRI_FORCE = ov0_hi_pri_force
#define set_OV0_FLAG_CNTRL_ov0_luma_10bit_en(reg, ov0_luma_10bit_en) (reg)->bitfields.OV0_LUMA_10BIT_EN = ov0_luma_10bit_en
#define set_OV0_FLAG_CNTRL_ov0_chroma_10bit_en(reg, ov0_chroma_10bit_en) (reg)->bitfields.OV0_CHROMA_10BIT_EN = ov0_chroma_10bit_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_SLICE_CNTL regOV0_SLICE_CNTL;

#ifdef DEBUG
__inline void set_OV0_SLICE_CNTL_ov0_slice_last_line(regOV0_SLICE_CNTL *reg, unsigned int ov0_slice_last_line)
{
  reg->bitfields.OV0_SLICE_LAST_LINE = ov0_slice_last_line;
  if (reg->bitfields.OV0_SLICE_LAST_LINE != ov0_slice_last_line) HSLDPF(E_ERROR_MESSAGE,"OV0_SLICE_CNTL::OV0_SLICE_LAST_LINE data too large\n");
}
__inline void set_OV0_SLICE_CNTL_ov0_slicedone_stat(regOV0_SLICE_CNTL *reg, unsigned int ov0_slicedone_stat)
{
  reg->bitfields.OV0_SLICEDONE_STAT = ov0_slicedone_stat;
  if (reg->bitfields.OV0_SLICEDONE_STAT != ov0_slicedone_stat) HSLDPF(E_ERROR_MESSAGE,"OV0_SLICE_CNTL::OV0_SLICEDONE_STAT data too large\n");
}
__inline void set_OV0_SLICE_CNTL_ov0_mpeg_eof_toggle(regOV0_SLICE_CNTL *reg, unsigned int ov0_mpeg_eof_toggle)
{
  reg->bitfields.OV0_MPEG_EOF_TOGGLE = ov0_mpeg_eof_toggle;
  if (reg->bitfields.OV0_MPEG_EOF_TOGGLE != ov0_mpeg_eof_toggle) HSLDPF(E_ERROR_MESSAGE,"OV0_SLICE_CNTL::OV0_MPEG_EOF_TOGGLE data too large\n");
}
#else
#define set_OV0_SLICE_CNTL_ov0_slice_last_line(reg, ov0_slice_last_line) (reg)->bitfields.OV0_SLICE_LAST_LINE = ov0_slice_last_line
#define set_OV0_SLICE_CNTL_ov0_slicedone_stat(reg, ov0_slicedone_stat) (reg)->bitfields.OV0_SLICEDONE_STAT = ov0_slicedone_stat
#define set_OV0_SLICE_CNTL_ov0_mpeg_eof_toggle(reg, ov0_mpeg_eof_toggle) (reg)->bitfields.OV0_MPEG_EOF_TOGGLE = ov0_mpeg_eof_toggle

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_VID_KEY_CLR_LOW regOV0_VID_KEY_CLR_LOW;

#ifdef DEBUG
__inline void set_OV0_VID_KEY_CLR_LOW_ov0_vid_key_cb_blue_low(regOV0_VID_KEY_CLR_LOW *reg, unsigned int ov0_vid_key_cb_blue_low)
{
  reg->bitfields.OV0_VID_KEY_Cb_BLUE_LOW = ov0_vid_key_cb_blue_low;
  if (reg->bitfields.OV0_VID_KEY_Cb_BLUE_LOW != ov0_vid_key_cb_blue_low) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_KEY_CLR_LOW::OV0_VID_KEY_Cb_BLUE_LOW data too large\n");
}
__inline void set_OV0_VID_KEY_CLR_LOW_ov0_vid_key_y_green_low(regOV0_VID_KEY_CLR_LOW *reg, unsigned int ov0_vid_key_y_green_low)
{
  reg->bitfields.OV0_VID_KEY_Y_GREEN_LOW = ov0_vid_key_y_green_low;
  if (reg->bitfields.OV0_VID_KEY_Y_GREEN_LOW != ov0_vid_key_y_green_low) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_KEY_CLR_LOW::OV0_VID_KEY_Y_GREEN_LOW data too large\n");
}
__inline void set_OV0_VID_KEY_CLR_LOW_ov0_vid_key_cr_red_low(regOV0_VID_KEY_CLR_LOW *reg, unsigned int ov0_vid_key_cr_red_low)
{
  reg->bitfields.OV0_VID_KEY_Cr_RED_LOW = ov0_vid_key_cr_red_low;
  if (reg->bitfields.OV0_VID_KEY_Cr_RED_LOW != ov0_vid_key_cr_red_low) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_KEY_CLR_LOW::OV0_VID_KEY_Cr_RED_LOW data too large\n");
}
#else
#define set_OV0_VID_KEY_CLR_LOW_ov0_vid_key_cb_blue_low(reg, ov0_vid_key_cb_blue_low) (reg)->bitfields.OV0_VID_KEY_Cb_BLUE_LOW = ov0_vid_key_cb_blue_low
#define set_OV0_VID_KEY_CLR_LOW_ov0_vid_key_y_green_low(reg, ov0_vid_key_y_green_low) (reg)->bitfields.OV0_VID_KEY_Y_GREEN_LOW = ov0_vid_key_y_green_low
#define set_OV0_VID_KEY_CLR_LOW_ov0_vid_key_cr_red_low(reg, ov0_vid_key_cr_red_low) (reg)->bitfields.OV0_VID_KEY_Cr_RED_LOW = ov0_vid_key_cr_red_low

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_VID_KEY_CLR_HIGH regOV0_VID_KEY_CLR_HIGH;

#ifdef DEBUG
__inline void set_OV0_VID_KEY_CLR_HIGH_ov0_vid_key_cb_blue_high(regOV0_VID_KEY_CLR_HIGH *reg, unsigned int ov0_vid_key_cb_blue_high)
{
  reg->bitfields.OV0_VID_KEY_Cb_BLUE_HIGH = ov0_vid_key_cb_blue_high;
  if (reg->bitfields.OV0_VID_KEY_Cb_BLUE_HIGH != ov0_vid_key_cb_blue_high) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_KEY_CLR_HIGH::OV0_VID_KEY_Cb_BLUE_HIGH data too large\n");
}
__inline void set_OV0_VID_KEY_CLR_HIGH_ov0_vid_key_y_green_high(regOV0_VID_KEY_CLR_HIGH *reg, unsigned int ov0_vid_key_y_green_high)
{
  reg->bitfields.OV0_VID_KEY_Y_GREEN_HIGH = ov0_vid_key_y_green_high;
  if (reg->bitfields.OV0_VID_KEY_Y_GREEN_HIGH != ov0_vid_key_y_green_high) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_KEY_CLR_HIGH::OV0_VID_KEY_Y_GREEN_HIGH data too large\n");
}
__inline void set_OV0_VID_KEY_CLR_HIGH_ov0_vid_key_cr_red_high(regOV0_VID_KEY_CLR_HIGH *reg, unsigned int ov0_vid_key_cr_red_high)
{
  reg->bitfields.OV0_VID_KEY_Cr_RED_HIGH = ov0_vid_key_cr_red_high;
  if (reg->bitfields.OV0_VID_KEY_Cr_RED_HIGH != ov0_vid_key_cr_red_high) HSLDPF(E_ERROR_MESSAGE,"OV0_VID_KEY_CLR_HIGH::OV0_VID_KEY_Cr_RED_HIGH data too large\n");
}
#else
#define set_OV0_VID_KEY_CLR_HIGH_ov0_vid_key_cb_blue_high(reg, ov0_vid_key_cb_blue_high) (reg)->bitfields.OV0_VID_KEY_Cb_BLUE_HIGH = ov0_vid_key_cb_blue_high
#define set_OV0_VID_KEY_CLR_HIGH_ov0_vid_key_y_green_high(reg, ov0_vid_key_y_green_high) (reg)->bitfields.OV0_VID_KEY_Y_GREEN_HIGH = ov0_vid_key_y_green_high
#define set_OV0_VID_KEY_CLR_HIGH_ov0_vid_key_cr_red_high(reg, ov0_vid_key_cr_red_high) (reg)->bitfields.OV0_VID_KEY_Cr_RED_HIGH = ov0_vid_key_cr_red_high

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_GRPH_KEY_CLR_LOW regOV0_GRPH_KEY_CLR_LOW;

#ifdef DEBUG
__inline void set_OV0_GRPH_KEY_CLR_LOW_ov0_grph_key_blue_low(regOV0_GRPH_KEY_CLR_LOW *reg, unsigned int ov0_grph_key_blue_low)
{
  reg->bitfields.OV0_GRPH_KEY_BLUE_LOW = ov0_grph_key_blue_low;
  if (reg->bitfields.OV0_GRPH_KEY_BLUE_LOW != ov0_grph_key_blue_low) HSLDPF(E_ERROR_MESSAGE,"OV0_GRPH_KEY_CLR_LOW::OV0_GRPH_KEY_BLUE_LOW data too large\n");
}
__inline void set_OV0_GRPH_KEY_CLR_LOW_ov0_grph_key_green_low(regOV0_GRPH_KEY_CLR_LOW *reg, unsigned int ov0_grph_key_green_low)
{
  reg->bitfields.OV0_GRPH_KEY_GREEN_LOW = ov0_grph_key_green_low;
  if (reg->bitfields.OV0_GRPH_KEY_GREEN_LOW != ov0_grph_key_green_low) HSLDPF(E_ERROR_MESSAGE,"OV0_GRPH_KEY_CLR_LOW::OV0_GRPH_KEY_GREEN_LOW data too large\n");
}
__inline void set_OV0_GRPH_KEY_CLR_LOW_ov0_grph_key_red_low(regOV0_GRPH_KEY_CLR_LOW *reg, unsigned int ov0_grph_key_red_low)
{
  reg->bitfields.OV0_GRPH_KEY_RED_LOW = ov0_grph_key_red_low;
  if (reg->bitfields.OV0_GRPH_KEY_RED_LOW != ov0_grph_key_red_low) HSLDPF(E_ERROR_MESSAGE,"OV0_GRPH_KEY_CLR_LOW::OV0_GRPH_KEY_RED_LOW data too large\n");
}
__inline void set_OV0_GRPH_KEY_CLR_LOW_ov0_grph_key_alpha_low(regOV0_GRPH_KEY_CLR_LOW *reg, unsigned int ov0_grph_key_alpha_low)
{
  reg->bitfields.OV0_GRPH_KEY_ALPHA_LOW = ov0_grph_key_alpha_low;
  if (reg->bitfields.OV0_GRPH_KEY_ALPHA_LOW != ov0_grph_key_alpha_low) HSLDPF(E_ERROR_MESSAGE,"OV0_GRPH_KEY_CLR_LOW::OV0_GRPH_KEY_ALPHA_LOW data too large\n");
}
#else
#define set_OV0_GRPH_KEY_CLR_LOW_ov0_grph_key_blue_low(reg, ov0_grph_key_blue_low) (reg)->bitfields.OV0_GRPH_KEY_BLUE_LOW = ov0_grph_key_blue_low
#define set_OV0_GRPH_KEY_CLR_LOW_ov0_grph_key_green_low(reg, ov0_grph_key_green_low) (reg)->bitfields.OV0_GRPH_KEY_GREEN_LOW = ov0_grph_key_green_low
#define set_OV0_GRPH_KEY_CLR_LOW_ov0_grph_key_red_low(reg, ov0_grph_key_red_low) (reg)->bitfields.OV0_GRPH_KEY_RED_LOW = ov0_grph_key_red_low
#define set_OV0_GRPH_KEY_CLR_LOW_ov0_grph_key_alpha_low(reg, ov0_grph_key_alpha_low) (reg)->bitfields.OV0_GRPH_KEY_ALPHA_LOW = ov0_grph_key_alpha_low

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_GRPH_KEY_CLR_HIGH regOV0_GRPH_KEY_CLR_HIGH;

#ifdef DEBUG
__inline void set_OV0_GRPH_KEY_CLR_HIGH_ov0_grph_key_blue_high(regOV0_GRPH_KEY_CLR_HIGH *reg, unsigned int ov0_grph_key_blue_high)
{
  reg->bitfields.OV0_GRPH_KEY_BLUE_HIGH = ov0_grph_key_blue_high;
  if (reg->bitfields.OV0_GRPH_KEY_BLUE_HIGH != ov0_grph_key_blue_high) HSLDPF(E_ERROR_MESSAGE,"OV0_GRPH_KEY_CLR_HIGH::OV0_GRPH_KEY_BLUE_HIGH data too large\n");
}
__inline void set_OV0_GRPH_KEY_CLR_HIGH_ov0_grph_key_green_high(regOV0_GRPH_KEY_CLR_HIGH *reg, unsigned int ov0_grph_key_green_high)
{
  reg->bitfields.OV0_GRPH_KEY_GREEN_HIGH = ov0_grph_key_green_high;
  if (reg->bitfields.OV0_GRPH_KEY_GREEN_HIGH != ov0_grph_key_green_high) HSLDPF(E_ERROR_MESSAGE,"OV0_GRPH_KEY_CLR_HIGH::OV0_GRPH_KEY_GREEN_HIGH data too large\n");
}
__inline void set_OV0_GRPH_KEY_CLR_HIGH_ov0_grph_key_red_high(regOV0_GRPH_KEY_CLR_HIGH *reg, unsigned int ov0_grph_key_red_high)
{
  reg->bitfields.OV0_GRPH_KEY_RED_HIGH = ov0_grph_key_red_high;
  if (reg->bitfields.OV0_GRPH_KEY_RED_HIGH != ov0_grph_key_red_high) HSLDPF(E_ERROR_MESSAGE,"OV0_GRPH_KEY_CLR_HIGH::OV0_GRPH_KEY_RED_HIGH data too large\n");
}
__inline void set_OV0_GRPH_KEY_CLR_HIGH_ov0_grph_key_alpha_high(regOV0_GRPH_KEY_CLR_HIGH *reg, unsigned int ov0_grph_key_alpha_high)
{
  reg->bitfields.OV0_GRPH_KEY_ALPHA_HIGH = ov0_grph_key_alpha_high;
  if (reg->bitfields.OV0_GRPH_KEY_ALPHA_HIGH != ov0_grph_key_alpha_high) HSLDPF(E_ERROR_MESSAGE,"OV0_GRPH_KEY_CLR_HIGH::OV0_GRPH_KEY_ALPHA_HIGH data too large\n");
}
#else
#define set_OV0_GRPH_KEY_CLR_HIGH_ov0_grph_key_blue_high(reg, ov0_grph_key_blue_high) (reg)->bitfields.OV0_GRPH_KEY_BLUE_HIGH = ov0_grph_key_blue_high
#define set_OV0_GRPH_KEY_CLR_HIGH_ov0_grph_key_green_high(reg, ov0_grph_key_green_high) (reg)->bitfields.OV0_GRPH_KEY_GREEN_HIGH = ov0_grph_key_green_high
#define set_OV0_GRPH_KEY_CLR_HIGH_ov0_grph_key_red_high(reg, ov0_grph_key_red_high) (reg)->bitfields.OV0_GRPH_KEY_RED_HIGH = ov0_grph_key_red_high
#define set_OV0_GRPH_KEY_CLR_HIGH_ov0_grph_key_alpha_high(reg, ov0_grph_key_alpha_high) (reg)->bitfields.OV0_GRPH_KEY_ALPHA_HIGH = ov0_grph_key_alpha_high

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_KEY_CNTL regOV0_KEY_CNTL;

#ifdef DEBUG
__inline void set_OV0_KEY_CNTL_ov0_video_key_fn(regOV0_KEY_CNTL *reg, unsigned int ov0_video_key_fn)
{
  reg->bitfields.OV0_VIDEO_KEY_FN = ov0_video_key_fn;
  if (reg->bitfields.OV0_VIDEO_KEY_FN != ov0_video_key_fn) HSLDPF(E_ERROR_MESSAGE,"OV0_KEY_CNTL::OV0_VIDEO_KEY_FN data too large\n");
}
__inline void set_OV0_KEY_CNTL_ov0_graphics_key_fn(regOV0_KEY_CNTL *reg, unsigned int ov0_graphics_key_fn)
{
  reg->bitfields.OV0_GRAPHICS_KEY_FN = ov0_graphics_key_fn;
  if (reg->bitfields.OV0_GRAPHICS_KEY_FN != ov0_graphics_key_fn) HSLDPF(E_ERROR_MESSAGE,"OV0_KEY_CNTL::OV0_GRAPHICS_KEY_FN data too large\n");
}
__inline void set_OV0_KEY_CNTL_ov0_cmp_mix(regOV0_KEY_CNTL *reg, unsigned int ov0_cmp_mix)
{
  reg->bitfields.OV0_CMP_MIX = ov0_cmp_mix;
  if (reg->bitfields.OV0_CMP_MIX != ov0_cmp_mix) HSLDPF(E_ERROR_MESSAGE,"OV0_KEY_CNTL::OV0_CMP_MIX data too large\n");
}
#else
#define set_OV0_KEY_CNTL_ov0_video_key_fn(reg, ov0_video_key_fn) (reg)->bitfields.OV0_VIDEO_KEY_FN = ov0_video_key_fn
#define set_OV0_KEY_CNTL_ov0_graphics_key_fn(reg, ov0_graphics_key_fn) (reg)->bitfields.OV0_GRAPHICS_KEY_FN = ov0_graphics_key_fn
#define set_OV0_KEY_CNTL_ov0_cmp_mix(reg, ov0_cmp_mix) (reg)->bitfields.OV0_CMP_MIX = ov0_cmp_mix

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250OV0_TEST regrv250OV0_TEST;

#ifdef DEBUG
__inline void set_rv250OV0_TEST_ov0_min_offset_en(regrv250OV0_TEST *reg, unsigned int ov0_min_offset_en)
{
  reg->bitfields.OV0_MIN_OFFSET_EN = ov0_min_offset_en;
  if (reg->bitfields.OV0_MIN_OFFSET_EN != ov0_min_offset_en) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_TEST::OV0_MIN_OFFSET_EN data too large\n");
}
__inline void set_rv250OV0_TEST_ov0_subpic_only(regrv250OV0_TEST *reg, unsigned int ov0_subpic_only)
{
  reg->bitfields.OV0_SUBPIC_ONLY = ov0_subpic_only;
  if (reg->bitfields.OV0_SUBPIC_ONLY != ov0_subpic_only) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_TEST::OV0_SUBPIC_ONLY data too large\n");
}
__inline void set_rv250OV0_TEST_ov0_swap_uv(regrv250OV0_TEST *reg, unsigned int ov0_swap_uv)
{
  reg->bitfields.OV0_SWAP_UV = ov0_swap_uv;
  if (reg->bitfields.OV0_SWAP_UV != ov0_swap_uv) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_TEST::OV0_SWAP_UV data too large\n");
}
__inline void set_rv250OV0_TEST_ov0_noroundup(regrv250OV0_TEST *reg, unsigned int ov0_noroundup)
{
  reg->bitfields.OV0_NOROUNDUP = ov0_noroundup;
  if (reg->bitfields.OV0_NOROUNDUP != ov0_noroundup) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_TEST::OV0_NOROUNDUP data too large\n");
}
__inline void set_rv250OV0_TEST_ov0_4th_line_rule_en(regrv250OV0_TEST *reg, unsigned int ov0_4th_line_rule_en)
{
  reg->bitfields.OV0_4TH_LINE_RULE_EN = ov0_4th_line_rule_en;
  if (reg->bitfields.OV0_4TH_LINE_RULE_EN != ov0_4th_line_rule_en) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_TEST::OV0_4TH_LINE_RULE_EN data too large\n");
}
__inline void set_rv250OV0_TEST_ov0_read_behind_scan_margin(regrv250OV0_TEST *reg, unsigned int ov0_read_behind_scan_margin)
{
  reg->bitfields.OV0_READ_BEHIND_SCAN_MARGIN = ov0_read_behind_scan_margin;
  if (reg->bitfields.OV0_READ_BEHIND_SCAN_MARGIN != ov0_read_behind_scan_margin) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_TEST::OV0_READ_BEHIND_SCAN_MARGIN data too large\n");
}
#else
#define set_rv250OV0_TEST_ov0_min_offset_en(reg, ov0_min_offset_en) (reg)->bitfields.OV0_MIN_OFFSET_EN = ov0_min_offset_en
#define set_rv250OV0_TEST_ov0_subpic_only(reg, ov0_subpic_only) (reg)->bitfields.OV0_SUBPIC_ONLY = ov0_subpic_only
#define set_rv250OV0_TEST_ov0_swap_uv(reg, ov0_swap_uv) (reg)->bitfields.OV0_SWAP_UV = ov0_swap_uv
#define set_rv250OV0_TEST_ov0_noroundup(reg, ov0_noroundup) (reg)->bitfields.OV0_NOROUNDUP = ov0_noroundup
#define set_rv250OV0_TEST_ov0_4th_line_rule_en(reg, ov0_4th_line_rule_en) (reg)->bitfields.OV0_4TH_LINE_RULE_EN = ov0_4th_line_rule_en
#define set_rv250OV0_TEST_ov0_read_behind_scan_margin(reg, ov0_read_behind_scan_margin) (reg)->bitfields.OV0_READ_BEHIND_SCAN_MARGIN = ov0_read_behind_scan_margin

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_ADAPTIVE_DEINT_OFFSET regOV0_ADAPTIVE_DEINT_OFFSET;

#ifdef DEBUG
__inline void set_OV0_ADAPTIVE_DEINT_OFFSET_ov0_bp_offset(regOV0_ADAPTIVE_DEINT_OFFSET *reg, unsigned int ov0_bp_offset)
{
  reg->bitfields.OV0_BP_OFFSET = ov0_bp_offset;
  if (reg->bitfields.OV0_BP_OFFSET != ov0_bp_offset) HSLDPF(E_ERROR_MESSAGE,"OV0_ADAPTIVE_DEINT_OFFSET::OV0_BP_OFFSET data too large\n");
}
__inline void set_OV0_ADAPTIVE_DEINT_OFFSET_ov0_4th_line_rule_offset(regOV0_ADAPTIVE_DEINT_OFFSET *reg, unsigned int ov0_4th_line_rule_offset)
{
  reg->bitfields.OV0_4TH_LINE_RULE_OFFSET = ov0_4th_line_rule_offset;
  if (reg->bitfields.OV0_4TH_LINE_RULE_OFFSET != ov0_4th_line_rule_offset) HSLDPF(E_ERROR_MESSAGE,"OV0_ADAPTIVE_DEINT_OFFSET::OV0_4TH_LINE_RULE_OFFSET data too large\n");
}
#else
#define set_OV0_ADAPTIVE_DEINT_OFFSET_ov0_bp_offset(reg, ov0_bp_offset) (reg)->bitfields.OV0_BP_OFFSET = ov0_bp_offset
#define set_OV0_ADAPTIVE_DEINT_OFFSET_ov0_4th_line_rule_offset(reg, ov0_4th_line_rule_offset) (reg)->bitfields.OV0_4TH_LINE_RULE_OFFSET = ov0_4th_line_rule_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_CNTL regSUBPIC_CNTL;

#ifdef DEBUG
__inline void set_SUBPIC_CNTL_subpic_on(regSUBPIC_CNTL *reg, unsigned int subpic_on)
{
  reg->bitfields.SUBPIC_ON = subpic_on;
  if (reg->bitfields.SUBPIC_ON != subpic_on) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_CNTL::SUBPIC_ON data too large\n");
}
__inline void set_SUBPIC_CNTL_btn_hli_on(regSUBPIC_CNTL *reg, unsigned int btn_hli_on)
{
  reg->bitfields.BTN_HLI_ON = btn_hli_on;
  if (reg->bitfields.BTN_HLI_ON != btn_hli_on) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_CNTL::BTN_HLI_ON data too large\n");
}
__inline void set_SUBPIC_CNTL_sp_horz_mode(regSUBPIC_CNTL *reg, unsigned int sp_horz_mode)
{
  reg->bitfields.SP_HORZ_MODE = sp_horz_mode;
  if (reg->bitfields.SP_HORZ_MODE != sp_horz_mode) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_CNTL::SP_HORZ_MODE data too large\n");
}
__inline void set_SUBPIC_CNTL_sp_vert_mode(regSUBPIC_CNTL *reg, unsigned int sp_vert_mode)
{
  reg->bitfields.SP_VERT_MODE = sp_vert_mode;
  if (reg->bitfields.SP_VERT_MODE != sp_vert_mode) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_CNTL::SP_VERT_MODE data too large\n");
}
__inline void set_SUBPIC_CNTL_sp_odd_field(regSUBPIC_CNTL *reg, unsigned int sp_odd_field)
{
  reg->bitfields.SP_ODD_FIELD = sp_odd_field;
  if (reg->bitfields.SP_ODD_FIELD != sp_odd_field) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_CNTL::SP_ODD_FIELD data too large\n");
}
__inline void set_SUBPIC_CNTL_sp_buf_select(regSUBPIC_CNTL *reg, unsigned int sp_buf_select)
{
  reg->bitfields.SP_BUF_SELECT = sp_buf_select;
  if (reg->bitfields.SP_BUF_SELECT != sp_buf_select) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_CNTL::SP_BUF_SELECT data too large\n");
}
__inline void set_SUBPIC_CNTL_sp_no_r_edge_blend(regSUBPIC_CNTL *reg, unsigned int sp_no_r_edge_blend)
{
  reg->bitfields.SP_NO_R_EDGE_BLEND = sp_no_r_edge_blend;
  if (reg->bitfields.SP_NO_R_EDGE_BLEND != sp_no_r_edge_blend) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_CNTL::SP_NO_R_EDGE_BLEND data too large\n");
}
#else
#define set_SUBPIC_CNTL_subpic_on(reg, subpic_on) (reg)->bitfields.SUBPIC_ON = subpic_on
#define set_SUBPIC_CNTL_btn_hli_on(reg, btn_hli_on) (reg)->bitfields.BTN_HLI_ON = btn_hli_on
#define set_SUBPIC_CNTL_sp_horz_mode(reg, sp_horz_mode) (reg)->bitfields.SP_HORZ_MODE = sp_horz_mode
#define set_SUBPIC_CNTL_sp_vert_mode(reg, sp_vert_mode) (reg)->bitfields.SP_VERT_MODE = sp_vert_mode
#define set_SUBPIC_CNTL_sp_odd_field(reg, sp_odd_field) (reg)->bitfields.SP_ODD_FIELD = sp_odd_field
#define set_SUBPIC_CNTL_sp_buf_select(reg, sp_buf_select) (reg)->bitfields.SP_BUF_SELECT = sp_buf_select
#define set_SUBPIC_CNTL_sp_no_r_edge_blend(reg, sp_no_r_edge_blend) (reg)->bitfields.SP_NO_R_EDGE_BLEND = sp_no_r_edge_blend

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_DEFCOLCON regSUBPIC_DEFCOLCON;

#ifdef DEBUG
__inline void set_SUBPIC_DEFCOLCON_bkgd_pix_con(regSUBPIC_DEFCOLCON *reg, unsigned int bkgd_pix_con)
{
  reg->bitfields.BKGD_PIX_CON = bkgd_pix_con;
  if (reg->bitfields.BKGD_PIX_CON != bkgd_pix_con) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_DEFCOLCON::BKGD_PIX_CON data too large\n");
}
__inline void set_SUBPIC_DEFCOLCON_patt_pix_con(regSUBPIC_DEFCOLCON *reg, unsigned int patt_pix_con)
{
  reg->bitfields.PATT_PIX_CON = patt_pix_con;
  if (reg->bitfields.PATT_PIX_CON != patt_pix_con) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_DEFCOLCON::PATT_PIX_CON data too large\n");
}
__inline void set_SUBPIC_DEFCOLCON_emph_pix1_con(regSUBPIC_DEFCOLCON *reg, unsigned int emph_pix1_con)
{
  reg->bitfields.EMPH_PIX1_CON = emph_pix1_con;
  if (reg->bitfields.EMPH_PIX1_CON != emph_pix1_con) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_DEFCOLCON::EMPH_PIX1_CON data too large\n");
}
__inline void set_SUBPIC_DEFCOLCON_emph_pix2_con(regSUBPIC_DEFCOLCON *reg, unsigned int emph_pix2_con)
{
  reg->bitfields.EMPH_PIX2_CON = emph_pix2_con;
  if (reg->bitfields.EMPH_PIX2_CON != emph_pix2_con) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_DEFCOLCON::EMPH_PIX2_CON data too large\n");
}
__inline void set_SUBPIC_DEFCOLCON_bkgd_pix_clr(regSUBPIC_DEFCOLCON *reg, unsigned int bkgd_pix_clr)
{
  reg->bitfields.BKGD_PIX_CLR = bkgd_pix_clr;
  if (reg->bitfields.BKGD_PIX_CLR != bkgd_pix_clr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_DEFCOLCON::BKGD_PIX_CLR data too large\n");
}
__inline void set_SUBPIC_DEFCOLCON_patt_pix_clr(regSUBPIC_DEFCOLCON *reg, unsigned int patt_pix_clr)
{
  reg->bitfields.PATT_PIX_CLR = patt_pix_clr;
  if (reg->bitfields.PATT_PIX_CLR != patt_pix_clr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_DEFCOLCON::PATT_PIX_CLR data too large\n");
}
__inline void set_SUBPIC_DEFCOLCON_emph_pix1_clr(regSUBPIC_DEFCOLCON *reg, unsigned int emph_pix1_clr)
{
  reg->bitfields.EMPH_PIX1_CLR = emph_pix1_clr;
  if (reg->bitfields.EMPH_PIX1_CLR != emph_pix1_clr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_DEFCOLCON::EMPH_PIX1_CLR data too large\n");
}
__inline void set_SUBPIC_DEFCOLCON_emph_pix2_clr(regSUBPIC_DEFCOLCON *reg, unsigned int emph_pix2_clr)
{
  reg->bitfields.EMPH_PIX2_CLR = emph_pix2_clr;
  if (reg->bitfields.EMPH_PIX2_CLR != emph_pix2_clr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_DEFCOLCON::EMPH_PIX2_CLR data too large\n");
}
#else
#define set_SUBPIC_DEFCOLCON_bkgd_pix_con(reg, bkgd_pix_con) (reg)->bitfields.BKGD_PIX_CON = bkgd_pix_con
#define set_SUBPIC_DEFCOLCON_patt_pix_con(reg, patt_pix_con) (reg)->bitfields.PATT_PIX_CON = patt_pix_con
#define set_SUBPIC_DEFCOLCON_emph_pix1_con(reg, emph_pix1_con) (reg)->bitfields.EMPH_PIX1_CON = emph_pix1_con
#define set_SUBPIC_DEFCOLCON_emph_pix2_con(reg, emph_pix2_con) (reg)->bitfields.EMPH_PIX2_CON = emph_pix2_con
#define set_SUBPIC_DEFCOLCON_bkgd_pix_clr(reg, bkgd_pix_clr) (reg)->bitfields.BKGD_PIX_CLR = bkgd_pix_clr
#define set_SUBPIC_DEFCOLCON_patt_pix_clr(reg, patt_pix_clr) (reg)->bitfields.PATT_PIX_CLR = patt_pix_clr
#define set_SUBPIC_DEFCOLCON_emph_pix1_clr(reg, emph_pix1_clr) (reg)->bitfields.EMPH_PIX1_CLR = emph_pix1_clr
#define set_SUBPIC_DEFCOLCON_emph_pix2_clr(reg, emph_pix2_clr) (reg)->bitfields.EMPH_PIX2_CLR = emph_pix2_clr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_Y_X_START regSUBPIC_Y_X_START;

#ifdef DEBUG
__inline void set_SUBPIC_Y_X_START_sp_start_x(regSUBPIC_Y_X_START *reg, unsigned int sp_start_x)
{
  reg->bitfields.SP_START_X = sp_start_x;
  if (reg->bitfields.SP_START_X != sp_start_x) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_Y_X_START::SP_START_X data too large\n");
}
__inline void set_SUBPIC_Y_X_START_sp_start_y(regSUBPIC_Y_X_START *reg, unsigned int sp_start_y)
{
  reg->bitfields.SP_START_Y = sp_start_y;
  if (reg->bitfields.SP_START_Y != sp_start_y) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_Y_X_START::SP_START_Y data too large\n");
}
#else
#define set_SUBPIC_Y_X_START_sp_start_x(reg, sp_start_x) (reg)->bitfields.SP_START_X = sp_start_x
#define set_SUBPIC_Y_X_START_sp_start_y(reg, sp_start_y) (reg)->bitfields.SP_START_Y = sp_start_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_Y_X_END regSUBPIC_Y_X_END;

#ifdef DEBUG
__inline void set_SUBPIC_Y_X_END_sp_end_x(regSUBPIC_Y_X_END *reg, unsigned int sp_end_x)
{
  reg->bitfields.SP_END_X = sp_end_x;
  if (reg->bitfields.SP_END_X != sp_end_x) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_Y_X_END::SP_END_X data too large\n");
}
__inline void set_SUBPIC_Y_X_END_sp_end_y(regSUBPIC_Y_X_END *reg, unsigned int sp_end_y)
{
  reg->bitfields.SP_END_Y = sp_end_y;
  if (reg->bitfields.SP_END_Y != sp_end_y) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_Y_X_END::SP_END_Y data too large\n");
}
#else
#define set_SUBPIC_Y_X_END_sp_end_x(reg, sp_end_x) (reg)->bitfields.SP_END_X = sp_end_x
#define set_SUBPIC_Y_X_END_sp_end_y(reg, sp_end_y) (reg)->bitfields.SP_END_Y = sp_end_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_V_INC regSUBPIC_V_INC;

#ifdef DEBUG
__inline void set_SUBPIC_V_INC_sp_v_inc_frac(regSUBPIC_V_INC *reg, unsigned int sp_v_inc_frac)
{
  reg->bitfields.SP_V_INC_FRAC = sp_v_inc_frac;
  if (reg->bitfields.SP_V_INC_FRAC != sp_v_inc_frac) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_V_INC::SP_V_INC_FRAC data too large\n");
}
__inline void set_SUBPIC_V_INC_sp_v_inc_int(regSUBPIC_V_INC *reg, unsigned int sp_v_inc_int)
{
  reg->bitfields.SP_V_INC_INT = sp_v_inc_int;
  if (reg->bitfields.SP_V_INC_INT != sp_v_inc_int) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_V_INC::SP_V_INC_INT data too large\n");
}
#else
#define set_SUBPIC_V_INC_sp_v_inc_frac(reg, sp_v_inc_frac) (reg)->bitfields.SP_V_INC_FRAC = sp_v_inc_frac
#define set_SUBPIC_V_INC_sp_v_inc_int(reg, sp_v_inc_int) (reg)->bitfields.SP_V_INC_INT = sp_v_inc_int

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_H_INC regSUBPIC_H_INC;

#ifdef DEBUG
__inline void set_SUBPIC_H_INC_sp_h_inc_frac(regSUBPIC_H_INC *reg, unsigned int sp_h_inc_frac)
{
  reg->bitfields.SP_H_INC_FRAC = sp_h_inc_frac;
  if (reg->bitfields.SP_H_INC_FRAC != sp_h_inc_frac) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_H_INC::SP_H_INC_FRAC data too large\n");
}
__inline void set_SUBPIC_H_INC_sp_h_inc_int(regSUBPIC_H_INC *reg, unsigned int sp_h_inc_int)
{
  reg->bitfields.SP_H_INC_INT = sp_h_inc_int;
  if (reg->bitfields.SP_H_INC_INT != sp_h_inc_int) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_H_INC::SP_H_INC_INT data too large\n");
}
#else
#define set_SUBPIC_H_INC_sp_h_inc_frac(reg, sp_h_inc_frac) (reg)->bitfields.SP_H_INC_FRAC = sp_h_inc_frac
#define set_SUBPIC_H_INC_sp_h_inc_int(reg, sp_h_inc_int) (reg)->bitfields.SP_H_INC_INT = sp_h_inc_int

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_BUF0_OFFSET regSUBPIC_BUF0_OFFSET;

#ifdef DEBUG
__inline void set_SUBPIC_BUF0_OFFSET_subpic_offset0(regSUBPIC_BUF0_OFFSET *reg, unsigned int subpic_offset0)
{
  reg->bitfields.SUBPIC_OFFSET0 = subpic_offset0;
  if (reg->bitfields.SUBPIC_OFFSET0 != subpic_offset0) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_BUF0_OFFSET::SUBPIC_OFFSET0 data too large\n");
}
#else
#define set_SUBPIC_BUF0_OFFSET_subpic_offset0(reg, subpic_offset0) (reg)->bitfields.SUBPIC_OFFSET0 = subpic_offset0

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_BUF1_OFFSET regSUBPIC_BUF1_OFFSET;

#ifdef DEBUG
__inline void set_SUBPIC_BUF1_OFFSET_subpic_offset1(regSUBPIC_BUF1_OFFSET *reg, unsigned int subpic_offset1)
{
  reg->bitfields.SUBPIC_OFFSET1 = subpic_offset1;
  if (reg->bitfields.SUBPIC_OFFSET1 != subpic_offset1) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_BUF1_OFFSET::SUBPIC_OFFSET1 data too large\n");
}
#else
#define set_SUBPIC_BUF1_OFFSET_subpic_offset1(reg, subpic_offset1) (reg)->bitfields.SUBPIC_OFFSET1 = subpic_offset1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_LC0_OFFSET regSUBPIC_LC0_OFFSET;

#ifdef DEBUG
__inline void set_SUBPIC_LC0_OFFSET_subpic_lc0_offset(regSUBPIC_LC0_OFFSET *reg, unsigned int subpic_lc0_offset)
{
  reg->bitfields.SUBPIC_LC0_OFFSET = subpic_lc0_offset;
  if (reg->bitfields.SUBPIC_LC0_OFFSET != subpic_lc0_offset) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_LC0_OFFSET::SUBPIC_LC0_OFFSET data too large\n");
}
#else
#define set_SUBPIC_LC0_OFFSET_subpic_lc0_offset(reg, subpic_lc0_offset) (reg)->bitfields.SUBPIC_LC0_OFFSET = subpic_lc0_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_LC1_OFFSET regSUBPIC_LC1_OFFSET;

#ifdef DEBUG
__inline void set_SUBPIC_LC1_OFFSET_subpic_lc1_offset(regSUBPIC_LC1_OFFSET *reg, unsigned int subpic_lc1_offset)
{
  reg->bitfields.SUBPIC_LC1_OFFSET = subpic_lc1_offset;
  if (reg->bitfields.SUBPIC_LC1_OFFSET != subpic_lc1_offset) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_LC1_OFFSET::SUBPIC_LC1_OFFSET data too large\n");
}
#else
#define set_SUBPIC_LC1_OFFSET_subpic_lc1_offset(reg, subpic_lc1_offset) (reg)->bitfields.SUBPIC_LC1_OFFSET = subpic_lc1_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_PITCH regSUBPIC_PITCH;

#ifdef DEBUG
__inline void set_SUBPIC_PITCH_subpic_buf_pitch(regSUBPIC_PITCH *reg, unsigned int subpic_buf_pitch)
{
  reg->bitfields.SUBPIC_BUF_PITCH = subpic_buf_pitch;
  if (reg->bitfields.SUBPIC_BUF_PITCH != subpic_buf_pitch) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_PITCH::SUBPIC_BUF_PITCH data too large\n");
}
__inline void set_SUBPIC_PITCH_subpic_lc_pitch(regSUBPIC_PITCH *reg, unsigned int subpic_lc_pitch)
{
  reg->bitfields.SUBPIC_LC_PITCH = subpic_lc_pitch;
  if (reg->bitfields.SUBPIC_LC_PITCH != subpic_lc_pitch) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_PITCH::SUBPIC_LC_PITCH data too large\n");
}
#else
#define set_SUBPIC_PITCH_subpic_buf_pitch(reg, subpic_buf_pitch) (reg)->bitfields.SUBPIC_BUF_PITCH = subpic_buf_pitch
#define set_SUBPIC_PITCH_subpic_lc_pitch(reg, subpic_lc_pitch) (reg)->bitfields.SUBPIC_LC_PITCH = subpic_lc_pitch

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_BTN_HLI_COLCON regSUBPIC_BTN_HLI_COLCON;

#ifdef DEBUG
__inline void set_SUBPIC_BTN_HLI_COLCON_btn_hli_bkgd_pix_con(regSUBPIC_BTN_HLI_COLCON *reg, unsigned int btn_hli_bkgd_pix_con)
{
  reg->bitfields.BTN_HLI_BKGD_PIX_CON = btn_hli_bkgd_pix_con;
  if (reg->bitfields.BTN_HLI_BKGD_PIX_CON != btn_hli_bkgd_pix_con) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_BTN_HLI_COLCON::BTN_HLI_BKGD_PIX_CON data too large\n");
}
__inline void set_SUBPIC_BTN_HLI_COLCON_btn_hli_patt_pix_con(regSUBPIC_BTN_HLI_COLCON *reg, unsigned int btn_hli_patt_pix_con)
{
  reg->bitfields.BTN_HLI_PATT_PIX_CON = btn_hli_patt_pix_con;
  if (reg->bitfields.BTN_HLI_PATT_PIX_CON != btn_hli_patt_pix_con) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_BTN_HLI_COLCON::BTN_HLI_PATT_PIX_CON data too large\n");
}
__inline void set_SUBPIC_BTN_HLI_COLCON_btn_hli_emph_pix1_con(regSUBPIC_BTN_HLI_COLCON *reg, unsigned int btn_hli_emph_pix1_con)
{
  reg->bitfields.BTN_HLI_EMPH_PIX1_CON = btn_hli_emph_pix1_con;
  if (reg->bitfields.BTN_HLI_EMPH_PIX1_CON != btn_hli_emph_pix1_con) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_BTN_HLI_COLCON::BTN_HLI_EMPH_PIX1_CON data too large\n");
}
__inline void set_SUBPIC_BTN_HLI_COLCON_btn_hli_emph_pix2_con(regSUBPIC_BTN_HLI_COLCON *reg, unsigned int btn_hli_emph_pix2_con)
{
  reg->bitfields.BTN_HLI_EMPH_PIX2_CON = btn_hli_emph_pix2_con;
  if (reg->bitfields.BTN_HLI_EMPH_PIX2_CON != btn_hli_emph_pix2_con) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_BTN_HLI_COLCON::BTN_HLI_EMPH_PIX2_CON data too large\n");
}
__inline void set_SUBPIC_BTN_HLI_COLCON_btn_hli_bkgd_pix_clr(regSUBPIC_BTN_HLI_COLCON *reg, unsigned int btn_hli_bkgd_pix_clr)
{
  reg->bitfields.BTN_HLI_BKGD_PIX_CLR = btn_hli_bkgd_pix_clr;
  if (reg->bitfields.BTN_HLI_BKGD_PIX_CLR != btn_hli_bkgd_pix_clr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_BTN_HLI_COLCON::BTN_HLI_BKGD_PIX_CLR data too large\n");
}
__inline void set_SUBPIC_BTN_HLI_COLCON_btn_hli_patt_pix_clr(regSUBPIC_BTN_HLI_COLCON *reg, unsigned int btn_hli_patt_pix_clr)
{
  reg->bitfields.BTN_HLI_PATT_PIX_CLR = btn_hli_patt_pix_clr;
  if (reg->bitfields.BTN_HLI_PATT_PIX_CLR != btn_hli_patt_pix_clr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_BTN_HLI_COLCON::BTN_HLI_PATT_PIX_CLR data too large\n");
}
__inline void set_SUBPIC_BTN_HLI_COLCON_btn_hli_emph_pix1_clr(regSUBPIC_BTN_HLI_COLCON *reg, unsigned int btn_hli_emph_pix1_clr)
{
  reg->bitfields.BTN_HLI_EMPH_PIX1_CLR = btn_hli_emph_pix1_clr;
  if (reg->bitfields.BTN_HLI_EMPH_PIX1_CLR != btn_hli_emph_pix1_clr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_BTN_HLI_COLCON::BTN_HLI_EMPH_PIX1_CLR data too large\n");
}
__inline void set_SUBPIC_BTN_HLI_COLCON_btn_hli_emph_pix2_clr(regSUBPIC_BTN_HLI_COLCON *reg, unsigned int btn_hli_emph_pix2_clr)
{
  reg->bitfields.BTN_HLI_EMPH_PIX2_CLR = btn_hli_emph_pix2_clr;
  if (reg->bitfields.BTN_HLI_EMPH_PIX2_CLR != btn_hli_emph_pix2_clr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_BTN_HLI_COLCON::BTN_HLI_EMPH_PIX2_CLR data too large\n");
}
#else
#define set_SUBPIC_BTN_HLI_COLCON_btn_hli_bkgd_pix_con(reg, btn_hli_bkgd_pix_con) (reg)->bitfields.BTN_HLI_BKGD_PIX_CON = btn_hli_bkgd_pix_con
#define set_SUBPIC_BTN_HLI_COLCON_btn_hli_patt_pix_con(reg, btn_hli_patt_pix_con) (reg)->bitfields.BTN_HLI_PATT_PIX_CON = btn_hli_patt_pix_con
#define set_SUBPIC_BTN_HLI_COLCON_btn_hli_emph_pix1_con(reg, btn_hli_emph_pix1_con) (reg)->bitfields.BTN_HLI_EMPH_PIX1_CON = btn_hli_emph_pix1_con
#define set_SUBPIC_BTN_HLI_COLCON_btn_hli_emph_pix2_con(reg, btn_hli_emph_pix2_con) (reg)->bitfields.BTN_HLI_EMPH_PIX2_CON = btn_hli_emph_pix2_con
#define set_SUBPIC_BTN_HLI_COLCON_btn_hli_bkgd_pix_clr(reg, btn_hli_bkgd_pix_clr) (reg)->bitfields.BTN_HLI_BKGD_PIX_CLR = btn_hli_bkgd_pix_clr
#define set_SUBPIC_BTN_HLI_COLCON_btn_hli_patt_pix_clr(reg, btn_hli_patt_pix_clr) (reg)->bitfields.BTN_HLI_PATT_PIX_CLR = btn_hli_patt_pix_clr
#define set_SUBPIC_BTN_HLI_COLCON_btn_hli_emph_pix1_clr(reg, btn_hli_emph_pix1_clr) (reg)->bitfields.BTN_HLI_EMPH_PIX1_CLR = btn_hli_emph_pix1_clr
#define set_SUBPIC_BTN_HLI_COLCON_btn_hli_emph_pix2_clr(reg, btn_hli_emph_pix2_clr) (reg)->bitfields.BTN_HLI_EMPH_PIX2_CLR = btn_hli_emph_pix2_clr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_BTN_HLI_Y_X_START regSUBPIC_BTN_HLI_Y_X_START;

#ifdef DEBUG
__inline void set_SUBPIC_BTN_HLI_Y_X_START_btn_hli_start_x(regSUBPIC_BTN_HLI_Y_X_START *reg, unsigned int btn_hli_start_x)
{
  reg->bitfields.BTN_HLI_START_X = btn_hli_start_x;
  if (reg->bitfields.BTN_HLI_START_X != btn_hli_start_x) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_BTN_HLI_Y_X_START::BTN_HLI_START_X data too large\n");
}
__inline void set_SUBPIC_BTN_HLI_Y_X_START_btn_hli_start_y(regSUBPIC_BTN_HLI_Y_X_START *reg, unsigned int btn_hli_start_y)
{
  reg->bitfields.BTN_HLI_START_Y = btn_hli_start_y;
  if (reg->bitfields.BTN_HLI_START_Y != btn_hli_start_y) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_BTN_HLI_Y_X_START::BTN_HLI_START_Y data too large\n");
}
#else
#define set_SUBPIC_BTN_HLI_Y_X_START_btn_hli_start_x(reg, btn_hli_start_x) (reg)->bitfields.BTN_HLI_START_X = btn_hli_start_x
#define set_SUBPIC_BTN_HLI_Y_X_START_btn_hli_start_y(reg, btn_hli_start_y) (reg)->bitfields.BTN_HLI_START_Y = btn_hli_start_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_BTN_HLI_Y_X_END regSUBPIC_BTN_HLI_Y_X_END;

#ifdef DEBUG
__inline void set_SUBPIC_BTN_HLI_Y_X_END_btn_hli_end_x(regSUBPIC_BTN_HLI_Y_X_END *reg, unsigned int btn_hli_end_x)
{
  reg->bitfields.BTN_HLI_END_X = btn_hli_end_x;
  if (reg->bitfields.BTN_HLI_END_X != btn_hli_end_x) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_BTN_HLI_Y_X_END::BTN_HLI_END_X data too large\n");
}
__inline void set_SUBPIC_BTN_HLI_Y_X_END_btn_hli_end_y(regSUBPIC_BTN_HLI_Y_X_END *reg, unsigned int btn_hli_end_y)
{
  reg->bitfields.BTN_HLI_END_Y = btn_hli_end_y;
  if (reg->bitfields.BTN_HLI_END_Y != btn_hli_end_y) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_BTN_HLI_Y_X_END::BTN_HLI_END_Y data too large\n");
}
#else
#define set_SUBPIC_BTN_HLI_Y_X_END_btn_hli_end_x(reg, btn_hli_end_x) (reg)->bitfields.BTN_HLI_END_X = btn_hli_end_x
#define set_SUBPIC_BTN_HLI_Y_X_END_btn_hli_end_y(reg, btn_hli_end_y) (reg)->bitfields.BTN_HLI_END_Y = btn_hli_end_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_PALETTE_INDEX regSUBPIC_PALETTE_INDEX;

#ifdef DEBUG
__inline void set_SUBPIC_PALETTE_INDEX_sp_pal_addr(regSUBPIC_PALETTE_INDEX *reg, unsigned int sp_pal_addr)
{
  reg->bitfields.SP_PAL_ADDR = sp_pal_addr;
  if (reg->bitfields.SP_PAL_ADDR != sp_pal_addr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_PALETTE_INDEX::SP_PAL_ADDR data too large\n");
}
#else
#define set_SUBPIC_PALETTE_INDEX_sp_pal_addr(reg, sp_pal_addr) (reg)->bitfields.SP_PAL_ADDR = sp_pal_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_PALETTE_DATA regSUBPIC_PALETTE_DATA;

#ifdef DEBUG
__inline void set_SUBPIC_PALETTE_DATA_sp_data(regSUBPIC_PALETTE_DATA *reg, unsigned int sp_data)
{
  reg->bitfields.SP_DATA = sp_data;
  if (reg->bitfields.SP_DATA != sp_data) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_PALETTE_DATA::SP_DATA data too large\n");
}
#else
#define set_SUBPIC_PALETTE_DATA_sp_data(reg, sp_data) (reg)->bitfields.SP_DATA = sp_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_0_PAL regSUBPIC_0_PAL;

#ifdef DEBUG
__inline void set_SUBPIC_0_PAL_sp_cb(regSUBPIC_0_PAL *reg, unsigned int sp_cb)
{
  reg->bitfields.SP_CB = sp_cb;
  if (reg->bitfields.SP_CB != sp_cb) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_0_PAL::SP_CB data too large\n");
}
__inline void set_SUBPIC_0_PAL_sp_cr(regSUBPIC_0_PAL *reg, unsigned int sp_cr)
{
  reg->bitfields.SP_CR = sp_cr;
  if (reg->bitfields.SP_CR != sp_cr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_0_PAL::SP_CR data too large\n");
}
__inline void set_SUBPIC_0_PAL_sp_y(regSUBPIC_0_PAL *reg, unsigned int sp_y)
{
  reg->bitfields.SP_Y = sp_y;
  if (reg->bitfields.SP_Y != sp_y) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_0_PAL::SP_Y data too large\n");
}
#else
#define set_SUBPIC_0_PAL_sp_cb(reg, sp_cb) (reg)->bitfields.SP_CB = sp_cb
#define set_SUBPIC_0_PAL_sp_cr(reg, sp_cr) (reg)->bitfields.SP_CR = sp_cr
#define set_SUBPIC_0_PAL_sp_y(reg, sp_y) (reg)->bitfields.SP_Y = sp_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_1_PAL regSUBPIC_1_PAL;

#ifdef DEBUG
__inline void set_SUBPIC_1_PAL_sp_cb(regSUBPIC_1_PAL *reg, unsigned int sp_cb)
{
  reg->bitfields.SP_CB = sp_cb;
  if (reg->bitfields.SP_CB != sp_cb) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_1_PAL::SP_CB data too large\n");
}
__inline void set_SUBPIC_1_PAL_sp_cr(regSUBPIC_1_PAL *reg, unsigned int sp_cr)
{
  reg->bitfields.SP_CR = sp_cr;
  if (reg->bitfields.SP_CR != sp_cr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_1_PAL::SP_CR data too large\n");
}
__inline void set_SUBPIC_1_PAL_sp_y(regSUBPIC_1_PAL *reg, unsigned int sp_y)
{
  reg->bitfields.SP_Y = sp_y;
  if (reg->bitfields.SP_Y != sp_y) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_1_PAL::SP_Y data too large\n");
}
#else
#define set_SUBPIC_1_PAL_sp_cb(reg, sp_cb) (reg)->bitfields.SP_CB = sp_cb
#define set_SUBPIC_1_PAL_sp_cr(reg, sp_cr) (reg)->bitfields.SP_CR = sp_cr
#define set_SUBPIC_1_PAL_sp_y(reg, sp_y) (reg)->bitfields.SP_Y = sp_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_2_PAL regSUBPIC_2_PAL;

#ifdef DEBUG
__inline void set_SUBPIC_2_PAL_sp_cb(regSUBPIC_2_PAL *reg, unsigned int sp_cb)
{
  reg->bitfields.SP_CB = sp_cb;
  if (reg->bitfields.SP_CB != sp_cb) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_2_PAL::SP_CB data too large\n");
}
__inline void set_SUBPIC_2_PAL_sp_cr(regSUBPIC_2_PAL *reg, unsigned int sp_cr)
{
  reg->bitfields.SP_CR = sp_cr;
  if (reg->bitfields.SP_CR != sp_cr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_2_PAL::SP_CR data too large\n");
}
__inline void set_SUBPIC_2_PAL_sp_y(regSUBPIC_2_PAL *reg, unsigned int sp_y)
{
  reg->bitfields.SP_Y = sp_y;
  if (reg->bitfields.SP_Y != sp_y) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_2_PAL::SP_Y data too large\n");
}
#else
#define set_SUBPIC_2_PAL_sp_cb(reg, sp_cb) (reg)->bitfields.SP_CB = sp_cb
#define set_SUBPIC_2_PAL_sp_cr(reg, sp_cr) (reg)->bitfields.SP_CR = sp_cr
#define set_SUBPIC_2_PAL_sp_y(reg, sp_y) (reg)->bitfields.SP_Y = sp_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_3_PAL regSUBPIC_3_PAL;

#ifdef DEBUG
__inline void set_SUBPIC_3_PAL_sp_cb(regSUBPIC_3_PAL *reg, unsigned int sp_cb)
{
  reg->bitfields.SP_CB = sp_cb;
  if (reg->bitfields.SP_CB != sp_cb) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_3_PAL::SP_CB data too large\n");
}
__inline void set_SUBPIC_3_PAL_sp_cr(regSUBPIC_3_PAL *reg, unsigned int sp_cr)
{
  reg->bitfields.SP_CR = sp_cr;
  if (reg->bitfields.SP_CR != sp_cr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_3_PAL::SP_CR data too large\n");
}
__inline void set_SUBPIC_3_PAL_sp_y(regSUBPIC_3_PAL *reg, unsigned int sp_y)
{
  reg->bitfields.SP_Y = sp_y;
  if (reg->bitfields.SP_Y != sp_y) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_3_PAL::SP_Y data too large\n");
}
#else
#define set_SUBPIC_3_PAL_sp_cb(reg, sp_cb) (reg)->bitfields.SP_CB = sp_cb
#define set_SUBPIC_3_PAL_sp_cr(reg, sp_cr) (reg)->bitfields.SP_CR = sp_cr
#define set_SUBPIC_3_PAL_sp_y(reg, sp_y) (reg)->bitfields.SP_Y = sp_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_4_PAL regSUBPIC_4_PAL;

#ifdef DEBUG
__inline void set_SUBPIC_4_PAL_sp_cb(regSUBPIC_4_PAL *reg, unsigned int sp_cb)
{
  reg->bitfields.SP_CB = sp_cb;
  if (reg->bitfields.SP_CB != sp_cb) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_4_PAL::SP_CB data too large\n");
}
__inline void set_SUBPIC_4_PAL_sp_cr(regSUBPIC_4_PAL *reg, unsigned int sp_cr)
{
  reg->bitfields.SP_CR = sp_cr;
  if (reg->bitfields.SP_CR != sp_cr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_4_PAL::SP_CR data too large\n");
}
__inline void set_SUBPIC_4_PAL_sp_y(regSUBPIC_4_PAL *reg, unsigned int sp_y)
{
  reg->bitfields.SP_Y = sp_y;
  if (reg->bitfields.SP_Y != sp_y) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_4_PAL::SP_Y data too large\n");
}
#else
#define set_SUBPIC_4_PAL_sp_cb(reg, sp_cb) (reg)->bitfields.SP_CB = sp_cb
#define set_SUBPIC_4_PAL_sp_cr(reg, sp_cr) (reg)->bitfields.SP_CR = sp_cr
#define set_SUBPIC_4_PAL_sp_y(reg, sp_y) (reg)->bitfields.SP_Y = sp_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_5_PAL regSUBPIC_5_PAL;

#ifdef DEBUG
__inline void set_SUBPIC_5_PAL_sp_cb(regSUBPIC_5_PAL *reg, unsigned int sp_cb)
{
  reg->bitfields.SP_CB = sp_cb;
  if (reg->bitfields.SP_CB != sp_cb) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_5_PAL::SP_CB data too large\n");
}
__inline void set_SUBPIC_5_PAL_sp_cr(regSUBPIC_5_PAL *reg, unsigned int sp_cr)
{
  reg->bitfields.SP_CR = sp_cr;
  if (reg->bitfields.SP_CR != sp_cr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_5_PAL::SP_CR data too large\n");
}
__inline void set_SUBPIC_5_PAL_sp_y(regSUBPIC_5_PAL *reg, unsigned int sp_y)
{
  reg->bitfields.SP_Y = sp_y;
  if (reg->bitfields.SP_Y != sp_y) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_5_PAL::SP_Y data too large\n");
}
#else
#define set_SUBPIC_5_PAL_sp_cb(reg, sp_cb) (reg)->bitfields.SP_CB = sp_cb
#define set_SUBPIC_5_PAL_sp_cr(reg, sp_cr) (reg)->bitfields.SP_CR = sp_cr
#define set_SUBPIC_5_PAL_sp_y(reg, sp_y) (reg)->bitfields.SP_Y = sp_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_6_PAL regSUBPIC_6_PAL;

#ifdef DEBUG
__inline void set_SUBPIC_6_PAL_sp_cb(regSUBPIC_6_PAL *reg, unsigned int sp_cb)
{
  reg->bitfields.SP_CB = sp_cb;
  if (reg->bitfields.SP_CB != sp_cb) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_6_PAL::SP_CB data too large\n");
}
__inline void set_SUBPIC_6_PAL_sp_cr(regSUBPIC_6_PAL *reg, unsigned int sp_cr)
{
  reg->bitfields.SP_CR = sp_cr;
  if (reg->bitfields.SP_CR != sp_cr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_6_PAL::SP_CR data too large\n");
}
__inline void set_SUBPIC_6_PAL_sp_y(regSUBPIC_6_PAL *reg, unsigned int sp_y)
{
  reg->bitfields.SP_Y = sp_y;
  if (reg->bitfields.SP_Y != sp_y) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_6_PAL::SP_Y data too large\n");
}
#else
#define set_SUBPIC_6_PAL_sp_cb(reg, sp_cb) (reg)->bitfields.SP_CB = sp_cb
#define set_SUBPIC_6_PAL_sp_cr(reg, sp_cr) (reg)->bitfields.SP_CR = sp_cr
#define set_SUBPIC_6_PAL_sp_y(reg, sp_y) (reg)->bitfields.SP_Y = sp_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_7_PAL regSUBPIC_7_PAL;

#ifdef DEBUG
__inline void set_SUBPIC_7_PAL_sp_cb(regSUBPIC_7_PAL *reg, unsigned int sp_cb)
{
  reg->bitfields.SP_CB = sp_cb;
  if (reg->bitfields.SP_CB != sp_cb) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_7_PAL::SP_CB data too large\n");
}
__inline void set_SUBPIC_7_PAL_sp_cr(regSUBPIC_7_PAL *reg, unsigned int sp_cr)
{
  reg->bitfields.SP_CR = sp_cr;
  if (reg->bitfields.SP_CR != sp_cr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_7_PAL::SP_CR data too large\n");
}
__inline void set_SUBPIC_7_PAL_sp_y(regSUBPIC_7_PAL *reg, unsigned int sp_y)
{
  reg->bitfields.SP_Y = sp_y;
  if (reg->bitfields.SP_Y != sp_y) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_7_PAL::SP_Y data too large\n");
}
#else
#define set_SUBPIC_7_PAL_sp_cb(reg, sp_cb) (reg)->bitfields.SP_CB = sp_cb
#define set_SUBPIC_7_PAL_sp_cr(reg, sp_cr) (reg)->bitfields.SP_CR = sp_cr
#define set_SUBPIC_7_PAL_sp_y(reg, sp_y) (reg)->bitfields.SP_Y = sp_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_8_PAL regSUBPIC_8_PAL;

#ifdef DEBUG
__inline void set_SUBPIC_8_PAL_sp_cb(regSUBPIC_8_PAL *reg, unsigned int sp_cb)
{
  reg->bitfields.SP_CB = sp_cb;
  if (reg->bitfields.SP_CB != sp_cb) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_8_PAL::SP_CB data too large\n");
}
__inline void set_SUBPIC_8_PAL_sp_cr(regSUBPIC_8_PAL *reg, unsigned int sp_cr)
{
  reg->bitfields.SP_CR = sp_cr;
  if (reg->bitfields.SP_CR != sp_cr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_8_PAL::SP_CR data too large\n");
}
__inline void set_SUBPIC_8_PAL_sp_y(regSUBPIC_8_PAL *reg, unsigned int sp_y)
{
  reg->bitfields.SP_Y = sp_y;
  if (reg->bitfields.SP_Y != sp_y) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_8_PAL::SP_Y data too large\n");
}
#else
#define set_SUBPIC_8_PAL_sp_cb(reg, sp_cb) (reg)->bitfields.SP_CB = sp_cb
#define set_SUBPIC_8_PAL_sp_cr(reg, sp_cr) (reg)->bitfields.SP_CR = sp_cr
#define set_SUBPIC_8_PAL_sp_y(reg, sp_y) (reg)->bitfields.SP_Y = sp_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_9_PAL regSUBPIC_9_PAL;

#ifdef DEBUG
__inline void set_SUBPIC_9_PAL_sp_cb(regSUBPIC_9_PAL *reg, unsigned int sp_cb)
{
  reg->bitfields.SP_CB = sp_cb;
  if (reg->bitfields.SP_CB != sp_cb) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_9_PAL::SP_CB data too large\n");
}
__inline void set_SUBPIC_9_PAL_sp_cr(regSUBPIC_9_PAL *reg, unsigned int sp_cr)
{
  reg->bitfields.SP_CR = sp_cr;
  if (reg->bitfields.SP_CR != sp_cr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_9_PAL::SP_CR data too large\n");
}
__inline void set_SUBPIC_9_PAL_sp_y(regSUBPIC_9_PAL *reg, unsigned int sp_y)
{
  reg->bitfields.SP_Y = sp_y;
  if (reg->bitfields.SP_Y != sp_y) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_9_PAL::SP_Y data too large\n");
}
#else
#define set_SUBPIC_9_PAL_sp_cb(reg, sp_cb) (reg)->bitfields.SP_CB = sp_cb
#define set_SUBPIC_9_PAL_sp_cr(reg, sp_cr) (reg)->bitfields.SP_CR = sp_cr
#define set_SUBPIC_9_PAL_sp_y(reg, sp_y) (reg)->bitfields.SP_Y = sp_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_A_PAL regSUBPIC_A_PAL;

#ifdef DEBUG
__inline void set_SUBPIC_A_PAL_sp_cb(regSUBPIC_A_PAL *reg, unsigned int sp_cb)
{
  reg->bitfields.SP_CB = sp_cb;
  if (reg->bitfields.SP_CB != sp_cb) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_A_PAL::SP_CB data too large\n");
}
__inline void set_SUBPIC_A_PAL_sp_cr(regSUBPIC_A_PAL *reg, unsigned int sp_cr)
{
  reg->bitfields.SP_CR = sp_cr;
  if (reg->bitfields.SP_CR != sp_cr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_A_PAL::SP_CR data too large\n");
}
__inline void set_SUBPIC_A_PAL_sp_y(regSUBPIC_A_PAL *reg, unsigned int sp_y)
{
  reg->bitfields.SP_Y = sp_y;
  if (reg->bitfields.SP_Y != sp_y) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_A_PAL::SP_Y data too large\n");
}
#else
#define set_SUBPIC_A_PAL_sp_cb(reg, sp_cb) (reg)->bitfields.SP_CB = sp_cb
#define set_SUBPIC_A_PAL_sp_cr(reg, sp_cr) (reg)->bitfields.SP_CR = sp_cr
#define set_SUBPIC_A_PAL_sp_y(reg, sp_y) (reg)->bitfields.SP_Y = sp_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_B_PAL regSUBPIC_B_PAL;

#ifdef DEBUG
__inline void set_SUBPIC_B_PAL_sp_cb(regSUBPIC_B_PAL *reg, unsigned int sp_cb)
{
  reg->bitfields.SP_CB = sp_cb;
  if (reg->bitfields.SP_CB != sp_cb) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_B_PAL::SP_CB data too large\n");
}
__inline void set_SUBPIC_B_PAL_sp_cr(regSUBPIC_B_PAL *reg, unsigned int sp_cr)
{
  reg->bitfields.SP_CR = sp_cr;
  if (reg->bitfields.SP_CR != sp_cr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_B_PAL::SP_CR data too large\n");
}
__inline void set_SUBPIC_B_PAL_sp_y(regSUBPIC_B_PAL *reg, unsigned int sp_y)
{
  reg->bitfields.SP_Y = sp_y;
  if (reg->bitfields.SP_Y != sp_y) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_B_PAL::SP_Y data too large\n");
}
#else
#define set_SUBPIC_B_PAL_sp_cb(reg, sp_cb) (reg)->bitfields.SP_CB = sp_cb
#define set_SUBPIC_B_PAL_sp_cr(reg, sp_cr) (reg)->bitfields.SP_CR = sp_cr
#define set_SUBPIC_B_PAL_sp_y(reg, sp_y) (reg)->bitfields.SP_Y = sp_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_C_PAL regSUBPIC_C_PAL;

#ifdef DEBUG
__inline void set_SUBPIC_C_PAL_sp_cb(regSUBPIC_C_PAL *reg, unsigned int sp_cb)
{
  reg->bitfields.SP_CB = sp_cb;
  if (reg->bitfields.SP_CB != sp_cb) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_C_PAL::SP_CB data too large\n");
}
__inline void set_SUBPIC_C_PAL_sp_cr(regSUBPIC_C_PAL *reg, unsigned int sp_cr)
{
  reg->bitfields.SP_CR = sp_cr;
  if (reg->bitfields.SP_CR != sp_cr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_C_PAL::SP_CR data too large\n");
}
__inline void set_SUBPIC_C_PAL_sp_y(regSUBPIC_C_PAL *reg, unsigned int sp_y)
{
  reg->bitfields.SP_Y = sp_y;
  if (reg->bitfields.SP_Y != sp_y) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_C_PAL::SP_Y data too large\n");
}
#else
#define set_SUBPIC_C_PAL_sp_cb(reg, sp_cb) (reg)->bitfields.SP_CB = sp_cb
#define set_SUBPIC_C_PAL_sp_cr(reg, sp_cr) (reg)->bitfields.SP_CR = sp_cr
#define set_SUBPIC_C_PAL_sp_y(reg, sp_y) (reg)->bitfields.SP_Y = sp_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_D_PAL regSUBPIC_D_PAL;

#ifdef DEBUG
__inline void set_SUBPIC_D_PAL_sp_cb(regSUBPIC_D_PAL *reg, unsigned int sp_cb)
{
  reg->bitfields.SP_CB = sp_cb;
  if (reg->bitfields.SP_CB != sp_cb) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_D_PAL::SP_CB data too large\n");
}
__inline void set_SUBPIC_D_PAL_sp_cr(regSUBPIC_D_PAL *reg, unsigned int sp_cr)
{
  reg->bitfields.SP_CR = sp_cr;
  if (reg->bitfields.SP_CR != sp_cr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_D_PAL::SP_CR data too large\n");
}
__inline void set_SUBPIC_D_PAL_sp_y(regSUBPIC_D_PAL *reg, unsigned int sp_y)
{
  reg->bitfields.SP_Y = sp_y;
  if (reg->bitfields.SP_Y != sp_y) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_D_PAL::SP_Y data too large\n");
}
#else
#define set_SUBPIC_D_PAL_sp_cb(reg, sp_cb) (reg)->bitfields.SP_CB = sp_cb
#define set_SUBPIC_D_PAL_sp_cr(reg, sp_cr) (reg)->bitfields.SP_CR = sp_cr
#define set_SUBPIC_D_PAL_sp_y(reg, sp_y) (reg)->bitfields.SP_Y = sp_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_E_PAL regSUBPIC_E_PAL;

#ifdef DEBUG
__inline void set_SUBPIC_E_PAL_sp_cb(regSUBPIC_E_PAL *reg, unsigned int sp_cb)
{
  reg->bitfields.SP_CB = sp_cb;
  if (reg->bitfields.SP_CB != sp_cb) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_E_PAL::SP_CB data too large\n");
}
__inline void set_SUBPIC_E_PAL_sp_cr(regSUBPIC_E_PAL *reg, unsigned int sp_cr)
{
  reg->bitfields.SP_CR = sp_cr;
  if (reg->bitfields.SP_CR != sp_cr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_E_PAL::SP_CR data too large\n");
}
__inline void set_SUBPIC_E_PAL_sp_y(regSUBPIC_E_PAL *reg, unsigned int sp_y)
{
  reg->bitfields.SP_Y = sp_y;
  if (reg->bitfields.SP_Y != sp_y) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_E_PAL::SP_Y data too large\n");
}
#else
#define set_SUBPIC_E_PAL_sp_cb(reg, sp_cb) (reg)->bitfields.SP_CB = sp_cb
#define set_SUBPIC_E_PAL_sp_cr(reg, sp_cr) (reg)->bitfields.SP_CR = sp_cr
#define set_SUBPIC_E_PAL_sp_y(reg, sp_y) (reg)->bitfields.SP_Y = sp_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_F_PAL regSUBPIC_F_PAL;

#ifdef DEBUG
__inline void set_SUBPIC_F_PAL_sp_cb(regSUBPIC_F_PAL *reg, unsigned int sp_cb)
{
  reg->bitfields.SP_CB = sp_cb;
  if (reg->bitfields.SP_CB != sp_cb) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_F_PAL::SP_CB data too large\n");
}
__inline void set_SUBPIC_F_PAL_sp_cr(regSUBPIC_F_PAL *reg, unsigned int sp_cr)
{
  reg->bitfields.SP_CR = sp_cr;
  if (reg->bitfields.SP_CR != sp_cr) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_F_PAL::SP_CR data too large\n");
}
__inline void set_SUBPIC_F_PAL_sp_y(regSUBPIC_F_PAL *reg, unsigned int sp_y)
{
  reg->bitfields.SP_Y = sp_y;
  if (reg->bitfields.SP_Y != sp_y) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_F_PAL::SP_Y data too large\n");
}
#else
#define set_SUBPIC_F_PAL_sp_cb(reg, sp_cb) (reg)->bitfields.SP_CB = sp_cb
#define set_SUBPIC_F_PAL_sp_cr(reg, sp_cr) (reg)->bitfields.SP_CR = sp_cr
#define set_SUBPIC_F_PAL_sp_y(reg, sp_y) (reg)->bitfields.SP_Y = sp_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_H_ACCUM_INIT regSUBPIC_H_ACCUM_INIT;

#ifdef DEBUG
__inline void set_SUBPIC_H_ACCUM_INIT_sp_h_acc_init_frac(regSUBPIC_H_ACCUM_INIT *reg, unsigned int sp_h_acc_init_frac)
{
  reg->bitfields.SP_H_ACC_INIT_FRAC = sp_h_acc_init_frac;
  if (reg->bitfields.SP_H_ACC_INIT_FRAC != sp_h_acc_init_frac) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_H_ACCUM_INIT::SP_H_ACC_INIT_FRAC data too large\n");
}
__inline void set_SUBPIC_H_ACCUM_INIT_sp_h_acc_init_int(regSUBPIC_H_ACCUM_INIT *reg, unsigned int sp_h_acc_init_int)
{
  reg->bitfields.SP_H_ACC_INIT_INT = sp_h_acc_init_int;
  if (reg->bitfields.SP_H_ACC_INIT_INT != sp_h_acc_init_int) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_H_ACCUM_INIT::SP_H_ACC_INIT_INT data too large\n");
}
#else
#define set_SUBPIC_H_ACCUM_INIT_sp_h_acc_init_frac(reg, sp_h_acc_init_frac) (reg)->bitfields.SP_H_ACC_INIT_FRAC = sp_h_acc_init_frac
#define set_SUBPIC_H_ACCUM_INIT_sp_h_acc_init_int(reg, sp_h_acc_init_int) (reg)->bitfields.SP_H_ACC_INIT_INT = sp_h_acc_init_int

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SUBPIC_V_ACCUM_INIT regSUBPIC_V_ACCUM_INIT;

#ifdef DEBUG
__inline void set_SUBPIC_V_ACCUM_INIT_sp_v_acc_init_frac(regSUBPIC_V_ACCUM_INIT *reg, unsigned int sp_v_acc_init_frac)
{
  reg->bitfields.SP_V_ACC_INIT_FRAC = sp_v_acc_init_frac;
  if (reg->bitfields.SP_V_ACC_INIT_FRAC != sp_v_acc_init_frac) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_V_ACCUM_INIT::SP_V_ACC_INIT_FRAC data too large\n");
}
__inline void set_SUBPIC_V_ACCUM_INIT_sp_v_acc_init_int(regSUBPIC_V_ACCUM_INIT *reg, unsigned int sp_v_acc_init_int)
{
  reg->bitfields.SP_V_ACC_INIT_INT = sp_v_acc_init_int;
  if (reg->bitfields.SP_V_ACC_INIT_INT != sp_v_acc_init_int) HSLDPF(E_ERROR_MESSAGE,"SUBPIC_V_ACCUM_INIT::SP_V_ACC_INIT_INT data too large\n");
}
#else
#define set_SUBPIC_V_ACCUM_INIT_sp_v_acc_init_frac(reg, sp_v_acc_init_frac) (reg)->bitfields.SP_V_ACC_INIT_FRAC = sp_v_acc_init_frac
#define set_SUBPIC_V_ACCUM_INIT_sp_v_acc_init_int(reg, sp_v_acc_init_int) (reg)->bitfields.SP_V_ACC_INIT_INT = sp_v_acc_init_int

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV1_Y_X_START regOV1_Y_X_START;

#ifdef DEBUG
__inline void set_OV1_Y_X_START_ov1_x_start(regOV1_Y_X_START *reg, unsigned int ov1_x_start)
{
  reg->bitfields.OV1_X_START = ov1_x_start;
  if (reg->bitfields.OV1_X_START != ov1_x_start) HSLDPF(E_ERROR_MESSAGE,"OV1_Y_X_START::OV1_X_START data too large\n");
}
__inline void set_OV1_Y_X_START_ov1_y_start(regOV1_Y_X_START *reg, unsigned int ov1_y_start)
{
  reg->bitfields.OV1_Y_START = ov1_y_start;
  if (reg->bitfields.OV1_Y_START != ov1_y_start) HSLDPF(E_ERROR_MESSAGE,"OV1_Y_X_START::OV1_Y_START data too large\n");
}
#else
#define set_OV1_Y_X_START_ov1_x_start(reg, ov1_x_start) (reg)->bitfields.OV1_X_START = ov1_x_start
#define set_OV1_Y_X_START_ov1_y_start(reg, ov1_y_start) (reg)->bitfields.OV1_Y_START = ov1_y_start

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV1_Y_X_END regOV1_Y_X_END;

#ifdef DEBUG
__inline void set_OV1_Y_X_END_ov1_x_end(regOV1_Y_X_END *reg, unsigned int ov1_x_end)
{
  reg->bitfields.OV1_X_END = ov1_x_end;
  if (reg->bitfields.OV1_X_END != ov1_x_end) HSLDPF(E_ERROR_MESSAGE,"OV1_Y_X_END::OV1_X_END data too large\n");
}
__inline void set_OV1_Y_X_END_ov1_y_end(regOV1_Y_X_END *reg, unsigned int ov1_y_end)
{
  reg->bitfields.OV1_Y_END = ov1_y_end;
  if (reg->bitfields.OV1_Y_END != ov1_y_end) HSLDPF(E_ERROR_MESSAGE,"OV1_Y_X_END::OV1_Y_END data too large\n");
}
#else
#define set_OV1_Y_X_END_ov1_x_end(reg, ov1_x_end) (reg)->bitfields.OV1_X_END = ov1_x_end
#define set_OV1_Y_X_END_ov1_y_end(reg, ov1_y_end) (reg)->bitfields.OV1_Y_END = ov1_y_end

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV1_PIPELINE_CNTL regOV1_PIPELINE_CNTL;

#ifdef DEBUG
__inline void set_OV1_PIPELINE_CNTL_ov1_disp_pipe_delay(regOV1_PIPELINE_CNTL *reg, unsigned int ov1_disp_pipe_delay)
{
  reg->bitfields.OV1_DISP_PIPE_DELAY = ov1_disp_pipe_delay;
  if (reg->bitfields.OV1_DISP_PIPE_DELAY != ov1_disp_pipe_delay) HSLDPF(E_ERROR_MESSAGE,"OV1_PIPELINE_CNTL::OV1_DISP_PIPE_DELAY data too large\n");
}
#else
#define set_OV1_PIPELINE_CNTL_ov1_disp_pipe_delay(reg, ov1_disp_pipe_delay) (reg)->bitfields.OV1_DISP_PIPE_DELAY = ov1_disp_pipe_delay

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250DISP_MISC_CNTL regrv250DISP_MISC_CNTL;

#ifdef DEBUG
__inline void set_rv250DISP_MISC_CNTL_soft_reset_grph_pp(regrv250DISP_MISC_CNTL *reg, unsigned int soft_reset_grph_pp)
{
  reg->bitfields.SOFT_RESET_GRPH_PP = soft_reset_grph_pp;
  if (reg->bitfields.SOFT_RESET_GRPH_PP != soft_reset_grph_pp) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_MISC_CNTL::SOFT_RESET_GRPH_PP data too large\n");
}
__inline void set_rv250DISP_MISC_CNTL_soft_reset_subpic_pp(regrv250DISP_MISC_CNTL *reg, unsigned int soft_reset_subpic_pp)
{
  reg->bitfields.SOFT_RESET_SUBPIC_PP = soft_reset_subpic_pp;
  if (reg->bitfields.SOFT_RESET_SUBPIC_PP != soft_reset_subpic_pp) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_MISC_CNTL::SOFT_RESET_SUBPIC_PP data too large\n");
}
__inline void set_rv250DISP_MISC_CNTL_soft_reset_ov0_pp(regrv250DISP_MISC_CNTL *reg, unsigned int soft_reset_ov0_pp)
{
  reg->bitfields.SOFT_RESET_OV0_PP = soft_reset_ov0_pp;
  if (reg->bitfields.SOFT_RESET_OV0_PP != soft_reset_ov0_pp) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_MISC_CNTL::SOFT_RESET_OV0_PP data too large\n");
}
__inline void set_rv250DISP_MISC_CNTL_soft_reset_grph_sclk(regrv250DISP_MISC_CNTL *reg, unsigned int soft_reset_grph_sclk)
{
  reg->bitfields.SOFT_RESET_GRPH_SCLK = soft_reset_grph_sclk;
  if (reg->bitfields.SOFT_RESET_GRPH_SCLK != soft_reset_grph_sclk) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_MISC_CNTL::SOFT_RESET_GRPH_SCLK data too large\n");
}
__inline void set_rv250DISP_MISC_CNTL_soft_reset_subpic_sclk(regrv250DISP_MISC_CNTL *reg, unsigned int soft_reset_subpic_sclk)
{
  reg->bitfields.SOFT_RESET_SUBPIC_SCLK = soft_reset_subpic_sclk;
  if (reg->bitfields.SOFT_RESET_SUBPIC_SCLK != soft_reset_subpic_sclk) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_MISC_CNTL::SOFT_RESET_SUBPIC_SCLK data too large\n");
}
__inline void set_rv250DISP_MISC_CNTL_soft_reset_ov0_sclk(regrv250DISP_MISC_CNTL *reg, unsigned int soft_reset_ov0_sclk)
{
  reg->bitfields.SOFT_RESET_OV0_SCLK = soft_reset_ov0_sclk;
  if (reg->bitfields.SOFT_RESET_OV0_SCLK != soft_reset_ov0_sclk) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_MISC_CNTL::SOFT_RESET_OV0_SCLK data too large\n");
}
__inline void set_rv250DISP_MISC_CNTL_sync_strength(regrv250DISP_MISC_CNTL *reg, unsigned int sync_strength)
{
  reg->bitfields.SYNC_STRENGTH = sync_strength;
  if (reg->bitfields.SYNC_STRENGTH != sync_strength) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_MISC_CNTL::SYNC_STRENGTH data too large\n");
}
__inline void set_rv250DISP_MISC_CNTL_sync_pad_flop_en(regrv250DISP_MISC_CNTL *reg, unsigned int sync_pad_flop_en)
{
  reg->bitfields.SYNC_PAD_FLOP_EN = sync_pad_flop_en;
  if (reg->bitfields.SYNC_PAD_FLOP_EN != sync_pad_flop_en) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_MISC_CNTL::SYNC_PAD_FLOP_EN data too large\n");
}
__inline void set_rv250DISP_MISC_CNTL_soft_reset_grph2_pp(regrv250DISP_MISC_CNTL *reg, unsigned int soft_reset_grph2_pp)
{
  reg->bitfields.SOFT_RESET_GRPH2_PP = soft_reset_grph2_pp;
  if (reg->bitfields.SOFT_RESET_GRPH2_PP != soft_reset_grph2_pp) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_MISC_CNTL::SOFT_RESET_GRPH2_PP data too large\n");
}
__inline void set_rv250DISP_MISC_CNTL_soft_reset_hdcp(regrv250DISP_MISC_CNTL *reg, unsigned int soft_reset_hdcp)
{
  reg->bitfields.SOFT_RESET_HDCP = soft_reset_hdcp;
  if (reg->bitfields.SOFT_RESET_HDCP != soft_reset_hdcp) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_MISC_CNTL::SOFT_RESET_HDCP data too large\n");
}
__inline void set_rv250DISP_MISC_CNTL_soft_reset_grph2_sclk(regrv250DISP_MISC_CNTL *reg, unsigned int soft_reset_grph2_sclk)
{
  reg->bitfields.SOFT_RESET_GRPH2_SCLK = soft_reset_grph2_sclk;
  if (reg->bitfields.SOFT_RESET_GRPH2_SCLK != soft_reset_grph2_sclk) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_MISC_CNTL::SOFT_RESET_GRPH2_SCLK data too large\n");
}
__inline void set_rv250DISP_MISC_CNTL_soft_reset_lvds(regrv250DISP_MISC_CNTL *reg, unsigned int soft_reset_lvds)
{
  reg->bitfields.SOFT_RESET_LVDS = soft_reset_lvds;
  if (reg->bitfields.SOFT_RESET_LVDS != soft_reset_lvds) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_MISC_CNTL::SOFT_RESET_LVDS data too large\n");
}
__inline void set_rv250DISP_MISC_CNTL_soft_reset_tmds(regrv250DISP_MISC_CNTL *reg, unsigned int soft_reset_tmds)
{
  reg->bitfields.SOFT_RESET_TMDS = soft_reset_tmds;
  if (reg->bitfields.SOFT_RESET_TMDS != soft_reset_tmds) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_MISC_CNTL::SOFT_RESET_TMDS data too large\n");
}
__inline void set_rv250DISP_MISC_CNTL_soft_reset_dig_tmds(regrv250DISP_MISC_CNTL *reg, unsigned int soft_reset_dig_tmds)
{
  reg->bitfields.SOFT_RESET_DIG_TMDS = soft_reset_dig_tmds;
  if (reg->bitfields.SOFT_RESET_DIG_TMDS != soft_reset_dig_tmds) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_MISC_CNTL::SOFT_RESET_DIG_TMDS data too large\n");
}
__inline void set_rv250DISP_MISC_CNTL_soft_reset_tv(regrv250DISP_MISC_CNTL *reg, unsigned int soft_reset_tv)
{
  reg->bitfields.SOFT_RESET_TV = soft_reset_tv;
  if (reg->bitfields.SOFT_RESET_TV != soft_reset_tv) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_MISC_CNTL::SOFT_RESET_TV data too large\n");
}
__inline void set_rv250DISP_MISC_CNTL_palette2_mem_rd_margin(regrv250DISP_MISC_CNTL *reg, unsigned int palette2_mem_rd_margin)
{
  reg->bitfields.PALETTE2_MEM_RD_MARGIN = palette2_mem_rd_margin;
  if (reg->bitfields.PALETTE2_MEM_RD_MARGIN != palette2_mem_rd_margin) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_MISC_CNTL::PALETTE2_MEM_RD_MARGIN data too large\n");
}
__inline void set_rv250DISP_MISC_CNTL_palette_mem_rd_margin(regrv250DISP_MISC_CNTL *reg, unsigned int palette_mem_rd_margin)
{
  reg->bitfields.PALETTE_MEM_RD_MARGIN = palette_mem_rd_margin;
  if (reg->bitfields.PALETTE_MEM_RD_MARGIN != palette_mem_rd_margin) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_MISC_CNTL::PALETTE_MEM_RD_MARGIN data too large\n");
}
__inline void set_rv250DISP_MISC_CNTL_rmx_buf_mem_rd_margin(regrv250DISP_MISC_CNTL *reg, unsigned int rmx_buf_mem_rd_margin)
{
  reg->bitfields.RMX_BUF_MEM_RD_MARGIN = rmx_buf_mem_rd_margin;
  if (reg->bitfields.RMX_BUF_MEM_RD_MARGIN != rmx_buf_mem_rd_margin) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_MISC_CNTL::RMX_BUF_MEM_RD_MARGIN data too large\n");
}
#else
#define set_rv250DISP_MISC_CNTL_soft_reset_grph_pp(reg, soft_reset_grph_pp) (reg)->bitfields.SOFT_RESET_GRPH_PP = soft_reset_grph_pp
#define set_rv250DISP_MISC_CNTL_soft_reset_subpic_pp(reg, soft_reset_subpic_pp) (reg)->bitfields.SOFT_RESET_SUBPIC_PP = soft_reset_subpic_pp
#define set_rv250DISP_MISC_CNTL_soft_reset_ov0_pp(reg, soft_reset_ov0_pp) (reg)->bitfields.SOFT_RESET_OV0_PP = soft_reset_ov0_pp
#define set_rv250DISP_MISC_CNTL_soft_reset_grph_sclk(reg, soft_reset_grph_sclk) (reg)->bitfields.SOFT_RESET_GRPH_SCLK = soft_reset_grph_sclk
#define set_rv250DISP_MISC_CNTL_soft_reset_subpic_sclk(reg, soft_reset_subpic_sclk) (reg)->bitfields.SOFT_RESET_SUBPIC_SCLK = soft_reset_subpic_sclk
#define set_rv250DISP_MISC_CNTL_soft_reset_ov0_sclk(reg, soft_reset_ov0_sclk) (reg)->bitfields.SOFT_RESET_OV0_SCLK = soft_reset_ov0_sclk
#define set_rv250DISP_MISC_CNTL_sync_strength(reg, sync_strength) (reg)->bitfields.SYNC_STRENGTH = sync_strength
#define set_rv250DISP_MISC_CNTL_sync_pad_flop_en(reg, sync_pad_flop_en) (reg)->bitfields.SYNC_PAD_FLOP_EN = sync_pad_flop_en
#define set_rv250DISP_MISC_CNTL_soft_reset_grph2_pp(reg, soft_reset_grph2_pp) (reg)->bitfields.SOFT_RESET_GRPH2_PP = soft_reset_grph2_pp
#define set_rv250DISP_MISC_CNTL_soft_reset_hdcp(reg, soft_reset_hdcp) (reg)->bitfields.SOFT_RESET_HDCP = soft_reset_hdcp
#define set_rv250DISP_MISC_CNTL_soft_reset_grph2_sclk(reg, soft_reset_grph2_sclk) (reg)->bitfields.SOFT_RESET_GRPH2_SCLK = soft_reset_grph2_sclk
#define set_rv250DISP_MISC_CNTL_soft_reset_lvds(reg, soft_reset_lvds) (reg)->bitfields.SOFT_RESET_LVDS = soft_reset_lvds
#define set_rv250DISP_MISC_CNTL_soft_reset_tmds(reg, soft_reset_tmds) (reg)->bitfields.SOFT_RESET_TMDS = soft_reset_tmds
#define set_rv250DISP_MISC_CNTL_soft_reset_dig_tmds(reg, soft_reset_dig_tmds) (reg)->bitfields.SOFT_RESET_DIG_TMDS = soft_reset_dig_tmds
#define set_rv250DISP_MISC_CNTL_soft_reset_tv(reg, soft_reset_tv) (reg)->bitfields.SOFT_RESET_TV = soft_reset_tv
#define set_rv250DISP_MISC_CNTL_palette2_mem_rd_margin(reg, palette2_mem_rd_margin) (reg)->bitfields.PALETTE2_MEM_RD_MARGIN = palette2_mem_rd_margin
#define set_rv250DISP_MISC_CNTL_palette_mem_rd_margin(reg, palette_mem_rd_margin) (reg)->bitfields.PALETTE_MEM_RD_MARGIN = palette_mem_rd_margin
#define set_rv250DISP_MISC_CNTL_rmx_buf_mem_rd_margin(reg, rmx_buf_mem_rd_margin) (reg)->bitfields.RMX_BUF_MEM_RD_MARGIN = rmx_buf_mem_rd_margin

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_MACRO_CNTL regDAC_MACRO_CNTL;

#ifdef DEBUG
__inline void set_DAC_MACRO_CNTL_dac_white_cntl(regDAC_MACRO_CNTL *reg, unsigned int dac_white_cntl)
{
  reg->bitfields.DAC_WHITE_CNTL = dac_white_cntl;
  if (reg->bitfields.DAC_WHITE_CNTL != dac_white_cntl) HSLDPF(E_ERROR_MESSAGE,"DAC_MACRO_CNTL::DAC_WHITE_CNTL data too large\n");
}
__inline void set_DAC_MACRO_CNTL_dac_bg_adj(regDAC_MACRO_CNTL *reg, unsigned int dac_bg_adj)
{
  reg->bitfields.DAC_BG_ADJ = dac_bg_adj;
  if (reg->bitfields.DAC_BG_ADJ != dac_bg_adj) HSLDPF(E_ERROR_MESSAGE,"DAC_MACRO_CNTL::DAC_BG_ADJ data too large\n");
}
__inline void set_DAC_MACRO_CNTL_dac_pdwn_r(regDAC_MACRO_CNTL *reg, unsigned int dac_pdwn_r)
{
  reg->bitfields.DAC_PDWN_R = dac_pdwn_r;
  if (reg->bitfields.DAC_PDWN_R != dac_pdwn_r) HSLDPF(E_ERROR_MESSAGE,"DAC_MACRO_CNTL::DAC_PDWN_R data too large\n");
}
__inline void set_DAC_MACRO_CNTL_dac_pdwn_g(regDAC_MACRO_CNTL *reg, unsigned int dac_pdwn_g)
{
  reg->bitfields.DAC_PDWN_G = dac_pdwn_g;
  if (reg->bitfields.DAC_PDWN_G != dac_pdwn_g) HSLDPF(E_ERROR_MESSAGE,"DAC_MACRO_CNTL::DAC_PDWN_G data too large\n");
}
__inline void set_DAC_MACRO_CNTL_dac_pdwn_b(regDAC_MACRO_CNTL *reg, unsigned int dac_pdwn_b)
{
  reg->bitfields.DAC_PDWN_B = dac_pdwn_b;
  if (reg->bitfields.DAC_PDWN_B != dac_pdwn_b) HSLDPF(E_ERROR_MESSAGE,"DAC_MACRO_CNTL::DAC_PDWN_B data too large\n");
}
#else
#define set_DAC_MACRO_CNTL_dac_white_cntl(reg, dac_white_cntl) (reg)->bitfields.DAC_WHITE_CNTL = dac_white_cntl
#define set_DAC_MACRO_CNTL_dac_bg_adj(reg, dac_bg_adj) (reg)->bitfields.DAC_BG_ADJ = dac_bg_adj
#define set_DAC_MACRO_CNTL_dac_pdwn_r(reg, dac_pdwn_r) (reg)->bitfields.DAC_PDWN_R = dac_pdwn_r
#define set_DAC_MACRO_CNTL_dac_pdwn_g(reg, dac_pdwn_g) (reg)->bitfields.DAC_PDWN_G = dac_pdwn_g
#define set_DAC_MACRO_CNTL_dac_pdwn_b(reg, dac_pdwn_b) (reg)->bitfields.DAC_PDWN_B = dac_pdwn_b

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250DISP_PWR_MAN regrv250DISP_PWR_MAN;

#ifdef DEBUG
__inline void set_rv250DISP_PWR_MAN_disp_pwr_man_d3_crtc_en(regrv250DISP_PWR_MAN *reg, unsigned int disp_pwr_man_d3_crtc_en)
{
  reg->bitfields.DISP_PWR_MAN_D3_CRTC_EN = disp_pwr_man_d3_crtc_en;
  if (reg->bitfields.DISP_PWR_MAN_D3_CRTC_EN != disp_pwr_man_d3_crtc_en) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_PWR_MAN::DISP_PWR_MAN_D3_CRTC_EN data too large\n");
}
__inline void set_rv250DISP_PWR_MAN_disp2_pwr_man_d3_crtc2_en(regrv250DISP_PWR_MAN *reg, unsigned int disp2_pwr_man_d3_crtc2_en)
{
  reg->bitfields.DISP2_PWR_MAN_D3_CRTC2_EN = disp2_pwr_man_d3_crtc2_en;
  if (reg->bitfields.DISP2_PWR_MAN_D3_CRTC2_EN != disp2_pwr_man_d3_crtc2_en) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_PWR_MAN::DISP2_PWR_MAN_D3_CRTC2_EN data too large\n");
}
__inline void set_rv250DISP_PWR_MAN_disp_pwr_man_dpms(regrv250DISP_PWR_MAN *reg, unsigned int disp_pwr_man_dpms)
{
  reg->bitfields.DISP_PWR_MAN_DPMS = disp_pwr_man_dpms;
  if (reg->bitfields.DISP_PWR_MAN_DPMS != disp_pwr_man_dpms) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_PWR_MAN::DISP_PWR_MAN_DPMS data too large\n");
}
__inline void set_rv250DISP_PWR_MAN_disp_d3_rst(regrv250DISP_PWR_MAN *reg, unsigned int disp_d3_rst)
{
  reg->bitfields.DISP_D3_RST = disp_d3_rst;
  if (reg->bitfields.DISP_D3_RST != disp_d3_rst) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_PWR_MAN::DISP_D3_RST data too large\n");
}
__inline void set_rv250DISP_PWR_MAN_disp_d3_reg_rst(regrv250DISP_PWR_MAN *reg, unsigned int disp_d3_reg_rst)
{
  reg->bitfields.DISP_D3_REG_RST = disp_d3_reg_rst;
  if (reg->bitfields.DISP_D3_REG_RST != disp_d3_reg_rst) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_PWR_MAN::DISP_D3_REG_RST data too large\n");
}
__inline void set_rv250DISP_PWR_MAN_disp_d3_grph_rst(regrv250DISP_PWR_MAN *reg, unsigned int disp_d3_grph_rst)
{
  reg->bitfields.DISP_D3_GRPH_RST = disp_d3_grph_rst;
  if (reg->bitfields.DISP_D3_GRPH_RST != disp_d3_grph_rst) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_PWR_MAN::DISP_D3_GRPH_RST data too large\n");
}
__inline void set_rv250DISP_PWR_MAN_disp_d3_subpic_rst(regrv250DISP_PWR_MAN *reg, unsigned int disp_d3_subpic_rst)
{
  reg->bitfields.DISP_D3_SUBPIC_RST = disp_d3_subpic_rst;
  if (reg->bitfields.DISP_D3_SUBPIC_RST != disp_d3_subpic_rst) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_PWR_MAN::DISP_D3_SUBPIC_RST data too large\n");
}
__inline void set_rv250DISP_PWR_MAN_disp_d3_ov0_rst(regrv250DISP_PWR_MAN *reg, unsigned int disp_d3_ov0_rst)
{
  reg->bitfields.DISP_D3_OV0_RST = disp_d3_ov0_rst;
  if (reg->bitfields.DISP_D3_OV0_RST != disp_d3_ov0_rst) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_PWR_MAN::DISP_D3_OV0_RST data too large\n");
}
__inline void set_rv250DISP_PWR_MAN_disp_d1d2_grph_rst(regrv250DISP_PWR_MAN *reg, unsigned int disp_d1d2_grph_rst)
{
  reg->bitfields.DISP_D1D2_GRPH_RST = disp_d1d2_grph_rst;
  if (reg->bitfields.DISP_D1D2_GRPH_RST != disp_d1d2_grph_rst) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_PWR_MAN::DISP_D1D2_GRPH_RST data too large\n");
}
__inline void set_rv250DISP_PWR_MAN_disp_d1d2_subpic_rst(regrv250DISP_PWR_MAN *reg, unsigned int disp_d1d2_subpic_rst)
{
  reg->bitfields.DISP_D1D2_SUBPIC_RST = disp_d1d2_subpic_rst;
  if (reg->bitfields.DISP_D1D2_SUBPIC_RST != disp_d1d2_subpic_rst) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_PWR_MAN::DISP_D1D2_SUBPIC_RST data too large\n");
}
__inline void set_rv250DISP_PWR_MAN_disp_d1d2_ov0_rst(regrv250DISP_PWR_MAN *reg, unsigned int disp_d1d2_ov0_rst)
{
  reg->bitfields.DISP_D1D2_OV0_RST = disp_d1d2_ov0_rst;
  if (reg->bitfields.DISP_D1D2_OV0_RST != disp_d1d2_ov0_rst) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_PWR_MAN::DISP_D1D2_OV0_RST data too large\n");
}
__inline void set_rv250DISP_PWR_MAN_dig_tmds_enable_rst(regrv250DISP_PWR_MAN *reg, unsigned int dig_tmds_enable_rst)
{
  reg->bitfields.DIG_TMDS_ENABLE_RST = dig_tmds_enable_rst;
  if (reg->bitfields.DIG_TMDS_ENABLE_RST != dig_tmds_enable_rst) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_PWR_MAN::DIG_TMDS_ENABLE_RST data too large\n");
}
__inline void set_rv250DISP_PWR_MAN_tv_enable_rst(regrv250DISP_PWR_MAN *reg, unsigned int tv_enable_rst)
{
  reg->bitfields.TV_ENABLE_RST = tv_enable_rst;
  if (reg->bitfields.TV_ENABLE_RST != tv_enable_rst) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_PWR_MAN::TV_ENABLE_RST data too large\n");
}
__inline void set_rv250DISP_PWR_MAN_auto_pwrup_en(regrv250DISP_PWR_MAN *reg, unsigned int auto_pwrup_en)
{
  reg->bitfields.AUTO_PWRUP_EN = auto_pwrup_en;
  if (reg->bitfields.AUTO_PWRUP_EN != auto_pwrup_en) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_PWR_MAN::AUTO_PWRUP_EN data too large\n");
}
#else
#define set_rv250DISP_PWR_MAN_disp_pwr_man_d3_crtc_en(reg, disp_pwr_man_d3_crtc_en) (reg)->bitfields.DISP_PWR_MAN_D3_CRTC_EN = disp_pwr_man_d3_crtc_en
#define set_rv250DISP_PWR_MAN_disp2_pwr_man_d3_crtc2_en(reg, disp2_pwr_man_d3_crtc2_en) (reg)->bitfields.DISP2_PWR_MAN_D3_CRTC2_EN = disp2_pwr_man_d3_crtc2_en
#define set_rv250DISP_PWR_MAN_disp_pwr_man_dpms(reg, disp_pwr_man_dpms) (reg)->bitfields.DISP_PWR_MAN_DPMS = disp_pwr_man_dpms
#define set_rv250DISP_PWR_MAN_disp_d3_rst(reg, disp_d3_rst) (reg)->bitfields.DISP_D3_RST = disp_d3_rst
#define set_rv250DISP_PWR_MAN_disp_d3_reg_rst(reg, disp_d3_reg_rst) (reg)->bitfields.DISP_D3_REG_RST = disp_d3_reg_rst
#define set_rv250DISP_PWR_MAN_disp_d3_grph_rst(reg, disp_d3_grph_rst) (reg)->bitfields.DISP_D3_GRPH_RST = disp_d3_grph_rst
#define set_rv250DISP_PWR_MAN_disp_d3_subpic_rst(reg, disp_d3_subpic_rst) (reg)->bitfields.DISP_D3_SUBPIC_RST = disp_d3_subpic_rst
#define set_rv250DISP_PWR_MAN_disp_d3_ov0_rst(reg, disp_d3_ov0_rst) (reg)->bitfields.DISP_D3_OV0_RST = disp_d3_ov0_rst
#define set_rv250DISP_PWR_MAN_disp_d1d2_grph_rst(reg, disp_d1d2_grph_rst) (reg)->bitfields.DISP_D1D2_GRPH_RST = disp_d1d2_grph_rst
#define set_rv250DISP_PWR_MAN_disp_d1d2_subpic_rst(reg, disp_d1d2_subpic_rst) (reg)->bitfields.DISP_D1D2_SUBPIC_RST = disp_d1d2_subpic_rst
#define set_rv250DISP_PWR_MAN_disp_d1d2_ov0_rst(reg, disp_d1d2_ov0_rst) (reg)->bitfields.DISP_D1D2_OV0_RST = disp_d1d2_ov0_rst
#define set_rv250DISP_PWR_MAN_dig_tmds_enable_rst(reg, dig_tmds_enable_rst) (reg)->bitfields.DIG_TMDS_ENABLE_RST = dig_tmds_enable_rst
#define set_rv250DISP_PWR_MAN_tv_enable_rst(reg, tv_enable_rst) (reg)->bitfields.TV_ENABLE_RST = tv_enable_rst
#define set_rv250DISP_PWR_MAN_auto_pwrup_en(reg, auto_pwrup_en) (reg)->bitfields.AUTO_PWRUP_EN = auto_pwrup_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_TEST_DEBUG_CNTL regDISP_TEST_DEBUG_CNTL;

#ifdef DEBUG
__inline void set_DISP_TEST_DEBUG_CNTL_disp_test_dispeng(regDISP_TEST_DEBUG_CNTL *reg, unsigned int disp_test_dispeng)
{
  reg->bitfields.DISP_TEST_DISPENG = disp_test_dispeng;
  if (reg->bitfields.DISP_TEST_DISPENG != disp_test_dispeng) HSLDPF(E_ERROR_MESSAGE,"DISP_TEST_DEBUG_CNTL::DISP_TEST_DISPENG data too large\n");
}
__inline void set_DISP_TEST_DEBUG_CNTL_disp_test_palette(regDISP_TEST_DEBUG_CNTL *reg, unsigned int disp_test_palette)
{
  reg->bitfields.DISP_TEST_PALETTE = disp_test_palette;
  if (reg->bitfields.DISP_TEST_PALETTE != disp_test_palette) HSLDPF(E_ERROR_MESSAGE,"DISP_TEST_DEBUG_CNTL::DISP_TEST_PALETTE data too large\n");
}
__inline void set_DISP_TEST_DEBUG_CNTL_disp_test_dac(regDISP_TEST_DEBUG_CNTL *reg, unsigned int disp_test_dac)
{
  reg->bitfields.DISP_TEST_DAC = disp_test_dac;
  if (reg->bitfields.DISP_TEST_DAC != disp_test_dac) HSLDPF(E_ERROR_MESSAGE,"DISP_TEST_DEBUG_CNTL::DISP_TEST_DAC data too large\n");
}
__inline void set_DISP_TEST_DEBUG_CNTL_disp_test_subpic(regDISP_TEST_DEBUG_CNTL *reg, unsigned int disp_test_subpic)
{
  reg->bitfields.DISP_TEST_SUBPIC = disp_test_subpic;
  if (reg->bitfields.DISP_TEST_SUBPIC != disp_test_subpic) HSLDPF(E_ERROR_MESSAGE,"DISP_TEST_DEBUG_CNTL::DISP_TEST_SUBPIC data too large\n");
}
__inline void set_DISP_TEST_DEBUG_CNTL_disp_test_ov0scale(regDISP_TEST_DEBUG_CNTL *reg, unsigned int disp_test_ov0scale)
{
  reg->bitfields.DISP_TEST_OV0SCALE = disp_test_ov0scale;
  if (reg->bitfields.DISP_TEST_OV0SCALE != disp_test_ov0scale) HSLDPF(E_ERROR_MESSAGE,"DISP_TEST_DEBUG_CNTL::DISP_TEST_OV0SCALE data too large\n");
}
__inline void set_DISP_TEST_DEBUG_CNTL_disp_test_clk(regDISP_TEST_DEBUG_CNTL *reg, unsigned int disp_test_clk)
{
  reg->bitfields.DISP_TEST_CLK = disp_test_clk;
  if (reg->bitfields.DISP_TEST_CLK != disp_test_clk) HSLDPF(E_ERROR_MESSAGE,"DISP_TEST_DEBUG_CNTL::DISP_TEST_CLK data too large\n");
}
__inline void set_DISP_TEST_DEBUG_CNTL_disp_test_disp2eng(regDISP_TEST_DEBUG_CNTL *reg, unsigned int disp_test_disp2eng)
{
  reg->bitfields.DISP_TEST_DISP2ENG = disp_test_disp2eng;
  if (reg->bitfields.DISP_TEST_DISP2ENG != disp_test_disp2eng) HSLDPF(E_ERROR_MESSAGE,"DISP_TEST_DEBUG_CNTL::DISP_TEST_DISP2ENG data too large\n");
}
__inline void set_DISP_TEST_DEBUG_CNTL_disp_test_palette2(regDISP_TEST_DEBUG_CNTL *reg, unsigned int disp_test_palette2)
{
  reg->bitfields.DISP_TEST_PALETTE2 = disp_test_palette2;
  if (reg->bitfields.DISP_TEST_PALETTE2 != disp_test_palette2) HSLDPF(E_ERROR_MESSAGE,"DISP_TEST_DEBUG_CNTL::DISP_TEST_PALETTE2 data too large\n");
}
__inline void set_DISP_TEST_DEBUG_CNTL_disp_grph2_underflow(regDISP_TEST_DEBUG_CNTL *reg, unsigned int disp_grph2_underflow)
{
  reg->bitfields.DISP_GRPH2_UNDERFLOW = disp_grph2_underflow;
  if (reg->bitfields.DISP_GRPH2_UNDERFLOW != disp_grph2_underflow) HSLDPF(E_ERROR_MESSAGE,"DISP_TEST_DEBUG_CNTL::DISP_GRPH2_UNDERFLOW data too large\n");
}
__inline void set_DISP_TEST_DEBUG_CNTL_disp_cur2_underflow(regDISP_TEST_DEBUG_CNTL *reg, unsigned int disp_cur2_underflow)
{
  reg->bitfields.DISP_CUR2_UNDERFLOW = disp_cur2_underflow;
  if (reg->bitfields.DISP_CUR2_UNDERFLOW != disp_cur2_underflow) HSLDPF(E_ERROR_MESSAGE,"DISP_TEST_DEBUG_CNTL::DISP_CUR2_UNDERFLOW data too large\n");
}
__inline void set_DISP_TEST_DEBUG_CNTL_disp_grph_underflow(regDISP_TEST_DEBUG_CNTL *reg, unsigned int disp_grph_underflow)
{
  reg->bitfields.DISP_GRPH_UNDERFLOW = disp_grph_underflow;
  if (reg->bitfields.DISP_GRPH_UNDERFLOW != disp_grph_underflow) HSLDPF(E_ERROR_MESSAGE,"DISP_TEST_DEBUG_CNTL::DISP_GRPH_UNDERFLOW data too large\n");
}
__inline void set_DISP_TEST_DEBUG_CNTL_disp_cur_underflow(regDISP_TEST_DEBUG_CNTL *reg, unsigned int disp_cur_underflow)
{
  reg->bitfields.DISP_CUR_UNDERFLOW = disp_cur_underflow;
  if (reg->bitfields.DISP_CUR_UNDERFLOW != disp_cur_underflow) HSLDPF(E_ERROR_MESSAGE,"DISP_TEST_DEBUG_CNTL::DISP_CUR_UNDERFLOW data too large\n");
}
__inline void set_DISP_TEST_DEBUG_CNTL_disp_ov0_underflow(regDISP_TEST_DEBUG_CNTL *reg, unsigned int disp_ov0_underflow)
{
  reg->bitfields.DISP_OV0_UNDERFLOW = disp_ov0_underflow;
  if (reg->bitfields.DISP_OV0_UNDERFLOW != disp_ov0_underflow) HSLDPF(E_ERROR_MESSAGE,"DISP_TEST_DEBUG_CNTL::DISP_OV0_UNDERFLOW data too large\n");
}
__inline void set_DISP_TEST_DEBUG_CNTL_disp_subpic_underflow(regDISP_TEST_DEBUG_CNTL *reg, unsigned int disp_subpic_underflow)
{
  reg->bitfields.DISP_SUBPIC_UNDERFLOW = disp_subpic_underflow;
  if (reg->bitfields.DISP_SUBPIC_UNDERFLOW != disp_subpic_underflow) HSLDPF(E_ERROR_MESSAGE,"DISP_TEST_DEBUG_CNTL::DISP_SUBPIC_UNDERFLOW data too large\n");
}
__inline void set_DISP_TEST_DEBUG_CNTL_disp_subpic_force_hi_pri(regDISP_TEST_DEBUG_CNTL *reg, unsigned int disp_subpic_force_hi_pri)
{
  reg->bitfields.DISP_SUBPIC_FORCE_HI_PRI = disp_subpic_force_hi_pri;
  if (reg->bitfields.DISP_SUBPIC_FORCE_HI_PRI != disp_subpic_force_hi_pri) HSLDPF(E_ERROR_MESSAGE,"DISP_TEST_DEBUG_CNTL::DISP_SUBPIC_FORCE_HI_PRI data too large\n");
}
#else
#define set_DISP_TEST_DEBUG_CNTL_disp_test_dispeng(reg, disp_test_dispeng) (reg)->bitfields.DISP_TEST_DISPENG = disp_test_dispeng
#define set_DISP_TEST_DEBUG_CNTL_disp_test_palette(reg, disp_test_palette) (reg)->bitfields.DISP_TEST_PALETTE = disp_test_palette
#define set_DISP_TEST_DEBUG_CNTL_disp_test_dac(reg, disp_test_dac) (reg)->bitfields.DISP_TEST_DAC = disp_test_dac
#define set_DISP_TEST_DEBUG_CNTL_disp_test_subpic(reg, disp_test_subpic) (reg)->bitfields.DISP_TEST_SUBPIC = disp_test_subpic
#define set_DISP_TEST_DEBUG_CNTL_disp_test_ov0scale(reg, disp_test_ov0scale) (reg)->bitfields.DISP_TEST_OV0SCALE = disp_test_ov0scale
#define set_DISP_TEST_DEBUG_CNTL_disp_test_clk(reg, disp_test_clk) (reg)->bitfields.DISP_TEST_CLK = disp_test_clk
#define set_DISP_TEST_DEBUG_CNTL_disp_test_disp2eng(reg, disp_test_disp2eng) (reg)->bitfields.DISP_TEST_DISP2ENG = disp_test_disp2eng
#define set_DISP_TEST_DEBUG_CNTL_disp_test_palette2(reg, disp_test_palette2) (reg)->bitfields.DISP_TEST_PALETTE2 = disp_test_palette2
#define set_DISP_TEST_DEBUG_CNTL_disp_grph2_underflow(reg, disp_grph2_underflow) (reg)->bitfields.DISP_GRPH2_UNDERFLOW = disp_grph2_underflow
#define set_DISP_TEST_DEBUG_CNTL_disp_cur2_underflow(reg, disp_cur2_underflow) (reg)->bitfields.DISP_CUR2_UNDERFLOW = disp_cur2_underflow
#define set_DISP_TEST_DEBUG_CNTL_disp_grph_underflow(reg, disp_grph_underflow) (reg)->bitfields.DISP_GRPH_UNDERFLOW = disp_grph_underflow
#define set_DISP_TEST_DEBUG_CNTL_disp_cur_underflow(reg, disp_cur_underflow) (reg)->bitfields.DISP_CUR_UNDERFLOW = disp_cur_underflow
#define set_DISP_TEST_DEBUG_CNTL_disp_ov0_underflow(reg, disp_ov0_underflow) (reg)->bitfields.DISP_OV0_UNDERFLOW = disp_ov0_underflow
#define set_DISP_TEST_DEBUG_CNTL_disp_subpic_underflow(reg, disp_subpic_underflow) (reg)->bitfields.DISP_SUBPIC_UNDERFLOW = disp_subpic_underflow
#define set_DISP_TEST_DEBUG_CNTL_disp_subpic_force_hi_pri(reg, disp_subpic_force_hi_pri) (reg)->bitfields.DISP_SUBPIC_FORCE_HI_PRI = disp_subpic_force_hi_pri

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_HW_DEBUG_M6 regDISP_HW_DEBUG_M6;

#ifdef DEBUG
__inline void set_DISP_HW_DEBUG_M6_disp_hw_0_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_0_debug)
{
  reg->bitfields.DISP_HW_0_DEBUG = disp_hw_0_debug;
  if (reg->bitfields.DISP_HW_0_DEBUG != disp_hw_0_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_0_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_1_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_1_debug)
{
  reg->bitfields.DISP_HW_1_DEBUG = disp_hw_1_debug;
  if (reg->bitfields.DISP_HW_1_DEBUG != disp_hw_1_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_1_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_2_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_2_debug)
{
  reg->bitfields.DISP_HW_2_DEBUG = disp_hw_2_debug;
  if (reg->bitfields.DISP_HW_2_DEBUG != disp_hw_2_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_2_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_3_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_3_debug)
{
  reg->bitfields.DISP_HW_3_DEBUG = disp_hw_3_debug;
  if (reg->bitfields.DISP_HW_3_DEBUG != disp_hw_3_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_3_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_4_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_4_debug)
{
  reg->bitfields.DISP_HW_4_DEBUG = disp_hw_4_debug;
  if (reg->bitfields.DISP_HW_4_DEBUG != disp_hw_4_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_4_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_crt2_disp1_sel(regDISP_HW_DEBUG_M6 *reg, unsigned int crt2_disp1_sel)
{
  reg->bitfields.CRT2_DISP1_SEL = crt2_disp1_sel;
  if (reg->bitfields.CRT2_DISP1_SEL != crt2_disp1_sel) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::CRT2_DISP1_SEL data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_6_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_6_debug)
{
  reg->bitfields.DISP_HW_6_DEBUG = disp_hw_6_debug;
  if (reg->bitfields.DISP_HW_6_DEBUG != disp_hw_6_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_6_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_7_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_7_debug)
{
  reg->bitfields.DISP_HW_7_DEBUG = disp_hw_7_debug;
  if (reg->bitfields.DISP_HW_7_DEBUG != disp_hw_7_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_7_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_8_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_8_debug)
{
  reg->bitfields.DISP_HW_8_DEBUG = disp_hw_8_debug;
  if (reg->bitfields.DISP_HW_8_DEBUG != disp_hw_8_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_8_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_9_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_9_debug)
{
  reg->bitfields.DISP_HW_9_DEBUG = disp_hw_9_debug;
  if (reg->bitfields.DISP_HW_9_DEBUG != disp_hw_9_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_9_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_a_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_a_debug)
{
  reg->bitfields.DISP_HW_A_DEBUG = disp_hw_a_debug;
  if (reg->bitfields.DISP_HW_A_DEBUG != disp_hw_a_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_A_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_b_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_b_debug)
{
  reg->bitfields.DISP_HW_B_DEBUG = disp_hw_b_debug;
  if (reg->bitfields.DISP_HW_B_DEBUG != disp_hw_b_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_B_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_c_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_c_debug)
{
  reg->bitfields.DISP_HW_C_DEBUG = disp_hw_c_debug;
  if (reg->bitfields.DISP_HW_C_DEBUG != disp_hw_c_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_C_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_d_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_d_debug)
{
  reg->bitfields.DISP_HW_D_DEBUG = disp_hw_d_debug;
  if (reg->bitfields.DISP_HW_D_DEBUG != disp_hw_d_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_D_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_e_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_e_debug)
{
  reg->bitfields.DISP_HW_E_DEBUG = disp_hw_e_debug;
  if (reg->bitfields.DISP_HW_E_DEBUG != disp_hw_e_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_E_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_f_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_f_debug)
{
  reg->bitfields.DISP_HW_F_DEBUG = disp_hw_f_debug;
  if (reg->bitfields.DISP_HW_F_DEBUG != disp_hw_f_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_F_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_10_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_10_debug)
{
  reg->bitfields.DISP_HW_10_DEBUG = disp_hw_10_debug;
  if (reg->bitfields.DISP_HW_10_DEBUG != disp_hw_10_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_10_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_11_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_11_debug)
{
  reg->bitfields.DISP_HW_11_DEBUG = disp_hw_11_debug;
  if (reg->bitfields.DISP_HW_11_DEBUG != disp_hw_11_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_11_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_12_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_12_debug)
{
  reg->bitfields.DISP_HW_12_DEBUG = disp_hw_12_debug;
  if (reg->bitfields.DISP_HW_12_DEBUG != disp_hw_12_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_12_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_13_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_13_debug)
{
  reg->bitfields.DISP_HW_13_DEBUG = disp_hw_13_debug;
  if (reg->bitfields.DISP_HW_13_DEBUG != disp_hw_13_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_13_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_14_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_14_debug)
{
  reg->bitfields.DISP_HW_14_DEBUG = disp_hw_14_debug;
  if (reg->bitfields.DISP_HW_14_DEBUG != disp_hw_14_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_14_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_15_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_15_debug)
{
  reg->bitfields.DISP_HW_15_DEBUG = disp_hw_15_debug;
  if (reg->bitfields.DISP_HW_15_DEBUG != disp_hw_15_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_15_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_16_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_16_debug)
{
  reg->bitfields.DISP_HW_16_DEBUG = disp_hw_16_debug;
  if (reg->bitfields.DISP_HW_16_DEBUG != disp_hw_16_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_16_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_17_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_17_debug)
{
  reg->bitfields.DISP_HW_17_DEBUG = disp_hw_17_debug;
  if (reg->bitfields.DISP_HW_17_DEBUG != disp_hw_17_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_17_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_18_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_18_debug)
{
  reg->bitfields.DISP_HW_18_DEBUG = disp_hw_18_debug;
  if (reg->bitfields.DISP_HW_18_DEBUG != disp_hw_18_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_18_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_19_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_19_debug)
{
  reg->bitfields.DISP_HW_19_DEBUG = disp_hw_19_debug;
  if (reg->bitfields.DISP_HW_19_DEBUG != disp_hw_19_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_19_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_1a_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_1a_debug)
{
  reg->bitfields.DISP_HW_1A_DEBUG = disp_hw_1a_debug;
  if (reg->bitfields.DISP_HW_1A_DEBUG != disp_hw_1a_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_1A_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_1b_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_1b_debug)
{
  reg->bitfields.DISP_HW_1B_DEBUG = disp_hw_1b_debug;
  if (reg->bitfields.DISP_HW_1B_DEBUG != disp_hw_1b_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_1B_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_1c_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_1c_debug)
{
  reg->bitfields.DISP_HW_1C_DEBUG = disp_hw_1c_debug;
  if (reg->bitfields.DISP_HW_1C_DEBUG != disp_hw_1c_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_1C_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_1d_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_1d_debug)
{
  reg->bitfields.DISP_HW_1D_DEBUG = disp_hw_1d_debug;
  if (reg->bitfields.DISP_HW_1D_DEBUG != disp_hw_1d_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_1D_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_1e_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_1e_debug)
{
  reg->bitfields.DISP_HW_1E_DEBUG = disp_hw_1e_debug;
  if (reg->bitfields.DISP_HW_1E_DEBUG != disp_hw_1e_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_1E_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_M6_disp_hw_1f_debug(regDISP_HW_DEBUG_M6 *reg, unsigned int disp_hw_1f_debug)
{
  reg->bitfields.DISP_HW_1F_DEBUG = disp_hw_1f_debug;
  if (reg->bitfields.DISP_HW_1F_DEBUG != disp_hw_1f_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG_M6::DISP_HW_1F_DEBUG data too large\n");
}
#else
#define set_DISP_HW_DEBUG_M6_disp_hw_0_debug(reg, disp_hw_0_debug) (reg)->bitfields.DISP_HW_0_DEBUG = disp_hw_0_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_1_debug(reg, disp_hw_1_debug) (reg)->bitfields.DISP_HW_1_DEBUG = disp_hw_1_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_2_debug(reg, disp_hw_2_debug) (reg)->bitfields.DISP_HW_2_DEBUG = disp_hw_2_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_3_debug(reg, disp_hw_3_debug) (reg)->bitfields.DISP_HW_3_DEBUG = disp_hw_3_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_4_debug(reg, disp_hw_4_debug) (reg)->bitfields.DISP_HW_4_DEBUG = disp_hw_4_debug
#define set_DISP_HW_DEBUG_M6_crt2_disp1_sel(reg, crt2_disp1_sel) (reg)->bitfields.CRT2_DISP1_SEL = crt2_disp1_sel
#define set_DISP_HW_DEBUG_M6_disp_hw_6_debug(reg, disp_hw_6_debug) (reg)->bitfields.DISP_HW_6_DEBUG = disp_hw_6_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_7_debug(reg, disp_hw_7_debug) (reg)->bitfields.DISP_HW_7_DEBUG = disp_hw_7_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_8_debug(reg, disp_hw_8_debug) (reg)->bitfields.DISP_HW_8_DEBUG = disp_hw_8_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_9_debug(reg, disp_hw_9_debug) (reg)->bitfields.DISP_HW_9_DEBUG = disp_hw_9_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_a_debug(reg, disp_hw_a_debug) (reg)->bitfields.DISP_HW_A_DEBUG = disp_hw_a_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_b_debug(reg, disp_hw_b_debug) (reg)->bitfields.DISP_HW_B_DEBUG = disp_hw_b_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_c_debug(reg, disp_hw_c_debug) (reg)->bitfields.DISP_HW_C_DEBUG = disp_hw_c_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_d_debug(reg, disp_hw_d_debug) (reg)->bitfields.DISP_HW_D_DEBUG = disp_hw_d_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_e_debug(reg, disp_hw_e_debug) (reg)->bitfields.DISP_HW_E_DEBUG = disp_hw_e_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_f_debug(reg, disp_hw_f_debug) (reg)->bitfields.DISP_HW_F_DEBUG = disp_hw_f_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_10_debug(reg, disp_hw_10_debug) (reg)->bitfields.DISP_HW_10_DEBUG = disp_hw_10_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_11_debug(reg, disp_hw_11_debug) (reg)->bitfields.DISP_HW_11_DEBUG = disp_hw_11_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_12_debug(reg, disp_hw_12_debug) (reg)->bitfields.DISP_HW_12_DEBUG = disp_hw_12_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_13_debug(reg, disp_hw_13_debug) (reg)->bitfields.DISP_HW_13_DEBUG = disp_hw_13_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_14_debug(reg, disp_hw_14_debug) (reg)->bitfields.DISP_HW_14_DEBUG = disp_hw_14_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_15_debug(reg, disp_hw_15_debug) (reg)->bitfields.DISP_HW_15_DEBUG = disp_hw_15_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_16_debug(reg, disp_hw_16_debug) (reg)->bitfields.DISP_HW_16_DEBUG = disp_hw_16_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_17_debug(reg, disp_hw_17_debug) (reg)->bitfields.DISP_HW_17_DEBUG = disp_hw_17_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_18_debug(reg, disp_hw_18_debug) (reg)->bitfields.DISP_HW_18_DEBUG = disp_hw_18_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_19_debug(reg, disp_hw_19_debug) (reg)->bitfields.DISP_HW_19_DEBUG = disp_hw_19_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_1a_debug(reg, disp_hw_1a_debug) (reg)->bitfields.DISP_HW_1A_DEBUG = disp_hw_1a_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_1b_debug(reg, disp_hw_1b_debug) (reg)->bitfields.DISP_HW_1B_DEBUG = disp_hw_1b_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_1c_debug(reg, disp_hw_1c_debug) (reg)->bitfields.DISP_HW_1C_DEBUG = disp_hw_1c_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_1d_debug(reg, disp_hw_1d_debug) (reg)->bitfields.DISP_HW_1D_DEBUG = disp_hw_1d_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_1e_debug(reg, disp_hw_1e_debug) (reg)->bitfields.DISP_HW_1E_DEBUG = disp_hw_1e_debug
#define set_DISP_HW_DEBUG_M6_disp_hw_1f_debug(reg, disp_hw_1f_debug) (reg)->bitfields.DISP_HW_1F_DEBUG = disp_hw_1f_debug

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_CRC_SIG1 regDAC_CRC_SIG1;

#ifdef DEBUG
__inline void set_DAC_CRC_SIG1_dac_crc_sig_b(regDAC_CRC_SIG1 *reg, unsigned int dac_crc_sig_b)
{
  reg->bitfields.DAC_CRC_SIG_B = dac_crc_sig_b;
  if (reg->bitfields.DAC_CRC_SIG_B != dac_crc_sig_b) HSLDPF(E_ERROR_MESSAGE,"DAC_CRC_SIG1::DAC_CRC_SIG_B data too large\n");
}
__inline void set_DAC_CRC_SIG1_dac_crc_sig_g(regDAC_CRC_SIG1 *reg, unsigned int dac_crc_sig_g)
{
  reg->bitfields.DAC_CRC_SIG_G = dac_crc_sig_g;
  if (reg->bitfields.DAC_CRC_SIG_G != dac_crc_sig_g) HSLDPF(E_ERROR_MESSAGE,"DAC_CRC_SIG1::DAC_CRC_SIG_G data too large\n");
}
#else
#define set_DAC_CRC_SIG1_dac_crc_sig_b(reg, dac_crc_sig_b) (reg)->bitfields.DAC_CRC_SIG_B = dac_crc_sig_b
#define set_DAC_CRC_SIG1_dac_crc_sig_g(reg, dac_crc_sig_g) (reg)->bitfields.DAC_CRC_SIG_G = dac_crc_sig_g

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_CRC_SIG2 regDAC_CRC_SIG2;

#ifdef DEBUG
__inline void set_DAC_CRC_SIG2_dac_crc_sig_r(regDAC_CRC_SIG2 *reg, unsigned int dac_crc_sig_r)
{
  reg->bitfields.DAC_CRC_SIG_R = dac_crc_sig_r;
  if (reg->bitfields.DAC_CRC_SIG_R != dac_crc_sig_r) HSLDPF(E_ERROR_MESSAGE,"DAC_CRC_SIG2::DAC_CRC_SIG_R data too large\n");
}
__inline void set_DAC_CRC_SIG2_dac_crc_sig_c(regDAC_CRC_SIG2 *reg, unsigned int dac_crc_sig_c)
{
  reg->bitfields.DAC_CRC_SIG_C = dac_crc_sig_c;
  if (reg->bitfields.DAC_CRC_SIG_C != dac_crc_sig_c) HSLDPF(E_ERROR_MESSAGE,"DAC_CRC_SIG2::DAC_CRC_SIG_C data too large\n");
}
#else
#define set_DAC_CRC_SIG2_dac_crc_sig_r(reg, dac_crc_sig_r) (reg)->bitfields.DAC_CRC_SIG_R = dac_crc_sig_r
#define set_DAC_CRC_SIG2_dac_crc_sig_c(reg, dac_crc_sig_c) (reg)->bitfields.DAC_CRC_SIG_C = dac_crc_sig_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_LIN_TRANS_A_M6 regOV0_LIN_TRANS_A_M6;

#ifdef DEBUG
__inline void set_OV0_LIN_TRANS_A_M6_ov0_lin_trans_cb_r(regOV0_LIN_TRANS_A_M6 *reg, unsigned int ov0_lin_trans_cb_r)
{
  reg->bitfields.OV0_LIN_TRANS_Cb_R = ov0_lin_trans_cb_r;
  if (reg->bitfields.OV0_LIN_TRANS_Cb_R != ov0_lin_trans_cb_r) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_A_M6::OV0_LIN_TRANS_Cb_R data too large\n");
}
__inline void set_OV0_LIN_TRANS_A_M6_ov0_lin_trans_y_r(regOV0_LIN_TRANS_A_M6 *reg, unsigned int ov0_lin_trans_y_r)
{
  reg->bitfields.OV0_LIN_TRANS_Y_R = ov0_lin_trans_y_r;
  if (reg->bitfields.OV0_LIN_TRANS_Y_R != ov0_lin_trans_y_r) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_A_M6::OV0_LIN_TRANS_Y_R data too large\n");
}
#else
#define set_OV0_LIN_TRANS_A_M6_ov0_lin_trans_cb_r(reg, ov0_lin_trans_cb_r) (reg)->bitfields.OV0_LIN_TRANS_Cb_R = ov0_lin_trans_cb_r
#define set_OV0_LIN_TRANS_A_M6_ov0_lin_trans_y_r(reg, ov0_lin_trans_y_r) (reg)->bitfields.OV0_LIN_TRANS_Y_R = ov0_lin_trans_y_r

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_LIN_TRANS_B_M6 regOV0_LIN_TRANS_B_M6;

#ifdef DEBUG
__inline void set_OV0_LIN_TRANS_B_M6_ov0_lin_trans_off_r(regOV0_LIN_TRANS_B_M6 *reg, unsigned int ov0_lin_trans_off_r)
{
  reg->bitfields.OV0_LIN_TRANS_OFF_R = ov0_lin_trans_off_r;
  if (reg->bitfields.OV0_LIN_TRANS_OFF_R != ov0_lin_trans_off_r) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_B_M6::OV0_LIN_TRANS_OFF_R data too large\n");
}
__inline void set_OV0_LIN_TRANS_B_M6_ov0_lin_trans_cr_r(regOV0_LIN_TRANS_B_M6 *reg, unsigned int ov0_lin_trans_cr_r)
{
  reg->bitfields.OV0_LIN_TRANS_Cr_R = ov0_lin_trans_cr_r;
  if (reg->bitfields.OV0_LIN_TRANS_Cr_R != ov0_lin_trans_cr_r) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_B_M6::OV0_LIN_TRANS_Cr_R data too large\n");
}
#else
#define set_OV0_LIN_TRANS_B_M6_ov0_lin_trans_off_r(reg, ov0_lin_trans_off_r) (reg)->bitfields.OV0_LIN_TRANS_OFF_R = ov0_lin_trans_off_r
#define set_OV0_LIN_TRANS_B_M6_ov0_lin_trans_cr_r(reg, ov0_lin_trans_cr_r) (reg)->bitfields.OV0_LIN_TRANS_Cr_R = ov0_lin_trans_cr_r

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_LIN_TRANS_C_M6 regOV0_LIN_TRANS_C_M6;

#ifdef DEBUG
__inline void set_OV0_LIN_TRANS_C_M6_ov0_lin_trans_cb_g(regOV0_LIN_TRANS_C_M6 *reg, unsigned int ov0_lin_trans_cb_g)
{
  reg->bitfields.OV0_LIN_TRANS_Cb_G = ov0_lin_trans_cb_g;
  if (reg->bitfields.OV0_LIN_TRANS_Cb_G != ov0_lin_trans_cb_g) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_C_M6::OV0_LIN_TRANS_Cb_G data too large\n");
}
__inline void set_OV0_LIN_TRANS_C_M6_ov0_lin_trans_y_g(regOV0_LIN_TRANS_C_M6 *reg, unsigned int ov0_lin_trans_y_g)
{
  reg->bitfields.OV0_LIN_TRANS_Y_G = ov0_lin_trans_y_g;
  if (reg->bitfields.OV0_LIN_TRANS_Y_G != ov0_lin_trans_y_g) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_C_M6::OV0_LIN_TRANS_Y_G data too large\n");
}
#else
#define set_OV0_LIN_TRANS_C_M6_ov0_lin_trans_cb_g(reg, ov0_lin_trans_cb_g) (reg)->bitfields.OV0_LIN_TRANS_Cb_G = ov0_lin_trans_cb_g
#define set_OV0_LIN_TRANS_C_M6_ov0_lin_trans_y_g(reg, ov0_lin_trans_y_g) (reg)->bitfields.OV0_LIN_TRANS_Y_G = ov0_lin_trans_y_g

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_LIN_TRANS_D_M6 regOV0_LIN_TRANS_D_M6;

#ifdef DEBUG
__inline void set_OV0_LIN_TRANS_D_M6_ov0_lin_trans_off_g(regOV0_LIN_TRANS_D_M6 *reg, unsigned int ov0_lin_trans_off_g)
{
  reg->bitfields.OV0_LIN_TRANS_OFF_G = ov0_lin_trans_off_g;
  if (reg->bitfields.OV0_LIN_TRANS_OFF_G != ov0_lin_trans_off_g) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_D_M6::OV0_LIN_TRANS_OFF_G data too large\n");
}
__inline void set_OV0_LIN_TRANS_D_M6_ov0_lin_trans_cr_g(regOV0_LIN_TRANS_D_M6 *reg, unsigned int ov0_lin_trans_cr_g)
{
  reg->bitfields.OV0_LIN_TRANS_Cr_G = ov0_lin_trans_cr_g;
  if (reg->bitfields.OV0_LIN_TRANS_Cr_G != ov0_lin_trans_cr_g) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_D_M6::OV0_LIN_TRANS_Cr_G data too large\n");
}
#else
#define set_OV0_LIN_TRANS_D_M6_ov0_lin_trans_off_g(reg, ov0_lin_trans_off_g) (reg)->bitfields.OV0_LIN_TRANS_OFF_G = ov0_lin_trans_off_g
#define set_OV0_LIN_TRANS_D_M6_ov0_lin_trans_cr_g(reg, ov0_lin_trans_cr_g) (reg)->bitfields.OV0_LIN_TRANS_Cr_G = ov0_lin_trans_cr_g

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_LIN_TRANS_E_M6 regOV0_LIN_TRANS_E_M6;

#ifdef DEBUG
__inline void set_OV0_LIN_TRANS_E_M6_ov0_lin_trans_cb_b(regOV0_LIN_TRANS_E_M6 *reg, unsigned int ov0_lin_trans_cb_b)
{
  reg->bitfields.OV0_LIN_TRANS_Cb_B = ov0_lin_trans_cb_b;
  if (reg->bitfields.OV0_LIN_TRANS_Cb_B != ov0_lin_trans_cb_b) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_E_M6::OV0_LIN_TRANS_Cb_B data too large\n");
}
__inline void set_OV0_LIN_TRANS_E_M6_ov0_lin_trans_y_b(regOV0_LIN_TRANS_E_M6 *reg, unsigned int ov0_lin_trans_y_b)
{
  reg->bitfields.OV0_LIN_TRANS_Y_B = ov0_lin_trans_y_b;
  if (reg->bitfields.OV0_LIN_TRANS_Y_B != ov0_lin_trans_y_b) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_E_M6::OV0_LIN_TRANS_Y_B data too large\n");
}
#else
#define set_OV0_LIN_TRANS_E_M6_ov0_lin_trans_cb_b(reg, ov0_lin_trans_cb_b) (reg)->bitfields.OV0_LIN_TRANS_Cb_B = ov0_lin_trans_cb_b
#define set_OV0_LIN_TRANS_E_M6_ov0_lin_trans_y_b(reg, ov0_lin_trans_y_b) (reg)->bitfields.OV0_LIN_TRANS_Y_B = ov0_lin_trans_y_b

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_LIN_TRANS_F_M6 regOV0_LIN_TRANS_F_M6;

#ifdef DEBUG
__inline void set_OV0_LIN_TRANS_F_M6_ov0_lin_trans_off_b(regOV0_LIN_TRANS_F_M6 *reg, unsigned int ov0_lin_trans_off_b)
{
  reg->bitfields.OV0_LIN_TRANS_OFF_B = ov0_lin_trans_off_b;
  if (reg->bitfields.OV0_LIN_TRANS_OFF_B != ov0_lin_trans_off_b) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_F_M6::OV0_LIN_TRANS_OFF_B data too large\n");
}
__inline void set_OV0_LIN_TRANS_F_M6_ov0_lin_trans_cr_b(regOV0_LIN_TRANS_F_M6 *reg, unsigned int ov0_lin_trans_cr_b)
{
  reg->bitfields.OV0_LIN_TRANS_Cr_B = ov0_lin_trans_cr_b;
  if (reg->bitfields.OV0_LIN_TRANS_Cr_B != ov0_lin_trans_cr_b) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_F_M6::OV0_LIN_TRANS_Cr_B data too large\n");
}
#else
#define set_OV0_LIN_TRANS_F_M6_ov0_lin_trans_off_b(reg, ov0_lin_trans_off_b) (reg)->bitfields.OV0_LIN_TRANS_OFF_B = ov0_lin_trans_off_b
#define set_OV0_LIN_TRANS_F_M6_ov0_lin_trans_cr_b(reg, ov0_lin_trans_cr_b) (reg)->bitfields.OV0_LIN_TRANS_Cr_B = ov0_lin_trans_cr_b

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_GAMMA_0_F regOV0_GAMMA_0_F;

#ifdef DEBUG
__inline void set_OV0_GAMMA_0_F_ov0_gamma_0_f_offset(regOV0_GAMMA_0_F *reg, unsigned int ov0_gamma_0_f_offset)
{
  reg->bitfields.OV0_GAMMA_0_F_OFFSET = ov0_gamma_0_f_offset;
  if (reg->bitfields.OV0_GAMMA_0_F_OFFSET != ov0_gamma_0_f_offset) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_0_F::OV0_GAMMA_0_F_OFFSET data too large\n");
}
__inline void set_OV0_GAMMA_0_F_ov0_gamma_0_f_slope(regOV0_GAMMA_0_F *reg, unsigned int ov0_gamma_0_f_slope)
{
  reg->bitfields.OV0_GAMMA_0_F_SLOPE = ov0_gamma_0_f_slope;
  if (reg->bitfields.OV0_GAMMA_0_F_SLOPE != ov0_gamma_0_f_slope) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_0_F::OV0_GAMMA_0_F_SLOPE data too large\n");
}
#else
#define set_OV0_GAMMA_0_F_ov0_gamma_0_f_offset(reg, ov0_gamma_0_f_offset) (reg)->bitfields.OV0_GAMMA_0_F_OFFSET = ov0_gamma_0_f_offset
#define set_OV0_GAMMA_0_F_ov0_gamma_0_f_slope(reg, ov0_gamma_0_f_slope) (reg)->bitfields.OV0_GAMMA_0_F_SLOPE = ov0_gamma_0_f_slope

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_GAMMA_10_1F regOV0_GAMMA_10_1F;

#ifdef DEBUG
__inline void set_OV0_GAMMA_10_1F_ov0_gamma_10_1f_offset(regOV0_GAMMA_10_1F *reg, unsigned int ov0_gamma_10_1f_offset)
{
  reg->bitfields.OV0_GAMMA_10_1F_OFFSET = ov0_gamma_10_1f_offset;
  if (reg->bitfields.OV0_GAMMA_10_1F_OFFSET != ov0_gamma_10_1f_offset) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_10_1F::OV0_GAMMA_10_1F_OFFSET data too large\n");
}
__inline void set_OV0_GAMMA_10_1F_ov0_gamma_10_1f_slope(regOV0_GAMMA_10_1F *reg, unsigned int ov0_gamma_10_1f_slope)
{
  reg->bitfields.OV0_GAMMA_10_1F_SLOPE = ov0_gamma_10_1f_slope;
  if (reg->bitfields.OV0_GAMMA_10_1F_SLOPE != ov0_gamma_10_1f_slope) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_10_1F::OV0_GAMMA_10_1F_SLOPE data too large\n");
}
#else
#define set_OV0_GAMMA_10_1F_ov0_gamma_10_1f_offset(reg, ov0_gamma_10_1f_offset) (reg)->bitfields.OV0_GAMMA_10_1F_OFFSET = ov0_gamma_10_1f_offset
#define set_OV0_GAMMA_10_1F_ov0_gamma_10_1f_slope(reg, ov0_gamma_10_1f_slope) (reg)->bitfields.OV0_GAMMA_10_1F_SLOPE = ov0_gamma_10_1f_slope

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_GAMMA_20_3F regOV0_GAMMA_20_3F;

#ifdef DEBUG
__inline void set_OV0_GAMMA_20_3F_ov0_gamma_20_3f_offset(regOV0_GAMMA_20_3F *reg, unsigned int ov0_gamma_20_3f_offset)
{
  reg->bitfields.OV0_GAMMA_20_3F_OFFSET = ov0_gamma_20_3f_offset;
  if (reg->bitfields.OV0_GAMMA_20_3F_OFFSET != ov0_gamma_20_3f_offset) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_20_3F::OV0_GAMMA_20_3F_OFFSET data too large\n");
}
__inline void set_OV0_GAMMA_20_3F_ov0_gamma_20_3f_slope(regOV0_GAMMA_20_3F *reg, unsigned int ov0_gamma_20_3f_slope)
{
  reg->bitfields.OV0_GAMMA_20_3F_SLOPE = ov0_gamma_20_3f_slope;
  if (reg->bitfields.OV0_GAMMA_20_3F_SLOPE != ov0_gamma_20_3f_slope) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_20_3F::OV0_GAMMA_20_3F_SLOPE data too large\n");
}
#else
#define set_OV0_GAMMA_20_3F_ov0_gamma_20_3f_offset(reg, ov0_gamma_20_3f_offset) (reg)->bitfields.OV0_GAMMA_20_3F_OFFSET = ov0_gamma_20_3f_offset
#define set_OV0_GAMMA_20_3F_ov0_gamma_20_3f_slope(reg, ov0_gamma_20_3f_slope) (reg)->bitfields.OV0_GAMMA_20_3F_SLOPE = ov0_gamma_20_3f_slope

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_GAMMA_40_7F regOV0_GAMMA_40_7F;

#ifdef DEBUG
__inline void set_OV0_GAMMA_40_7F_ov0_gamma_40_7f_offset(regOV0_GAMMA_40_7F *reg, unsigned int ov0_gamma_40_7f_offset)
{
  reg->bitfields.OV0_GAMMA_40_7F_OFFSET = ov0_gamma_40_7f_offset;
  if (reg->bitfields.OV0_GAMMA_40_7F_OFFSET != ov0_gamma_40_7f_offset) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_40_7F::OV0_GAMMA_40_7F_OFFSET data too large\n");
}
__inline void set_OV0_GAMMA_40_7F_ov0_gamma_40_7f_slope(regOV0_GAMMA_40_7F *reg, unsigned int ov0_gamma_40_7f_slope)
{
  reg->bitfields.OV0_GAMMA_40_7F_SLOPE = ov0_gamma_40_7f_slope;
  if (reg->bitfields.OV0_GAMMA_40_7F_SLOPE != ov0_gamma_40_7f_slope) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_40_7F::OV0_GAMMA_40_7F_SLOPE data too large\n");
}
#else
#define set_OV0_GAMMA_40_7F_ov0_gamma_40_7f_offset(reg, ov0_gamma_40_7f_offset) (reg)->bitfields.OV0_GAMMA_40_7F_OFFSET = ov0_gamma_40_7f_offset
#define set_OV0_GAMMA_40_7F_ov0_gamma_40_7f_slope(reg, ov0_gamma_40_7f_slope) (reg)->bitfields.OV0_GAMMA_40_7F_SLOPE = ov0_gamma_40_7f_slope

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250OV0_GAMMA_380_3BF regrv250OV0_GAMMA_380_3BF;

#ifdef DEBUG
__inline void set_rv250OV0_GAMMA_380_3BF_ov0_gamma_380_3bf_offset(regrv250OV0_GAMMA_380_3BF *reg, unsigned int ov0_gamma_380_3bf_offset)
{
  reg->bitfields.OV0_GAMMA_380_3BF_OFFSET = ov0_gamma_380_3bf_offset;
  if (reg->bitfields.OV0_GAMMA_380_3BF_OFFSET != ov0_gamma_380_3bf_offset) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_GAMMA_380_3BF::OV0_GAMMA_380_3BF_OFFSET data too large\n");
}
__inline void set_rv250OV0_GAMMA_380_3BF_ov0_gamma_380_3bf_slope(regrv250OV0_GAMMA_380_3BF *reg, unsigned int ov0_gamma_380_3bf_slope)
{
  reg->bitfields.OV0_GAMMA_380_3BF_SLOPE = ov0_gamma_380_3bf_slope;
  if (reg->bitfields.OV0_GAMMA_380_3BF_SLOPE != ov0_gamma_380_3bf_slope) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_GAMMA_380_3BF::OV0_GAMMA_380_3BF_SLOPE data too large\n");
}
#else
#define set_rv250OV0_GAMMA_380_3BF_ov0_gamma_380_3bf_offset(reg, ov0_gamma_380_3bf_offset) (reg)->bitfields.OV0_GAMMA_380_3BF_OFFSET = ov0_gamma_380_3bf_offset
#define set_rv250OV0_GAMMA_380_3BF_ov0_gamma_380_3bf_slope(reg, ov0_gamma_380_3bf_slope) (reg)->bitfields.OV0_GAMMA_380_3BF_SLOPE = ov0_gamma_380_3bf_slope

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250OV0_GAMMA_3C0_3FF regrv250OV0_GAMMA_3C0_3FF;

#ifdef DEBUG
__inline void set_rv250OV0_GAMMA_3C0_3FF_ov0_gamma_3c0_3ff_offset(regrv250OV0_GAMMA_3C0_3FF *reg, unsigned int ov0_gamma_3c0_3ff_offset)
{
  reg->bitfields.OV0_GAMMA_3C0_3FF_OFFSET = ov0_gamma_3c0_3ff_offset;
  if (reg->bitfields.OV0_GAMMA_3C0_3FF_OFFSET != ov0_gamma_3c0_3ff_offset) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_GAMMA_3C0_3FF::OV0_GAMMA_3C0_3FF_OFFSET data too large\n");
}
__inline void set_rv250OV0_GAMMA_3C0_3FF_ov0_gamma_3c0_3ff_slope(regrv250OV0_GAMMA_3C0_3FF *reg, unsigned int ov0_gamma_3c0_3ff_slope)
{
  reg->bitfields.OV0_GAMMA_3C0_3FF_SLOPE = ov0_gamma_3c0_3ff_slope;
  if (reg->bitfields.OV0_GAMMA_3C0_3FF_SLOPE != ov0_gamma_3c0_3ff_slope) HSLDPF(E_ERROR_MESSAGE,"rv250OV0_GAMMA_3C0_3FF::OV0_GAMMA_3C0_3FF_SLOPE data too large\n");
}
#else
#define set_rv250OV0_GAMMA_3C0_3FF_ov0_gamma_3c0_3ff_offset(reg, ov0_gamma_3c0_3ff_offset) (reg)->bitfields.OV0_GAMMA_3C0_3FF_OFFSET = ov0_gamma_3c0_3ff_offset
#define set_rv250OV0_GAMMA_3C0_3FF_ov0_gamma_3c0_3ff_slope(reg, ov0_gamma_3c0_3ff_slope) (reg)->bitfields.OV0_GAMMA_3C0_3FF_SLOPE = ov0_gamma_3c0_3ff_slope

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250DISP_OUTPUT_CNTL regrv250DISP_OUTPUT_CNTL;

#ifdef DEBUG
__inline void set_rv250DISP_OUTPUT_CNTL_disp_dac_source(regrv250DISP_OUTPUT_CNTL *reg, unsigned int disp_dac_source)
{
  reg->bitfields.DISP_DAC_SOURCE = disp_dac_source;
  if (reg->bitfields.DISP_DAC_SOURCE != disp_dac_source) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_OUTPUT_CNTL::DISP_DAC_SOURCE data too large\n");
}
__inline void set_rv250DISP_OUTPUT_CNTL_disp_rmx_source(regrv250DISP_OUTPUT_CNTL *reg, unsigned int disp_rmx_source)
{
  reg->bitfields.DISP_RMX_SOURCE = disp_rmx_source;
  if (reg->bitfields.DISP_RMX_SOURCE != disp_rmx_source) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_OUTPUT_CNTL::DISP_RMX_SOURCE data too large\n");
}
__inline void set_rv250DISP_OUTPUT_CNTL_disp_rmx_dith_en(regrv250DISP_OUTPUT_CNTL *reg, unsigned int disp_rmx_dith_en)
{
  reg->bitfields.DISP_RMX_DITH_EN = disp_rmx_dith_en;
  if (reg->bitfields.DISP_RMX_DITH_EN != disp_rmx_dith_en) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_OUTPUT_CNTL::DISP_RMX_DITH_EN data too large\n");
}
__inline void set_rv250DISP_OUTPUT_CNTL_disp_tv_even_flag_cntl(regrv250DISP_OUTPUT_CNTL *reg, unsigned int disp_tv_even_flag_cntl)
{
  reg->bitfields.DISP_TV_EVEN_FLAG_CNTL = disp_tv_even_flag_cntl;
  if (reg->bitfields.DISP_TV_EVEN_FLAG_CNTL != disp_tv_even_flag_cntl) HSLDPF(E_ERROR_MESSAGE,"rv250DISP_OUTPUT_CNTL::DISP_TV_EVEN_FLAG_CNTL data too large\n");
}
#else
#define set_rv250DISP_OUTPUT_CNTL_disp_dac_source(reg, disp_dac_source) (reg)->bitfields.DISP_DAC_SOURCE = disp_dac_source
#define set_rv250DISP_OUTPUT_CNTL_disp_rmx_source(reg, disp_rmx_source) (reg)->bitfields.DISP_RMX_SOURCE = disp_rmx_source
#define set_rv250DISP_OUTPUT_CNTL_disp_rmx_dith_en(reg, disp_rmx_dith_en) (reg)->bitfields.DISP_RMX_DITH_EN = disp_rmx_dith_en
#define set_rv250DISP_OUTPUT_CNTL_disp_tv_even_flag_cntl(reg, disp_tv_even_flag_cntl) (reg)->bitfields.DISP_TV_EVEN_FLAG_CNTL = disp_tv_even_flag_cntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP2_MERGE_CNTL regDISP2_MERGE_CNTL;

#ifdef DEBUG
__inline void set_DISP2_MERGE_CNTL_disp2_rgb_offset_en(regDISP2_MERGE_CNTL *reg, unsigned int disp2_rgb_offset_en)
{
  reg->bitfields.DISP2_RGB_OFFSET_EN = disp2_rgb_offset_en;
  if (reg->bitfields.DISP2_RGB_OFFSET_EN != disp2_rgb_offset_en) HSLDPF(E_ERROR_MESSAGE,"DISP2_MERGE_CNTL::DISP2_RGB_OFFSET_EN data too large\n");
}
#else
#define set_DISP2_MERGE_CNTL_disp2_rgb_offset_en(reg, disp2_rgb_offset_en) (reg)->bitfields.DISP2_RGB_OFFSET_EN = disp2_rgb_offset_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_CRC2_SIG1 regDAC_CRC2_SIG1;

#ifdef DEBUG
__inline void set_DAC_CRC2_SIG1_dac_crc2_sig_b(regDAC_CRC2_SIG1 *reg, unsigned int dac_crc2_sig_b)
{
  reg->bitfields.DAC_CRC2_SIG_B = dac_crc2_sig_b;
  if (reg->bitfields.DAC_CRC2_SIG_B != dac_crc2_sig_b) HSLDPF(E_ERROR_MESSAGE,"DAC_CRC2_SIG1::DAC_CRC2_SIG_B data too large\n");
}
__inline void set_DAC_CRC2_SIG1_dac_crc2_sig_g(regDAC_CRC2_SIG1 *reg, unsigned int dac_crc2_sig_g)
{
  reg->bitfields.DAC_CRC2_SIG_G = dac_crc2_sig_g;
  if (reg->bitfields.DAC_CRC2_SIG_G != dac_crc2_sig_g) HSLDPF(E_ERROR_MESSAGE,"DAC_CRC2_SIG1::DAC_CRC2_SIG_G data too large\n");
}
#else
#define set_DAC_CRC2_SIG1_dac_crc2_sig_b(reg, dac_crc2_sig_b) (reg)->bitfields.DAC_CRC2_SIG_B = dac_crc2_sig_b
#define set_DAC_CRC2_SIG1_dac_crc2_sig_g(reg, dac_crc2_sig_g) (reg)->bitfields.DAC_CRC2_SIG_G = dac_crc2_sig_g

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_CRC2_SIG2 regDAC_CRC2_SIG2;

#ifdef DEBUG
__inline void set_DAC_CRC2_SIG2_dac_crc2_sig_r(regDAC_CRC2_SIG2 *reg, unsigned int dac_crc2_sig_r)
{
  reg->bitfields.DAC_CRC2_SIG_R = dac_crc2_sig_r;
  if (reg->bitfields.DAC_CRC2_SIG_R != dac_crc2_sig_r) HSLDPF(E_ERROR_MESSAGE,"DAC_CRC2_SIG2::DAC_CRC2_SIG_R data too large\n");
}
__inline void set_DAC_CRC2_SIG2_dac_crc2_sig_c(regDAC_CRC2_SIG2 *reg, unsigned int dac_crc2_sig_c)
{
  reg->bitfields.DAC_CRC2_SIG_C = dac_crc2_sig_c;
  if (reg->bitfields.DAC_CRC2_SIG_C != dac_crc2_sig_c) HSLDPF(E_ERROR_MESSAGE,"DAC_CRC2_SIG2::DAC_CRC2_SIG_C data too large\n");
}
#else
#define set_DAC_CRC2_SIG2_dac_crc2_sig_r(reg, dac_crc2_sig_r) (reg)->bitfields.DAC_CRC2_SIG_R = dac_crc2_sig_r
#define set_DAC_CRC2_SIG2_dac_crc2_sig_c(reg, dac_crc2_sig_c) (reg)->bitfields.DAC_CRC2_SIG_C = dac_crc2_sig_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RMX_HORZ_PHASE regRMX_HORZ_PHASE;

#ifdef DEBUG
__inline void set_RMX_HORZ_PHASE_rmx_horz_start_phase(regRMX_HORZ_PHASE *reg, unsigned int rmx_horz_start_phase)
{
  reg->bitfields.RMX_HORZ_START_PHASE = rmx_horz_start_phase;
  if (reg->bitfields.RMX_HORZ_START_PHASE != rmx_horz_start_phase) HSLDPF(E_ERROR_MESSAGE,"RMX_HORZ_PHASE::RMX_HORZ_START_PHASE data too large\n");
}
__inline void set_RMX_HORZ_PHASE_rmx_h_acc_init(regRMX_HORZ_PHASE *reg, unsigned int rmx_h_acc_init)
{
  reg->bitfields.RMX_H_ACC_INIT = rmx_h_acc_init;
  if (reg->bitfields.RMX_H_ACC_INIT != rmx_h_acc_init) HSLDPF(E_ERROR_MESSAGE,"RMX_HORZ_PHASE::RMX_H_ACC_INIT data too large\n");
}
__inline void set_RMX_HORZ_PHASE_rmx_v_acc_init(regRMX_HORZ_PHASE *reg, unsigned int rmx_v_acc_init)
{
  reg->bitfields.RMX_V_ACC_INIT = rmx_v_acc_init;
  if (reg->bitfields.RMX_V_ACC_INIT != rmx_v_acc_init) HSLDPF(E_ERROR_MESSAGE,"RMX_HORZ_PHASE::RMX_V_ACC_INIT data too large\n");
}
__inline void set_RMX_HORZ_PHASE_rmx_vert_start_phase(regRMX_HORZ_PHASE *reg, unsigned int rmx_vert_start_phase)
{
  reg->bitfields.RMX_VERT_START_PHASE = rmx_vert_start_phase;
  if (reg->bitfields.RMX_VERT_START_PHASE != rmx_vert_start_phase) HSLDPF(E_ERROR_MESSAGE,"RMX_HORZ_PHASE::RMX_VERT_START_PHASE data too large\n");
}
__inline void set_RMX_HORZ_PHASE_rmx_vert_half_start_phase_en(regRMX_HORZ_PHASE *reg, unsigned int rmx_vert_half_start_phase_en)
{
  reg->bitfields.RMX_VERT_HALF_START_PHASE_EN = rmx_vert_half_start_phase_en;
  if (reg->bitfields.RMX_VERT_HALF_START_PHASE_EN != rmx_vert_half_start_phase_en) HSLDPF(E_ERROR_MESSAGE,"RMX_HORZ_PHASE::RMX_VERT_HALF_START_PHASE_EN data too large\n");
}
__inline void set_RMX_HORZ_PHASE_rmx_vert_start_phase_overflow_en(regRMX_HORZ_PHASE *reg, unsigned int rmx_vert_start_phase_overflow_en)
{
  reg->bitfields.RMX_VERT_START_PHASE_OVERFLOW_EN = rmx_vert_start_phase_overflow_en;
  if (reg->bitfields.RMX_VERT_START_PHASE_OVERFLOW_EN != rmx_vert_start_phase_overflow_en) HSLDPF(E_ERROR_MESSAGE,"RMX_HORZ_PHASE::RMX_VERT_START_PHASE_OVERFLOW_EN data too large\n");
}
__inline void set_RMX_HORZ_PHASE_rmx_horz_half_start_phase_en(regRMX_HORZ_PHASE *reg, unsigned int rmx_horz_half_start_phase_en)
{
  reg->bitfields.RMX_HORZ_HALF_START_PHASE_EN = rmx_horz_half_start_phase_en;
  if (reg->bitfields.RMX_HORZ_HALF_START_PHASE_EN != rmx_horz_half_start_phase_en) HSLDPF(E_ERROR_MESSAGE,"RMX_HORZ_PHASE::RMX_HORZ_HALF_START_PHASE_EN data too large\n");
}
__inline void set_RMX_HORZ_PHASE_rmx_horz_start_phase_overflow_en(regRMX_HORZ_PHASE *reg, unsigned int rmx_horz_start_phase_overflow_en)
{
  reg->bitfields.RMX_HORZ_START_PHASE_OVERFLOW_EN = rmx_horz_start_phase_overflow_en;
  if (reg->bitfields.RMX_HORZ_START_PHASE_OVERFLOW_EN != rmx_horz_start_phase_overflow_en) HSLDPF(E_ERROR_MESSAGE,"RMX_HORZ_PHASE::RMX_HORZ_START_PHASE_OVERFLOW_EN data too large\n");
}
#else
#define set_RMX_HORZ_PHASE_rmx_horz_start_phase(reg, rmx_horz_start_phase) (reg)->bitfields.RMX_HORZ_START_PHASE = rmx_horz_start_phase
#define set_RMX_HORZ_PHASE_rmx_h_acc_init(reg, rmx_h_acc_init) (reg)->bitfields.RMX_H_ACC_INIT = rmx_h_acc_init
#define set_RMX_HORZ_PHASE_rmx_v_acc_init(reg, rmx_v_acc_init) (reg)->bitfields.RMX_V_ACC_INIT = rmx_v_acc_init
#define set_RMX_HORZ_PHASE_rmx_vert_start_phase(reg, rmx_vert_start_phase) (reg)->bitfields.RMX_VERT_START_PHASE = rmx_vert_start_phase
#define set_RMX_HORZ_PHASE_rmx_vert_half_start_phase_en(reg, rmx_vert_half_start_phase_en) (reg)->bitfields.RMX_VERT_HALF_START_PHASE_EN = rmx_vert_half_start_phase_en
#define set_RMX_HORZ_PHASE_rmx_vert_start_phase_overflow_en(reg, rmx_vert_start_phase_overflow_en) (reg)->bitfields.RMX_VERT_START_PHASE_OVERFLOW_EN = rmx_vert_start_phase_overflow_en
#define set_RMX_HORZ_PHASE_rmx_horz_half_start_phase_en(reg, rmx_horz_half_start_phase_en) (reg)->bitfields.RMX_HORZ_HALF_START_PHASE_EN = rmx_horz_half_start_phase_en
#define set_RMX_HORZ_PHASE_rmx_horz_start_phase_overflow_en(reg, rmx_horz_start_phase_overflow_en) (reg)->bitfields.RMX_HORZ_START_PHASE_OVERFLOW_EN = rmx_horz_start_phase_overflow_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union HDCP_GEN_CNTL regHDCP_GEN_CNTL;

#ifdef DEBUG
__inline void set_HDCP_GEN_CNTL_hdcp_authorized_int_stat(regHDCP_GEN_CNTL *reg, unsigned int hdcp_authorized_int_stat)
{
  reg->bitfields.HDCP_AUTHORIZED_INT_STAT = hdcp_authorized_int_stat;
  if (reg->bitfields.HDCP_AUTHORIZED_INT_STAT != hdcp_authorized_int_stat) HSLDPF(E_ERROR_MESSAGE,"HDCP_GEN_CNTL::HDCP_AUTHORIZED_INT_STAT data too large\n");
}
__inline void set_HDCP_GEN_CNTL_hdcp_authorized_int_pol(regHDCP_GEN_CNTL *reg, unsigned int hdcp_authorized_int_pol)
{
  reg->bitfields.HDCP_AUTHORIZED_INT_POL = hdcp_authorized_int_pol;
  if (reg->bitfields.HDCP_AUTHORIZED_INT_POL != hdcp_authorized_int_pol) HSLDPF(E_ERROR_MESSAGE,"HDCP_GEN_CNTL::HDCP_AUTHORIZED_INT_POL data too large\n");
}
__inline void set_HDCP_GEN_CNTL_hdcp_authorized_int_mask(regHDCP_GEN_CNTL *reg, unsigned int hdcp_authorized_int_mask)
{
  reg->bitfields.HDCP_AUTHORIZED_INT_MASK = hdcp_authorized_int_mask;
  if (reg->bitfields.HDCP_AUTHORIZED_INT_MASK != hdcp_authorized_int_mask) HSLDPF(E_ERROR_MESSAGE,"HDCP_GEN_CNTL::HDCP_AUTHORIZED_INT_MASK data too large\n");
}
__inline void set_HDCP_GEN_CNTL_hot_plug_affects_hdcp_en(regHDCP_GEN_CNTL *reg, unsigned int hot_plug_affects_hdcp_en)
{
  reg->bitfields.HOT_PLUG_AFFECTS_HDCP_EN = hot_plug_affects_hdcp_en;
  if (reg->bitfields.HOT_PLUG_AFFECTS_HDCP_EN != hot_plug_affects_hdcp_en) HSLDPF(E_ERROR_MESSAGE,"HDCP_GEN_CNTL::HOT_PLUG_AFFECTS_HDCP_EN data too large\n");
}
__inline void set_HDCP_GEN_CNTL_hdcp_authorized(regHDCP_GEN_CNTL *reg, unsigned int hdcp_authorized)
{
  reg->bitfields.HDCP_AUTHORIZED = hdcp_authorized;
  if (reg->bitfields.HDCP_AUTHORIZED != hdcp_authorized) HSLDPF(E_ERROR_MESSAGE,"HDCP_GEN_CNTL::HDCP_AUTHORIZED data too large\n");
}
__inline void set_HDCP_GEN_CNTL_hdcp_reset(regHDCP_GEN_CNTL *reg, unsigned int hdcp_reset)
{
  reg->bitfields.HDCP_RESET = hdcp_reset;
  if (reg->bitfields.HDCP_RESET != hdcp_reset) HSLDPF(E_ERROR_MESSAGE,"HDCP_GEN_CNTL::HDCP_RESET data too large\n");
}
__inline void set_HDCP_GEN_CNTL_hdcp_i2c_scl_drive_en(regHDCP_GEN_CNTL *reg, unsigned int hdcp_i2c_scl_drive_en)
{
  reg->bitfields.HDCP_I2C_SCL_DRIVE_EN = hdcp_i2c_scl_drive_en;
  if (reg->bitfields.HDCP_I2C_SCL_DRIVE_EN != hdcp_i2c_scl_drive_en) HSLDPF(E_ERROR_MESSAGE,"HDCP_GEN_CNTL::HDCP_I2C_SCL_DRIVE_EN data too large\n");
}
__inline void set_HDCP_GEN_CNTL_hdcp_i2c_sda_drive_en(regHDCP_GEN_CNTL *reg, unsigned int hdcp_i2c_sda_drive_en)
{
  reg->bitfields.HDCP_I2C_SDA_DRIVE_EN = hdcp_i2c_sda_drive_en;
  if (reg->bitfields.HDCP_I2C_SDA_DRIVE_EN != hdcp_i2c_sda_drive_en) HSLDPF(E_ERROR_MESSAGE,"HDCP_GEN_CNTL::HDCP_I2C_SDA_DRIVE_EN data too large\n");
}
__inline void set_HDCP_GEN_CNTL_hdcp_i2c_time_limit(regHDCP_GEN_CNTL *reg, unsigned int hdcp_i2c_time_limit)
{
  reg->bitfields.HDCP_I2C_TIME_LIMIT = hdcp_i2c_time_limit;
  if (reg->bitfields.HDCP_I2C_TIME_LIMIT != hdcp_i2c_time_limit) HSLDPF(E_ERROR_MESSAGE,"HDCP_GEN_CNTL::HDCP_I2C_TIME_LIMIT data too large\n");
}
__inline void set_HDCP_GEN_CNTL_hdcp_i2c_prescale(regHDCP_GEN_CNTL *reg, unsigned int hdcp_i2c_prescale)
{
  reg->bitfields.HDCP_I2C_PRESCALE = hdcp_i2c_prescale;
  if (reg->bitfields.HDCP_I2C_PRESCALE != hdcp_i2c_prescale) HSLDPF(E_ERROR_MESSAGE,"HDCP_GEN_CNTL::HDCP_I2C_PRESCALE data too large\n");
}
#else
#define set_HDCP_GEN_CNTL_hdcp_authorized_int_stat(reg, hdcp_authorized_int_stat) (reg)->bitfields.HDCP_AUTHORIZED_INT_STAT = hdcp_authorized_int_stat
#define set_HDCP_GEN_CNTL_hdcp_authorized_int_pol(reg, hdcp_authorized_int_pol) (reg)->bitfields.HDCP_AUTHORIZED_INT_POL = hdcp_authorized_int_pol
#define set_HDCP_GEN_CNTL_hdcp_authorized_int_mask(reg, hdcp_authorized_int_mask) (reg)->bitfields.HDCP_AUTHORIZED_INT_MASK = hdcp_authorized_int_mask
#define set_HDCP_GEN_CNTL_hot_plug_affects_hdcp_en(reg, hot_plug_affects_hdcp_en) (reg)->bitfields.HOT_PLUG_AFFECTS_HDCP_EN = hot_plug_affects_hdcp_en
#define set_HDCP_GEN_CNTL_hdcp_authorized(reg, hdcp_authorized) (reg)->bitfields.HDCP_AUTHORIZED = hdcp_authorized
#define set_HDCP_GEN_CNTL_hdcp_reset(reg, hdcp_reset) (reg)->bitfields.HDCP_RESET = hdcp_reset
#define set_HDCP_GEN_CNTL_hdcp_i2c_scl_drive_en(reg, hdcp_i2c_scl_drive_en) (reg)->bitfields.HDCP_I2C_SCL_DRIVE_EN = hdcp_i2c_scl_drive_en
#define set_HDCP_GEN_CNTL_hdcp_i2c_sda_drive_en(reg, hdcp_i2c_sda_drive_en) (reg)->bitfields.HDCP_I2C_SDA_DRIVE_EN = hdcp_i2c_sda_drive_en
#define set_HDCP_GEN_CNTL_hdcp_i2c_time_limit(reg, hdcp_i2c_time_limit) (reg)->bitfields.HDCP_I2C_TIME_LIMIT = hdcp_i2c_time_limit
#define set_HDCP_GEN_CNTL_hdcp_i2c_prescale(reg, hdcp_i2c_prescale) (reg)->bitfields.HDCP_I2C_PRESCALE = hdcp_i2c_prescale

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union HDCP_CONTROL regHDCP_CONTROL;

#ifdef DEBUG
__inline void set_HDCP_CONTROL_hdcp_upstream_address(regHDCP_CONTROL *reg, unsigned int hdcp_upstream_address)
{
  reg->bitfields.HDCP_UPSTREAM_ADDRESS = hdcp_upstream_address;
  if (reg->bitfields.HDCP_UPSTREAM_ADDRESS != hdcp_upstream_address) HSLDPF(E_ERROR_MESSAGE,"HDCP_CONTROL::HDCP_UPSTREAM_ADDRESS data too large\n");
}
#else
#define set_HDCP_CONTROL_hdcp_upstream_address(reg, hdcp_upstream_address) (reg)->bitfields.HDCP_UPSTREAM_ADDRESS = hdcp_upstream_address

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union HDCP_DATA regHDCP_DATA;

#ifdef DEBUG
__inline void set_HDCP_DATA_hdcp_upstream_data(regHDCP_DATA *reg, unsigned int hdcp_upstream_data)
{
  reg->bitfields.HDCP_UPSTREAM_DATA = hdcp_upstream_data;
  if (reg->bitfields.HDCP_UPSTREAM_DATA != hdcp_upstream_data) HSLDPF(E_ERROR_MESSAGE,"HDCP_DATA::HDCP_UPSTREAM_DATA data too large\n");
}
#else
#define set_HDCP_DATA_hdcp_upstream_data(reg, hdcp_upstream_data) (reg)->bitfields.HDCP_UPSTREAM_DATA = hdcp_upstream_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union HDCP_DEBUG regHDCP_DEBUG;

#ifdef DEBUG
__inline void set_HDCP_DEBUG_hdcp_debug_en(regHDCP_DEBUG *reg, unsigned int hdcp_debug_en)
{
  reg->bitfields.HDCP_DEBUG_EN = hdcp_debug_en;
  if (reg->bitfields.HDCP_DEBUG_EN != hdcp_debug_en) HSLDPF(E_ERROR_MESSAGE,"HDCP_DEBUG::HDCP_DEBUG_EN data too large\n");
}
__inline void set_HDCP_DEBUG_i2c_cntl_regs_affect_hdcp_i2c(regHDCP_DEBUG *reg, unsigned int i2c_cntl_regs_affect_hdcp_i2c)
{
  reg->bitfields.I2C_CNTL_REGS_AFFECT_HDCP_I2C = i2c_cntl_regs_affect_hdcp_i2c;
  if (reg->bitfields.I2C_CNTL_REGS_AFFECT_HDCP_I2C != i2c_cntl_regs_affect_hdcp_i2c) HSLDPF(E_ERROR_MESSAGE,"HDCP_DEBUG::I2C_CNTL_REGS_AFFECT_HDCP_I2C data too large\n");
}
__inline void set_HDCP_DEBUG_sw_can_queue_i2c_go(regHDCP_DEBUG *reg, unsigned int sw_can_queue_i2c_go)
{
  reg->bitfields.SW_CAN_QUEUE_I2C_GO = sw_can_queue_i2c_go;
  if (reg->bitfields.SW_CAN_QUEUE_I2C_GO != sw_can_queue_i2c_go) HSLDPF(E_ERROR_MESSAGE,"HDCP_DEBUG::SW_CAN_QUEUE_I2C_GO data too large\n");
}
__inline void set_HDCP_DEBUG_use_hdcp_i2c_short_reads(regHDCP_DEBUG *reg, unsigned int use_hdcp_i2c_short_reads)
{
  reg->bitfields.USE_HDCP_I2C_SHORT_READS = use_hdcp_i2c_short_reads;
  if (reg->bitfields.USE_HDCP_I2C_SHORT_READS != use_hdcp_i2c_short_reads) HSLDPF(E_ERROR_MESSAGE,"HDCP_DEBUG::USE_HDCP_I2C_SHORT_READS data too large\n");
}
__inline void set_HDCP_DEBUG_hdcp_mode(regHDCP_DEBUG *reg, unsigned int hdcp_mode)
{
  reg->bitfields.HDCP_MODE = hdcp_mode;
  if (reg->bitfields.HDCP_MODE != hdcp_mode) HSLDPF(E_ERROR_MESSAGE,"HDCP_DEBUG::HDCP_MODE data too large\n");
}
__inline void set_HDCP_DEBUG_hdcp_hotplug_sel_bypass_en(regHDCP_DEBUG *reg, unsigned int hdcp_hotplug_sel_bypass_en)
{
  reg->bitfields.HDCP_HOTPLUG_SEL_BYPASS_EN = hdcp_hotplug_sel_bypass_en;
  if (reg->bitfields.HDCP_HOTPLUG_SEL_BYPASS_EN != hdcp_hotplug_sel_bypass_en) HSLDPF(E_ERROR_MESSAGE,"HDCP_DEBUG::HDCP_HOTPLUG_SEL_BYPASS_EN data too large\n");
}
__inline void set_HDCP_DEBUG_hdcp_hotplug_select(regHDCP_DEBUG *reg, unsigned int hdcp_hotplug_select)
{
  reg->bitfields.HDCP_HOTPLUG_SELECT = hdcp_hotplug_select;
  if (reg->bitfields.HDCP_HOTPLUG_SELECT != hdcp_hotplug_select) HSLDPF(E_ERROR_MESSAGE,"HDCP_DEBUG::HDCP_HOTPLUG_SELECT data too large\n");
}
__inline void set_HDCP_DEBUG_hdcp_debug_bit7(regHDCP_DEBUG *reg, unsigned int hdcp_debug_bit7)
{
  reg->bitfields.HDCP_DEBUG_BIT7 = hdcp_debug_bit7;
  if (reg->bitfields.HDCP_DEBUG_BIT7 != hdcp_debug_bit7) HSLDPF(E_ERROR_MESSAGE,"HDCP_DEBUG::HDCP_DEBUG_BIT7 data too large\n");
}
__inline void set_HDCP_DEBUG_hdcp_debug_addr(regHDCP_DEBUG *reg, unsigned int hdcp_debug_addr)
{
  reg->bitfields.HDCP_DEBUG_ADDR = hdcp_debug_addr;
  if (reg->bitfields.HDCP_DEBUG_ADDR != hdcp_debug_addr) HSLDPF(E_ERROR_MESSAGE,"HDCP_DEBUG::HDCP_DEBUG_ADDR data too large\n");
}
__inline void set_HDCP_DEBUG_hdcp_debug_data(regHDCP_DEBUG *reg, unsigned int hdcp_debug_data)
{
  reg->bitfields.HDCP_DEBUG_DATA = hdcp_debug_data;
  if (reg->bitfields.HDCP_DEBUG_DATA != hdcp_debug_data) HSLDPF(E_ERROR_MESSAGE,"HDCP_DEBUG::HDCP_DEBUG_DATA data too large\n");
}
#else
#define set_HDCP_DEBUG_hdcp_debug_en(reg, hdcp_debug_en) (reg)->bitfields.HDCP_DEBUG_EN = hdcp_debug_en
#define set_HDCP_DEBUG_i2c_cntl_regs_affect_hdcp_i2c(reg, i2c_cntl_regs_affect_hdcp_i2c) (reg)->bitfields.I2C_CNTL_REGS_AFFECT_HDCP_I2C = i2c_cntl_regs_affect_hdcp_i2c
#define set_HDCP_DEBUG_sw_can_queue_i2c_go(reg, sw_can_queue_i2c_go) (reg)->bitfields.SW_CAN_QUEUE_I2C_GO = sw_can_queue_i2c_go
#define set_HDCP_DEBUG_use_hdcp_i2c_short_reads(reg, use_hdcp_i2c_short_reads) (reg)->bitfields.USE_HDCP_I2C_SHORT_READS = use_hdcp_i2c_short_reads
#define set_HDCP_DEBUG_hdcp_mode(reg, hdcp_mode) (reg)->bitfields.HDCP_MODE = hdcp_mode
#define set_HDCP_DEBUG_hdcp_hotplug_sel_bypass_en(reg, hdcp_hotplug_sel_bypass_en) (reg)->bitfields.HDCP_HOTPLUG_SEL_BYPASS_EN = hdcp_hotplug_sel_bypass_en
#define set_HDCP_DEBUG_hdcp_hotplug_select(reg, hdcp_hotplug_select) (reg)->bitfields.HDCP_HOTPLUG_SELECT = hdcp_hotplug_select
#define set_HDCP_DEBUG_hdcp_debug_bit7(reg, hdcp_debug_bit7) (reg)->bitfields.HDCP_DEBUG_BIT7 = hdcp_debug_bit7
#define set_HDCP_DEBUG_hdcp_debug_addr(reg, hdcp_debug_addr) (reg)->bitfields.HDCP_DEBUG_ADDR = hdcp_debug_addr
#define set_HDCP_DEBUG_hdcp_debug_data(reg, hdcp_debug_data) (reg)->bitfields.HDCP_DEBUG_DATA = hdcp_debug_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CLOCK_CNTL_INDEX_M6 regCLOCK_CNTL_INDEX_M6;

#ifdef DEBUG
__inline void set_CLOCK_CNTL_INDEX_M6_pll_addr(regCLOCK_CNTL_INDEX_M6 *reg, unsigned int pll_addr)
{
  reg->bitfields.PLL_ADDR = pll_addr;
  if (reg->bitfields.PLL_ADDR != pll_addr) HSLDPF(E_ERROR_MESSAGE,"CLOCK_CNTL_INDEX_M6::PLL_ADDR data too large\n");
}
__inline void set_CLOCK_CNTL_INDEX_M6_pll_wr_en(regCLOCK_CNTL_INDEX_M6 *reg, unsigned int pll_wr_en)
{
  reg->bitfields.PLL_WR_EN = pll_wr_en;
  if (reg->bitfields.PLL_WR_EN != pll_wr_en) HSLDPF(E_ERROR_MESSAGE,"CLOCK_CNTL_INDEX_M6::PLL_WR_EN data too large\n");
}
__inline void set_CLOCK_CNTL_INDEX_M6_ppll_div_sel(regCLOCK_CNTL_INDEX_M6 *reg, unsigned int ppll_div_sel)
{
  reg->bitfields.PPLL_DIV_SEL = ppll_div_sel;
  if (reg->bitfields.PPLL_DIV_SEL != ppll_div_sel) HSLDPF(E_ERROR_MESSAGE,"CLOCK_CNTL_INDEX_M6::PPLL_DIV_SEL data too large\n");
}
#else
#define set_CLOCK_CNTL_INDEX_M6_pll_addr(reg, pll_addr) (reg)->bitfields.PLL_ADDR = pll_addr
#define set_CLOCK_CNTL_INDEX_M6_pll_wr_en(reg, pll_wr_en) (reg)->bitfields.PLL_WR_EN = pll_wr_en
#define set_CLOCK_CNTL_INDEX_M6_ppll_div_sel(reg, ppll_div_sel) (reg)->bitfields.PPLL_DIV_SEL = ppll_div_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CLOCK_CNTL_DATA regCLOCK_CNTL_DATA;

#ifdef DEBUG
__inline void set_CLOCK_CNTL_DATA_pll_data(regCLOCK_CNTL_DATA *reg, unsigned int pll_data)
{
  reg->bitfields.PLL_DATA = pll_data;
  if (reg->bitfields.PLL_DATA != pll_data) HSLDPF(E_ERROR_MESSAGE,"CLOCK_CNTL_DATA::PLL_DATA data too large\n");
}
#else
#define set_CLOCK_CNTL_DATA_pll_data(reg, pll_data) (reg)->bitfields.PLL_DATA = pll_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PPLL_DIV_0 regPPLL_DIV_0;

#ifdef DEBUG
__inline void set_PPLL_DIV_0_ppll_fb0_div(regPPLL_DIV_0 *reg, unsigned int ppll_fb0_div)
{
  reg->bitfields.PPLL_FB0_DIV = ppll_fb0_div;
  if (reg->bitfields.PPLL_FB0_DIV != ppll_fb0_div) HSLDPF(E_ERROR_MESSAGE,"PPLL_DIV_0::PPLL_FB0_DIV data too large\n");
}
__inline void set_PPLL_DIV_0_ppll_atomic_update_w(regPPLL_DIV_0 *reg, unsigned int ppll_atomic_update_w)
{
  reg->bitfields.PPLL_ATOMIC_UPDATE_W = ppll_atomic_update_w;
  if (reg->bitfields.PPLL_ATOMIC_UPDATE_W != ppll_atomic_update_w) HSLDPF(E_ERROR_MESSAGE,"PPLL_DIV_0::PPLL_ATOMIC_UPDATE_W data too large\n");
}
__inline void set_PPLL_DIV_0_ppll_post0_div(regPPLL_DIV_0 *reg, unsigned int ppll_post0_div)
{
  reg->bitfields.PPLL_POST0_DIV = ppll_post0_div;
  if (reg->bitfields.PPLL_POST0_DIV != ppll_post0_div) HSLDPF(E_ERROR_MESSAGE,"PPLL_DIV_0::PPLL_POST0_DIV data too large\n");
}
#else
#define set_PPLL_DIV_0_ppll_fb0_div(reg, ppll_fb0_div) (reg)->bitfields.PPLL_FB0_DIV = ppll_fb0_div
#define set_PPLL_DIV_0_ppll_atomic_update_w(reg, ppll_atomic_update_w) (reg)->bitfields.PPLL_ATOMIC_UPDATE_W = ppll_atomic_update_w
#define set_PPLL_DIV_0_ppll_post0_div(reg, ppll_post0_div) (reg)->bitfields.PPLL_POST0_DIV = ppll_post0_div

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PPLL_DIV_1 regPPLL_DIV_1;

#ifdef DEBUG
__inline void set_PPLL_DIV_1_ppll_fb1_div(regPPLL_DIV_1 *reg, unsigned int ppll_fb1_div)
{
  reg->bitfields.PPLL_FB1_DIV = ppll_fb1_div;
  if (reg->bitfields.PPLL_FB1_DIV != ppll_fb1_div) HSLDPF(E_ERROR_MESSAGE,"PPLL_DIV_1::PPLL_FB1_DIV data too large\n");
}
__inline void set_PPLL_DIV_1_ppll_atomic_update_w(regPPLL_DIV_1 *reg, unsigned int ppll_atomic_update_w)
{
  reg->bitfields.PPLL_ATOMIC_UPDATE_W = ppll_atomic_update_w;
  if (reg->bitfields.PPLL_ATOMIC_UPDATE_W != ppll_atomic_update_w) HSLDPF(E_ERROR_MESSAGE,"PPLL_DIV_1::PPLL_ATOMIC_UPDATE_W data too large\n");
}
__inline void set_PPLL_DIV_1_ppll_post1_div(regPPLL_DIV_1 *reg, unsigned int ppll_post1_div)
{
  reg->bitfields.PPLL_POST1_DIV = ppll_post1_div;
  if (reg->bitfields.PPLL_POST1_DIV != ppll_post1_div) HSLDPF(E_ERROR_MESSAGE,"PPLL_DIV_1::PPLL_POST1_DIV data too large\n");
}
#else
#define set_PPLL_DIV_1_ppll_fb1_div(reg, ppll_fb1_div) (reg)->bitfields.PPLL_FB1_DIV = ppll_fb1_div
#define set_PPLL_DIV_1_ppll_atomic_update_w(reg, ppll_atomic_update_w) (reg)->bitfields.PPLL_ATOMIC_UPDATE_W = ppll_atomic_update_w
#define set_PPLL_DIV_1_ppll_post1_div(reg, ppll_post1_div) (reg)->bitfields.PPLL_POST1_DIV = ppll_post1_div

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PPLL_DIV_2 regPPLL_DIV_2;

#ifdef DEBUG
__inline void set_PPLL_DIV_2_ppll_fb2_div(regPPLL_DIV_2 *reg, unsigned int ppll_fb2_div)
{
  reg->bitfields.PPLL_FB2_DIV = ppll_fb2_div;
  if (reg->bitfields.PPLL_FB2_DIV != ppll_fb2_div) HSLDPF(E_ERROR_MESSAGE,"PPLL_DIV_2::PPLL_FB2_DIV data too large\n");
}
__inline void set_PPLL_DIV_2_ppll_atomic_update_w(regPPLL_DIV_2 *reg, unsigned int ppll_atomic_update_w)
{
  reg->bitfields.PPLL_ATOMIC_UPDATE_W = ppll_atomic_update_w;
  if (reg->bitfields.PPLL_ATOMIC_UPDATE_W != ppll_atomic_update_w) HSLDPF(E_ERROR_MESSAGE,"PPLL_DIV_2::PPLL_ATOMIC_UPDATE_W data too large\n");
}
__inline void set_PPLL_DIV_2_ppll_post2_div(regPPLL_DIV_2 *reg, unsigned int ppll_post2_div)
{
  reg->bitfields.PPLL_POST2_DIV = ppll_post2_div;
  if (reg->bitfields.PPLL_POST2_DIV != ppll_post2_div) HSLDPF(E_ERROR_MESSAGE,"PPLL_DIV_2::PPLL_POST2_DIV data too large\n");
}
#else
#define set_PPLL_DIV_2_ppll_fb2_div(reg, ppll_fb2_div) (reg)->bitfields.PPLL_FB2_DIV = ppll_fb2_div
#define set_PPLL_DIV_2_ppll_atomic_update_w(reg, ppll_atomic_update_w) (reg)->bitfields.PPLL_ATOMIC_UPDATE_W = ppll_atomic_update_w
#define set_PPLL_DIV_2_ppll_post2_div(reg, ppll_post2_div) (reg)->bitfields.PPLL_POST2_DIV = ppll_post2_div

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PPLL_DIV_3 regPPLL_DIV_3;

#ifdef DEBUG
__inline void set_PPLL_DIV_3_ppll_fb3_div(regPPLL_DIV_3 *reg, unsigned int ppll_fb3_div)
{
  reg->bitfields.PPLL_FB3_DIV = ppll_fb3_div;
  if (reg->bitfields.PPLL_FB3_DIV != ppll_fb3_div) HSLDPF(E_ERROR_MESSAGE,"PPLL_DIV_3::PPLL_FB3_DIV data too large\n");
}
__inline void set_PPLL_DIV_3_ppll_atomic_update_w(regPPLL_DIV_3 *reg, unsigned int ppll_atomic_update_w)
{
  reg->bitfields.PPLL_ATOMIC_UPDATE_W = ppll_atomic_update_w;
  if (reg->bitfields.PPLL_ATOMIC_UPDATE_W != ppll_atomic_update_w) HSLDPF(E_ERROR_MESSAGE,"PPLL_DIV_3::PPLL_ATOMIC_UPDATE_W data too large\n");
}
__inline void set_PPLL_DIV_3_ppll_post3_div(regPPLL_DIV_3 *reg, unsigned int ppll_post3_div)
{
  reg->bitfields.PPLL_POST3_DIV = ppll_post3_div;
  if (reg->bitfields.PPLL_POST3_DIV != ppll_post3_div) HSLDPF(E_ERROR_MESSAGE,"PPLL_DIV_3::PPLL_POST3_DIV data too large\n");
}
#else
#define set_PPLL_DIV_3_ppll_fb3_div(reg, ppll_fb3_div) (reg)->bitfields.PPLL_FB3_DIV = ppll_fb3_div
#define set_PPLL_DIV_3_ppll_atomic_update_w(reg, ppll_atomic_update_w) (reg)->bitfields.PPLL_ATOMIC_UPDATE_W = ppll_atomic_update_w
#define set_PPLL_DIV_3_ppll_post3_div(reg, ppll_post3_div) (reg)->bitfields.PPLL_POST3_DIV = ppll_post3_div

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union HTOTAL_CNTL regHTOTAL_CNTL;

#ifdef DEBUG
__inline void set_HTOTAL_CNTL_htot_pix_slip(regHTOTAL_CNTL *reg, unsigned int htot_pix_slip)
{
  reg->bitfields.HTOT_PIX_SLIP = htot_pix_slip;
  if (reg->bitfields.HTOT_PIX_SLIP != htot_pix_slip) HSLDPF(E_ERROR_MESSAGE,"HTOTAL_CNTL::HTOT_PIX_SLIP data too large\n");
}
__inline void set_HTOTAL_CNTL_htot_vclk_slip(regHTOTAL_CNTL *reg, unsigned int htot_vclk_slip)
{
  reg->bitfields.HTOT_VCLK_SLIP = htot_vclk_slip;
  if (reg->bitfields.HTOT_VCLK_SLIP != htot_vclk_slip) HSLDPF(E_ERROR_MESSAGE,"HTOTAL_CNTL::HTOT_VCLK_SLIP data too large\n");
}
__inline void set_HTOTAL_CNTL_htot_ppll_slip(regHTOTAL_CNTL *reg, unsigned int htot_ppll_slip)
{
  reg->bitfields.HTOT_PPLL_SLIP = htot_ppll_slip;
  if (reg->bitfields.HTOT_PPLL_SLIP != htot_ppll_slip) HSLDPF(E_ERROR_MESSAGE,"HTOTAL_CNTL::HTOT_PPLL_SLIP data too large\n");
}
__inline void set_HTOTAL_CNTL_htot_cntl_edge(regHTOTAL_CNTL *reg, unsigned int htot_cntl_edge)
{
  reg->bitfields.HTOT_CNTL_EDGE = htot_cntl_edge;
  if (reg->bitfields.HTOT_CNTL_EDGE != htot_cntl_edge) HSLDPF(E_ERROR_MESSAGE,"HTOTAL_CNTL::HTOT_CNTL_EDGE data too large\n");
}
__inline void set_HTOTAL_CNTL_htot_cntl_vga_en(regHTOTAL_CNTL *reg, unsigned int htot_cntl_vga_en)
{
  reg->bitfields.HTOT_CNTL_VGA_EN = htot_cntl_vga_en;
  if (reg->bitfields.HTOT_CNTL_VGA_EN != htot_cntl_vga_en) HSLDPF(E_ERROR_MESSAGE,"HTOTAL_CNTL::HTOT_CNTL_VGA_EN data too large\n");
}
#else
#define set_HTOTAL_CNTL_htot_pix_slip(reg, htot_pix_slip) (reg)->bitfields.HTOT_PIX_SLIP = htot_pix_slip
#define set_HTOTAL_CNTL_htot_vclk_slip(reg, htot_vclk_slip) (reg)->bitfields.HTOT_VCLK_SLIP = htot_vclk_slip
#define set_HTOTAL_CNTL_htot_ppll_slip(reg, htot_ppll_slip) (reg)->bitfields.HTOT_PPLL_SLIP = htot_ppll_slip
#define set_HTOTAL_CNTL_htot_cntl_edge(reg, htot_cntl_edge) (reg)->bitfields.HTOT_CNTL_EDGE = htot_cntl_edge
#define set_HTOTAL_CNTL_htot_cntl_vga_en(reg, htot_cntl_vga_en) (reg)->bitfields.HTOT_CNTL_VGA_EN = htot_cntl_vga_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PLL_TEST_CNTL_M6 regPLL_TEST_CNTL_M6;

#ifdef DEBUG
__inline void set_PLL_TEST_CNTL_M6_tst_src_sel(regPLL_TEST_CNTL_M6 *reg, unsigned int tst_src_sel)
{
  reg->bitfields.TST_SRC_SEL = tst_src_sel;
  if (reg->bitfields.TST_SRC_SEL != tst_src_sel) HSLDPF(E_ERROR_MESSAGE,"PLL_TEST_CNTL_M6::TST_SRC_SEL data too large\n");
}
__inline void set_PLL_TEST_CNTL_M6_tst_src_inv(regPLL_TEST_CNTL_M6 *reg, unsigned int tst_src_inv)
{
  reg->bitfields.TST_SRC_INV = tst_src_inv;
  if (reg->bitfields.TST_SRC_INV != tst_src_inv) HSLDPF(E_ERROR_MESSAGE,"PLL_TEST_CNTL_M6::TST_SRC_INV data too large\n");
}
__inline void set_PLL_TEST_CNTL_M6_tst_dividers(regPLL_TEST_CNTL_M6 *reg, unsigned int tst_dividers)
{
  reg->bitfields.TST_DIVIDERS = tst_dividers;
  if (reg->bitfields.TST_DIVIDERS != tst_dividers) HSLDPF(E_ERROR_MESSAGE,"PLL_TEST_CNTL_M6::TST_DIVIDERS data too large\n");
}
__inline void set_PLL_TEST_CNTL_M6_pll_mask_read_b(regPLL_TEST_CNTL_M6 *reg, unsigned int pll_mask_read_b)
{
  reg->bitfields.PLL_MASK_READ_B = pll_mask_read_b;
  if (reg->bitfields.PLL_MASK_READ_B != pll_mask_read_b) HSLDPF(E_ERROR_MESSAGE,"PLL_TEST_CNTL_M6::PLL_MASK_READ_B data too large\n");
}
__inline void set_PLL_TEST_CNTL_M6_testclk_mux_sel(regPLL_TEST_CNTL_M6 *reg, unsigned int testclk_mux_sel)
{
  reg->bitfields.TESTCLK_MUX_SEL = testclk_mux_sel;
  if (reg->bitfields.TESTCLK_MUX_SEL != testclk_mux_sel) HSLDPF(E_ERROR_MESSAGE,"PLL_TEST_CNTL_M6::TESTCLK_MUX_SEL data too large\n");
}
__inline void set_PLL_TEST_CNTL_M6_analog_mon(regPLL_TEST_CNTL_M6 *reg, unsigned int analog_mon)
{
  reg->bitfields.ANALOG_MON = analog_mon;
  if (reg->bitfields.ANALOG_MON != analog_mon) HSLDPF(E_ERROR_MESSAGE,"PLL_TEST_CNTL_M6::ANALOG_MON data too large\n");
}
__inline void set_PLL_TEST_CNTL_M6_test_count(regPLL_TEST_CNTL_M6 *reg, unsigned int test_count)
{
  reg->bitfields.TEST_COUNT = test_count;
  if (reg->bitfields.TEST_COUNT != test_count) HSLDPF(E_ERROR_MESSAGE,"PLL_TEST_CNTL_M6::TEST_COUNT data too large\n");
}
#else
#define set_PLL_TEST_CNTL_M6_tst_src_sel(reg, tst_src_sel) (reg)->bitfields.TST_SRC_SEL = tst_src_sel
#define set_PLL_TEST_CNTL_M6_tst_src_inv(reg, tst_src_inv) (reg)->bitfields.TST_SRC_INV = tst_src_inv
#define set_PLL_TEST_CNTL_M6_tst_dividers(reg, tst_dividers) (reg)->bitfields.TST_DIVIDERS = tst_dividers
#define set_PLL_TEST_CNTL_M6_pll_mask_read_b(reg, pll_mask_read_b) (reg)->bitfields.PLL_MASK_READ_B = pll_mask_read_b
#define set_PLL_TEST_CNTL_M6_testclk_mux_sel(reg, testclk_mux_sel) (reg)->bitfields.TESTCLK_MUX_SEL = testclk_mux_sel
#define set_PLL_TEST_CNTL_M6_analog_mon(reg, analog_mon) (reg)->bitfields.ANALOG_MON = analog_mon
#define set_PLL_TEST_CNTL_M6_test_count(reg, test_count) (reg)->bitfields.TEST_COUNT = test_count

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union P2PLL_DIV_0 regP2PLL_DIV_0;

#ifdef DEBUG
__inline void set_P2PLL_DIV_0_p2pll_fb_div(regP2PLL_DIV_0 *reg, unsigned int p2pll_fb_div)
{
  reg->bitfields.P2PLL_FB_DIV = p2pll_fb_div;
  if (reg->bitfields.P2PLL_FB_DIV != p2pll_fb_div) HSLDPF(E_ERROR_MESSAGE,"P2PLL_DIV_0::P2PLL_FB_DIV data too large\n");
}
__inline void set_P2PLL_DIV_0_p2pll_atomic_update_w(regP2PLL_DIV_0 *reg, unsigned int p2pll_atomic_update_w)
{
  reg->bitfields.P2PLL_ATOMIC_UPDATE_W = p2pll_atomic_update_w;
  if (reg->bitfields.P2PLL_ATOMIC_UPDATE_W != p2pll_atomic_update_w) HSLDPF(E_ERROR_MESSAGE,"P2PLL_DIV_0::P2PLL_ATOMIC_UPDATE_W data too large\n");
}
__inline void set_P2PLL_DIV_0_p2pll_post_div(regP2PLL_DIV_0 *reg, unsigned int p2pll_post_div)
{
  reg->bitfields.P2PLL_POST_DIV = p2pll_post_div;
  if (reg->bitfields.P2PLL_POST_DIV != p2pll_post_div) HSLDPF(E_ERROR_MESSAGE,"P2PLL_DIV_0::P2PLL_POST_DIV data too large\n");
}
#else
#define set_P2PLL_DIV_0_p2pll_fb_div(reg, p2pll_fb_div) (reg)->bitfields.P2PLL_FB_DIV = p2pll_fb_div
#define set_P2PLL_DIV_0_p2pll_atomic_update_w(reg, p2pll_atomic_update_w) (reg)->bitfields.P2PLL_ATOMIC_UPDATE_W = p2pll_atomic_update_w
#define set_P2PLL_DIV_0_p2pll_post_div(reg, p2pll_post_div) (reg)->bitfields.P2PLL_POST_DIV = p2pll_post_div

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union HTOTAL2_CNTL regHTOTAL2_CNTL;

#ifdef DEBUG
__inline void set_HTOTAL2_CNTL_htot2_pix_slip(regHTOTAL2_CNTL *reg, unsigned int htot2_pix_slip)
{
  reg->bitfields.HTOT2_PIX_SLIP = htot2_pix_slip;
  if (reg->bitfields.HTOT2_PIX_SLIP != htot2_pix_slip) HSLDPF(E_ERROR_MESSAGE,"HTOTAL2_CNTL::HTOT2_PIX_SLIP data too large\n");
}
__inline void set_HTOTAL2_CNTL_htot2_pix2clk_slip(regHTOTAL2_CNTL *reg, unsigned int htot2_pix2clk_slip)
{
  reg->bitfields.HTOT2_PIX2CLK_SLIP = htot2_pix2clk_slip;
  if (reg->bitfields.HTOT2_PIX2CLK_SLIP != htot2_pix2clk_slip) HSLDPF(E_ERROR_MESSAGE,"HTOTAL2_CNTL::HTOT2_PIX2CLK_SLIP data too large\n");
}
__inline void set_HTOTAL2_CNTL_htot2_p2pll_slip(regHTOTAL2_CNTL *reg, unsigned int htot2_p2pll_slip)
{
  reg->bitfields.HTOT2_P2PLL_SLIP = htot2_p2pll_slip;
  if (reg->bitfields.HTOT2_P2PLL_SLIP != htot2_p2pll_slip) HSLDPF(E_ERROR_MESSAGE,"HTOTAL2_CNTL::HTOT2_P2PLL_SLIP data too large\n");
}
__inline void set_HTOTAL2_CNTL_htot2_cntl_edge(regHTOTAL2_CNTL *reg, unsigned int htot2_cntl_edge)
{
  reg->bitfields.HTOT2_CNTL_EDGE = htot2_cntl_edge;
  if (reg->bitfields.HTOT2_CNTL_EDGE != htot2_cntl_edge) HSLDPF(E_ERROR_MESSAGE,"HTOTAL2_CNTL::HTOT2_CNTL_EDGE data too large\n");
}
__inline void set_HTOTAL2_CNTL_htot2_cntl_update(regHTOTAL2_CNTL *reg, unsigned int htot2_cntl_update)
{
  reg->bitfields.HTOT2_CNTL_UPDATE = htot2_cntl_update;
  if (reg->bitfields.HTOT2_CNTL_UPDATE != htot2_cntl_update) HSLDPF(E_ERROR_MESSAGE,"HTOTAL2_CNTL::HTOT2_CNTL_UPDATE data too large\n");
}
#else
#define set_HTOTAL2_CNTL_htot2_pix_slip(reg, htot2_pix_slip) (reg)->bitfields.HTOT2_PIX_SLIP = htot2_pix_slip
#define set_HTOTAL2_CNTL_htot2_pix2clk_slip(reg, htot2_pix2clk_slip) (reg)->bitfields.HTOT2_PIX2CLK_SLIP = htot2_pix2clk_slip
#define set_HTOTAL2_CNTL_htot2_p2pll_slip(reg, htot2_p2pll_slip) (reg)->bitfields.HTOT2_P2PLL_SLIP = htot2_p2pll_slip
#define set_HTOTAL2_CNTL_htot2_cntl_edge(reg, htot2_cntl_edge) (reg)->bitfields.HTOT2_CNTL_EDGE = htot2_cntl_edge
#define set_HTOTAL2_CNTL_htot2_cntl_update(reg, htot2_cntl_update) (reg)->bitfields.HTOT2_CNTL_UPDATE = htot2_cntl_update

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250DAC_CNTL2 regrv250DAC_CNTL2;

#ifdef DEBUG
__inline void set_rv250DAC_CNTL2_dac_clk_sel(regrv250DAC_CNTL2 *reg, unsigned int dac_clk_sel)
{
  reg->bitfields.DAC_CLK_SEL = dac_clk_sel;
  if (reg->bitfields.DAC_CLK_SEL != dac_clk_sel) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL2::DAC_CLK_SEL data too large\n");
}
__inline void set_rv250DAC_CNTL2_dac2_clk_sel(regrv250DAC_CNTL2 *reg, unsigned int dac2_clk_sel)
{
  reg->bitfields.DAC2_CLK_SEL = dac2_clk_sel;
  if (reg->bitfields.DAC2_CLK_SEL != dac2_clk_sel) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL2::DAC2_CLK_SEL data too large\n");
}
__inline void set_rv250DAC_CNTL2_palette_access_cntl(regrv250DAC_CNTL2 *reg, unsigned int palette_access_cntl)
{
  reg->bitfields.PALETTE_ACCESS_CNTL = palette_access_cntl;
  if (reg->bitfields.PALETTE_ACCESS_CNTL != palette_access_cntl) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL2::PALETTE_ACCESS_CNTL data too large\n");
}
__inline void set_rv250DAC_CNTL2_dac2_cmp_en(regrv250DAC_CNTL2 *reg, unsigned int dac2_cmp_en)
{
  reg->bitfields.DAC2_CMP_EN = dac2_cmp_en;
  if (reg->bitfields.DAC2_CMP_EN != dac2_cmp_en) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL2::DAC2_CMP_EN data too large\n");
}
__inline void set_rv250DAC_CNTL2_dac2_cmp_out_r(regrv250DAC_CNTL2 *reg, unsigned int dac2_cmp_out_r)
{
  reg->bitfields.DAC2_CMP_OUT_R = dac2_cmp_out_r;
  if (reg->bitfields.DAC2_CMP_OUT_R != dac2_cmp_out_r) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL2::DAC2_CMP_OUT_R data too large\n");
}
__inline void set_rv250DAC_CNTL2_dac2_cmp_out_g(regrv250DAC_CNTL2 *reg, unsigned int dac2_cmp_out_g)
{
  reg->bitfields.DAC2_CMP_OUT_G = dac2_cmp_out_g;
  if (reg->bitfields.DAC2_CMP_OUT_G != dac2_cmp_out_g) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL2::DAC2_CMP_OUT_G data too large\n");
}
__inline void set_rv250DAC_CNTL2_dac2_cmp_out_b(regrv250DAC_CNTL2 *reg, unsigned int dac2_cmp_out_b)
{
  reg->bitfields.DAC2_CMP_OUT_B = dac2_cmp_out_b;
  if (reg->bitfields.DAC2_CMP_OUT_B != dac2_cmp_out_b) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL2::DAC2_CMP_OUT_B data too large\n");
}
__inline void set_rv250DAC_CNTL2_dac2_cmp_output(regrv250DAC_CNTL2 *reg, unsigned int dac2_cmp_output)
{
  reg->bitfields.DAC2_CMP_OUTPUT = dac2_cmp_output;
  if (reg->bitfields.DAC2_CMP_OUTPUT != dac2_cmp_output) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL2::DAC2_CMP_OUTPUT data too large\n");
}
__inline void set_rv250DAC_CNTL2_dac2_expand_mode(regrv250DAC_CNTL2 *reg, unsigned int dac2_expand_mode)
{
  reg->bitfields.DAC2_EXPAND_MODE = dac2_expand_mode;
  if (reg->bitfields.DAC2_EXPAND_MODE != dac2_expand_mode) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL2::DAC2_EXPAND_MODE data too large\n");
}
__inline void set_rv250DAC_CNTL2_crt2_sense(regrv250DAC_CNTL2 *reg, unsigned int crt2_sense)
{
  reg->bitfields.CRT2_SENSE = crt2_sense;
  if (reg->bitfields.CRT2_SENSE != crt2_sense) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL2::CRT2_SENSE data too large\n");
}
__inline void set_rv250DAC_CNTL2_crt2_detection_on(regrv250DAC_CNTL2 *reg, unsigned int crt2_detection_on)
{
  reg->bitfields.CRT2_DETECTION_ON = crt2_detection_on;
  if (reg->bitfields.CRT2_DETECTION_ON != crt2_detection_on) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL2::CRT2_DETECTION_ON data too large\n");
}
__inline void set_rv250DAC_CNTL2_dac_crc2_cont_en(regrv250DAC_CNTL2 *reg, unsigned int dac_crc2_cont_en)
{
  reg->bitfields.DAC_CRC2_CONT_EN = dac_crc2_cont_en;
  if (reg->bitfields.DAC_CRC2_CONT_EN != dac_crc2_cont_en) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL2::DAC_CRC2_CONT_EN data too large\n");
}
__inline void set_rv250DAC_CNTL2_dac_crc2_en(regrv250DAC_CNTL2 *reg, unsigned int dac_crc2_en)
{
  reg->bitfields.DAC_CRC2_EN = dac_crc2_en;
  if (reg->bitfields.DAC_CRC2_EN != dac_crc2_en) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL2::DAC_CRC2_EN data too large\n");
}
__inline void set_rv250DAC_CNTL2_dac_crc2_field(regrv250DAC_CNTL2 *reg, unsigned int dac_crc2_field)
{
  reg->bitfields.DAC_CRC2_FIELD = dac_crc2_field;
  if (reg->bitfields.DAC_CRC2_FIELD != dac_crc2_field) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL2::DAC_CRC2_FIELD data too large\n");
}
__inline void set_rv250DAC_CNTL2_dac2_lut_counter_limit(regrv250DAC_CNTL2 *reg, unsigned int dac2_lut_counter_limit)
{
  reg->bitfields.DAC2_LUT_COUNTER_LIMIT = dac2_lut_counter_limit;
  if (reg->bitfields.DAC2_LUT_COUNTER_LIMIT != dac2_lut_counter_limit) HSLDPF(E_ERROR_MESSAGE,"rv250DAC_CNTL2::DAC2_LUT_COUNTER_LIMIT data too large\n");
}
#else
#define set_rv250DAC_CNTL2_dac_clk_sel(reg, dac_clk_sel) (reg)->bitfields.DAC_CLK_SEL = dac_clk_sel
#define set_rv250DAC_CNTL2_dac2_clk_sel(reg, dac2_clk_sel) (reg)->bitfields.DAC2_CLK_SEL = dac2_clk_sel
#define set_rv250DAC_CNTL2_palette_access_cntl(reg, palette_access_cntl) (reg)->bitfields.PALETTE_ACCESS_CNTL = palette_access_cntl
#define set_rv250DAC_CNTL2_dac2_cmp_en(reg, dac2_cmp_en) (reg)->bitfields.DAC2_CMP_EN = dac2_cmp_en
#define set_rv250DAC_CNTL2_dac2_cmp_out_r(reg, dac2_cmp_out_r) (reg)->bitfields.DAC2_CMP_OUT_R = dac2_cmp_out_r
#define set_rv250DAC_CNTL2_dac2_cmp_out_g(reg, dac2_cmp_out_g) (reg)->bitfields.DAC2_CMP_OUT_G = dac2_cmp_out_g
#define set_rv250DAC_CNTL2_dac2_cmp_out_b(reg, dac2_cmp_out_b) (reg)->bitfields.DAC2_CMP_OUT_B = dac2_cmp_out_b
#define set_rv250DAC_CNTL2_dac2_cmp_output(reg, dac2_cmp_output) (reg)->bitfields.DAC2_CMP_OUTPUT = dac2_cmp_output
#define set_rv250DAC_CNTL2_dac2_expand_mode(reg, dac2_expand_mode) (reg)->bitfields.DAC2_EXPAND_MODE = dac2_expand_mode
#define set_rv250DAC_CNTL2_crt2_sense(reg, crt2_sense) (reg)->bitfields.CRT2_SENSE = crt2_sense
#define set_rv250DAC_CNTL2_crt2_detection_on(reg, crt2_detection_on) (reg)->bitfields.CRT2_DETECTION_ON = crt2_detection_on
#define set_rv250DAC_CNTL2_dac_crc2_cont_en(reg, dac_crc2_cont_en) (reg)->bitfields.DAC_CRC2_CONT_EN = dac_crc2_cont_en
#define set_rv250DAC_CNTL2_dac_crc2_en(reg, dac_crc2_en) (reg)->bitfields.DAC_CRC2_EN = dac_crc2_en
#define set_rv250DAC_CNTL2_dac_crc2_field(reg, dac_crc2_field) (reg)->bitfields.DAC_CRC2_FIELD = dac_crc2_field
#define set_rv250DAC_CNTL2_dac2_lut_counter_limit(reg, dac2_lut_counter_limit) (reg)->bitfields.DAC2_LUT_COUNTER_LIMIT = dac2_lut_counter_limit

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_MASTER_CNTL regTV_MASTER_CNTL;

#ifdef DEBUG
__inline void set_TV_MASTER_CNTL_tv_async_rst(regTV_MASTER_CNTL *reg, unsigned int tv_async_rst)
{
  reg->bitfields.TV_ASYNC_RST = tv_async_rst;
  if (reg->bitfields.TV_ASYNC_RST != tv_async_rst) HSLDPF(E_ERROR_MESSAGE,"TV_MASTER_CNTL::TV_ASYNC_RST data too large\n");
}
__inline void set_TV_MASTER_CNTL_crt_async_rst(regTV_MASTER_CNTL *reg, unsigned int crt_async_rst)
{
  reg->bitfields.CRT_ASYNC_RST = crt_async_rst;
  if (reg->bitfields.CRT_ASYNC_RST != crt_async_rst) HSLDPF(E_ERROR_MESSAGE,"TV_MASTER_CNTL::CRT_ASYNC_RST data too large\n");
}
__inline void set_TV_MASTER_CNTL_restart_phase_fix(regTV_MASTER_CNTL *reg, unsigned int restart_phase_fix)
{
  reg->bitfields.RESTART_PHASE_FIX = restart_phase_fix;
  if (reg->bitfields.RESTART_PHASE_FIX != restart_phase_fix) HSLDPF(E_ERROR_MESSAGE,"TV_MASTER_CNTL::RESTART_PHASE_FIX data too large\n");
}
__inline void set_TV_MASTER_CNTL_tv_fifo_async_rst(regTV_MASTER_CNTL *reg, unsigned int tv_fifo_async_rst)
{
  reg->bitfields.TV_FIFO_ASYNC_RST = tv_fifo_async_rst;
  if (reg->bitfields.TV_FIFO_ASYNC_RST != tv_fifo_async_rst) HSLDPF(E_ERROR_MESSAGE,"TV_MASTER_CNTL::TV_FIFO_ASYNC_RST data too large\n");
}
__inline void set_TV_MASTER_CNTL_mv_bp_level_fix_en(regTV_MASTER_CNTL *reg, unsigned int mv_bp_level_fix_en)
{
  reg->bitfields.MV_BP_LEVEL_FIX_EN = mv_bp_level_fix_en;
  if (reg->bitfields.MV_BP_LEVEL_FIX_EN != mv_bp_level_fix_en) HSLDPF(E_ERROR_MESSAGE,"TV_MASTER_CNTL::MV_BP_LEVEL_FIX_EN data too large\n");
}
__inline void set_TV_MASTER_CNTL_extra_bit_one_0(regTV_MASTER_CNTL *reg, unsigned int extra_bit_one_0)
{
  reg->bitfields.EXTRA_BIT_ONE_0 = extra_bit_one_0;
  if (reg->bitfields.EXTRA_BIT_ONE_0 != extra_bit_one_0) HSLDPF(E_ERROR_MESSAGE,"TV_MASTER_CNTL::EXTRA_BIT_ONE_0 data too large\n");
}
__inline void set_TV_MASTER_CNTL_crt_fifo_ce_en(regTV_MASTER_CNTL *reg, unsigned int crt_fifo_ce_en)
{
  reg->bitfields.CRT_FIFO_CE_EN = crt_fifo_ce_en;
  if (reg->bitfields.CRT_FIFO_CE_EN != crt_fifo_ce_en) HSLDPF(E_ERROR_MESSAGE,"TV_MASTER_CNTL::CRT_FIFO_CE_EN data too large\n");
}
__inline void set_TV_MASTER_CNTL_tv_fifo_ce_en(regTV_MASTER_CNTL *reg, unsigned int tv_fifo_ce_en)
{
  reg->bitfields.TV_FIFO_CE_EN = tv_fifo_ce_en;
  if (reg->bitfields.TV_FIFO_CE_EN != tv_fifo_ce_en) HSLDPF(E_ERROR_MESSAGE,"TV_MASTER_CNTL::TV_FIFO_CE_EN data too large\n");
}
__inline void set_TV_MASTER_CNTL_re_sync_now_sel(regTV_MASTER_CNTL *reg, unsigned int re_sync_now_sel)
{
  reg->bitfields.RE_SYNC_NOW_SEL = re_sync_now_sel;
  if (reg->bitfields.RE_SYNC_NOW_SEL != re_sync_now_sel) HSLDPF(E_ERROR_MESSAGE,"TV_MASTER_CNTL::RE_SYNC_NOW_SEL data too large\n");
}
__inline void set_TV_MASTER_CNTL_extra_bit_zero_1(regTV_MASTER_CNTL *reg, unsigned int extra_bit_zero_1)
{
  reg->bitfields.EXTRA_BIT_ZERO_1 = extra_bit_zero_1;
  if (reg->bitfields.EXTRA_BIT_ZERO_1 != extra_bit_zero_1) HSLDPF(E_ERROR_MESSAGE,"TV_MASTER_CNTL::EXTRA_BIT_ZERO_1 data too large\n");
}
__inline void set_TV_MASTER_CNTL_extra_bit_one_1(regTV_MASTER_CNTL *reg, unsigned int extra_bit_one_1)
{
  reg->bitfields.EXTRA_BIT_ONE_1 = extra_bit_one_1;
  if (reg->bitfields.EXTRA_BIT_ONE_1 != extra_bit_one_1) HSLDPF(E_ERROR_MESSAGE,"TV_MASTER_CNTL::EXTRA_BIT_ONE_1 data too large\n");
}
__inline void set_TV_MASTER_CNTL_extra_bit_zero_2(regTV_MASTER_CNTL *reg, unsigned int extra_bit_zero_2)
{
  reg->bitfields.EXTRA_BIT_ZERO_2 = extra_bit_zero_2;
  if (reg->bitfields.EXTRA_BIT_ZERO_2 != extra_bit_zero_2) HSLDPF(E_ERROR_MESSAGE,"TV_MASTER_CNTL::EXTRA_BIT_ZERO_2 data too large\n");
}
__inline void set_TV_MASTER_CNTL_extra_bit_one_2(regTV_MASTER_CNTL *reg, unsigned int extra_bit_one_2)
{
  reg->bitfields.EXTRA_BIT_ONE_2 = extra_bit_one_2;
  if (reg->bitfields.EXTRA_BIT_ONE_2 != extra_bit_one_2) HSLDPF(E_ERROR_MESSAGE,"TV_MASTER_CNTL::EXTRA_BIT_ONE_2 data too large\n");
}
__inline void set_TV_MASTER_CNTL_tvclk_always_onb(regTV_MASTER_CNTL *reg, unsigned int tvclk_always_onb)
{
  reg->bitfields.TVCLK_ALWAYS_ONb = tvclk_always_onb;
  if (reg->bitfields.TVCLK_ALWAYS_ONb != tvclk_always_onb) HSLDPF(E_ERROR_MESSAGE,"TV_MASTER_CNTL::TVCLK_ALWAYS_ONb data too large\n");
}
__inline void set_TV_MASTER_CNTL_tv_on(regTV_MASTER_CNTL *reg, unsigned int tv_on)
{
  reg->bitfields.TV_ON = tv_on;
  if (reg->bitfields.TV_ON != tv_on) HSLDPF(E_ERROR_MESSAGE,"TV_MASTER_CNTL::TV_ON data too large\n");
}
#else
#define set_TV_MASTER_CNTL_tv_async_rst(reg, tv_async_rst) (reg)->bitfields.TV_ASYNC_RST = tv_async_rst
#define set_TV_MASTER_CNTL_crt_async_rst(reg, crt_async_rst) (reg)->bitfields.CRT_ASYNC_RST = crt_async_rst
#define set_TV_MASTER_CNTL_restart_phase_fix(reg, restart_phase_fix) (reg)->bitfields.RESTART_PHASE_FIX = restart_phase_fix
#define set_TV_MASTER_CNTL_tv_fifo_async_rst(reg, tv_fifo_async_rst) (reg)->bitfields.TV_FIFO_ASYNC_RST = tv_fifo_async_rst
#define set_TV_MASTER_CNTL_mv_bp_level_fix_en(reg, mv_bp_level_fix_en) (reg)->bitfields.MV_BP_LEVEL_FIX_EN = mv_bp_level_fix_en
#define set_TV_MASTER_CNTL_extra_bit_one_0(reg, extra_bit_one_0) (reg)->bitfields.EXTRA_BIT_ONE_0 = extra_bit_one_0
#define set_TV_MASTER_CNTL_crt_fifo_ce_en(reg, crt_fifo_ce_en) (reg)->bitfields.CRT_FIFO_CE_EN = crt_fifo_ce_en
#define set_TV_MASTER_CNTL_tv_fifo_ce_en(reg, tv_fifo_ce_en) (reg)->bitfields.TV_FIFO_CE_EN = tv_fifo_ce_en
#define set_TV_MASTER_CNTL_re_sync_now_sel(reg, re_sync_now_sel) (reg)->bitfields.RE_SYNC_NOW_SEL = re_sync_now_sel
#define set_TV_MASTER_CNTL_extra_bit_zero_1(reg, extra_bit_zero_1) (reg)->bitfields.EXTRA_BIT_ZERO_1 = extra_bit_zero_1
#define set_TV_MASTER_CNTL_extra_bit_one_1(reg, extra_bit_one_1) (reg)->bitfields.EXTRA_BIT_ONE_1 = extra_bit_one_1
#define set_TV_MASTER_CNTL_extra_bit_zero_2(reg, extra_bit_zero_2) (reg)->bitfields.EXTRA_BIT_ZERO_2 = extra_bit_zero_2
#define set_TV_MASTER_CNTL_extra_bit_one_2(reg, extra_bit_one_2) (reg)->bitfields.EXTRA_BIT_ONE_2 = extra_bit_one_2
#define set_TV_MASTER_CNTL_tvclk_always_onb(reg, tvclk_always_onb) (reg)->bitfields.TVCLK_ALWAYS_ONb = tvclk_always_onb
#define set_TV_MASTER_CNTL_tv_on(reg, tv_on) (reg)->bitfields.TV_ON = tv_on

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_RGB_CNTL regTV_RGB_CNTL;

#ifdef DEBUG
__inline void set_TV_RGB_CNTL_uv_dither_en(regTV_RGB_CNTL *reg, unsigned int uv_dither_en)
{
  reg->bitfields.UV_DITHER_EN = uv_dither_en;
  if (reg->bitfields.UV_DITHER_EN != uv_dither_en) HSLDPF(E_ERROR_MESSAGE,"TV_RGB_CNTL::UV_DITHER_EN data too large\n");
}
__inline void set_TV_RGB_CNTL_switch_to_blue(regTV_RGB_CNTL *reg, unsigned int switch_to_blue)
{
  reg->bitfields.SWITCH_TO_BLUE = switch_to_blue;
  if (reg->bitfields.SWITCH_TO_BLUE != switch_to_blue) HSLDPF(E_ERROR_MESSAGE,"TV_RGB_CNTL::SWITCH_TO_BLUE data too large\n");
}
__inline void set_TV_RGB_CNTL_rgb_dither_en(regTV_RGB_CNTL *reg, unsigned int rgb_dither_en)
{
  reg->bitfields.RGB_DITHER_EN = rgb_dither_en;
  if (reg->bitfields.RGB_DITHER_EN != rgb_dither_en) HSLDPF(E_ERROR_MESSAGE,"TV_RGB_CNTL::RGB_DITHER_EN data too large\n");
}
__inline void set_TV_RGB_CNTL_rgb_src_sel(regTV_RGB_CNTL *reg, unsigned int rgb_src_sel)
{
  reg->bitfields.RGB_SRC_SEL = rgb_src_sel;
  if (reg->bitfields.RGB_SRC_SEL != rgb_src_sel) HSLDPF(E_ERROR_MESSAGE,"TV_RGB_CNTL::RGB_SRC_SEL data too large\n");
}
__inline void set_TV_RGB_CNTL_rgb_convert_by_pass(regTV_RGB_CNTL *reg, unsigned int rgb_convert_by_pass)
{
  reg->bitfields.RGB_CONVERT_BY_PASS = rgb_convert_by_pass;
  if (reg->bitfields.RGB_CONVERT_BY_PASS != rgb_convert_by_pass) HSLDPF(E_ERROR_MESSAGE,"TV_RGB_CNTL::RGB_CONVERT_BY_PASS data too large\n");
}
__inline void set_TV_RGB_CNTL_re_sync_now_pos(regTV_RGB_CNTL *reg, unsigned int re_sync_now_pos)
{
  reg->bitfields.RE_SYNC_NOW_POS = re_sync_now_pos;
  if (reg->bitfields.RE_SYNC_NOW_POS != re_sync_now_pos) HSLDPF(E_ERROR_MESSAGE,"TV_RGB_CNTL::RE_SYNC_NOW_POS data too large\n");
}
__inline void set_TV_RGB_CNTL_ignore_odd_lines(regTV_RGB_CNTL *reg, unsigned int ignore_odd_lines)
{
  reg->bitfields.IGNORE_ODD_LINES = ignore_odd_lines;
  if (reg->bitfields.IGNORE_ODD_LINES != ignore_odd_lines) HSLDPF(E_ERROR_MESSAGE,"TV_RGB_CNTL::IGNORE_ODD_LINES data too large\n");
}
__inline void set_TV_RGB_CNTL_dsp_vcount_rst(regTV_RGB_CNTL *reg, unsigned int dsp_vcount_rst)
{
  reg->bitfields.DSP_VCOUNT_RST = dsp_vcount_rst;
  if (reg->bitfields.DSP_VCOUNT_RST != dsp_vcount_rst) HSLDPF(E_ERROR_MESSAGE,"TV_RGB_CNTL::DSP_VCOUNT_RST data too large\n");
}
__inline void set_TV_RGB_CNTL_dsp2_vcount_rst(regTV_RGB_CNTL *reg, unsigned int dsp2_vcount_rst)
{
  reg->bitfields.DSP2_VCOUNT_RST = dsp2_vcount_rst;
  if (reg->bitfields.DSP2_VCOUNT_RST != dsp2_vcount_rst) HSLDPF(E_ERROR_MESSAGE,"TV_RGB_CNTL::DSP2_VCOUNT_RST data too large\n");
}
__inline void set_TV_RGB_CNTL_uvram_read_margin(regTV_RGB_CNTL *reg, unsigned int uvram_read_margin)
{
  reg->bitfields.UVRAM_READ_MARGIN = uvram_read_margin;
  if (reg->bitfields.UVRAM_READ_MARGIN != uvram_read_margin) HSLDPF(E_ERROR_MESSAGE,"TV_RGB_CNTL::UVRAM_READ_MARGIN data too large\n");
}
__inline void set_TV_RGB_CNTL_fiforam_ffmacro_read_margin(regTV_RGB_CNTL *reg, unsigned int fiforam_ffmacro_read_margin)
{
  reg->bitfields.FIFORAM_FFMACRO_READ_MARGIN = fiforam_ffmacro_read_margin;
  if (reg->bitfields.FIFORAM_FFMACRO_READ_MARGIN != fiforam_ffmacro_read_margin) HSLDPF(E_ERROR_MESSAGE,"TV_RGB_CNTL::FIFORAM_FFMACRO_READ_MARGIN data too large\n");
}
__inline void set_TV_RGB_CNTL_rgb_atten_sel(regTV_RGB_CNTL *reg, unsigned int rgb_atten_sel)
{
  reg->bitfields.RGB_ATTEN_SEL = rgb_atten_sel;
  if (reg->bitfields.RGB_ATTEN_SEL != rgb_atten_sel) HSLDPF(E_ERROR_MESSAGE,"TV_RGB_CNTL::RGB_ATTEN_SEL data too large\n");
}
__inline void set_TV_RGB_CNTL_rgb_atten_val(regTV_RGB_CNTL *reg, unsigned int rgb_atten_val)
{
  reg->bitfields.RGB_ATTEN_VAL = rgb_atten_val;
  if (reg->bitfields.RGB_ATTEN_VAL != rgb_atten_val) HSLDPF(E_ERROR_MESSAGE,"TV_RGB_CNTL::RGB_ATTEN_VAL data too large\n");
}
#else
#define set_TV_RGB_CNTL_uv_dither_en(reg, uv_dither_en) (reg)->bitfields.UV_DITHER_EN = uv_dither_en
#define set_TV_RGB_CNTL_switch_to_blue(reg, switch_to_blue) (reg)->bitfields.SWITCH_TO_BLUE = switch_to_blue
#define set_TV_RGB_CNTL_rgb_dither_en(reg, rgb_dither_en) (reg)->bitfields.RGB_DITHER_EN = rgb_dither_en
#define set_TV_RGB_CNTL_rgb_src_sel(reg, rgb_src_sel) (reg)->bitfields.RGB_SRC_SEL = rgb_src_sel
#define set_TV_RGB_CNTL_rgb_convert_by_pass(reg, rgb_convert_by_pass) (reg)->bitfields.RGB_CONVERT_BY_PASS = rgb_convert_by_pass
#define set_TV_RGB_CNTL_re_sync_now_pos(reg, re_sync_now_pos) (reg)->bitfields.RE_SYNC_NOW_POS = re_sync_now_pos
#define set_TV_RGB_CNTL_ignore_odd_lines(reg, ignore_odd_lines) (reg)->bitfields.IGNORE_ODD_LINES = ignore_odd_lines
#define set_TV_RGB_CNTL_dsp_vcount_rst(reg, dsp_vcount_rst) (reg)->bitfields.DSP_VCOUNT_RST = dsp_vcount_rst
#define set_TV_RGB_CNTL_dsp2_vcount_rst(reg, dsp2_vcount_rst) (reg)->bitfields.DSP2_VCOUNT_RST = dsp2_vcount_rst
#define set_TV_RGB_CNTL_uvram_read_margin(reg, uvram_read_margin) (reg)->bitfields.UVRAM_READ_MARGIN = uvram_read_margin
#define set_TV_RGB_CNTL_fiforam_ffmacro_read_margin(reg, fiforam_ffmacro_read_margin) (reg)->bitfields.FIFORAM_FFMACRO_READ_MARGIN = fiforam_ffmacro_read_margin
#define set_TV_RGB_CNTL_rgb_atten_sel(reg, rgb_atten_sel) (reg)->bitfields.RGB_ATTEN_SEL = rgb_atten_sel
#define set_TV_RGB_CNTL_rgb_atten_val(reg, rgb_atten_val) (reg)->bitfields.RGB_ATTEN_VAL = rgb_atten_val

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_SYNC_CNTL regTV_SYNC_CNTL;

#ifdef DEBUG
__inline void set_TV_SYNC_CNTL_sync_oe(regTV_SYNC_CNTL *reg, unsigned int sync_oe)
{
  reg->bitfields.SYNC_OE = sync_oe;
  if (reg->bitfields.SYNC_OE != sync_oe) HSLDPF(E_ERROR_MESSAGE,"TV_SYNC_CNTL::SYNC_OE data too large\n");
}
__inline void set_TV_SYNC_CNTL_sync_out(regTV_SYNC_CNTL *reg, unsigned int sync_out)
{
  reg->bitfields.SYNC_OUT = sync_out;
  if (reg->bitfields.SYNC_OUT != sync_out) HSLDPF(E_ERROR_MESSAGE,"TV_SYNC_CNTL::SYNC_OUT data too large\n");
}
__inline void set_TV_SYNC_CNTL_sync_in(regTV_SYNC_CNTL *reg, unsigned int sync_in)
{
  reg->bitfields.SYNC_IN = sync_in;
  if (reg->bitfields.SYNC_IN != sync_in) HSLDPF(E_ERROR_MESSAGE,"TV_SYNC_CNTL::SYNC_IN data too large\n");
}
__inline void set_TV_SYNC_CNTL_sync_pub(regTV_SYNC_CNTL *reg, unsigned int sync_pub)
{
  reg->bitfields.SYNC_PUB = sync_pub;
  if (reg->bitfields.SYNC_PUB != sync_pub) HSLDPF(E_ERROR_MESSAGE,"TV_SYNC_CNTL::SYNC_PUB data too large\n");
}
__inline void set_TV_SYNC_CNTL_sync_pd(regTV_SYNC_CNTL *reg, unsigned int sync_pd)
{
  reg->bitfields.SYNC_PD = sync_pd;
  if (reg->bitfields.SYNC_PD != sync_pd) HSLDPF(E_ERROR_MESSAGE,"TV_SYNC_CNTL::SYNC_PD data too large\n");
}
__inline void set_TV_SYNC_CNTL_tv_sync_io_drive(regTV_SYNC_CNTL *reg, unsigned int tv_sync_io_drive)
{
  reg->bitfields.TV_SYNC_IO_DRIVE = tv_sync_io_drive;
  if (reg->bitfields.TV_SYNC_IO_DRIVE != tv_sync_io_drive) HSLDPF(E_ERROR_MESSAGE,"TV_SYNC_CNTL::TV_SYNC_IO_DRIVE data too large\n");
}
__inline void set_TV_SYNC_CNTL_sync_mx(regTV_SYNC_CNTL *reg, unsigned int sync_mx)
{
  reg->bitfields.SYNC_MX = sync_mx;
  if (reg->bitfields.SYNC_MX != sync_mx) HSLDPF(E_ERROR_MESSAGE,"TV_SYNC_CNTL::SYNC_MX data too large\n");
}
#else
#define set_TV_SYNC_CNTL_sync_oe(reg, sync_oe) (reg)->bitfields.SYNC_OE = sync_oe
#define set_TV_SYNC_CNTL_sync_out(reg, sync_out) (reg)->bitfields.SYNC_OUT = sync_out
#define set_TV_SYNC_CNTL_sync_in(reg, sync_in) (reg)->bitfields.SYNC_IN = sync_in
#define set_TV_SYNC_CNTL_sync_pub(reg, sync_pub) (reg)->bitfields.SYNC_PUB = sync_pub
#define set_TV_SYNC_CNTL_sync_pd(reg, sync_pd) (reg)->bitfields.SYNC_PD = sync_pd
#define set_TV_SYNC_CNTL_tv_sync_io_drive(reg, tv_sync_io_drive) (reg)->bitfields.TV_SYNC_IO_DRIVE = tv_sync_io_drive
#define set_TV_SYNC_CNTL_sync_mx(reg, sync_mx) (reg)->bitfields.SYNC_MX = sync_mx

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_HTOTAL regTV_HTOTAL;

#ifdef DEBUG
__inline void set_TV_HTOTAL_d_htotal(regTV_HTOTAL *reg, unsigned int d_htotal)
{
  reg->bitfields.D_HTOTAL = d_htotal;
  if (reg->bitfields.D_HTOTAL != d_htotal) HSLDPF(E_ERROR_MESSAGE,"TV_HTOTAL::D_HTOTAL data too large\n");
}
#else
#define set_TV_HTOTAL_d_htotal(reg, d_htotal) (reg)->bitfields.D_HTOTAL = d_htotal

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_HDISP regTV_HDISP;

#ifdef DEBUG
__inline void set_TV_HDISP_d_hdisp(regTV_HDISP *reg, unsigned int d_hdisp)
{
  reg->bitfields.D_HDISP = d_hdisp;
  if (reg->bitfields.D_HDISP != d_hdisp) HSLDPF(E_ERROR_MESSAGE,"TV_HDISP::D_HDISP data too large\n");
}
#else
#define set_TV_HDISP_d_hdisp(reg, d_hdisp) (reg)->bitfields.D_HDISP = d_hdisp

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_HSTART regTV_HSTART;

#ifdef DEBUG
__inline void set_TV_HSTART_d_hstart(regTV_HSTART *reg, unsigned int d_hstart)
{
  reg->bitfields.D_HSTART = d_hstart;
  if (reg->bitfields.D_HSTART != d_hstart) HSLDPF(E_ERROR_MESSAGE,"TV_HSTART::D_HSTART data too large\n");
}
#else
#define set_TV_HSTART_d_hstart(reg, d_hstart) (reg)->bitfields.D_HSTART = d_hstart

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_HCOUNT regTV_HCOUNT;

#ifdef DEBUG
__inline void set_TV_HCOUNT_d_hcount(regTV_HCOUNT *reg, unsigned int d_hcount)
{
  reg->bitfields.D_HCOUNT = d_hcount;
  if (reg->bitfields.D_HCOUNT != d_hcount) HSLDPF(E_ERROR_MESSAGE,"TV_HCOUNT::D_HCOUNT data too large\n");
}
#else
#define set_TV_HCOUNT_d_hcount(reg, d_hcount) (reg)->bitfields.D_HCOUNT = d_hcount

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_VTOTAL regTV_VTOTAL;

#ifdef DEBUG
__inline void set_TV_VTOTAL_d_vtotal(regTV_VTOTAL *reg, unsigned int d_vtotal)
{
  reg->bitfields.D_VTOTAL = d_vtotal;
  if (reg->bitfields.D_VTOTAL != d_vtotal) HSLDPF(E_ERROR_MESSAGE,"TV_VTOTAL::D_VTOTAL data too large\n");
}
#else
#define set_TV_VTOTAL_d_vtotal(reg, d_vtotal) (reg)->bitfields.D_VTOTAL = d_vtotal

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_VDISP regTV_VDISP;

#ifdef DEBUG
__inline void set_TV_VDISP_d_vdisp(regTV_VDISP *reg, unsigned int d_vdisp)
{
  reg->bitfields.D_VDISP = d_vdisp;
  if (reg->bitfields.D_VDISP != d_vdisp) HSLDPF(E_ERROR_MESSAGE,"TV_VDISP::D_VDISP data too large\n");
}
#else
#define set_TV_VDISP_d_vdisp(reg, d_vdisp) (reg)->bitfields.D_VDISP = d_vdisp

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_VCOUNT regTV_VCOUNT;

#ifdef DEBUG
__inline void set_TV_VCOUNT_d_vcount(regTV_VCOUNT *reg, unsigned int d_vcount)
{
  reg->bitfields.D_VCOUNT = d_vcount;
  if (reg->bitfields.D_VCOUNT != d_vcount) HSLDPF(E_ERROR_MESSAGE,"TV_VCOUNT::D_VCOUNT data too large\n");
}
#else
#define set_TV_VCOUNT_d_vcount(reg, d_vcount) (reg)->bitfields.D_VCOUNT = d_vcount

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_FTOTAL regTV_FTOTAL;

#ifdef DEBUG
__inline void set_TV_FTOTAL_d_ftotal(regTV_FTOTAL *reg, unsigned int d_ftotal)
{
  reg->bitfields.D_FTOTAL = d_ftotal;
  if (reg->bitfields.D_FTOTAL != d_ftotal) HSLDPF(E_ERROR_MESSAGE,"TV_FTOTAL::D_FTOTAL data too large\n");
}
#else
#define set_TV_FTOTAL_d_ftotal(reg, d_ftotal) (reg)->bitfields.D_FTOTAL = d_ftotal

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_FCOUNT regTV_FCOUNT;

#ifdef DEBUG
__inline void set_TV_FCOUNT_d_fcount(regTV_FCOUNT *reg, unsigned int d_fcount)
{
  reg->bitfields.D_FCOUNT = d_fcount;
  if (reg->bitfields.D_FCOUNT != d_fcount) HSLDPF(E_ERROR_MESSAGE,"TV_FCOUNT::D_FCOUNT data too large\n");
}
#else
#define set_TV_FCOUNT_d_fcount(reg, d_fcount) (reg)->bitfields.D_FCOUNT = d_fcount

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_FRESTART regTV_FRESTART;

#ifdef DEBUG
__inline void set_TV_FRESTART_d_frestart(regTV_FRESTART *reg, unsigned int d_frestart)
{
  reg->bitfields.D_FRESTART = d_frestart;
  if (reg->bitfields.D_FRESTART != d_frestart) HSLDPF(E_ERROR_MESSAGE,"TV_FRESTART::D_FRESTART data too large\n");
}
#else
#define set_TV_FRESTART_d_frestart(reg, d_frestart) (reg)->bitfields.D_FRESTART = d_frestart

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_HRESTART regTV_HRESTART;

#ifdef DEBUG
__inline void set_TV_HRESTART_d_hrestart(regTV_HRESTART *reg, unsigned int d_hrestart)
{
  reg->bitfields.D_HRESTART = d_hrestart;
  if (reg->bitfields.D_HRESTART != d_hrestart) HSLDPF(E_ERROR_MESSAGE,"TV_HRESTART::D_HRESTART data too large\n");
}
#else
#define set_TV_HRESTART_d_hrestart(reg, d_hrestart) (reg)->bitfields.D_HRESTART = d_hrestart

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_VRESTART regTV_VRESTART;

#ifdef DEBUG
__inline void set_TV_VRESTART_d_vrestart(regTV_VRESTART *reg, unsigned int d_vrestart)
{
  reg->bitfields.D_VRESTART = d_vrestart;
  if (reg->bitfields.D_VRESTART != d_vrestart) HSLDPF(E_ERROR_MESSAGE,"TV_VRESTART::D_VRESTART data too large\n");
}
#else
#define set_TV_VRESTART_d_vrestart(reg, d_vrestart) (reg)->bitfields.D_VRESTART = d_vrestart

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_HOST_READ_DATA regTV_HOST_READ_DATA;

#ifdef DEBUG
__inline void set_TV_HOST_READ_DATA_host_rd_data_w0(regTV_HOST_READ_DATA *reg, unsigned int host_rd_data_w0)
{
  reg->bitfields.HOST_RD_DATA_W0 = host_rd_data_w0;
  if (reg->bitfields.HOST_RD_DATA_W0 != host_rd_data_w0) HSLDPF(E_ERROR_MESSAGE,"TV_HOST_READ_DATA::HOST_RD_DATA_W0 data too large\n");
}
__inline void set_TV_HOST_READ_DATA_host_rd_data_w1(regTV_HOST_READ_DATA *reg, unsigned int host_rd_data_w1)
{
  reg->bitfields.HOST_RD_DATA_W1 = host_rd_data_w1;
  if (reg->bitfields.HOST_RD_DATA_W1 != host_rd_data_w1) HSLDPF(E_ERROR_MESSAGE,"TV_HOST_READ_DATA::HOST_RD_DATA_W1 data too large\n");
}
#else
#define set_TV_HOST_READ_DATA_host_rd_data_w0(reg, host_rd_data_w0) (reg)->bitfields.HOST_RD_DATA_W0 = host_rd_data_w0
#define set_TV_HOST_READ_DATA_host_rd_data_w1(reg, host_rd_data_w1) (reg)->bitfields.HOST_RD_DATA_W1 = host_rd_data_w1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_HOST_WRITE_DATA regTV_HOST_WRITE_DATA;

#ifdef DEBUG
__inline void set_TV_HOST_WRITE_DATA_host_wt_data_w0(regTV_HOST_WRITE_DATA *reg, unsigned int host_wt_data_w0)
{
  reg->bitfields.HOST_WT_DATA_W0 = host_wt_data_w0;
  if (reg->bitfields.HOST_WT_DATA_W0 != host_wt_data_w0) HSLDPF(E_ERROR_MESSAGE,"TV_HOST_WRITE_DATA::HOST_WT_DATA_W0 data too large\n");
}
__inline void set_TV_HOST_WRITE_DATA_host_wt_data_w1(regTV_HOST_WRITE_DATA *reg, unsigned int host_wt_data_w1)
{
  reg->bitfields.HOST_WT_DATA_W1 = host_wt_data_w1;
  if (reg->bitfields.HOST_WT_DATA_W1 != host_wt_data_w1) HSLDPF(E_ERROR_MESSAGE,"TV_HOST_WRITE_DATA::HOST_WT_DATA_W1 data too large\n");
}
#else
#define set_TV_HOST_WRITE_DATA_host_wt_data_w0(reg, host_wt_data_w0) (reg)->bitfields.HOST_WT_DATA_W0 = host_wt_data_w0
#define set_TV_HOST_WRITE_DATA_host_wt_data_w1(reg, host_wt_data_w1) (reg)->bitfields.HOST_WT_DATA_W1 = host_wt_data_w1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_HOST_RD_WT_CNTL regTV_HOST_RD_WT_CNTL;

#ifdef DEBUG
__inline void set_TV_HOST_RD_WT_CNTL_host_adr(regTV_HOST_RD_WT_CNTL *reg, unsigned int host_adr)
{
  reg->bitfields.HOST_ADR = host_adr;
  if (reg->bitfields.HOST_ADR != host_adr) HSLDPF(E_ERROR_MESSAGE,"TV_HOST_RD_WT_CNTL::HOST_ADR data too large\n");
}
__inline void set_TV_HOST_RD_WT_CNTL_host_fifo_rd(regTV_HOST_RD_WT_CNTL *reg, unsigned int host_fifo_rd)
{
  reg->bitfields.HOST_FIFO_RD = host_fifo_rd;
  if (reg->bitfields.HOST_FIFO_RD != host_fifo_rd) HSLDPF(E_ERROR_MESSAGE,"TV_HOST_RD_WT_CNTL::HOST_FIFO_RD data too large\n");
}
__inline void set_TV_HOST_RD_WT_CNTL_host_fifo_rd_ack(regTV_HOST_RD_WT_CNTL *reg, unsigned int host_fifo_rd_ack)
{
  reg->bitfields.HOST_FIFO_RD_ACK = host_fifo_rd_ack;
  if (reg->bitfields.HOST_FIFO_RD_ACK != host_fifo_rd_ack) HSLDPF(E_ERROR_MESSAGE,"TV_HOST_RD_WT_CNTL::HOST_FIFO_RD_ACK data too large\n");
}
__inline void set_TV_HOST_RD_WT_CNTL_host_fifo_wt(regTV_HOST_RD_WT_CNTL *reg, unsigned int host_fifo_wt)
{
  reg->bitfields.HOST_FIFO_WT = host_fifo_wt;
  if (reg->bitfields.HOST_FIFO_WT != host_fifo_wt) HSLDPF(E_ERROR_MESSAGE,"TV_HOST_RD_WT_CNTL::HOST_FIFO_WT data too large\n");
}
__inline void set_TV_HOST_RD_WT_CNTL_host_fifo_wt_ack(regTV_HOST_RD_WT_CNTL *reg, unsigned int host_fifo_wt_ack)
{
  reg->bitfields.HOST_FIFO_WT_ACK = host_fifo_wt_ack;
  if (reg->bitfields.HOST_FIFO_WT_ACK != host_fifo_wt_ack) HSLDPF(E_ERROR_MESSAGE,"TV_HOST_RD_WT_CNTL::HOST_FIFO_WT_ACK data too large\n");
}
#else
#define set_TV_HOST_RD_WT_CNTL_host_adr(reg, host_adr) (reg)->bitfields.HOST_ADR = host_adr
#define set_TV_HOST_RD_WT_CNTL_host_fifo_rd(reg, host_fifo_rd) (reg)->bitfields.HOST_FIFO_RD = host_fifo_rd
#define set_TV_HOST_RD_WT_CNTL_host_fifo_rd_ack(reg, host_fifo_rd_ack) (reg)->bitfields.HOST_FIFO_RD_ACK = host_fifo_rd_ack
#define set_TV_HOST_RD_WT_CNTL_host_fifo_wt(reg, host_fifo_wt) (reg)->bitfields.HOST_FIFO_WT = host_fifo_wt
#define set_TV_HOST_RD_WT_CNTL_host_fifo_wt_ack(reg, host_fifo_wt_ack) (reg)->bitfields.HOST_FIFO_WT_ACK = host_fifo_wt_ack

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_VSCALER_CNTL1 regTV_VSCALER_CNTL1;

#ifdef DEBUG
__inline void set_TV_VSCALER_CNTL1_uv_inc(regTV_VSCALER_CNTL1 *reg, unsigned int uv_inc)
{
  reg->bitfields.UV_INC = uv_inc;
  if (reg->bitfields.UV_INC != uv_inc) HSLDPF(E_ERROR_MESSAGE,"TV_VSCALER_CNTL1::UV_INC data too large\n");
}
__inline void set_TV_VSCALER_CNTL1_uv_thinner(regTV_VSCALER_CNTL1 *reg, unsigned int uv_thinner)
{
  reg->bitfields.UV_THINNER = uv_thinner;
  if (reg->bitfields.UV_THINNER != uv_thinner) HSLDPF(E_ERROR_MESSAGE,"TV_VSCALER_CNTL1::UV_THINNER data too large\n");
}
__inline void set_TV_VSCALER_CNTL1_y_w_en(regTV_VSCALER_CNTL1 *reg, unsigned int y_w_en)
{
  reg->bitfields.Y_W_EN = y_w_en;
  if (reg->bitfields.Y_W_EN != y_w_en) HSLDPF(E_ERROR_MESSAGE,"TV_VSCALER_CNTL1::Y_W_EN data too large\n");
}
__inline void set_TV_VSCALER_CNTL1_y_del_w_sig(regTV_VSCALER_CNTL1 *reg, unsigned int y_del_w_sig)
{
  reg->bitfields.Y_DEL_W_SIG = y_del_w_sig;
  if (reg->bitfields.Y_DEL_W_SIG != y_del_w_sig) HSLDPF(E_ERROR_MESSAGE,"TV_VSCALER_CNTL1::Y_DEL_W_SIG data too large\n");
}
__inline void set_TV_VSCALER_CNTL1_restart_field(regTV_VSCALER_CNTL1 *reg, unsigned int restart_field)
{
  reg->bitfields.RESTART_FIELD = restart_field;
  if (reg->bitfields.RESTART_FIELD != restart_field) HSLDPF(E_ERROR_MESSAGE,"TV_VSCALER_CNTL1::RESTART_FIELD data too large\n");
}
#else
#define set_TV_VSCALER_CNTL1_uv_inc(reg, uv_inc) (reg)->bitfields.UV_INC = uv_inc
#define set_TV_VSCALER_CNTL1_uv_thinner(reg, uv_thinner) (reg)->bitfields.UV_THINNER = uv_thinner
#define set_TV_VSCALER_CNTL1_y_w_en(reg, y_w_en) (reg)->bitfields.Y_W_EN = y_w_en
#define set_TV_VSCALER_CNTL1_y_del_w_sig(reg, y_del_w_sig) (reg)->bitfields.Y_DEL_W_SIG = y_del_w_sig
#define set_TV_VSCALER_CNTL1_restart_field(reg, restart_field) (reg)->bitfields.RESTART_FIELD = restart_field

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_TIMING_CNTL regTV_TIMING_CNTL;

#ifdef DEBUG
__inline void set_TV_TIMING_CNTL_h_inc(regTV_TIMING_CNTL *reg, unsigned int h_inc)
{
  reg->bitfields.H_INC = h_inc;
  if (reg->bitfields.H_INC != h_inc) HSLDPF(E_ERROR_MESSAGE,"TV_TIMING_CNTL::H_INC data too large\n");
}
__inline void set_TV_TIMING_CNTL_req_delay(regTV_TIMING_CNTL *reg, unsigned int req_delay)
{
  reg->bitfields.REQ_DELAY = req_delay;
  if (reg->bitfields.REQ_DELAY != req_delay) HSLDPF(E_ERROR_MESSAGE,"TV_TIMING_CNTL::REQ_DELAY data too large\n");
}
__inline void set_TV_TIMING_CNTL_req_y_first(regTV_TIMING_CNTL *reg, unsigned int req_y_first)
{
  reg->bitfields.REQ_Y_FIRST = req_y_first;
  if (reg->bitfields.REQ_Y_FIRST != req_y_first) HSLDPF(E_ERROR_MESSAGE,"TV_TIMING_CNTL::REQ_Y_FIRST data too large\n");
}
__inline void set_TV_TIMING_CNTL_mv_vbipulse_enb(regTV_TIMING_CNTL *reg, unsigned int mv_vbipulse_enb)
{
  reg->bitfields.MV_VBIPULSE_ENB = mv_vbipulse_enb;
  if (reg->bitfields.MV_VBIPULSE_ENB != mv_vbipulse_enb) HSLDPF(E_ERROR_MESSAGE,"TV_TIMING_CNTL::MV_VBIPULSE_ENB data too large\n");
}
__inline void set_TV_TIMING_CNTL_force_burst_always(regTV_TIMING_CNTL *reg, unsigned int force_burst_always)
{
  reg->bitfields.FORCE_BURST_ALWAYS = force_burst_always;
  if (reg->bitfields.FORCE_BURST_ALWAYS != force_burst_always) HSLDPF(E_ERROR_MESSAGE,"TV_TIMING_CNTL::FORCE_BURST_ALWAYS data too large\n");
}
__inline void set_TV_TIMING_CNTL_uv_post_scale_bypass(regTV_TIMING_CNTL *reg, unsigned int uv_post_scale_bypass)
{
  reg->bitfields.UV_POST_SCALE_BYPASS = uv_post_scale_bypass;
  if (reg->bitfields.UV_POST_SCALE_BYPASS != uv_post_scale_bypass) HSLDPF(E_ERROR_MESSAGE,"TV_TIMING_CNTL::UV_POST_SCALE_BYPASS data too large\n");
}
__inline void set_TV_TIMING_CNTL_uv_output_post_scale(regTV_TIMING_CNTL *reg, unsigned int uv_output_post_scale)
{
  reg->bitfields.UV_OUTPUT_POST_SCALE = uv_output_post_scale;
  if (reg->bitfields.UV_OUTPUT_POST_SCALE != uv_output_post_scale) HSLDPF(E_ERROR_MESSAGE,"TV_TIMING_CNTL::UV_OUTPUT_POST_SCALE data too large\n");
}
#else
#define set_TV_TIMING_CNTL_h_inc(reg, h_inc) (reg)->bitfields.H_INC = h_inc
#define set_TV_TIMING_CNTL_req_delay(reg, req_delay) (reg)->bitfields.REQ_DELAY = req_delay
#define set_TV_TIMING_CNTL_req_y_first(reg, req_y_first) (reg)->bitfields.REQ_Y_FIRST = req_y_first
#define set_TV_TIMING_CNTL_mv_vbipulse_enb(reg, mv_vbipulse_enb) (reg)->bitfields.MV_VBIPULSE_ENB = mv_vbipulse_enb
#define set_TV_TIMING_CNTL_force_burst_always(reg, force_burst_always) (reg)->bitfields.FORCE_BURST_ALWAYS = force_burst_always
#define set_TV_TIMING_CNTL_uv_post_scale_bypass(reg, uv_post_scale_bypass) (reg)->bitfields.UV_POST_SCALE_BYPASS = uv_post_scale_bypass
#define set_TV_TIMING_CNTL_uv_output_post_scale(reg, uv_output_post_scale) (reg)->bitfields.UV_OUTPUT_POST_SCALE = uv_output_post_scale

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_VSCALER_CNTL2 regTV_VSCALER_CNTL2;

#ifdef DEBUG
__inline void set_TV_VSCALER_CNTL2_dither_mode(regTV_VSCALER_CNTL2 *reg, unsigned int dither_mode)
{
  reg->bitfields.DITHER_MODE = dither_mode;
  if (reg->bitfields.DITHER_MODE != dither_mode) HSLDPF(E_ERROR_MESSAGE,"TV_VSCALER_CNTL2::DITHER_MODE data too large\n");
}
__inline void set_TV_VSCALER_CNTL2_y_output_dither_en(regTV_VSCALER_CNTL2 *reg, unsigned int y_output_dither_en)
{
  reg->bitfields.Y_OUTPUT_DITHER_EN = y_output_dither_en;
  if (reg->bitfields.Y_OUTPUT_DITHER_EN != y_output_dither_en) HSLDPF(E_ERROR_MESSAGE,"TV_VSCALER_CNTL2::Y_OUTPUT_DITHER_EN data too large\n");
}
__inline void set_TV_VSCALER_CNTL2_uv_output_dither_en(regTV_VSCALER_CNTL2 *reg, unsigned int uv_output_dither_en)
{
  reg->bitfields.UV_OUTPUT_DITHER_EN = uv_output_dither_en;
  if (reg->bitfields.UV_OUTPUT_DITHER_EN != uv_output_dither_en) HSLDPF(E_ERROR_MESSAGE,"TV_VSCALER_CNTL2::UV_OUTPUT_DITHER_EN data too large\n");
}
__inline void set_TV_VSCALER_CNTL2_uv_to_buf_dither_en(regTV_VSCALER_CNTL2 *reg, unsigned int uv_to_buf_dither_en)
{
  reg->bitfields.UV_TO_BUF_DITHER_EN = uv_to_buf_dither_en;
  if (reg->bitfields.UV_TO_BUF_DITHER_EN != uv_to_buf_dither_en) HSLDPF(E_ERROR_MESSAGE,"TV_VSCALER_CNTL2::UV_TO_BUF_DITHER_EN data too large\n");
}
__inline void set_TV_VSCALER_CNTL2_uv_accum_init(regTV_VSCALER_CNTL2 *reg, unsigned int uv_accum_init)
{
  reg->bitfields.UV_ACCUM_INIT = uv_accum_init;
  if (reg->bitfields.UV_ACCUM_INIT != uv_accum_init) HSLDPF(E_ERROR_MESSAGE,"TV_VSCALER_CNTL2::UV_ACCUM_INIT data too large\n");
}
#else
#define set_TV_VSCALER_CNTL2_dither_mode(reg, dither_mode) (reg)->bitfields.DITHER_MODE = dither_mode
#define set_TV_VSCALER_CNTL2_y_output_dither_en(reg, y_output_dither_en) (reg)->bitfields.Y_OUTPUT_DITHER_EN = y_output_dither_en
#define set_TV_VSCALER_CNTL2_uv_output_dither_en(reg, uv_output_dither_en) (reg)->bitfields.UV_OUTPUT_DITHER_EN = uv_output_dither_en
#define set_TV_VSCALER_CNTL2_uv_to_buf_dither_en(reg, uv_to_buf_dither_en) (reg)->bitfields.UV_TO_BUF_DITHER_EN = uv_to_buf_dither_en
#define set_TV_VSCALER_CNTL2_uv_accum_init(reg, uv_accum_init) (reg)->bitfields.UV_ACCUM_INIT = uv_accum_init

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_Y_FALL_CNTL regTV_Y_FALL_CNTL;

#ifdef DEBUG
__inline void set_TV_Y_FALL_CNTL_y_fall_accum_init(regTV_Y_FALL_CNTL *reg, unsigned int y_fall_accum_init)
{
  reg->bitfields.Y_FALL_ACCUM_INIT = y_fall_accum_init;
  if (reg->bitfields.Y_FALL_ACCUM_INIT != y_fall_accum_init) HSLDPF(E_ERROR_MESSAGE,"TV_Y_FALL_CNTL::Y_FALL_ACCUM_INIT data too large\n");
}
__inline void set_TV_Y_FALL_CNTL_y_fall_ping_pong(regTV_Y_FALL_CNTL *reg, unsigned int y_fall_ping_pong)
{
  reg->bitfields.Y_FALL_PING_PONG = y_fall_ping_pong;
  if (reg->bitfields.Y_FALL_PING_PONG != y_fall_ping_pong) HSLDPF(E_ERROR_MESSAGE,"TV_Y_FALL_CNTL::Y_FALL_PING_PONG data too large\n");
}
__inline void set_TV_Y_FALL_CNTL_y_coef_en(regTV_Y_FALL_CNTL *reg, unsigned int y_coef_en)
{
  reg->bitfields.Y_COEF_EN = y_coef_en;
  if (reg->bitfields.Y_COEF_EN != y_coef_en) HSLDPF(E_ERROR_MESSAGE,"TV_Y_FALL_CNTL::Y_COEF_EN data too large\n");
}
__inline void set_TV_Y_FALL_CNTL_y_coef_value(regTV_Y_FALL_CNTL *reg, unsigned int y_coef_value)
{
  reg->bitfields.Y_COEF_VALUE = y_coef_value;
  if (reg->bitfields.Y_COEF_VALUE != y_coef_value) HSLDPF(E_ERROR_MESSAGE,"TV_Y_FALL_CNTL::Y_COEF_VALUE data too large\n");
}
#else
#define set_TV_Y_FALL_CNTL_y_fall_accum_init(reg, y_fall_accum_init) (reg)->bitfields.Y_FALL_ACCUM_INIT = y_fall_accum_init
#define set_TV_Y_FALL_CNTL_y_fall_ping_pong(reg, y_fall_ping_pong) (reg)->bitfields.Y_FALL_PING_PONG = y_fall_ping_pong
#define set_TV_Y_FALL_CNTL_y_coef_en(reg, y_coef_en) (reg)->bitfields.Y_COEF_EN = y_coef_en
#define set_TV_Y_FALL_CNTL_y_coef_value(reg, y_coef_value) (reg)->bitfields.Y_COEF_VALUE = y_coef_value

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_Y_RISE_CNTL regTV_Y_RISE_CNTL;

#ifdef DEBUG
__inline void set_TV_Y_RISE_CNTL_y_rise_accum_init(regTV_Y_RISE_CNTL *reg, unsigned int y_rise_accum_init)
{
  reg->bitfields.Y_RISE_ACCUM_INIT = y_rise_accum_init;
  if (reg->bitfields.Y_RISE_ACCUM_INIT != y_rise_accum_init) HSLDPF(E_ERROR_MESSAGE,"TV_Y_RISE_CNTL::Y_RISE_ACCUM_INIT data too large\n");
}
__inline void set_TV_Y_RISE_CNTL_y_rise_ping_pong(regTV_Y_RISE_CNTL *reg, unsigned int y_rise_ping_pong)
{
  reg->bitfields.Y_RISE_PING_PONG = y_rise_ping_pong;
  if (reg->bitfields.Y_RISE_PING_PONG != y_rise_ping_pong) HSLDPF(E_ERROR_MESSAGE,"TV_Y_RISE_CNTL::Y_RISE_PING_PONG data too large\n");
}
__inline void set_TV_Y_RISE_CNTL_mv_stripe_enb(regTV_Y_RISE_CNTL *reg, unsigned int mv_stripe_enb)
{
  reg->bitfields.MV_STRIPE_ENB = mv_stripe_enb;
  if (reg->bitfields.MV_STRIPE_ENB != mv_stripe_enb) HSLDPF(E_ERROR_MESSAGE,"TV_Y_RISE_CNTL::MV_STRIPE_ENB data too large\n");
}
__inline void set_TV_Y_RISE_CNTL_mv_bppulse_enb(regTV_Y_RISE_CNTL *reg, unsigned int mv_bppulse_enb)
{
  reg->bitfields.MV_BPPULSE_ENB = mv_bppulse_enb;
  if (reg->bitfields.MV_BPPULSE_ENB != mv_bppulse_enb) HSLDPF(E_ERROR_MESSAGE,"TV_Y_RISE_CNTL::MV_BPPULSE_ENB data too large\n");
}
__inline void set_TV_Y_RISE_CNTL_mv_zone_1_phase(regTV_Y_RISE_CNTL *reg, unsigned int mv_zone_1_phase)
{
  reg->bitfields.MV_ZONE_1_PHASE = mv_zone_1_phase;
  if (reg->bitfields.MV_ZONE_1_PHASE != mv_zone_1_phase) HSLDPF(E_ERROR_MESSAGE,"TV_Y_RISE_CNTL::MV_ZONE_1_PHASE data too large\n");
}
__inline void set_TV_Y_RISE_CNTL_mv_zone_2_phase(regTV_Y_RISE_CNTL *reg, unsigned int mv_zone_2_phase)
{
  reg->bitfields.MV_ZONE_2_PHASE = mv_zone_2_phase;
  if (reg->bitfields.MV_ZONE_2_PHASE != mv_zone_2_phase) HSLDPF(E_ERROR_MESSAGE,"TV_Y_RISE_CNTL::MV_ZONE_2_PHASE data too large\n");
}
__inline void set_TV_Y_RISE_CNTL_mv_zone_3_phase(regTV_Y_RISE_CNTL *reg, unsigned int mv_zone_3_phase)
{
  reg->bitfields.MV_ZONE_3_PHASE = mv_zone_3_phase;
  if (reg->bitfields.MV_ZONE_3_PHASE != mv_zone_3_phase) HSLDPF(E_ERROR_MESSAGE,"TV_Y_RISE_CNTL::MV_ZONE_3_PHASE data too large\n");
}
#else
#define set_TV_Y_RISE_CNTL_y_rise_accum_init(reg, y_rise_accum_init) (reg)->bitfields.Y_RISE_ACCUM_INIT = y_rise_accum_init
#define set_TV_Y_RISE_CNTL_y_rise_ping_pong(reg, y_rise_ping_pong) (reg)->bitfields.Y_RISE_PING_PONG = y_rise_ping_pong
#define set_TV_Y_RISE_CNTL_mv_stripe_enb(reg, mv_stripe_enb) (reg)->bitfields.MV_STRIPE_ENB = mv_stripe_enb
#define set_TV_Y_RISE_CNTL_mv_bppulse_enb(reg, mv_bppulse_enb) (reg)->bitfields.MV_BPPULSE_ENB = mv_bppulse_enb
#define set_TV_Y_RISE_CNTL_mv_zone_1_phase(reg, mv_zone_1_phase) (reg)->bitfields.MV_ZONE_1_PHASE = mv_zone_1_phase
#define set_TV_Y_RISE_CNTL_mv_zone_2_phase(reg, mv_zone_2_phase) (reg)->bitfields.MV_ZONE_2_PHASE = mv_zone_2_phase
#define set_TV_Y_RISE_CNTL_mv_zone_3_phase(reg, mv_zone_3_phase) (reg)->bitfields.MV_ZONE_3_PHASE = mv_zone_3_phase

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_Y_SAW_TOOTH_CNTL regTV_Y_SAW_TOOTH_CNTL;

#ifdef DEBUG
__inline void set_TV_Y_SAW_TOOTH_CNTL_y_saw_tooth_amp(regTV_Y_SAW_TOOTH_CNTL *reg, unsigned int y_saw_tooth_amp)
{
  reg->bitfields.Y_SAW_TOOTH_AMP = y_saw_tooth_amp;
  if (reg->bitfields.Y_SAW_TOOTH_AMP != y_saw_tooth_amp) HSLDPF(E_ERROR_MESSAGE,"TV_Y_SAW_TOOTH_CNTL::Y_SAW_TOOTH_AMP data too large\n");
}
__inline void set_TV_Y_SAW_TOOTH_CNTL_y_saw_tooth_slope(regTV_Y_SAW_TOOTH_CNTL *reg, unsigned int y_saw_tooth_slope)
{
  reg->bitfields.Y_SAW_TOOTH_SLOPE = y_saw_tooth_slope;
  if (reg->bitfields.Y_SAW_TOOTH_SLOPE != y_saw_tooth_slope) HSLDPF(E_ERROR_MESSAGE,"TV_Y_SAW_TOOTH_CNTL::Y_SAW_TOOTH_SLOPE data too large\n");
}
#else
#define set_TV_Y_SAW_TOOTH_CNTL_y_saw_tooth_amp(reg, y_saw_tooth_amp) (reg)->bitfields.Y_SAW_TOOTH_AMP = y_saw_tooth_amp
#define set_TV_Y_SAW_TOOTH_CNTL_y_saw_tooth_slope(reg, y_saw_tooth_slope) (reg)->bitfields.Y_SAW_TOOTH_SLOPE = y_saw_tooth_slope

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_UPSAMP_AND_GAIN_CNTL regTV_UPSAMP_AND_GAIN_CNTL;

#ifdef DEBUG
__inline void set_TV_UPSAMP_AND_GAIN_CNTL_yupsamp_en(regTV_UPSAMP_AND_GAIN_CNTL *reg, unsigned int yupsamp_en)
{
  reg->bitfields.YUPSAMP_EN = yupsamp_en;
  if (reg->bitfields.YUPSAMP_EN != yupsamp_en) HSLDPF(E_ERROR_MESSAGE,"TV_UPSAMP_AND_GAIN_CNTL::YUPSAMP_EN data too large\n");
}
__inline void set_TV_UPSAMP_AND_GAIN_CNTL_yupsamp_flat(regTV_UPSAMP_AND_GAIN_CNTL *reg, unsigned int yupsamp_flat)
{
  reg->bitfields.YUPSAMP_FLAT = yupsamp_flat;
  if (reg->bitfields.YUPSAMP_FLAT != yupsamp_flat) HSLDPF(E_ERROR_MESSAGE,"TV_UPSAMP_AND_GAIN_CNTL::YUPSAMP_FLAT data too large\n");
}
__inline void set_TV_UPSAMP_AND_GAIN_CNTL_uvupsamp_en(regTV_UPSAMP_AND_GAIN_CNTL *reg, unsigned int uvupsamp_en)
{
  reg->bitfields.UVUPSAMP_EN = uvupsamp_en;
  if (reg->bitfields.UVUPSAMP_EN != uvupsamp_en) HSLDPF(E_ERROR_MESSAGE,"TV_UPSAMP_AND_GAIN_CNTL::UVUPSAMP_EN data too large\n");
}
__inline void set_TV_UPSAMP_AND_GAIN_CNTL_uvupsamp_flat(regTV_UPSAMP_AND_GAIN_CNTL *reg, unsigned int uvupsamp_flat)
{
  reg->bitfields.UVUPSAMP_FLAT = uvupsamp_flat;
  if (reg->bitfields.UVUPSAMP_FLAT != uvupsamp_flat) HSLDPF(E_ERROR_MESSAGE,"TV_UPSAMP_AND_GAIN_CNTL::UVUPSAMP_FLAT data too large\n");
}
__inline void set_TV_UPSAMP_AND_GAIN_CNTL_yupsamp_window_cntl(regTV_UPSAMP_AND_GAIN_CNTL *reg, unsigned int yupsamp_window_cntl)
{
  reg->bitfields.YUPSAMP_WINDOW_CNTL = yupsamp_window_cntl;
  if (reg->bitfields.YUPSAMP_WINDOW_CNTL != yupsamp_window_cntl) HSLDPF(E_ERROR_MESSAGE,"TV_UPSAMP_AND_GAIN_CNTL::YUPSAMP_WINDOW_CNTL data too large\n");
}
__inline void set_TV_UPSAMP_AND_GAIN_CNTL_yupsamp_coef_sel(regTV_UPSAMP_AND_GAIN_CNTL *reg, unsigned int yupsamp_coef_sel)
{
  reg->bitfields.YUPSAMP_COEF_SEL = yupsamp_coef_sel;
  if (reg->bitfields.YUPSAMP_COEF_SEL != yupsamp_coef_sel) HSLDPF(E_ERROR_MESSAGE,"TV_UPSAMP_AND_GAIN_CNTL::YUPSAMP_COEF_SEL data too large\n");
}
__inline void set_TV_UPSAMP_AND_GAIN_CNTL_y_break_en(regTV_UPSAMP_AND_GAIN_CNTL *reg, unsigned int y_break_en)
{
  reg->bitfields.Y_BREAK_EN = y_break_en;
  if (reg->bitfields.Y_BREAK_EN != y_break_en) HSLDPF(E_ERROR_MESSAGE,"TV_UPSAMP_AND_GAIN_CNTL::Y_BREAK_EN data too large\n");
}
__inline void set_TV_UPSAMP_AND_GAIN_CNTL_uv_break_en(regTV_UPSAMP_AND_GAIN_CNTL *reg, unsigned int uv_break_en)
{
  reg->bitfields.UV_BREAK_EN = uv_break_en;
  if (reg->bitfields.UV_BREAK_EN != uv_break_en) HSLDPF(E_ERROR_MESSAGE,"TV_UPSAMP_AND_GAIN_CNTL::UV_BREAK_EN data too large\n");
}
#else
#define set_TV_UPSAMP_AND_GAIN_CNTL_yupsamp_en(reg, yupsamp_en) (reg)->bitfields.YUPSAMP_EN = yupsamp_en
#define set_TV_UPSAMP_AND_GAIN_CNTL_yupsamp_flat(reg, yupsamp_flat) (reg)->bitfields.YUPSAMP_FLAT = yupsamp_flat
#define set_TV_UPSAMP_AND_GAIN_CNTL_uvupsamp_en(reg, uvupsamp_en) (reg)->bitfields.UVUPSAMP_EN = uvupsamp_en
#define set_TV_UPSAMP_AND_GAIN_CNTL_uvupsamp_flat(reg, uvupsamp_flat) (reg)->bitfields.UVUPSAMP_FLAT = uvupsamp_flat
#define set_TV_UPSAMP_AND_GAIN_CNTL_yupsamp_window_cntl(reg, yupsamp_window_cntl) (reg)->bitfields.YUPSAMP_WINDOW_CNTL = yupsamp_window_cntl
#define set_TV_UPSAMP_AND_GAIN_CNTL_yupsamp_coef_sel(reg, yupsamp_coef_sel) (reg)->bitfields.YUPSAMP_COEF_SEL = yupsamp_coef_sel
#define set_TV_UPSAMP_AND_GAIN_CNTL_y_break_en(reg, y_break_en) (reg)->bitfields.Y_BREAK_EN = y_break_en
#define set_TV_UPSAMP_AND_GAIN_CNTL_uv_break_en(reg, uv_break_en) (reg)->bitfields.UV_BREAK_EN = uv_break_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_GAIN_LIMIT_SETTINGS regTV_GAIN_LIMIT_SETTINGS;

#ifdef DEBUG
__inline void set_TV_GAIN_LIMIT_SETTINGS_y_gain_limit(regTV_GAIN_LIMIT_SETTINGS *reg, unsigned int y_gain_limit)
{
  reg->bitfields.Y_GAIN_LIMIT = y_gain_limit;
  if (reg->bitfields.Y_GAIN_LIMIT != y_gain_limit) HSLDPF(E_ERROR_MESSAGE,"TV_GAIN_LIMIT_SETTINGS::Y_GAIN_LIMIT data too large\n");
}
__inline void set_TV_GAIN_LIMIT_SETTINGS_uv_gain_limit(regTV_GAIN_LIMIT_SETTINGS *reg, unsigned int uv_gain_limit)
{
  reg->bitfields.UV_GAIN_LIMIT = uv_gain_limit;
  if (reg->bitfields.UV_GAIN_LIMIT != uv_gain_limit) HSLDPF(E_ERROR_MESSAGE,"TV_GAIN_LIMIT_SETTINGS::UV_GAIN_LIMIT data too large\n");
}
#else
#define set_TV_GAIN_LIMIT_SETTINGS_y_gain_limit(reg, y_gain_limit) (reg)->bitfields.Y_GAIN_LIMIT = y_gain_limit
#define set_TV_GAIN_LIMIT_SETTINGS_uv_gain_limit(reg, uv_gain_limit) (reg)->bitfields.UV_GAIN_LIMIT = uv_gain_limit

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_LINEAR_GAIN_SETTINGS regTV_LINEAR_GAIN_SETTINGS;

#ifdef DEBUG
__inline void set_TV_LINEAR_GAIN_SETTINGS_y_gain(regTV_LINEAR_GAIN_SETTINGS *reg, unsigned int y_gain)
{
  reg->bitfields.Y_GAIN = y_gain;
  if (reg->bitfields.Y_GAIN != y_gain) HSLDPF(E_ERROR_MESSAGE,"TV_LINEAR_GAIN_SETTINGS::Y_GAIN data too large\n");
}
__inline void set_TV_LINEAR_GAIN_SETTINGS_uv_gain(regTV_LINEAR_GAIN_SETTINGS *reg, unsigned int uv_gain)
{
  reg->bitfields.UV_GAIN = uv_gain;
  if (reg->bitfields.UV_GAIN != uv_gain) HSLDPF(E_ERROR_MESSAGE,"TV_LINEAR_GAIN_SETTINGS::UV_GAIN data too large\n");
}
#else
#define set_TV_LINEAR_GAIN_SETTINGS_y_gain(reg, y_gain) (reg)->bitfields.Y_GAIN = y_gain
#define set_TV_LINEAR_GAIN_SETTINGS_uv_gain(reg, uv_gain) (reg)->bitfields.UV_GAIN = uv_gain

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_MODULATOR_CNTL1 regTV_MODULATOR_CNTL1;

#ifdef DEBUG
__inline void set_TV_MODULATOR_CNTL1_yy_filt_blend(regTV_MODULATOR_CNTL1 *reg, unsigned int yy_filt_blend)
{
  reg->bitfields.YY_FILT_BLEND = yy_filt_blend;
  if (reg->bitfields.YY_FILT_BLEND != yy_filt_blend) HSLDPF(E_ERROR_MESSAGE,"TV_MODULATOR_CNTL1::YY_FILT_BLEND data too large\n");
}
__inline void set_TV_MODULATOR_CNTL1_yflt_en(regTV_MODULATOR_CNTL1 *reg, unsigned int yflt_en)
{
  reg->bitfields.YFLT_EN = yflt_en;
  if (reg->bitfields.YFLT_EN != yflt_en) HSLDPF(E_ERROR_MESSAGE,"TV_MODULATOR_CNTL1::YFLT_EN data too large\n");
}
__inline void set_TV_MODULATOR_CNTL1_uvflt_en(regTV_MODULATOR_CNTL1 *reg, unsigned int uvflt_en)
{
  reg->bitfields.UVFLT_EN = uvflt_en;
  if (reg->bitfields.UVFLT_EN != uvflt_en) HSLDPF(E_ERROR_MESSAGE,"TV_MODULATOR_CNTL1::UVFLT_EN data too large\n");
}
__inline void set_TV_MODULATOR_CNTL1_alt_phase_en(regTV_MODULATOR_CNTL1 *reg, unsigned int alt_phase_en)
{
  reg->bitfields.ALT_PHASE_EN = alt_phase_en;
  if (reg->bitfields.ALT_PHASE_EN != alt_phase_en) HSLDPF(E_ERROR_MESSAGE,"TV_MODULATOR_CNTL1::ALT_PHASE_EN data too large\n");
}
__inline void set_TV_MODULATOR_CNTL1_sync_tip_level(regTV_MODULATOR_CNTL1 *reg, unsigned int sync_tip_level)
{
  reg->bitfields.SYNC_TIP_LEVEL = sync_tip_level;
  if (reg->bitfields.SYNC_TIP_LEVEL != sync_tip_level) HSLDPF(E_ERROR_MESSAGE,"TV_MODULATOR_CNTL1::SYNC_TIP_LEVEL data too large\n");
}
__inline void set_TV_MODULATOR_CNTL1_set_up_level(regTV_MODULATOR_CNTL1 *reg, unsigned int set_up_level)
{
  reg->bitfields.SET_UP_LEVEL = set_up_level;
  if (reg->bitfields.SET_UP_LEVEL != set_up_level) HSLDPF(E_ERROR_MESSAGE,"TV_MODULATOR_CNTL1::SET_UP_LEVEL data too large\n");
}
__inline void set_TV_MODULATOR_CNTL1_blank_level(regTV_MODULATOR_CNTL1 *reg, unsigned int blank_level)
{
  reg->bitfields.BLANK_LEVEL = blank_level;
  if (reg->bitfields.BLANK_LEVEL != blank_level) HSLDPF(E_ERROR_MESSAGE,"TV_MODULATOR_CNTL1::BLANK_LEVEL data too large\n");
}
__inline void set_TV_MODULATOR_CNTL1_slew_rate_limit(regTV_MODULATOR_CNTL1 *reg, unsigned int slew_rate_limit)
{
  reg->bitfields.SLEW_RATE_LIMIT = slew_rate_limit;
  if (reg->bitfields.SLEW_RATE_LIMIT != slew_rate_limit) HSLDPF(E_ERROR_MESSAGE,"TV_MODULATOR_CNTL1::SLEW_RATE_LIMIT data too large\n");
}
__inline void set_TV_MODULATOR_CNTL1_force_black_white(regTV_MODULATOR_CNTL1 *reg, unsigned int force_black_white)
{
  reg->bitfields.FORCE_BLACK_WHITE = force_black_white;
  if (reg->bitfields.FORCE_BLACK_WHITE != force_black_white) HSLDPF(E_ERROR_MESSAGE,"TV_MODULATOR_CNTL1::FORCE_BLACK_WHITE data too large\n");
}
__inline void set_TV_MODULATOR_CNTL1_mv_vsync_amp(regTV_MODULATOR_CNTL1 *reg, unsigned int mv_vsync_amp)
{
  reg->bitfields.MV_VSYNC_AMP = mv_vsync_amp;
  if (reg->bitfields.MV_VSYNC_AMP != mv_vsync_amp) HSLDPF(E_ERROR_MESSAGE,"TV_MODULATOR_CNTL1::MV_VSYNC_AMP data too large\n");
}
__inline void set_TV_MODULATOR_CNTL1_mv_hsync_amp(regTV_MODULATOR_CNTL1 *reg, unsigned int mv_hsync_amp)
{
  reg->bitfields.MV_HSYNC_AMP = mv_hsync_amp;
  if (reg->bitfields.MV_HSYNC_AMP != mv_hsync_amp) HSLDPF(E_ERROR_MESSAGE,"TV_MODULATOR_CNTL1::MV_HSYNC_AMP data too large\n");
}
__inline void set_TV_MODULATOR_CNTL1_cy_filt_blend(regTV_MODULATOR_CNTL1 *reg, unsigned int cy_filt_blend)
{
  reg->bitfields.CY_FILT_BLEND = cy_filt_blend;
  if (reg->bitfields.CY_FILT_BLEND != cy_filt_blend) HSLDPF(E_ERROR_MESSAGE,"TV_MODULATOR_CNTL1::CY_FILT_BLEND data too large\n");
}
#else
#define set_TV_MODULATOR_CNTL1_yy_filt_blend(reg, yy_filt_blend) (reg)->bitfields.YY_FILT_BLEND = yy_filt_blend
#define set_TV_MODULATOR_CNTL1_yflt_en(reg, yflt_en) (reg)->bitfields.YFLT_EN = yflt_en
#define set_TV_MODULATOR_CNTL1_uvflt_en(reg, uvflt_en) (reg)->bitfields.UVFLT_EN = uvflt_en
#define set_TV_MODULATOR_CNTL1_alt_phase_en(reg, alt_phase_en) (reg)->bitfields.ALT_PHASE_EN = alt_phase_en
#define set_TV_MODULATOR_CNTL1_sync_tip_level(reg, sync_tip_level) (reg)->bitfields.SYNC_TIP_LEVEL = sync_tip_level
#define set_TV_MODULATOR_CNTL1_set_up_level(reg, set_up_level) (reg)->bitfields.SET_UP_LEVEL = set_up_level
#define set_TV_MODULATOR_CNTL1_blank_level(reg, blank_level) (reg)->bitfields.BLANK_LEVEL = blank_level
#define set_TV_MODULATOR_CNTL1_slew_rate_limit(reg, slew_rate_limit) (reg)->bitfields.SLEW_RATE_LIMIT = slew_rate_limit
#define set_TV_MODULATOR_CNTL1_force_black_white(reg, force_black_white) (reg)->bitfields.FORCE_BLACK_WHITE = force_black_white
#define set_TV_MODULATOR_CNTL1_mv_vsync_amp(reg, mv_vsync_amp) (reg)->bitfields.MV_VSYNC_AMP = mv_vsync_amp
#define set_TV_MODULATOR_CNTL1_mv_hsync_amp(reg, mv_hsync_amp) (reg)->bitfields.MV_HSYNC_AMP = mv_hsync_amp
#define set_TV_MODULATOR_CNTL1_cy_filt_blend(reg, cy_filt_blend) (reg)->bitfields.CY_FILT_BLEND = cy_filt_blend

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_MODULATOR_CNTL2 regTV_MODULATOR_CNTL2;

#ifdef DEBUG
__inline void set_TV_MODULATOR_CNTL2_u_burst_level(regTV_MODULATOR_CNTL2 *reg, unsigned int u_burst_level)
{
  reg->bitfields.U_BURST_LEVEL = u_burst_level;
  if (reg->bitfields.U_BURST_LEVEL != u_burst_level) HSLDPF(E_ERROR_MESSAGE,"TV_MODULATOR_CNTL2::U_BURST_LEVEL data too large\n");
}
__inline void set_TV_MODULATOR_CNTL2_v_burst_level(regTV_MODULATOR_CNTL2 *reg, unsigned int v_burst_level)
{
  reg->bitfields.V_BURST_LEVEL = v_burst_level;
  if (reg->bitfields.V_BURST_LEVEL != v_burst_level) HSLDPF(E_ERROR_MESSAGE,"TV_MODULATOR_CNTL2::V_BURST_LEVEL data too large\n");
}
__inline void set_TV_MODULATOR_CNTL2_setup_delay(regTV_MODULATOR_CNTL2 *reg, unsigned int setup_delay)
{
  reg->bitfields.SETUP_DELAY = setup_delay;
  if (reg->bitfields.SETUP_DELAY != setup_delay) HSLDPF(E_ERROR_MESSAGE,"TV_MODULATOR_CNTL2::SETUP_DELAY data too large\n");
}
#else
#define set_TV_MODULATOR_CNTL2_u_burst_level(reg, u_burst_level) (reg)->bitfields.U_BURST_LEVEL = u_burst_level
#define set_TV_MODULATOR_CNTL2_v_burst_level(reg, v_burst_level) (reg)->bitfields.V_BURST_LEVEL = v_burst_level
#define set_TV_MODULATOR_CNTL2_setup_delay(reg, setup_delay) (reg)->bitfields.SETUP_DELAY = setup_delay

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_MV_MODE_CNTL regTV_MV_MODE_CNTL;

#ifdef DEBUG
__inline void set_TV_MV_MODE_CNTL_mv_agc_cyc_mode(regTV_MV_MODE_CNTL *reg, unsigned int mv_agc_cyc_mode)
{
  reg->bitfields.MV_AGC_CYC_MODE = mv_agc_cyc_mode;
  if (reg->bitfields.MV_AGC_CYC_MODE != mv_agc_cyc_mode) HSLDPF(E_ERROR_MESSAGE,"TV_MV_MODE_CNTL::MV_AGC_CYC_MODE data too large\n");
}
__inline void set_TV_MV_MODE_CNTL_mv_agc_cyc_tmode_en(regTV_MV_MODE_CNTL *reg, unsigned int mv_agc_cyc_tmode_en)
{
  reg->bitfields.MV_AGC_CYC_TMODE_EN = mv_agc_cyc_tmode_en;
  if (reg->bitfields.MV_AGC_CYC_TMODE_EN != mv_agc_cyc_tmode_en) HSLDPF(E_ERROR_MESSAGE,"TV_MV_MODE_CNTL::MV_AGC_CYC_TMODE_EN data too large\n");
}
__inline void set_TV_MV_MODE_CNTL_mv_agc_ampl_step(regTV_MV_MODE_CNTL *reg, unsigned int mv_agc_ampl_step)
{
  reg->bitfields.MV_AGC_AMPL_STEP = mv_agc_ampl_step;
  if (reg->bitfields.MV_AGC_AMPL_STEP != mv_agc_ampl_step) HSLDPF(E_ERROR_MESSAGE,"TV_MV_MODE_CNTL::MV_AGC_AMPL_STEP data too large\n");
}
__inline void set_TV_MV_MODE_CNTL_mv_agc_clk_devide_sel(regTV_MV_MODE_CNTL *reg, unsigned int mv_agc_clk_devide_sel)
{
  reg->bitfields.MV_AGC_CLK_DEVIDE_SEL = mv_agc_clk_devide_sel;
  if (reg->bitfields.MV_AGC_CLK_DEVIDE_SEL != mv_agc_clk_devide_sel) HSLDPF(E_ERROR_MESSAGE,"TV_MV_MODE_CNTL::MV_AGC_CLK_DEVIDE_SEL data too large\n");
}
__inline void set_TV_MV_MODE_CNTL_mv_ovrb_en(regTV_MV_MODE_CNTL *reg, unsigned int mv_ovrb_en)
{
  reg->bitfields.MV_OVRB_EN = mv_ovrb_en;
  if (reg->bitfields.MV_OVRB_EN != mv_ovrb_en) HSLDPF(E_ERROR_MESSAGE,"TV_MV_MODE_CNTL::MV_OVRB_EN data too large\n");
}
__inline void set_TV_MV_MODE_CNTL_mv_ovrb_level(regTV_MV_MODE_CNTL *reg, unsigned int mv_ovrb_level)
{
  reg->bitfields.MV_OVRB_LEVEL = mv_ovrb_level;
  if (reg->bitfields.MV_OVRB_LEVEL != mv_ovrb_level) HSLDPF(E_ERROR_MESSAGE,"TV_MV_MODE_CNTL::MV_OVRB_LEVEL data too large\n");
}
#else
#define set_TV_MV_MODE_CNTL_mv_agc_cyc_mode(reg, mv_agc_cyc_mode) (reg)->bitfields.MV_AGC_CYC_MODE = mv_agc_cyc_mode
#define set_TV_MV_MODE_CNTL_mv_agc_cyc_tmode_en(reg, mv_agc_cyc_tmode_en) (reg)->bitfields.MV_AGC_CYC_TMODE_EN = mv_agc_cyc_tmode_en
#define set_TV_MV_MODE_CNTL_mv_agc_ampl_step(reg, mv_agc_ampl_step) (reg)->bitfields.MV_AGC_AMPL_STEP = mv_agc_ampl_step
#define set_TV_MV_MODE_CNTL_mv_agc_clk_devide_sel(reg, mv_agc_clk_devide_sel) (reg)->bitfields.MV_AGC_CLK_DEVIDE_SEL = mv_agc_clk_devide_sel
#define set_TV_MV_MODE_CNTL_mv_ovrb_en(reg, mv_ovrb_en) (reg)->bitfields.MV_OVRB_EN = mv_ovrb_en
#define set_TV_MV_MODE_CNTL_mv_ovrb_level(reg, mv_ovrb_level) (reg)->bitfields.MV_OVRB_LEVEL = mv_ovrb_level

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_MV_STRIPE_CNTL regTV_MV_STRIPE_CNTL;

#ifdef DEBUG
__inline void set_TV_MV_STRIPE_CNTL_mv_line_1_phase(regTV_MV_STRIPE_CNTL *reg, unsigned int mv_line_1_phase)
{
  reg->bitfields.MV_LINE_1_PHASE = mv_line_1_phase;
  if (reg->bitfields.MV_LINE_1_PHASE != mv_line_1_phase) HSLDPF(E_ERROR_MESSAGE,"TV_MV_STRIPE_CNTL::MV_LINE_1_PHASE data too large\n");
}
__inline void set_TV_MV_STRIPE_CNTL_mv_line_2_phase(regTV_MV_STRIPE_CNTL *reg, unsigned int mv_line_2_phase)
{
  reg->bitfields.MV_LINE_2_PHASE = mv_line_2_phase;
  if (reg->bitfields.MV_LINE_2_PHASE != mv_line_2_phase) HSLDPF(E_ERROR_MESSAGE,"TV_MV_STRIPE_CNTL::MV_LINE_2_PHASE data too large\n");
}
__inline void set_TV_MV_STRIPE_CNTL_mv_line_3_phase(regTV_MV_STRIPE_CNTL *reg, unsigned int mv_line_3_phase)
{
  reg->bitfields.MV_LINE_3_PHASE = mv_line_3_phase;
  if (reg->bitfields.MV_LINE_3_PHASE != mv_line_3_phase) HSLDPF(E_ERROR_MESSAGE,"TV_MV_STRIPE_CNTL::MV_LINE_3_PHASE data too large\n");
}
__inline void set_TV_MV_STRIPE_CNTL_mv_line_4_phase(regTV_MV_STRIPE_CNTL *reg, unsigned int mv_line_4_phase)
{
  reg->bitfields.MV_LINE_4_PHASE = mv_line_4_phase;
  if (reg->bitfields.MV_LINE_4_PHASE != mv_line_4_phase) HSLDPF(E_ERROR_MESSAGE,"TV_MV_STRIPE_CNTL::MV_LINE_4_PHASE data too large\n");
}
__inline void set_TV_MV_STRIPE_CNTL_mv_line_5_phase(regTV_MV_STRIPE_CNTL *reg, unsigned int mv_line_5_phase)
{
  reg->bitfields.MV_LINE_5_PHASE = mv_line_5_phase;
  if (reg->bitfields.MV_LINE_5_PHASE != mv_line_5_phase) HSLDPF(E_ERROR_MESSAGE,"TV_MV_STRIPE_CNTL::MV_LINE_5_PHASE data too large\n");
}
#else
#define set_TV_MV_STRIPE_CNTL_mv_line_1_phase(reg, mv_line_1_phase) (reg)->bitfields.MV_LINE_1_PHASE = mv_line_1_phase
#define set_TV_MV_STRIPE_CNTL_mv_line_2_phase(reg, mv_line_2_phase) (reg)->bitfields.MV_LINE_2_PHASE = mv_line_2_phase
#define set_TV_MV_STRIPE_CNTL_mv_line_3_phase(reg, mv_line_3_phase) (reg)->bitfields.MV_LINE_3_PHASE = mv_line_3_phase
#define set_TV_MV_STRIPE_CNTL_mv_line_4_phase(reg, mv_line_4_phase) (reg)->bitfields.MV_LINE_4_PHASE = mv_line_4_phase
#define set_TV_MV_STRIPE_CNTL_mv_line_5_phase(reg, mv_line_5_phase) (reg)->bitfields.MV_LINE_5_PHASE = mv_line_5_phase

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_MV_LEVEL_CNTL regTV_MV_LEVEL_CNTL;

#ifdef DEBUG
__inline void set_TV_MV_LEVEL_CNTL_mv_blank_level(regTV_MV_LEVEL_CNTL *reg, unsigned int mv_blank_level)
{
  reg->bitfields.MV_BLANK_LEVEL = mv_blank_level;
  if (reg->bitfields.MV_BLANK_LEVEL != mv_blank_level) HSLDPF(E_ERROR_MESSAGE,"TV_MV_LEVEL_CNTL::MV_BLANK_LEVEL data too large\n");
}
__inline void set_TV_MV_LEVEL_CNTL_mv_setup_level(regTV_MV_LEVEL_CNTL *reg, unsigned int mv_setup_level)
{
  reg->bitfields.MV_SETUP_LEVEL = mv_setup_level;
  if (reg->bitfields.MV_SETUP_LEVEL != mv_setup_level) HSLDPF(E_ERROR_MESSAGE,"TV_MV_LEVEL_CNTL::MV_SETUP_LEVEL data too large\n");
}
__inline void set_TV_MV_LEVEL_CNTL_mv_agc_ampl_a(regTV_MV_LEVEL_CNTL *reg, unsigned int mv_agc_ampl_a)
{
  reg->bitfields.MV_AGC_AMPL_A = mv_agc_ampl_a;
  if (reg->bitfields.MV_AGC_AMPL_A != mv_agc_ampl_a) HSLDPF(E_ERROR_MESSAGE,"TV_MV_LEVEL_CNTL::MV_AGC_AMPL_A data too large\n");
}
__inline void set_TV_MV_LEVEL_CNTL_mv_agc_ampl_b(regTV_MV_LEVEL_CNTL *reg, unsigned int mv_agc_ampl_b)
{
  reg->bitfields.MV_AGC_AMPL_B = mv_agc_ampl_b;
  if (reg->bitfields.MV_AGC_AMPL_B != mv_agc_ampl_b) HSLDPF(E_ERROR_MESSAGE,"TV_MV_LEVEL_CNTL::MV_AGC_AMPL_B data too large\n");
}
#else
#define set_TV_MV_LEVEL_CNTL_mv_blank_level(reg, mv_blank_level) (reg)->bitfields.MV_BLANK_LEVEL = mv_blank_level
#define set_TV_MV_LEVEL_CNTL_mv_setup_level(reg, mv_setup_level) (reg)->bitfields.MV_SETUP_LEVEL = mv_setup_level
#define set_TV_MV_LEVEL_CNTL_mv_agc_ampl_a(reg, mv_agc_ampl_a) (reg)->bitfields.MV_AGC_AMPL_A = mv_agc_ampl_a
#define set_TV_MV_LEVEL_CNTL_mv_agc_ampl_b(reg, mv_agc_ampl_b) (reg)->bitfields.MV_AGC_AMPL_B = mv_agc_ampl_b

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_MV_LEVEL_CNTL2 regTV_MV_LEVEL_CNTL2;

#ifdef DEBUG
__inline void set_TV_MV_LEVEL_CNTL2_mv_agc_ampl_max(regTV_MV_LEVEL_CNTL2 *reg, unsigned int mv_agc_ampl_max)
{
  reg->bitfields.MV_AGC_AMPL_MAX = mv_agc_ampl_max;
  if (reg->bitfields.MV_AGC_AMPL_MAX != mv_agc_ampl_max) HSLDPF(E_ERROR_MESSAGE,"TV_MV_LEVEL_CNTL2::MV_AGC_AMPL_MAX data too large\n");
}
__inline void set_TV_MV_LEVEL_CNTL2_mv_bp_level(regTV_MV_LEVEL_CNTL2 *reg, unsigned int mv_bp_level)
{
  reg->bitfields.MV_BP_LEVEL = mv_bp_level;
  if (reg->bitfields.MV_BP_LEVEL != mv_bp_level) HSLDPF(E_ERROR_MESSAGE,"TV_MV_LEVEL_CNTL2::MV_BP_LEVEL data too large\n");
}
#else
#define set_TV_MV_LEVEL_CNTL2_mv_agc_ampl_max(reg, mv_agc_ampl_max) (reg)->bitfields.MV_AGC_AMPL_MAX = mv_agc_ampl_max
#define set_TV_MV_LEVEL_CNTL2_mv_bp_level(reg, mv_bp_level) (reg)->bitfields.MV_BP_LEVEL = mv_bp_level

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_PRE_DAC_MUX_CNTL regTV_PRE_DAC_MUX_CNTL;

#ifdef DEBUG
__inline void set_TV_PRE_DAC_MUX_CNTL_y_red_en(regTV_PRE_DAC_MUX_CNTL *reg, unsigned int y_red_en)
{
  reg->bitfields.Y_RED_EN = y_red_en;
  if (reg->bitfields.Y_RED_EN != y_red_en) HSLDPF(E_ERROR_MESSAGE,"TV_PRE_DAC_MUX_CNTL::Y_RED_EN data too large\n");
}
__inline void set_TV_PRE_DAC_MUX_CNTL_c_grn_en(regTV_PRE_DAC_MUX_CNTL *reg, unsigned int c_grn_en)
{
  reg->bitfields.C_GRN_EN = c_grn_en;
  if (reg->bitfields.C_GRN_EN != c_grn_en) HSLDPF(E_ERROR_MESSAGE,"TV_PRE_DAC_MUX_CNTL::C_GRN_EN data too large\n");
}
__inline void set_TV_PRE_DAC_MUX_CNTL_cmp_blu_en(regTV_PRE_DAC_MUX_CNTL *reg, unsigned int cmp_blu_en)
{
  reg->bitfields.CMP_BLU_EN = cmp_blu_en;
  if (reg->bitfields.CMP_BLU_EN != cmp_blu_en) HSLDPF(E_ERROR_MESSAGE,"TV_PRE_DAC_MUX_CNTL::CMP_BLU_EN data too large\n");
}
__inline void set_TV_PRE_DAC_MUX_CNTL_dac_dither_en(regTV_PRE_DAC_MUX_CNTL *reg, unsigned int dac_dither_en)
{
  reg->bitfields.DAC_DITHER_EN = dac_dither_en;
  if (reg->bitfields.DAC_DITHER_EN != dac_dither_en) HSLDPF(E_ERROR_MESSAGE,"TV_PRE_DAC_MUX_CNTL::DAC_DITHER_EN data too large\n");
}
__inline void set_TV_PRE_DAC_MUX_CNTL_red_mx(regTV_PRE_DAC_MUX_CNTL *reg, unsigned int red_mx)
{
  reg->bitfields.RED_MX = red_mx;
  if (reg->bitfields.RED_MX != red_mx) HSLDPF(E_ERROR_MESSAGE,"TV_PRE_DAC_MUX_CNTL::RED_MX data too large\n");
}
__inline void set_TV_PRE_DAC_MUX_CNTL_grn_mx(regTV_PRE_DAC_MUX_CNTL *reg, unsigned int grn_mx)
{
  reg->bitfields.GRN_MX = grn_mx;
  if (reg->bitfields.GRN_MX != grn_mx) HSLDPF(E_ERROR_MESSAGE,"TV_PRE_DAC_MUX_CNTL::GRN_MX data too large\n");
}
__inline void set_TV_PRE_DAC_MUX_CNTL_blu_mx(regTV_PRE_DAC_MUX_CNTL *reg, unsigned int blu_mx)
{
  reg->bitfields.BLU_MX = blu_mx;
  if (reg->bitfields.BLU_MX != blu_mx) HSLDPF(E_ERROR_MESSAGE,"TV_PRE_DAC_MUX_CNTL::BLU_MX data too large\n");
}
__inline void set_TV_PRE_DAC_MUX_CNTL_force_dac_data(regTV_PRE_DAC_MUX_CNTL *reg, unsigned int force_dac_data)
{
  reg->bitfields.FORCE_DAC_DATA = force_dac_data;
  if (reg->bitfields.FORCE_DAC_DATA != force_dac_data) HSLDPF(E_ERROR_MESSAGE,"TV_PRE_DAC_MUX_CNTL::FORCE_DAC_DATA data too large\n");
}
#else
#define set_TV_PRE_DAC_MUX_CNTL_y_red_en(reg, y_red_en) (reg)->bitfields.Y_RED_EN = y_red_en
#define set_TV_PRE_DAC_MUX_CNTL_c_grn_en(reg, c_grn_en) (reg)->bitfields.C_GRN_EN = c_grn_en
#define set_TV_PRE_DAC_MUX_CNTL_cmp_blu_en(reg, cmp_blu_en) (reg)->bitfields.CMP_BLU_EN = cmp_blu_en
#define set_TV_PRE_DAC_MUX_CNTL_dac_dither_en(reg, dac_dither_en) (reg)->bitfields.DAC_DITHER_EN = dac_dither_en
#define set_TV_PRE_DAC_MUX_CNTL_red_mx(reg, red_mx) (reg)->bitfields.RED_MX = red_mx
#define set_TV_PRE_DAC_MUX_CNTL_grn_mx(reg, grn_mx) (reg)->bitfields.GRN_MX = grn_mx
#define set_TV_PRE_DAC_MUX_CNTL_blu_mx(reg, blu_mx) (reg)->bitfields.BLU_MX = blu_mx
#define set_TV_PRE_DAC_MUX_CNTL_force_dac_data(reg, force_dac_data) (reg)->bitfields.FORCE_DAC_DATA = force_dac_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_DAC_CNTL regTV_DAC_CNTL;

#ifdef DEBUG
__inline void set_TV_DAC_CNTL_nblank(regTV_DAC_CNTL *reg, unsigned int nblank)
{
  reg->bitfields.NBLANK = nblank;
  if (reg->bitfields.NBLANK != nblank) HSLDPF(E_ERROR_MESSAGE,"TV_DAC_CNTL::NBLANK data too large\n");
}
__inline void set_TV_DAC_CNTL_nhold(regTV_DAC_CNTL *reg, unsigned int nhold)
{
  reg->bitfields.NHOLD = nhold;
  if (reg->bitfields.NHOLD != nhold) HSLDPF(E_ERROR_MESSAGE,"TV_DAC_CNTL::NHOLD data too large\n");
}
__inline void set_TV_DAC_CNTL_pedestal(regTV_DAC_CNTL *reg, unsigned int pedestal)
{
  reg->bitfields.PEDESTAL = pedestal;
  if (reg->bitfields.PEDESTAL != pedestal) HSLDPF(E_ERROR_MESSAGE,"TV_DAC_CNTL::PEDESTAL data too large\n");
}
__inline void set_TV_DAC_CNTL_detect(regTV_DAC_CNTL *reg, unsigned int detect)
{
  reg->bitfields.DETECT = detect;
  if (reg->bitfields.DETECT != detect) HSLDPF(E_ERROR_MESSAGE,"TV_DAC_CNTL::DETECT data too large\n");
}
__inline void set_TV_DAC_CNTL_cmpout(regTV_DAC_CNTL *reg, unsigned int cmpout)
{
  reg->bitfields.CMPOUT = cmpout;
  if (reg->bitfields.CMPOUT != cmpout) HSLDPF(E_ERROR_MESSAGE,"TV_DAC_CNTL::CMPOUT data too large\n");
}
__inline void set_TV_DAC_CNTL_bgsleep(regTV_DAC_CNTL *reg, unsigned int bgsleep)
{
  reg->bitfields.BGSLEEP = bgsleep;
  if (reg->bitfields.BGSLEEP != bgsleep) HSLDPF(E_ERROR_MESSAGE,"TV_DAC_CNTL::BGSLEEP data too large\n");
}
__inline void set_TV_DAC_CNTL_std(regTV_DAC_CNTL *reg, unsigned int std)
{
  reg->bitfields.STD = std;
  if (reg->bitfields.STD != std) HSLDPF(E_ERROR_MESSAGE,"TV_DAC_CNTL::STD data too large\n");
}
__inline void set_TV_DAC_CNTL_mon(regTV_DAC_CNTL *reg, unsigned int mon)
{
  reg->bitfields.MON = mon;
  if (reg->bitfields.MON != mon) HSLDPF(E_ERROR_MESSAGE,"TV_DAC_CNTL::MON data too large\n");
}
__inline void set_TV_DAC_CNTL_bgadj(regTV_DAC_CNTL *reg, unsigned int bgadj)
{
  reg->bitfields.BGADJ = bgadj;
  if (reg->bitfields.BGADJ != bgadj) HSLDPF(E_ERROR_MESSAGE,"TV_DAC_CNTL::BGADJ data too large\n");
}
__inline void set_TV_DAC_CNTL_dacadj(regTV_DAC_CNTL *reg, unsigned int dacadj)
{
  reg->bitfields.DACADJ = dacadj;
  if (reg->bitfields.DACADJ != dacadj) HSLDPF(E_ERROR_MESSAGE,"TV_DAC_CNTL::DACADJ data too large\n");
}
__inline void set_TV_DAC_CNTL_rdacpd(regTV_DAC_CNTL *reg, unsigned int rdacpd)
{
  reg->bitfields.RDACPD = rdacpd;
  if (reg->bitfields.RDACPD != rdacpd) HSLDPF(E_ERROR_MESSAGE,"TV_DAC_CNTL::RDACPD data too large\n");
}
__inline void set_TV_DAC_CNTL_gdacpd(regTV_DAC_CNTL *reg, unsigned int gdacpd)
{
  reg->bitfields.GDACPD = gdacpd;
  if (reg->bitfields.GDACPD != gdacpd) HSLDPF(E_ERROR_MESSAGE,"TV_DAC_CNTL::GDACPD data too large\n");
}
__inline void set_TV_DAC_CNTL_bdacpd(regTV_DAC_CNTL *reg, unsigned int bdacpd)
{
  reg->bitfields.BDACPD = bdacpd;
  if (reg->bitfields.BDACPD != bdacpd) HSLDPF(E_ERROR_MESSAGE,"TV_DAC_CNTL::BDACPD data too large\n");
}
__inline void set_TV_DAC_CNTL_rdacdet(regTV_DAC_CNTL *reg, unsigned int rdacdet)
{
  reg->bitfields.RDACDET = rdacdet;
  if (reg->bitfields.RDACDET != rdacdet) HSLDPF(E_ERROR_MESSAGE,"TV_DAC_CNTL::RDACDET data too large\n");
}
__inline void set_TV_DAC_CNTL_gdacdet(regTV_DAC_CNTL *reg, unsigned int gdacdet)
{
  reg->bitfields.GDACDET = gdacdet;
  if (reg->bitfields.GDACDET != gdacdet) HSLDPF(E_ERROR_MESSAGE,"TV_DAC_CNTL::GDACDET data too large\n");
}
__inline void set_TV_DAC_CNTL_bdacdet(regTV_DAC_CNTL *reg, unsigned int bdacdet)
{
  reg->bitfields.BDACDET = bdacdet;
  if (reg->bitfields.BDACDET != bdacdet) HSLDPF(E_ERROR_MESSAGE,"TV_DAC_CNTL::BDACDET data too large\n");
}
#else
#define set_TV_DAC_CNTL_nblank(reg, nblank) (reg)->bitfields.NBLANK = nblank
#define set_TV_DAC_CNTL_nhold(reg, nhold) (reg)->bitfields.NHOLD = nhold
#define set_TV_DAC_CNTL_pedestal(reg, pedestal) (reg)->bitfields.PEDESTAL = pedestal
#define set_TV_DAC_CNTL_detect(reg, detect) (reg)->bitfields.DETECT = detect
#define set_TV_DAC_CNTL_cmpout(reg, cmpout) (reg)->bitfields.CMPOUT = cmpout
#define set_TV_DAC_CNTL_bgsleep(reg, bgsleep) (reg)->bitfields.BGSLEEP = bgsleep
#define set_TV_DAC_CNTL_std(reg, std) (reg)->bitfields.STD = std
#define set_TV_DAC_CNTL_mon(reg, mon) (reg)->bitfields.MON = mon
#define set_TV_DAC_CNTL_bgadj(reg, bgadj) (reg)->bitfields.BGADJ = bgadj
#define set_TV_DAC_CNTL_dacadj(reg, dacadj) (reg)->bitfields.DACADJ = dacadj
#define set_TV_DAC_CNTL_rdacpd(reg, rdacpd) (reg)->bitfields.RDACPD = rdacpd
#define set_TV_DAC_CNTL_gdacpd(reg, gdacpd) (reg)->bitfields.GDACPD = gdacpd
#define set_TV_DAC_CNTL_bdacpd(reg, bdacpd) (reg)->bitfields.BDACPD = bdacpd
#define set_TV_DAC_CNTL_rdacdet(reg, rdacdet) (reg)->bitfields.RDACDET = rdacdet
#define set_TV_DAC_CNTL_gdacdet(reg, gdacdet) (reg)->bitfields.GDACDET = gdacdet
#define set_TV_DAC_CNTL_bdacdet(reg, bdacdet) (reg)->bitfields.BDACDET = bdacdet

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_CRC_CNTL regTV_CRC_CNTL;

#ifdef DEBUG
__inline void set_TV_CRC_CNTL_v_comp_data_en(regTV_CRC_CNTL *reg, unsigned int v_comp_data_en)
{
  reg->bitfields.V_COMP_DATA_EN = v_comp_data_en;
  if (reg->bitfields.V_COMP_DATA_EN != v_comp_data_en) HSLDPF(E_ERROR_MESSAGE,"TV_CRC_CNTL::V_COMP_DATA_EN data too large\n");
}
__inline void set_TV_CRC_CNTL_v_comp_gate(regTV_CRC_CNTL *reg, unsigned int v_comp_gate)
{
  reg->bitfields.V_COMP_GATE = v_comp_gate;
  if (reg->bitfields.V_COMP_GATE != v_comp_gate) HSLDPF(E_ERROR_MESSAGE,"TV_CRC_CNTL::V_COMP_GATE data too large\n");
}
__inline void set_TV_CRC_CNTL_v_comp_en(regTV_CRC_CNTL *reg, unsigned int v_comp_en)
{
  reg->bitfields.V_COMP_EN = v_comp_en;
  if (reg->bitfields.V_COMP_EN != v_comp_en) HSLDPF(E_ERROR_MESSAGE,"TV_CRC_CNTL::V_COMP_EN data too large\n");
}
__inline void set_TV_CRC_CNTL_rst_subc_onrstrt(regTV_CRC_CNTL *reg, unsigned int rst_subc_onrstrt)
{
  reg->bitfields.RST_SUBC_ONRSTRT = rst_subc_onrstrt;
  if (reg->bitfields.RST_SUBC_ONRSTRT != rst_subc_onrstrt) HSLDPF(E_ERROR_MESSAGE,"TV_CRC_CNTL::RST_SUBC_ONRSTRT data too large\n");
}
__inline void set_TV_CRC_CNTL_crc_tv_rstrt_sel(regTV_CRC_CNTL *reg, unsigned int crc_tv_rstrt_sel)
{
  reg->bitfields.CRC_TV_RSTRT_SEL = crc_tv_rstrt_sel;
  if (reg->bitfields.CRC_TV_RSTRT_SEL != crc_tv_rstrt_sel) HSLDPF(E_ERROR_MESSAGE,"TV_CRC_CNTL::CRC_TV_RSTRT_SEL data too large\n");
}
#else
#define set_TV_CRC_CNTL_v_comp_data_en(reg, v_comp_data_en) (reg)->bitfields.V_COMP_DATA_EN = v_comp_data_en
#define set_TV_CRC_CNTL_v_comp_gate(reg, v_comp_gate) (reg)->bitfields.V_COMP_GATE = v_comp_gate
#define set_TV_CRC_CNTL_v_comp_en(reg, v_comp_en) (reg)->bitfields.V_COMP_EN = v_comp_en
#define set_TV_CRC_CNTL_rst_subc_onrstrt(reg, rst_subc_onrstrt) (reg)->bitfields.RST_SUBC_ONRSTRT = rst_subc_onrstrt
#define set_TV_CRC_CNTL_crc_tv_rstrt_sel(reg, crc_tv_rstrt_sel) (reg)->bitfields.CRC_TV_RSTRT_SEL = crc_tv_rstrt_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_VIDEO_PORT_SIG regTV_VIDEO_PORT_SIG;

#ifdef DEBUG
__inline void set_TV_VIDEO_PORT_SIG_crc_sig(regTV_VIDEO_PORT_SIG *reg, unsigned int crc_sig)
{
  reg->bitfields.CRC_SIG = crc_sig;
  if (reg->bitfields.CRC_SIG != crc_sig) HSLDPF(E_ERROR_MESSAGE,"TV_VIDEO_PORT_SIG::CRC_SIG data too large\n");
}
#else
#define set_TV_VIDEO_PORT_SIG_crc_sig(reg, crc_sig) (reg)->bitfields.CRC_SIG = crc_sig

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_VBI_CC_CNTL regTV_VBI_CC_CNTL;

#ifdef DEBUG
__inline void set_TV_VBI_CC_CNTL_vbi_cc_data(regTV_VBI_CC_CNTL *reg, unsigned int vbi_cc_data)
{
  reg->bitfields.VBI_CC_DATA = vbi_cc_data;
  if (reg->bitfields.VBI_CC_DATA != vbi_cc_data) HSLDPF(E_ERROR_MESSAGE,"TV_VBI_CC_CNTL::VBI_CC_DATA data too large\n");
}
__inline void set_TV_VBI_CC_CNTL_vbi_cc_wt(regTV_VBI_CC_CNTL *reg, unsigned int vbi_cc_wt)
{
  reg->bitfields.VBI_CC_WT = vbi_cc_wt;
  if (reg->bitfields.VBI_CC_WT != vbi_cc_wt) HSLDPF(E_ERROR_MESSAGE,"TV_VBI_CC_CNTL::VBI_CC_WT data too large\n");
}
__inline void set_TV_VBI_CC_CNTL_vbi_cc_wt_ack(regTV_VBI_CC_CNTL *reg, unsigned int vbi_cc_wt_ack)
{
  reg->bitfields.VBI_CC_WT_ACK = vbi_cc_wt_ack;
  if (reg->bitfields.VBI_CC_WT_ACK != vbi_cc_wt_ack) HSLDPF(E_ERROR_MESSAGE,"TV_VBI_CC_CNTL::VBI_CC_WT_ACK data too large\n");
}
__inline void set_TV_VBI_CC_CNTL_vbi_cc_hold(regTV_VBI_CC_CNTL *reg, unsigned int vbi_cc_hold)
{
  reg->bitfields.VBI_CC_HOLD = vbi_cc_hold;
  if (reg->bitfields.VBI_CC_HOLD != vbi_cc_hold) HSLDPF(E_ERROR_MESSAGE,"TV_VBI_CC_CNTL::VBI_CC_HOLD data too large\n");
}
__inline void set_TV_VBI_CC_CNTL_vbi_decode_en(regTV_VBI_CC_CNTL *reg, unsigned int vbi_decode_en)
{
  reg->bitfields.VBI_DECODE_EN = vbi_decode_en;
  if (reg->bitfields.VBI_DECODE_EN != vbi_decode_en) HSLDPF(E_ERROR_MESSAGE,"TV_VBI_CC_CNTL::VBI_DECODE_EN data too large\n");
}
#else
#define set_TV_VBI_CC_CNTL_vbi_cc_data(reg, vbi_cc_data) (reg)->bitfields.VBI_CC_DATA = vbi_cc_data
#define set_TV_VBI_CC_CNTL_vbi_cc_wt(reg, vbi_cc_wt) (reg)->bitfields.VBI_CC_WT = vbi_cc_wt
#define set_TV_VBI_CC_CNTL_vbi_cc_wt_ack(reg, vbi_cc_wt_ack) (reg)->bitfields.VBI_CC_WT_ACK = vbi_cc_wt_ack
#define set_TV_VBI_CC_CNTL_vbi_cc_hold(reg, vbi_cc_hold) (reg)->bitfields.VBI_CC_HOLD = vbi_cc_hold
#define set_TV_VBI_CC_CNTL_vbi_decode_en(reg, vbi_decode_en) (reg)->bitfields.VBI_DECODE_EN = vbi_decode_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_VBI_EDS_CNTL regTV_VBI_EDS_CNTL;

#ifdef DEBUG
__inline void set_TV_VBI_EDS_CNTL_vbi_eds_data(regTV_VBI_EDS_CNTL *reg, unsigned int vbi_eds_data)
{
  reg->bitfields.VBI_EDS_DATA = vbi_eds_data;
  if (reg->bitfields.VBI_EDS_DATA != vbi_eds_data) HSLDPF(E_ERROR_MESSAGE,"TV_VBI_EDS_CNTL::VBI_EDS_DATA data too large\n");
}
__inline void set_TV_VBI_EDS_CNTL_vbi_eds_wt(regTV_VBI_EDS_CNTL *reg, unsigned int vbi_eds_wt)
{
  reg->bitfields.VBI_EDS_WT = vbi_eds_wt;
  if (reg->bitfields.VBI_EDS_WT != vbi_eds_wt) HSLDPF(E_ERROR_MESSAGE,"TV_VBI_EDS_CNTL::VBI_EDS_WT data too large\n");
}
__inline void set_TV_VBI_EDS_CNTL_vbi_eds_wt_ack(regTV_VBI_EDS_CNTL *reg, unsigned int vbi_eds_wt_ack)
{
  reg->bitfields.VBI_EDS_WT_ACK = vbi_eds_wt_ack;
  if (reg->bitfields.VBI_EDS_WT_ACK != vbi_eds_wt_ack) HSLDPF(E_ERROR_MESSAGE,"TV_VBI_EDS_CNTL::VBI_EDS_WT_ACK data too large\n");
}
__inline void set_TV_VBI_EDS_CNTL_vbi_eds_hold(regTV_VBI_EDS_CNTL *reg, unsigned int vbi_eds_hold)
{
  reg->bitfields.VBI_EDS_HOLD = vbi_eds_hold;
  if (reg->bitfields.VBI_EDS_HOLD != vbi_eds_hold) HSLDPF(E_ERROR_MESSAGE,"TV_VBI_EDS_CNTL::VBI_EDS_HOLD data too large\n");
}
#else
#define set_TV_VBI_EDS_CNTL_vbi_eds_data(reg, vbi_eds_data) (reg)->bitfields.VBI_EDS_DATA = vbi_eds_data
#define set_TV_VBI_EDS_CNTL_vbi_eds_wt(reg, vbi_eds_wt) (reg)->bitfields.VBI_EDS_WT = vbi_eds_wt
#define set_TV_VBI_EDS_CNTL_vbi_eds_wt_ack(reg, vbi_eds_wt_ack) (reg)->bitfields.VBI_EDS_WT_ACK = vbi_eds_wt_ack
#define set_TV_VBI_EDS_CNTL_vbi_eds_hold(reg, vbi_eds_hold) (reg)->bitfields.VBI_EDS_HOLD = vbi_eds_hold

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_VBI_20BIT_CNTL regTV_VBI_20BIT_CNTL;

#ifdef DEBUG
__inline void set_TV_VBI_20BIT_CNTL_vbi_20bit_data0(regTV_VBI_20BIT_CNTL *reg, unsigned int vbi_20bit_data0)
{
  reg->bitfields.VBI_20BIT_DATA0 = vbi_20bit_data0;
  if (reg->bitfields.VBI_20BIT_DATA0 != vbi_20bit_data0) HSLDPF(E_ERROR_MESSAGE,"TV_VBI_20BIT_CNTL::VBI_20BIT_DATA0 data too large\n");
}
__inline void set_TV_VBI_20BIT_CNTL_vbi_20bit_data1(regTV_VBI_20BIT_CNTL *reg, unsigned int vbi_20bit_data1)
{
  reg->bitfields.VBI_20BIT_DATA1 = vbi_20bit_data1;
  if (reg->bitfields.VBI_20BIT_DATA1 != vbi_20bit_data1) HSLDPF(E_ERROR_MESSAGE,"TV_VBI_20BIT_CNTL::VBI_20BIT_DATA1 data too large\n");
}
__inline void set_TV_VBI_20BIT_CNTL_vbi_20bit_wt(regTV_VBI_20BIT_CNTL *reg, unsigned int vbi_20bit_wt)
{
  reg->bitfields.VBI_20BIT_WT = vbi_20bit_wt;
  if (reg->bitfields.VBI_20BIT_WT != vbi_20bit_wt) HSLDPF(E_ERROR_MESSAGE,"TV_VBI_20BIT_CNTL::VBI_20BIT_WT data too large\n");
}
__inline void set_TV_VBI_20BIT_CNTL_vbi_20bit_wt_ack(regTV_VBI_20BIT_CNTL *reg, unsigned int vbi_20bit_wt_ack)
{
  reg->bitfields.VBI_20BIT_WT_ACK = vbi_20bit_wt_ack;
  if (reg->bitfields.VBI_20BIT_WT_ACK != vbi_20bit_wt_ack) HSLDPF(E_ERROR_MESSAGE,"TV_VBI_20BIT_CNTL::VBI_20BIT_WT_ACK data too large\n");
}
__inline void set_TV_VBI_20BIT_CNTL_vbi_20bit_hold(regTV_VBI_20BIT_CNTL *reg, unsigned int vbi_20bit_hold)
{
  reg->bitfields.VBI_20BIT_HOLD = vbi_20bit_hold;
  if (reg->bitfields.VBI_20BIT_HOLD != vbi_20bit_hold) HSLDPF(E_ERROR_MESSAGE,"TV_VBI_20BIT_CNTL::VBI_20BIT_HOLD data too large\n");
}
#else
#define set_TV_VBI_20BIT_CNTL_vbi_20bit_data0(reg, vbi_20bit_data0) (reg)->bitfields.VBI_20BIT_DATA0 = vbi_20bit_data0
#define set_TV_VBI_20BIT_CNTL_vbi_20bit_data1(reg, vbi_20bit_data1) (reg)->bitfields.VBI_20BIT_DATA1 = vbi_20bit_data1
#define set_TV_VBI_20BIT_CNTL_vbi_20bit_wt(reg, vbi_20bit_wt) (reg)->bitfields.VBI_20BIT_WT = vbi_20bit_wt
#define set_TV_VBI_20BIT_CNTL_vbi_20bit_wt_ack(reg, vbi_20bit_wt_ack) (reg)->bitfields.VBI_20BIT_WT_ACK = vbi_20bit_wt_ack
#define set_TV_VBI_20BIT_CNTL_vbi_20bit_hold(reg, vbi_20bit_hold) (reg)->bitfields.VBI_20BIT_HOLD = vbi_20bit_hold

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_VBI_DTO_CNTL regTV_VBI_DTO_CNTL;

#ifdef DEBUG
__inline void set_TV_VBI_DTO_CNTL_vbi_cc_dto_p(regTV_VBI_DTO_CNTL *reg, unsigned int vbi_cc_dto_p)
{
  reg->bitfields.VBI_CC_DTO_P = vbi_cc_dto_p;
  if (reg->bitfields.VBI_CC_DTO_P != vbi_cc_dto_p) HSLDPF(E_ERROR_MESSAGE,"TV_VBI_DTO_CNTL::VBI_CC_DTO_P data too large\n");
}
__inline void set_TV_VBI_DTO_CNTL_vbi_20bit_dto_p(regTV_VBI_DTO_CNTL *reg, unsigned int vbi_20bit_dto_p)
{
  reg->bitfields.VBI_20BIT_DTO_P = vbi_20bit_dto_p;
  if (reg->bitfields.VBI_20BIT_DTO_P != vbi_20bit_dto_p) HSLDPF(E_ERROR_MESSAGE,"TV_VBI_DTO_CNTL::VBI_20BIT_DTO_P data too large\n");
}
#else
#define set_TV_VBI_DTO_CNTL_vbi_cc_dto_p(reg, vbi_cc_dto_p) (reg)->bitfields.VBI_CC_DTO_P = vbi_cc_dto_p
#define set_TV_VBI_DTO_CNTL_vbi_20bit_dto_p(reg, vbi_20bit_dto_p) (reg)->bitfields.VBI_20BIT_DTO_P = vbi_20bit_dto_p

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_VBI_LEVEL_CNTL regTV_VBI_LEVEL_CNTL;

#ifdef DEBUG
__inline void set_TV_VBI_LEVEL_CNTL_vbi_cc_level(regTV_VBI_LEVEL_CNTL *reg, unsigned int vbi_cc_level)
{
  reg->bitfields.VBI_CC_LEVEL = vbi_cc_level;
  if (reg->bitfields.VBI_CC_LEVEL != vbi_cc_level) HSLDPF(E_ERROR_MESSAGE,"TV_VBI_LEVEL_CNTL::VBI_CC_LEVEL data too large\n");
}
__inline void set_TV_VBI_LEVEL_CNTL_vbi_20bit_level(regTV_VBI_LEVEL_CNTL *reg, unsigned int vbi_20bit_level)
{
  reg->bitfields.VBI_20BIT_LEVEL = vbi_20bit_level;
  if (reg->bitfields.VBI_20BIT_LEVEL != vbi_20bit_level) HSLDPF(E_ERROR_MESSAGE,"TV_VBI_LEVEL_CNTL::VBI_20BIT_LEVEL data too large\n");
}
__inline void set_TV_VBI_LEVEL_CNTL_vbi_clk_runin_gain(regTV_VBI_LEVEL_CNTL *reg, unsigned int vbi_clk_runin_gain)
{
  reg->bitfields.VBI_CLK_RUNIN_GAIN = vbi_clk_runin_gain;
  if (reg->bitfields.VBI_CLK_RUNIN_GAIN != vbi_clk_runin_gain) HSLDPF(E_ERROR_MESSAGE,"TV_VBI_LEVEL_CNTL::VBI_CLK_RUNIN_GAIN data too large\n");
}
#else
#define set_TV_VBI_LEVEL_CNTL_vbi_cc_level(reg, vbi_cc_level) (reg)->bitfields.VBI_CC_LEVEL = vbi_cc_level
#define set_TV_VBI_LEVEL_CNTL_vbi_20bit_level(reg, vbi_20bit_level) (reg)->bitfields.VBI_20BIT_LEVEL = vbi_20bit_level
#define set_TV_VBI_LEVEL_CNTL_vbi_clk_runin_gain(reg, vbi_clk_runin_gain) (reg)->bitfields.VBI_CLK_RUNIN_GAIN = vbi_clk_runin_gain

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_UV_ADR regTV_UV_ADR;

#ifdef DEBUG
__inline void set_TV_UV_ADR_max_uv_adr(regTV_UV_ADR *reg, unsigned int max_uv_adr)
{
  reg->bitfields.MAX_UV_ADR = max_uv_adr;
  if (reg->bitfields.MAX_UV_ADR != max_uv_adr) HSLDPF(E_ERROR_MESSAGE,"TV_UV_ADR::MAX_UV_ADR data too large\n");
}
__inline void set_TV_UV_ADR_table1_bot_adr(regTV_UV_ADR *reg, unsigned int table1_bot_adr)
{
  reg->bitfields.TABLE1_BOT_ADR = table1_bot_adr;
  if (reg->bitfields.TABLE1_BOT_ADR != table1_bot_adr) HSLDPF(E_ERROR_MESSAGE,"TV_UV_ADR::TABLE1_BOT_ADR data too large\n");
}
__inline void set_TV_UV_ADR_table3_top_adr(regTV_UV_ADR *reg, unsigned int table3_top_adr)
{
  reg->bitfields.TABLE3_TOP_ADR = table3_top_adr;
  if (reg->bitfields.TABLE3_TOP_ADR != table3_top_adr) HSLDPF(E_ERROR_MESSAGE,"TV_UV_ADR::TABLE3_TOP_ADR data too large\n");
}
__inline void set_TV_UV_ADR_mv_decode_en(regTV_UV_ADR *reg, unsigned int mv_decode_en)
{
  reg->bitfields.MV_DECODE_EN = mv_decode_en;
  if (reg->bitfields.MV_DECODE_EN != mv_decode_en) HSLDPF(E_ERROR_MESSAGE,"TV_UV_ADR::MV_DECODE_EN data too large\n");
}
__inline void set_TV_UV_ADR_hcode_table_sel(regTV_UV_ADR *reg, unsigned int hcode_table_sel)
{
  reg->bitfields.HCODE_TABLE_SEL = hcode_table_sel;
  if (reg->bitfields.HCODE_TABLE_SEL != hcode_table_sel) HSLDPF(E_ERROR_MESSAGE,"TV_UV_ADR::HCODE_TABLE_SEL data too large\n");
}
__inline void set_TV_UV_ADR_vcode_table_sel(regTV_UV_ADR *reg, unsigned int vcode_table_sel)
{
  reg->bitfields.VCODE_TABLE_SEL = vcode_table_sel;
  if (reg->bitfields.VCODE_TABLE_SEL != vcode_table_sel) HSLDPF(E_ERROR_MESSAGE,"TV_UV_ADR::VCODE_TABLE_SEL data too large\n");
}
__inline void set_TV_UV_ADR_mv_lines_per_stripe(regTV_UV_ADR *reg, unsigned int mv_lines_per_stripe)
{
  reg->bitfields.MV_LINES_PER_STRIPE = mv_lines_per_stripe;
  if (reg->bitfields.MV_LINES_PER_STRIPE != mv_lines_per_stripe) HSLDPF(E_ERROR_MESSAGE,"TV_UV_ADR::MV_LINES_PER_STRIPE data too large\n");
}
__inline void set_TV_UV_ADR_switch_table_req(regTV_UV_ADR *reg, unsigned int switch_table_req)
{
  reg->bitfields.SWITCH_TABLE_REQ = switch_table_req;
  if (reg->bitfields.SWITCH_TABLE_REQ != switch_table_req) HSLDPF(E_ERROR_MESSAGE,"TV_UV_ADR::SWITCH_TABLE_REQ data too large\n");
}
#else
#define set_TV_UV_ADR_max_uv_adr(reg, max_uv_adr) (reg)->bitfields.MAX_UV_ADR = max_uv_adr
#define set_TV_UV_ADR_table1_bot_adr(reg, table1_bot_adr) (reg)->bitfields.TABLE1_BOT_ADR = table1_bot_adr
#define set_TV_UV_ADR_table3_top_adr(reg, table3_top_adr) (reg)->bitfields.TABLE3_TOP_ADR = table3_top_adr
#define set_TV_UV_ADR_mv_decode_en(reg, mv_decode_en) (reg)->bitfields.MV_DECODE_EN = mv_decode_en
#define set_TV_UV_ADR_hcode_table_sel(reg, hcode_table_sel) (reg)->bitfields.HCODE_TABLE_SEL = hcode_table_sel
#define set_TV_UV_ADR_vcode_table_sel(reg, vcode_table_sel) (reg)->bitfields.VCODE_TABLE_SEL = vcode_table_sel
#define set_TV_UV_ADR_mv_lines_per_stripe(reg, mv_lines_per_stripe) (reg)->bitfields.MV_LINES_PER_STRIPE = mv_lines_per_stripe
#define set_TV_UV_ADR_switch_table_req(reg, switch_table_req) (reg)->bitfields.SWITCH_TABLE_REQ = switch_table_req

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_VSYNC_DIFF_CNTL regTV_VSYNC_DIFF_CNTL;

#ifdef DEBUG
__inline void set_TV_VSYNC_DIFF_CNTL_vsync_diff_measure_en(regTV_VSYNC_DIFF_CNTL *reg, unsigned int vsync_diff_measure_en)
{
  reg->bitfields.VSYNC_DIFF_MEASURE_EN = vsync_diff_measure_en;
  if (reg->bitfields.VSYNC_DIFF_MEASURE_EN != vsync_diff_measure_en) HSLDPF(E_ERROR_MESSAGE,"TV_VSYNC_DIFF_CNTL::VSYNC_DIFF_MEASURE_EN data too large\n");
}
__inline void set_TV_VSYNC_DIFF_CNTL_vsync_restart_at_limit(regTV_VSYNC_DIFF_CNTL *reg, unsigned int vsync_restart_at_limit)
{
  reg->bitfields.VSYNC_RESTART_AT_LIMIT = vsync_restart_at_limit;
  if (reg->bitfields.VSYNC_RESTART_AT_LIMIT != vsync_restart_at_limit) HSLDPF(E_ERROR_MESSAGE,"TV_VSYNC_DIFF_CNTL::VSYNC_RESTART_AT_LIMIT data too large\n");
}
__inline void set_TV_VSYNC_DIFF_CNTL_vsync_hw_lock_en(regTV_VSYNC_DIFF_CNTL *reg, unsigned int vsync_hw_lock_en)
{
  reg->bitfields.VSYNC_HW_LOCK_EN = vsync_hw_lock_en;
  if (reg->bitfields.VSYNC_HW_LOCK_EN != vsync_hw_lock_en) HSLDPF(E_ERROR_MESSAGE,"TV_VSYNC_DIFF_CNTL::VSYNC_HW_LOCK_EN data too large\n");
}
__inline void set_TV_VSYNC_DIFF_CNTL_vsync_hw_lock_type(regTV_VSYNC_DIFF_CNTL *reg, unsigned int vsync_hw_lock_type)
{
  reg->bitfields.VSYNC_HW_LOCK_TYPE = vsync_hw_lock_type;
  if (reg->bitfields.VSYNC_HW_LOCK_TYPE != vsync_hw_lock_type) HSLDPF(E_ERROR_MESSAGE,"TV_VSYNC_DIFF_CNTL::VSYNC_HW_LOCK_TYPE data too large\n");
}
__inline void set_TV_VSYNC_DIFF_CNTL_vsync_slip_req_en(regTV_VSYNC_DIFF_CNTL *reg, unsigned int vsync_slip_req_en)
{
  reg->bitfields.VSYNC_SLIP_REQ_EN = vsync_slip_req_en;
  if (reg->bitfields.VSYNC_SLIP_REQ_EN != vsync_slip_req_en) HSLDPF(E_ERROR_MESSAGE,"TV_VSYNC_DIFF_CNTL::VSYNC_SLIP_REQ_EN data too large\n");
}
__inline void set_TV_VSYNC_DIFF_CNTL_invert_lock_cntl(regTV_VSYNC_DIFF_CNTL *reg, unsigned int invert_lock_cntl)
{
  reg->bitfields.INVERT_LOCK_CNTL = invert_lock_cntl;
  if (reg->bitfields.INVERT_LOCK_CNTL != invert_lock_cntl) HSLDPF(E_ERROR_MESSAGE,"TV_VSYNC_DIFF_CNTL::INVERT_LOCK_CNTL data too large\n");
}
__inline void set_TV_VSYNC_DIFF_CNTL_slip_during_hsync_only(regTV_VSYNC_DIFF_CNTL *reg, unsigned int slip_during_hsync_only)
{
  reg->bitfields.SLIP_DURING_HSYNC_ONLY = slip_during_hsync_only;
  if (reg->bitfields.SLIP_DURING_HSYNC_ONLY != slip_during_hsync_only) HSLDPF(E_ERROR_MESSAGE,"TV_VSYNC_DIFF_CNTL::SLIP_DURING_HSYNC_ONLY data too large\n");
}
__inline void set_TV_VSYNC_DIFF_CNTL_restart_twice(regTV_VSYNC_DIFF_CNTL *reg, unsigned int restart_twice)
{
  reg->bitfields.RESTART_TWICE = restart_twice;
  if (reg->bitfields.RESTART_TWICE != restart_twice) HSLDPF(E_ERROR_MESSAGE,"TV_VSYNC_DIFF_CNTL::RESTART_TWICE data too large\n");
}
__inline void set_TV_VSYNC_DIFF_CNTL_delay_restart(regTV_VSYNC_DIFF_CNTL *reg, unsigned int delay_restart)
{
  reg->bitfields.DELAY_RESTART = delay_restart;
  if (reg->bitfields.DELAY_RESTART != delay_restart) HSLDPF(E_ERROR_MESSAGE,"TV_VSYNC_DIFF_CNTL::DELAY_RESTART data too large\n");
}
#else
#define set_TV_VSYNC_DIFF_CNTL_vsync_diff_measure_en(reg, vsync_diff_measure_en) (reg)->bitfields.VSYNC_DIFF_MEASURE_EN = vsync_diff_measure_en
#define set_TV_VSYNC_DIFF_CNTL_vsync_restart_at_limit(reg, vsync_restart_at_limit) (reg)->bitfields.VSYNC_RESTART_AT_LIMIT = vsync_restart_at_limit
#define set_TV_VSYNC_DIFF_CNTL_vsync_hw_lock_en(reg, vsync_hw_lock_en) (reg)->bitfields.VSYNC_HW_LOCK_EN = vsync_hw_lock_en
#define set_TV_VSYNC_DIFF_CNTL_vsync_hw_lock_type(reg, vsync_hw_lock_type) (reg)->bitfields.VSYNC_HW_LOCK_TYPE = vsync_hw_lock_type
#define set_TV_VSYNC_DIFF_CNTL_vsync_slip_req_en(reg, vsync_slip_req_en) (reg)->bitfields.VSYNC_SLIP_REQ_EN = vsync_slip_req_en
#define set_TV_VSYNC_DIFF_CNTL_invert_lock_cntl(reg, invert_lock_cntl) (reg)->bitfields.INVERT_LOCK_CNTL = invert_lock_cntl
#define set_TV_VSYNC_DIFF_CNTL_slip_during_hsync_only(reg, slip_during_hsync_only) (reg)->bitfields.SLIP_DURING_HSYNC_ONLY = slip_during_hsync_only
#define set_TV_VSYNC_DIFF_CNTL_restart_twice(reg, restart_twice) (reg)->bitfields.RESTART_TWICE = restart_twice
#define set_TV_VSYNC_DIFF_CNTL_delay_restart(reg, delay_restart) (reg)->bitfields.DELAY_RESTART = delay_restart

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_VSYNC_DIFF_LIMITS regTV_VSYNC_DIFF_LIMITS;

#ifdef DEBUG
__inline void set_TV_VSYNC_DIFF_LIMITS_diff_limit_low(regTV_VSYNC_DIFF_LIMITS *reg, unsigned int diff_limit_low)
{
  reg->bitfields.DIFF_LIMIT_LOW = diff_limit_low;
  if (reg->bitfields.DIFF_LIMIT_LOW != diff_limit_low) HSLDPF(E_ERROR_MESSAGE,"TV_VSYNC_DIFF_LIMITS::DIFF_LIMIT_LOW data too large\n");
}
__inline void set_TV_VSYNC_DIFF_LIMITS_diff_limit_high(regTV_VSYNC_DIFF_LIMITS *reg, unsigned int diff_limit_high)
{
  reg->bitfields.DIFF_LIMIT_HIGH = diff_limit_high;
  if (reg->bitfields.DIFF_LIMIT_HIGH != diff_limit_high) HSLDPF(E_ERROR_MESSAGE,"TV_VSYNC_DIFF_LIMITS::DIFF_LIMIT_HIGH data too large\n");
}
#else
#define set_TV_VSYNC_DIFF_LIMITS_diff_limit_low(reg, diff_limit_low) (reg)->bitfields.DIFF_LIMIT_LOW = diff_limit_low
#define set_TV_VSYNC_DIFF_LIMITS_diff_limit_high(reg, diff_limit_high) (reg)->bitfields.DIFF_LIMIT_HIGH = diff_limit_high

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_VSYNC_DIFF_RD_DATA regTV_VSYNC_DIFF_RD_DATA;

#ifdef DEBUG
__inline void set_TV_VSYNC_DIFF_RD_DATA_update_end_toggle(regTV_VSYNC_DIFF_RD_DATA *reg, unsigned int update_end_toggle)
{
  reg->bitfields.UPDATE_END_TOGGLE = update_end_toggle;
  if (reg->bitfields.UPDATE_END_TOGGLE != update_end_toggle) HSLDPF(E_ERROR_MESSAGE,"TV_VSYNC_DIFF_RD_DATA::UPDATE_END_TOGGLE data too large\n");
}
__inline void set_TV_VSYNC_DIFF_RD_DATA_vsync_diff(regTV_VSYNC_DIFF_RD_DATA *reg, unsigned int vsync_diff)
{
  reg->bitfields.VSYNC_DIFF = vsync_diff;
  if (reg->bitfields.VSYNC_DIFF != vsync_diff) HSLDPF(E_ERROR_MESSAGE,"TV_VSYNC_DIFF_RD_DATA::VSYNC_DIFF data too large\n");
}
__inline void set_TV_VSYNC_DIFF_RD_DATA_vsync_diff_overflow(regTV_VSYNC_DIFF_RD_DATA *reg, unsigned int vsync_diff_overflow)
{
  reg->bitfields.VSYNC_DIFF_OVERFLOW = vsync_diff_overflow;
  if (reg->bitfields.VSYNC_DIFF_OVERFLOW != vsync_diff_overflow) HSLDPF(E_ERROR_MESSAGE,"TV_VSYNC_DIFF_RD_DATA::VSYNC_DIFF_OVERFLOW data too large\n");
}
__inline void set_TV_VSYNC_DIFF_RD_DATA_tv_first(regTV_VSYNC_DIFF_RD_DATA *reg, unsigned int tv_first)
{
  reg->bitfields.TV_FIRST = tv_first;
  if (reg->bitfields.TV_FIRST != tv_first) HSLDPF(E_ERROR_MESSAGE,"TV_VSYNC_DIFF_RD_DATA::TV_FIRST data too large\n");
}
__inline void set_TV_VSYNC_DIFF_RD_DATA_update_start_toggle(regTV_VSYNC_DIFF_RD_DATA *reg, unsigned int update_start_toggle)
{
  reg->bitfields.UPDATE_START_TOGGLE = update_start_toggle;
  if (reg->bitfields.UPDATE_START_TOGGLE != update_start_toggle) HSLDPF(E_ERROR_MESSAGE,"TV_VSYNC_DIFF_RD_DATA::UPDATE_START_TOGGLE data too large\n");
}
#else
#define set_TV_VSYNC_DIFF_RD_DATA_update_end_toggle(reg, update_end_toggle) (reg)->bitfields.UPDATE_END_TOGGLE = update_end_toggle
#define set_TV_VSYNC_DIFF_RD_DATA_vsync_diff(reg, vsync_diff) (reg)->bitfields.VSYNC_DIFF = vsync_diff
#define set_TV_VSYNC_DIFF_RD_DATA_vsync_diff_overflow(reg, vsync_diff_overflow) (reg)->bitfields.VSYNC_DIFF_OVERFLOW = vsync_diff_overflow
#define set_TV_VSYNC_DIFF_RD_DATA_tv_first(reg, tv_first) (reg)->bitfields.TV_FIRST = tv_first
#define set_TV_VSYNC_DIFF_RD_DATA_update_start_toggle(reg, update_start_toggle) (reg)->bitfields.UPDATE_START_TOGGLE = update_start_toggle

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_RB_BASE regCP_RB_BASE;

#ifdef DEBUG
__inline void set_CP_RB_BASE_rb_base(regCP_RB_BASE *reg, unsigned int rb_base)
{
  reg->bitfields.RB_BASE = rb_base;
  if (reg->bitfields.RB_BASE != rb_base) HSLDPF(E_ERROR_MESSAGE,"CP_RB_BASE::RB_BASE data too large\n");
}
#else
#define set_CP_RB_BASE_rb_base(reg, rb_base) (reg)->bitfields.RB_BASE = rb_base

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_RB_CNTL regCP_RB_CNTL;

#ifdef DEBUG
__inline void set_CP_RB_CNTL_rb_bufsz(regCP_RB_CNTL *reg, unsigned int rb_bufsz)
{
  reg->bitfields.RB_BUFSZ = rb_bufsz;
  if (reg->bitfields.RB_BUFSZ != rb_bufsz) HSLDPF(E_ERROR_MESSAGE,"CP_RB_CNTL::RB_BUFSZ data too large\n");
}
__inline void set_CP_RB_CNTL_rb_blksz(regCP_RB_CNTL *reg, unsigned int rb_blksz)
{
  reg->bitfields.RB_BLKSZ = rb_blksz;
  if (reg->bitfields.RB_BLKSZ != rb_blksz) HSLDPF(E_ERROR_MESSAGE,"CP_RB_CNTL::RB_BLKSZ data too large\n");
}
__inline void set_CP_RB_CNTL_buf_swap(regCP_RB_CNTL *reg, unsigned int buf_swap)
{
  reg->bitfields.BUF_SWAP = buf_swap;
  if (reg->bitfields.BUF_SWAP != buf_swap) HSLDPF(E_ERROR_MESSAGE,"CP_RB_CNTL::BUF_SWAP data too large\n");
}
__inline void set_CP_RB_CNTL_max_fetch(regCP_RB_CNTL *reg, unsigned int max_fetch)
{
  reg->bitfields.MAX_FETCH = max_fetch;
  if (reg->bitfields.MAX_FETCH != max_fetch) HSLDPF(E_ERROR_MESSAGE,"CP_RB_CNTL::MAX_FETCH data too large\n");
}
__inline void set_CP_RB_CNTL_rb_no_update(regCP_RB_CNTL *reg, unsigned int rb_no_update)
{
  reg->bitfields.RB_NO_UPDATE = rb_no_update;
  if (reg->bitfields.RB_NO_UPDATE != rb_no_update) HSLDPF(E_ERROR_MESSAGE,"CP_RB_CNTL::RB_NO_UPDATE data too large\n");
}
__inline void set_CP_RB_CNTL_rb_rptr_wr_ena(regCP_RB_CNTL *reg, unsigned int rb_rptr_wr_ena)
{
  reg->bitfields.RB_RPTR_WR_ENA = rb_rptr_wr_ena;
  if (reg->bitfields.RB_RPTR_WR_ENA != rb_rptr_wr_ena) HSLDPF(E_ERROR_MESSAGE,"CP_RB_CNTL::RB_RPTR_WR_ENA data too large\n");
}
#else
#define set_CP_RB_CNTL_rb_bufsz(reg, rb_bufsz) (reg)->bitfields.RB_BUFSZ = rb_bufsz
#define set_CP_RB_CNTL_rb_blksz(reg, rb_blksz) (reg)->bitfields.RB_BLKSZ = rb_blksz
#define set_CP_RB_CNTL_buf_swap(reg, buf_swap) (reg)->bitfields.BUF_SWAP = buf_swap
#define set_CP_RB_CNTL_max_fetch(reg, max_fetch) (reg)->bitfields.MAX_FETCH = max_fetch
#define set_CP_RB_CNTL_rb_no_update(reg, rb_no_update) (reg)->bitfields.RB_NO_UPDATE = rb_no_update
#define set_CP_RB_CNTL_rb_rptr_wr_ena(reg, rb_rptr_wr_ena) (reg)->bitfields.RB_RPTR_WR_ENA = rb_rptr_wr_ena

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_RB_RPTR_ADDR regCP_RB_RPTR_ADDR;

#ifdef DEBUG
__inline void set_CP_RB_RPTR_ADDR_rb_rptr_swap(regCP_RB_RPTR_ADDR *reg, unsigned int rb_rptr_swap)
{
  reg->bitfields.RB_RPTR_SWAP = rb_rptr_swap;
  if (reg->bitfields.RB_RPTR_SWAP != rb_rptr_swap) HSLDPF(E_ERROR_MESSAGE,"CP_RB_RPTR_ADDR::RB_RPTR_SWAP data too large\n");
}
__inline void set_CP_RB_RPTR_ADDR_rb_rptr_addr(regCP_RB_RPTR_ADDR *reg, unsigned int rb_rptr_addr)
{
  reg->bitfields.RB_RPTR_ADDR = rb_rptr_addr;
  if (reg->bitfields.RB_RPTR_ADDR != rb_rptr_addr) HSLDPF(E_ERROR_MESSAGE,"CP_RB_RPTR_ADDR::RB_RPTR_ADDR data too large\n");
}
#else
#define set_CP_RB_RPTR_ADDR_rb_rptr_swap(reg, rb_rptr_swap) (reg)->bitfields.RB_RPTR_SWAP = rb_rptr_swap
#define set_CP_RB_RPTR_ADDR_rb_rptr_addr(reg, rb_rptr_addr) (reg)->bitfields.RB_RPTR_ADDR = rb_rptr_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_RB_RPTR regCP_RB_RPTR;

#ifdef DEBUG
__inline void set_CP_RB_RPTR_rb_rptr(regCP_RB_RPTR *reg, unsigned int rb_rptr)
{
  reg->bitfields.RB_RPTR = rb_rptr;
  if (reg->bitfields.RB_RPTR != rb_rptr) HSLDPF(E_ERROR_MESSAGE,"CP_RB_RPTR::RB_RPTR data too large\n");
}
#else
#define set_CP_RB_RPTR_rb_rptr(reg, rb_rptr) (reg)->bitfields.RB_RPTR = rb_rptr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_RB_RPTR_WR regCP_RB_RPTR_WR;

#ifdef DEBUG
__inline void set_CP_RB_RPTR_WR_rb_rptr_wr(regCP_RB_RPTR_WR *reg, unsigned int rb_rptr_wr)
{
  reg->bitfields.RB_RPTR_WR = rb_rptr_wr;
  if (reg->bitfields.RB_RPTR_WR != rb_rptr_wr) HSLDPF(E_ERROR_MESSAGE,"CP_RB_RPTR_WR::RB_RPTR_WR data too large\n");
}
#else
#define set_CP_RB_RPTR_WR_rb_rptr_wr(reg, rb_rptr_wr) (reg)->bitfields.RB_RPTR_WR = rb_rptr_wr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_RB_WPTR regCP_RB_WPTR;

#ifdef DEBUG
__inline void set_CP_RB_WPTR_rb_wptr(regCP_RB_WPTR *reg, unsigned int rb_wptr)
{
  reg->bitfields.RB_WPTR = rb_wptr;
  if (reg->bitfields.RB_WPTR != rb_wptr) HSLDPF(E_ERROR_MESSAGE,"CP_RB_WPTR::RB_WPTR data too large\n");
}
#else
#define set_CP_RB_WPTR_rb_wptr(reg, rb_wptr) (reg)->bitfields.RB_WPTR = rb_wptr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_RB_WPTR_DELAY regCP_RB_WPTR_DELAY;

#ifdef DEBUG
__inline void set_CP_RB_WPTR_DELAY_pre_write_timer(regCP_RB_WPTR_DELAY *reg, unsigned int pre_write_timer)
{
  reg->bitfields.PRE_WRITE_TIMER = pre_write_timer;
  if (reg->bitfields.PRE_WRITE_TIMER != pre_write_timer) HSLDPF(E_ERROR_MESSAGE,"CP_RB_WPTR_DELAY::PRE_WRITE_TIMER data too large\n");
}
__inline void set_CP_RB_WPTR_DELAY_pre_write_limit(regCP_RB_WPTR_DELAY *reg, unsigned int pre_write_limit)
{
  reg->bitfields.PRE_WRITE_LIMIT = pre_write_limit;
  if (reg->bitfields.PRE_WRITE_LIMIT != pre_write_limit) HSLDPF(E_ERROR_MESSAGE,"CP_RB_WPTR_DELAY::PRE_WRITE_LIMIT data too large\n");
}
#else
#define set_CP_RB_WPTR_DELAY_pre_write_timer(reg, pre_write_timer) (reg)->bitfields.PRE_WRITE_TIMER = pre_write_timer
#define set_CP_RB_WPTR_DELAY_pre_write_limit(reg, pre_write_limit) (reg)->bitfields.PRE_WRITE_LIMIT = pre_write_limit

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_IB_BASE regCP_IB_BASE;

#ifdef DEBUG
__inline void set_CP_IB_BASE_ib_base(regCP_IB_BASE *reg, unsigned int ib_base)
{
  reg->bitfields.IB_BASE = ib_base;
  if (reg->bitfields.IB_BASE != ib_base) HSLDPF(E_ERROR_MESSAGE,"CP_IB_BASE::IB_BASE data too large\n");
}
#else
#define set_CP_IB_BASE_ib_base(reg, ib_base) (reg)->bitfields.IB_BASE = ib_base

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_IB_BUFSZ regCP_IB_BUFSZ;

#ifdef DEBUG
__inline void set_CP_IB_BUFSZ_ib_bufsz(regCP_IB_BUFSZ *reg, unsigned int ib_bufsz)
{
  reg->bitfields.IB_BUFSZ = ib_bufsz;
  if (reg->bitfields.IB_BUFSZ != ib_bufsz) HSLDPF(E_ERROR_MESSAGE,"CP_IB_BUFSZ::IB_BUFSZ data too large\n");
}
#else
#define set_CP_IB_BUFSZ_ib_bufsz(reg, ib_bufsz) (reg)->bitfields.IB_BUFSZ = ib_bufsz

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_IB2_BASE regCP_IB2_BASE;

#ifdef DEBUG
__inline void set_CP_IB2_BASE_ib2_base(regCP_IB2_BASE *reg, unsigned int ib2_base)
{
  reg->bitfields.IB2_BASE = ib2_base;
  if (reg->bitfields.IB2_BASE != ib2_base) HSLDPF(E_ERROR_MESSAGE,"CP_IB2_BASE::IB2_BASE data too large\n");
}
#else
#define set_CP_IB2_BASE_ib2_base(reg, ib2_base) (reg)->bitfields.IB2_BASE = ib2_base

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_IB2_BUFSZ regCP_IB2_BUFSZ;

#ifdef DEBUG
__inline void set_CP_IB2_BUFSZ_ib2_bufsz(regCP_IB2_BUFSZ *reg, unsigned int ib2_bufsz)
{
  reg->bitfields.IB2_BUFSZ = ib2_bufsz;
  if (reg->bitfields.IB2_BUFSZ != ib2_bufsz) HSLDPF(E_ERROR_MESSAGE,"CP_IB2_BUFSZ::IB2_BUFSZ data too large\n");
}
#else
#define set_CP_IB2_BUFSZ_ib2_bufsz(reg, ib2_bufsz) (reg)->bitfields.IB2_BUFSZ = ib2_bufsz

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_CSQ_CNTL regCP_CSQ_CNTL;

#ifdef DEBUG
__inline void set_CP_CSQ_CNTL_csq_cnt_primary(regCP_CSQ_CNTL *reg, unsigned int csq_cnt_primary)
{
  reg->bitfields.CSQ_CNT_PRIMARY = csq_cnt_primary;
  if (reg->bitfields.CSQ_CNT_PRIMARY != csq_cnt_primary) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ_CNTL::CSQ_CNT_PRIMARY data too large\n");
}
__inline void set_CP_CSQ_CNTL_csq_cnt_indirect(regCP_CSQ_CNTL *reg, unsigned int csq_cnt_indirect)
{
  reg->bitfields.CSQ_CNT_INDIRECT = csq_cnt_indirect;
  if (reg->bitfields.CSQ_CNT_INDIRECT != csq_cnt_indirect) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ_CNTL::CSQ_CNT_INDIRECT data too large\n");
}
__inline void set_CP_CSQ_CNTL_csq_cnt_indirect2(regCP_CSQ_CNTL *reg, unsigned int csq_cnt_indirect2)
{
  reg->bitfields.CSQ_CNT_INDIRECT2 = csq_cnt_indirect2;
  if (reg->bitfields.CSQ_CNT_INDIRECT2 != csq_cnt_indirect2) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ_CNTL::CSQ_CNT_INDIRECT2 data too large\n");
}
__inline void set_CP_CSQ_CNTL_csq_mode(regCP_CSQ_CNTL *reg, unsigned int csq_mode)
{
  reg->bitfields.CSQ_MODE = csq_mode;
  if (reg->bitfields.CSQ_MODE != csq_mode) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ_CNTL::CSQ_MODE data too large\n");
}
#else
#define set_CP_CSQ_CNTL_csq_cnt_primary(reg, csq_cnt_primary) (reg)->bitfields.CSQ_CNT_PRIMARY = csq_cnt_primary
#define set_CP_CSQ_CNTL_csq_cnt_indirect(reg, csq_cnt_indirect) (reg)->bitfields.CSQ_CNT_INDIRECT = csq_cnt_indirect
#define set_CP_CSQ_CNTL_csq_cnt_indirect2(reg, csq_cnt_indirect2) (reg)->bitfields.CSQ_CNT_INDIRECT2 = csq_cnt_indirect2
#define set_CP_CSQ_CNTL_csq_mode(reg, csq_mode) (reg)->bitfields.CSQ_MODE = csq_mode

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_CSQ_APER_PRIMARY regCP_CSQ_APER_PRIMARY;

#ifdef DEBUG
__inline void set_CP_CSQ_APER_PRIMARY_cp_csq_aper_primary(regCP_CSQ_APER_PRIMARY *reg, unsigned int cp_csq_aper_primary)
{
  reg->bitfields.CP_CSQ_APER_PRIMARY = cp_csq_aper_primary;
  if (reg->bitfields.CP_CSQ_APER_PRIMARY != cp_csq_aper_primary) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ_APER_PRIMARY::CP_CSQ_APER_PRIMARY data too large\n");
}
#else
#define set_CP_CSQ_APER_PRIMARY_cp_csq_aper_primary(reg, cp_csq_aper_primary) (reg)->bitfields.CP_CSQ_APER_PRIMARY = cp_csq_aper_primary

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_CSQ_APER_INDIRECT regCP_CSQ_APER_INDIRECT;

#ifdef DEBUG
__inline void set_CP_CSQ_APER_INDIRECT_cp_csq_aper_indirect(regCP_CSQ_APER_INDIRECT *reg, unsigned int cp_csq_aper_indirect)
{
  reg->bitfields.CP_CSQ_APER_INDIRECT = cp_csq_aper_indirect;
  if (reg->bitfields.CP_CSQ_APER_INDIRECT != cp_csq_aper_indirect) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ_APER_INDIRECT::CP_CSQ_APER_INDIRECT data too large\n");
}
#else
#define set_CP_CSQ_APER_INDIRECT_cp_csq_aper_indirect(reg, cp_csq_aper_indirect) (reg)->bitfields.CP_CSQ_APER_INDIRECT = cp_csq_aper_indirect

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_CSQ_APER_INDIRECT2 regCP_CSQ_APER_INDIRECT2;

#ifdef DEBUG
__inline void set_CP_CSQ_APER_INDIRECT2_cp_csq_aper_indirect2(regCP_CSQ_APER_INDIRECT2 *reg, unsigned int cp_csq_aper_indirect2)
{
  reg->bitfields.CP_CSQ_APER_INDIRECT2 = cp_csq_aper_indirect2;
  if (reg->bitfields.CP_CSQ_APER_INDIRECT2 != cp_csq_aper_indirect2) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ_APER_INDIRECT2::CP_CSQ_APER_INDIRECT2 data too large\n");
}
#else
#define set_CP_CSQ_APER_INDIRECT2_cp_csq_aper_indirect2(reg, cp_csq_aper_indirect2) (reg)->bitfields.CP_CSQ_APER_INDIRECT2 = cp_csq_aper_indirect2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_CSQ_MODE regCP_CSQ_MODE;

#ifdef DEBUG
__inline void set_CP_CSQ_MODE_indirect2_start(regCP_CSQ_MODE *reg, unsigned int indirect2_start)
{
  reg->bitfields.INDIRECT2_START = indirect2_start;
  if (reg->bitfields.INDIRECT2_START != indirect2_start) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ_MODE::INDIRECT2_START data too large\n");
}
__inline void set_CP_CSQ_MODE_indirect1_start(regCP_CSQ_MODE *reg, unsigned int indirect1_start)
{
  reg->bitfields.INDIRECT1_START = indirect1_start;
  if (reg->bitfields.INDIRECT1_START != indirect1_start) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ_MODE::INDIRECT1_START data too large\n");
}
__inline void set_CP_CSQ_MODE_csq_indirect2_mode(regCP_CSQ_MODE *reg, unsigned int csq_indirect2_mode)
{
  reg->bitfields.CSQ_INDIRECT2_MODE = csq_indirect2_mode;
  if (reg->bitfields.CSQ_INDIRECT2_MODE != csq_indirect2_mode) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ_MODE::CSQ_INDIRECT2_MODE data too large\n");
}
__inline void set_CP_CSQ_MODE_csq_indirect2_enable(regCP_CSQ_MODE *reg, unsigned int csq_indirect2_enable)
{
  reg->bitfields.CSQ_INDIRECT2_ENABLE = csq_indirect2_enable;
  if (reg->bitfields.CSQ_INDIRECT2_ENABLE != csq_indirect2_enable) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ_MODE::CSQ_INDIRECT2_ENABLE data too large\n");
}
__inline void set_CP_CSQ_MODE_csq_indirect1_mode(regCP_CSQ_MODE *reg, unsigned int csq_indirect1_mode)
{
  reg->bitfields.CSQ_INDIRECT1_MODE = csq_indirect1_mode;
  if (reg->bitfields.CSQ_INDIRECT1_MODE != csq_indirect1_mode) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ_MODE::CSQ_INDIRECT1_MODE data too large\n");
}
__inline void set_CP_CSQ_MODE_csq_indirect1_enable(regCP_CSQ_MODE *reg, unsigned int csq_indirect1_enable)
{
  reg->bitfields.CSQ_INDIRECT1_ENABLE = csq_indirect1_enable;
  if (reg->bitfields.CSQ_INDIRECT1_ENABLE != csq_indirect1_enable) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ_MODE::CSQ_INDIRECT1_ENABLE data too large\n");
}
__inline void set_CP_CSQ_MODE_csq_primary_mode(regCP_CSQ_MODE *reg, unsigned int csq_primary_mode)
{
  reg->bitfields.CSQ_PRIMARY_MODE = csq_primary_mode;
  if (reg->bitfields.CSQ_PRIMARY_MODE != csq_primary_mode) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ_MODE::CSQ_PRIMARY_MODE data too large\n");
}
__inline void set_CP_CSQ_MODE_csq_primary_enable(regCP_CSQ_MODE *reg, unsigned int csq_primary_enable)
{
  reg->bitfields.CSQ_PRIMARY_ENABLE = csq_primary_enable;
  if (reg->bitfields.CSQ_PRIMARY_ENABLE != csq_primary_enable) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ_MODE::CSQ_PRIMARY_ENABLE data too large\n");
}
#else
#define set_CP_CSQ_MODE_indirect2_start(reg, indirect2_start) (reg)->bitfields.INDIRECT2_START = indirect2_start
#define set_CP_CSQ_MODE_indirect1_start(reg, indirect1_start) (reg)->bitfields.INDIRECT1_START = indirect1_start
#define set_CP_CSQ_MODE_csq_indirect2_mode(reg, csq_indirect2_mode) (reg)->bitfields.CSQ_INDIRECT2_MODE = csq_indirect2_mode
#define set_CP_CSQ_MODE_csq_indirect2_enable(reg, csq_indirect2_enable) (reg)->bitfields.CSQ_INDIRECT2_ENABLE = csq_indirect2_enable
#define set_CP_CSQ_MODE_csq_indirect1_mode(reg, csq_indirect1_mode) (reg)->bitfields.CSQ_INDIRECT1_MODE = csq_indirect1_mode
#define set_CP_CSQ_MODE_csq_indirect1_enable(reg, csq_indirect1_enable) (reg)->bitfields.CSQ_INDIRECT1_ENABLE = csq_indirect1_enable
#define set_CP_CSQ_MODE_csq_primary_mode(reg, csq_primary_mode) (reg)->bitfields.CSQ_PRIMARY_MODE = csq_primary_mode
#define set_CP_CSQ_MODE_csq_primary_enable(reg, csq_primary_enable) (reg)->bitfields.CSQ_PRIMARY_ENABLE = csq_primary_enable

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_ME_CNTL regCP_ME_CNTL;

#ifdef DEBUG
__inline void set_CP_ME_CNTL_me_stat(regCP_ME_CNTL *reg, unsigned int me_stat)
{
  reg->bitfields.ME_STAT = me_stat;
  if (reg->bitfields.ME_STAT != me_stat) HSLDPF(E_ERROR_MESSAGE,"CP_ME_CNTL::ME_STAT data too large\n");
}
__inline void set_CP_ME_CNTL_me_statmux(regCP_ME_CNTL *reg, unsigned int me_statmux)
{
  reg->bitfields.ME_STATMUX = me_statmux;
  if (reg->bitfields.ME_STATMUX != me_statmux) HSLDPF(E_ERROR_MESSAGE,"CP_ME_CNTL::ME_STATMUX data too large\n");
}
__inline void set_CP_ME_CNTL_me_busy(regCP_ME_CNTL *reg, unsigned int me_busy)
{
  reg->bitfields.ME_BUSY = me_busy;
  if (reg->bitfields.ME_BUSY != me_busy) HSLDPF(E_ERROR_MESSAGE,"CP_ME_CNTL::ME_BUSY data too large\n");
}
__inline void set_CP_ME_CNTL_me_mode(regCP_ME_CNTL *reg, unsigned int me_mode)
{
  reg->bitfields.ME_MODE = me_mode;
  if (reg->bitfields.ME_MODE != me_mode) HSLDPF(E_ERROR_MESSAGE,"CP_ME_CNTL::ME_MODE data too large\n");
}
__inline void set_CP_ME_CNTL_me_step(regCP_ME_CNTL *reg, unsigned int me_step)
{
  reg->bitfields.ME_STEP = me_step;
  if (reg->bitfields.ME_STEP != me_step) HSLDPF(E_ERROR_MESSAGE,"CP_ME_CNTL::ME_STEP data too large\n");
}
#else
#define set_CP_ME_CNTL_me_stat(reg, me_stat) (reg)->bitfields.ME_STAT = me_stat
#define set_CP_ME_CNTL_me_statmux(reg, me_statmux) (reg)->bitfields.ME_STATMUX = me_statmux
#define set_CP_ME_CNTL_me_busy(reg, me_busy) (reg)->bitfields.ME_BUSY = me_busy
#define set_CP_ME_CNTL_me_mode(reg, me_mode) (reg)->bitfields.ME_MODE = me_mode
#define set_CP_ME_CNTL_me_step(reg, me_step) (reg)->bitfields.ME_STEP = me_step

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_ME_RAM_ADDR regCP_ME_RAM_ADDR;

#ifdef DEBUG
__inline void set_CP_ME_RAM_ADDR_me_ram_addr(regCP_ME_RAM_ADDR *reg, unsigned int me_ram_addr)
{
  reg->bitfields.ME_RAM_ADDR = me_ram_addr;
  if (reg->bitfields.ME_RAM_ADDR != me_ram_addr) HSLDPF(E_ERROR_MESSAGE,"CP_ME_RAM_ADDR::ME_RAM_ADDR data too large\n");
}
#else
#define set_CP_ME_RAM_ADDR_me_ram_addr(reg, me_ram_addr) (reg)->bitfields.ME_RAM_ADDR = me_ram_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_ME_RAM_RADDR regCP_ME_RAM_RADDR;

#ifdef DEBUG
__inline void set_CP_ME_RAM_RADDR_me_ram_raddr(regCP_ME_RAM_RADDR *reg, unsigned int me_ram_raddr)
{
  reg->bitfields.ME_RAM_RADDR = me_ram_raddr;
  if (reg->bitfields.ME_RAM_RADDR != me_ram_raddr) HSLDPF(E_ERROR_MESSAGE,"CP_ME_RAM_RADDR::ME_RAM_RADDR data too large\n");
}
#else
#define set_CP_ME_RAM_RADDR_me_ram_raddr(reg, me_ram_raddr) (reg)->bitfields.ME_RAM_RADDR = me_ram_raddr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_ME_RAM_DATAH regCP_ME_RAM_DATAH;

#ifdef DEBUG
__inline void set_CP_ME_RAM_DATAH_me_ram_datah(regCP_ME_RAM_DATAH *reg, unsigned int me_ram_datah)
{
  reg->bitfields.ME_RAM_DATAH = me_ram_datah;
  if (reg->bitfields.ME_RAM_DATAH != me_ram_datah) HSLDPF(E_ERROR_MESSAGE,"CP_ME_RAM_DATAH::ME_RAM_DATAH data too large\n");
}
#else
#define set_CP_ME_RAM_DATAH_me_ram_datah(reg, me_ram_datah) (reg)->bitfields.ME_RAM_DATAH = me_ram_datah

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_ME_RAM_DATAL regCP_ME_RAM_DATAL;

#ifdef DEBUG
__inline void set_CP_ME_RAM_DATAL_me_ram_datal(regCP_ME_RAM_DATAL *reg, unsigned int me_ram_datal)
{
  reg->bitfields.ME_RAM_DATAL = me_ram_datal;
  if (reg->bitfields.ME_RAM_DATAL != me_ram_datal) HSLDPF(E_ERROR_MESSAGE,"CP_ME_RAM_DATAL::ME_RAM_DATAL data too large\n");
}
#else
#define set_CP_ME_RAM_DATAL_me_ram_datal(reg, me_ram_datal) (reg)->bitfields.ME_RAM_DATAL = me_ram_datal

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_DEBUG regCP_DEBUG;

#ifdef DEBUG
__inline void set_CP_DEBUG_cp_debug(regCP_DEBUG *reg, unsigned int cp_debug)
{
  reg->bitfields.CP_DEBUG = cp_debug;
  if (reg->bitfields.CP_DEBUG != cp_debug) HSLDPF(E_ERROR_MESSAGE,"CP_DEBUG::CP_DEBUG data too large\n");
}
#else
#define set_CP_DEBUG_cp_debug(reg, cp_debug) (reg)->bitfields.CP_DEBUG = cp_debug

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SCRATCH_REG0 regSCRATCH_REG0;

#ifdef DEBUG
__inline void set_SCRATCH_REG0_scratch_reg0(regSCRATCH_REG0 *reg, unsigned int scratch_reg0)
{
  reg->bitfields.SCRATCH_REG0 = scratch_reg0;
  if (reg->bitfields.SCRATCH_REG0 != scratch_reg0) HSLDPF(E_ERROR_MESSAGE,"SCRATCH_REG0::SCRATCH_REG0 data too large\n");
}
#else
#define set_SCRATCH_REG0_scratch_reg0(reg, scratch_reg0) (reg)->bitfields.SCRATCH_REG0 = scratch_reg0

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SCRATCH_REG1 regSCRATCH_REG1;

#ifdef DEBUG
__inline void set_SCRATCH_REG1_scratch_reg1(regSCRATCH_REG1 *reg, unsigned int scratch_reg1)
{
  reg->bitfields.SCRATCH_REG1 = scratch_reg1;
  if (reg->bitfields.SCRATCH_REG1 != scratch_reg1) HSLDPF(E_ERROR_MESSAGE,"SCRATCH_REG1::SCRATCH_REG1 data too large\n");
}
#else
#define set_SCRATCH_REG1_scratch_reg1(reg, scratch_reg1) (reg)->bitfields.SCRATCH_REG1 = scratch_reg1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SCRATCH_REG2 regSCRATCH_REG2;

#ifdef DEBUG
__inline void set_SCRATCH_REG2_scratch_reg2(regSCRATCH_REG2 *reg, unsigned int scratch_reg2)
{
  reg->bitfields.SCRATCH_REG2 = scratch_reg2;
  if (reg->bitfields.SCRATCH_REG2 != scratch_reg2) HSLDPF(E_ERROR_MESSAGE,"SCRATCH_REG2::SCRATCH_REG2 data too large\n");
}
#else
#define set_SCRATCH_REG2_scratch_reg2(reg, scratch_reg2) (reg)->bitfields.SCRATCH_REG2 = scratch_reg2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SCRATCH_REG3 regSCRATCH_REG3;

#ifdef DEBUG
__inline void set_SCRATCH_REG3_scratch_reg3(regSCRATCH_REG3 *reg, unsigned int scratch_reg3)
{
  reg->bitfields.SCRATCH_REG3 = scratch_reg3;
  if (reg->bitfields.SCRATCH_REG3 != scratch_reg3) HSLDPF(E_ERROR_MESSAGE,"SCRATCH_REG3::SCRATCH_REG3 data too large\n");
}
#else
#define set_SCRATCH_REG3_scratch_reg3(reg, scratch_reg3) (reg)->bitfields.SCRATCH_REG3 = scratch_reg3

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SCRATCH_REG4 regSCRATCH_REG4;

#ifdef DEBUG
__inline void set_SCRATCH_REG4_scratch_reg4(regSCRATCH_REG4 *reg, unsigned int scratch_reg4)
{
  reg->bitfields.SCRATCH_REG4 = scratch_reg4;
  if (reg->bitfields.SCRATCH_REG4 != scratch_reg4) HSLDPF(E_ERROR_MESSAGE,"SCRATCH_REG4::SCRATCH_REG4 data too large\n");
}
#else
#define set_SCRATCH_REG4_scratch_reg4(reg, scratch_reg4) (reg)->bitfields.SCRATCH_REG4 = scratch_reg4

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SCRATCH_REG5 regSCRATCH_REG5;

#ifdef DEBUG
__inline void set_SCRATCH_REG5_scratch_reg5(regSCRATCH_REG5 *reg, unsigned int scratch_reg5)
{
  reg->bitfields.SCRATCH_REG5 = scratch_reg5;
  if (reg->bitfields.SCRATCH_REG5 != scratch_reg5) HSLDPF(E_ERROR_MESSAGE,"SCRATCH_REG5::SCRATCH_REG5 data too large\n");
}
#else
#define set_SCRATCH_REG5_scratch_reg5(reg, scratch_reg5) (reg)->bitfields.SCRATCH_REG5 = scratch_reg5

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SCRATCH_REG6 regSCRATCH_REG6;

#ifdef DEBUG
__inline void set_SCRATCH_REG6_scratch_reg6(regSCRATCH_REG6 *reg, unsigned int scratch_reg6)
{
  reg->bitfields.SCRATCH_REG6 = scratch_reg6;
  if (reg->bitfields.SCRATCH_REG6 != scratch_reg6) HSLDPF(E_ERROR_MESSAGE,"SCRATCH_REG6::SCRATCH_REG6 data too large\n");
}
#else
#define set_SCRATCH_REG6_scratch_reg6(reg, scratch_reg6) (reg)->bitfields.SCRATCH_REG6 = scratch_reg6

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SCRATCH_REG7 regSCRATCH_REG7;

#ifdef DEBUG
__inline void set_SCRATCH_REG7_scratch_reg7(regSCRATCH_REG7 *reg, unsigned int scratch_reg7)
{
  reg->bitfields.SCRATCH_REG7 = scratch_reg7;
  if (reg->bitfields.SCRATCH_REG7 != scratch_reg7) HSLDPF(E_ERROR_MESSAGE,"SCRATCH_REG7::SCRATCH_REG7 data too large\n");
}
#else
#define set_SCRATCH_REG7_scratch_reg7(reg, scratch_reg7) (reg)->bitfields.SCRATCH_REG7 = scratch_reg7

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SCRATCH_UMSK regSCRATCH_UMSK;

#ifdef DEBUG
__inline void set_SCRATCH_UMSK_scratch_umsk(regSCRATCH_UMSK *reg, unsigned int scratch_umsk)
{
  reg->bitfields.SCRATCH_UMSK = scratch_umsk;
  if (reg->bitfields.SCRATCH_UMSK != scratch_umsk) HSLDPF(E_ERROR_MESSAGE,"SCRATCH_UMSK::SCRATCH_UMSK data too large\n");
}
__inline void set_SCRATCH_UMSK_scratch_swap(regSCRATCH_UMSK *reg, unsigned int scratch_swap)
{
  reg->bitfields.SCRATCH_SWAP = scratch_swap;
  if (reg->bitfields.SCRATCH_SWAP != scratch_swap) HSLDPF(E_ERROR_MESSAGE,"SCRATCH_UMSK::SCRATCH_SWAP data too large\n");
}
#else
#define set_SCRATCH_UMSK_scratch_umsk(reg, scratch_umsk) (reg)->bitfields.SCRATCH_UMSK = scratch_umsk
#define set_SCRATCH_UMSK_scratch_swap(reg, scratch_swap) (reg)->bitfields.SCRATCH_SWAP = scratch_swap

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SCRATCH_ADDR regSCRATCH_ADDR;

#ifdef DEBUG
__inline void set_SCRATCH_ADDR_scratch_addr(regSCRATCH_ADDR *reg, unsigned int scratch_addr)
{
  reg->bitfields.SCRATCH_ADDR = scratch_addr;
  if (reg->bitfields.SCRATCH_ADDR != scratch_addr) HSLDPF(E_ERROR_MESSAGE,"SCRATCH_ADDR::SCRATCH_ADDR data too large\n");
}
#else
#define set_SCRATCH_ADDR_scratch_addr(reg, scratch_addr) (reg)->bitfields.SCRATCH_ADDR = scratch_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_GUI_TABLE_ADDR regDMA_GUI_TABLE_ADDR;

#ifdef DEBUG
__inline void set_DMA_GUI_TABLE_ADDR_cp_sync(regDMA_GUI_TABLE_ADDR *reg, unsigned int cp_sync)
{
  reg->bitfields.CP_SYNC = cp_sync;
  if (reg->bitfields.CP_SYNC != cp_sync) HSLDPF(E_ERROR_MESSAGE,"DMA_GUI_TABLE_ADDR::CP_SYNC data too large\n");
}
__inline void set_DMA_GUI_TABLE_ADDR_table_addr(regDMA_GUI_TABLE_ADDR *reg, unsigned int table_addr)
{
  reg->bitfields.TABLE_ADDR = table_addr;
  if (reg->bitfields.TABLE_ADDR != table_addr) HSLDPF(E_ERROR_MESSAGE,"DMA_GUI_TABLE_ADDR::TABLE_ADDR data too large\n");
}
#else
#define set_DMA_GUI_TABLE_ADDR_cp_sync(reg, cp_sync) (reg)->bitfields.CP_SYNC = cp_sync
#define set_DMA_GUI_TABLE_ADDR_table_addr(reg, table_addr) (reg)->bitfields.TABLE_ADDR = table_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_GUI_SRC_ADDR regDMA_GUI_SRC_ADDR;

#ifdef DEBUG
__inline void set_DMA_GUI_SRC_ADDR_src_addr(regDMA_GUI_SRC_ADDR *reg, unsigned int src_addr)
{
  reg->bitfields.SRC_ADDR = src_addr;
  if (reg->bitfields.SRC_ADDR != src_addr) HSLDPF(E_ERROR_MESSAGE,"DMA_GUI_SRC_ADDR::SRC_ADDR data too large\n");
}
#else
#define set_DMA_GUI_SRC_ADDR_src_addr(reg, src_addr) (reg)->bitfields.SRC_ADDR = src_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_GUI_DST_ADDR regDMA_GUI_DST_ADDR;

#ifdef DEBUG
__inline void set_DMA_GUI_DST_ADDR_dst_addr(regDMA_GUI_DST_ADDR *reg, unsigned int dst_addr)
{
  reg->bitfields.DST_ADDR = dst_addr;
  if (reg->bitfields.DST_ADDR != dst_addr) HSLDPF(E_ERROR_MESSAGE,"DMA_GUI_DST_ADDR::DST_ADDR data too large\n");
}
#else
#define set_DMA_GUI_DST_ADDR_dst_addr(reg, dst_addr) (reg)->bitfields.DST_ADDR = dst_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_GUI_COMMAND regDMA_GUI_COMMAND;

#ifdef DEBUG
__inline void set_DMA_GUI_COMMAND_byte_count(regDMA_GUI_COMMAND *reg, unsigned int byte_count)
{
  reg->bitfields.BYTE_COUNT = byte_count;
  if (reg->bitfields.BYTE_COUNT != byte_count) HSLDPF(E_ERROR_MESSAGE,"DMA_GUI_COMMAND::BYTE_COUNT data too large\n");
}
__inline void set_DMA_GUI_COMMAND_src_swap(regDMA_GUI_COMMAND *reg, unsigned int src_swap)
{
  reg->bitfields.SRC_SWAP = src_swap;
  if (reg->bitfields.SRC_SWAP != src_swap) HSLDPF(E_ERROR_MESSAGE,"DMA_GUI_COMMAND::SRC_SWAP data too large\n");
}
__inline void set_DMA_GUI_COMMAND_dst_swap(regDMA_GUI_COMMAND *reg, unsigned int dst_swap)
{
  reg->bitfields.DST_SWAP = dst_swap;
  if (reg->bitfields.DST_SWAP != dst_swap) HSLDPF(E_ERROR_MESSAGE,"DMA_GUI_COMMAND::DST_SWAP data too large\n");
}
__inline void set_DMA_GUI_COMMAND_sas(regDMA_GUI_COMMAND *reg, unsigned int sas)
{
  reg->bitfields.SAS = sas;
  if (reg->bitfields.SAS != sas) HSLDPF(E_ERROR_MESSAGE,"DMA_GUI_COMMAND::SAS data too large\n");
}
__inline void set_DMA_GUI_COMMAND_das(regDMA_GUI_COMMAND *reg, unsigned int das)
{
  reg->bitfields.DAS = das;
  if (reg->bitfields.DAS != das) HSLDPF(E_ERROR_MESSAGE,"DMA_GUI_COMMAND::DAS data too large\n");
}
__inline void set_DMA_GUI_COMMAND_saic(regDMA_GUI_COMMAND *reg, unsigned int saic)
{
  reg->bitfields.SAIC = saic;
  if (reg->bitfields.SAIC != saic) HSLDPF(E_ERROR_MESSAGE,"DMA_GUI_COMMAND::SAIC data too large\n");
}
__inline void set_DMA_GUI_COMMAND_daic(regDMA_GUI_COMMAND *reg, unsigned int daic)
{
  reg->bitfields.DAIC = daic;
  if (reg->bitfields.DAIC != daic) HSLDPF(E_ERROR_MESSAGE,"DMA_GUI_COMMAND::DAIC data too large\n");
}
__inline void set_DMA_GUI_COMMAND_intdis(regDMA_GUI_COMMAND *reg, unsigned int intdis)
{
  reg->bitfields.INTDIS = intdis;
  if (reg->bitfields.INTDIS != intdis) HSLDPF(E_ERROR_MESSAGE,"DMA_GUI_COMMAND::INTDIS data too large\n");
}
__inline void set_DMA_GUI_COMMAND_eol(regDMA_GUI_COMMAND *reg, unsigned int eol)
{
  reg->bitfields.EOL = eol;
  if (reg->bitfields.EOL != eol) HSLDPF(E_ERROR_MESSAGE,"DMA_GUI_COMMAND::EOL data too large\n");
}
#else
#define set_DMA_GUI_COMMAND_byte_count(reg, byte_count) (reg)->bitfields.BYTE_COUNT = byte_count
#define set_DMA_GUI_COMMAND_src_swap(reg, src_swap) (reg)->bitfields.SRC_SWAP = src_swap
#define set_DMA_GUI_COMMAND_dst_swap(reg, dst_swap) (reg)->bitfields.DST_SWAP = dst_swap
#define set_DMA_GUI_COMMAND_sas(reg, sas) (reg)->bitfields.SAS = sas
#define set_DMA_GUI_COMMAND_das(reg, das) (reg)->bitfields.DAS = das
#define set_DMA_GUI_COMMAND_saic(reg, saic) (reg)->bitfields.SAIC = saic
#define set_DMA_GUI_COMMAND_daic(reg, daic) (reg)->bitfields.DAIC = daic
#define set_DMA_GUI_COMMAND_intdis(reg, intdis) (reg)->bitfields.INTDIS = intdis
#define set_DMA_GUI_COMMAND_eol(reg, eol) (reg)->bitfields.EOL = eol

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_GUI_STATUS regDMA_GUI_STATUS;

#ifdef DEBUG
__inline void set_DMA_GUI_STATUS_dtaq_avail(regDMA_GUI_STATUS *reg, unsigned int dtaq_avail)
{
  reg->bitfields.DTAQ_AVAIL = dtaq_avail;
  if (reg->bitfields.DTAQ_AVAIL != dtaq_avail) HSLDPF(E_ERROR_MESSAGE,"DMA_GUI_STATUS::DTAQ_AVAIL data too large\n");
}
__inline void set_DMA_GUI_STATUS_last_table_num(regDMA_GUI_STATUS *reg, unsigned int last_table_num)
{
  reg->bitfields.LAST_TABLE_NUM = last_table_num;
  if (reg->bitfields.LAST_TABLE_NUM != last_table_num) HSLDPF(E_ERROR_MESSAGE,"DMA_GUI_STATUS::LAST_TABLE_NUM data too large\n");
}
__inline void set_DMA_GUI_STATUS_current_table_num(regDMA_GUI_STATUS *reg, unsigned int current_table_num)
{
  reg->bitfields.CURRENT_TABLE_NUM = current_table_num;
  if (reg->bitfields.CURRENT_TABLE_NUM != current_table_num) HSLDPF(E_ERROR_MESSAGE,"DMA_GUI_STATUS::CURRENT_TABLE_NUM data too large\n");
}
__inline void set_DMA_GUI_STATUS_abort_en(regDMA_GUI_STATUS *reg, unsigned int abort_en)
{
  reg->bitfields.ABORT_EN = abort_en;
  if (reg->bitfields.ABORT_EN != abort_en) HSLDPF(E_ERROR_MESSAGE,"DMA_GUI_STATUS::ABORT_EN data too large\n");
}
__inline void set_DMA_GUI_STATUS_active(regDMA_GUI_STATUS *reg, unsigned int active)
{
  reg->bitfields.ACTIVE = active;
  if (reg->bitfields.ACTIVE != active) HSLDPF(E_ERROR_MESSAGE,"DMA_GUI_STATUS::ACTIVE data too large\n");
}
__inline void set_DMA_GUI_STATUS_swap(regDMA_GUI_STATUS *reg, unsigned int swap)
{
  reg->bitfields.SWAP = swap;
  if (reg->bitfields.SWAP != swap) HSLDPF(E_ERROR_MESSAGE,"DMA_GUI_STATUS::SWAP data too large\n");
}
#else
#define set_DMA_GUI_STATUS_dtaq_avail(reg, dtaq_avail) (reg)->bitfields.DTAQ_AVAIL = dtaq_avail
#define set_DMA_GUI_STATUS_last_table_num(reg, last_table_num) (reg)->bitfields.LAST_TABLE_NUM = last_table_num
#define set_DMA_GUI_STATUS_current_table_num(reg, current_table_num) (reg)->bitfields.CURRENT_TABLE_NUM = current_table_num
#define set_DMA_GUI_STATUS_abort_en(reg, abort_en) (reg)->bitfields.ABORT_EN = abort_en
#define set_DMA_GUI_STATUS_active(reg, active) (reg)->bitfields.ACTIVE = active
#define set_DMA_GUI_STATUS_swap(reg, swap) (reg)->bitfields.SWAP = swap

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_GUI_ACT_DSCRPTR regDMA_GUI_ACT_DSCRPTR;

#ifdef DEBUG
__inline void set_DMA_GUI_ACT_DSCRPTR_table_addr(regDMA_GUI_ACT_DSCRPTR *reg, unsigned int table_addr)
{
  reg->bitfields.TABLE_ADDR = table_addr;
  if (reg->bitfields.TABLE_ADDR != table_addr) HSLDPF(E_ERROR_MESSAGE,"DMA_GUI_ACT_DSCRPTR::TABLE_ADDR data too large\n");
}
#else
#define set_DMA_GUI_ACT_DSCRPTR_table_addr(reg, table_addr) (reg)->bitfields.TABLE_ADDR = table_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_GUI_SRC_ADDR regCP_GUI_SRC_ADDR;

#ifdef DEBUG
__inline void set_CP_GUI_SRC_ADDR_cp_gui_src_addr(regCP_GUI_SRC_ADDR *reg, unsigned int cp_gui_src_addr)
{
  reg->bitfields.CP_GUI_SRC_ADDR = cp_gui_src_addr;
  if (reg->bitfields.CP_GUI_SRC_ADDR != cp_gui_src_addr) HSLDPF(E_ERROR_MESSAGE,"CP_GUI_SRC_ADDR::CP_GUI_SRC_ADDR data too large\n");
}
#else
#define set_CP_GUI_SRC_ADDR_cp_gui_src_addr(reg, cp_gui_src_addr) (reg)->bitfields.CP_GUI_SRC_ADDR = cp_gui_src_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_GUI_DST_ADDR regCP_GUI_DST_ADDR;

#ifdef DEBUG
__inline void set_CP_GUI_DST_ADDR_cp_gui_dst_addr(regCP_GUI_DST_ADDR *reg, unsigned int cp_gui_dst_addr)
{
  reg->bitfields.CP_GUI_DST_ADDR = cp_gui_dst_addr;
  if (reg->bitfields.CP_GUI_DST_ADDR != cp_gui_dst_addr) HSLDPF(E_ERROR_MESSAGE,"CP_GUI_DST_ADDR::CP_GUI_DST_ADDR data too large\n");
}
#else
#define set_CP_GUI_DST_ADDR_cp_gui_dst_addr(reg, cp_gui_dst_addr) (reg)->bitfields.CP_GUI_DST_ADDR = cp_gui_dst_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_GUI_COMMAND regCP_GUI_COMMAND;

#ifdef DEBUG
__inline void set_CP_GUI_COMMAND_cp_gui_command(regCP_GUI_COMMAND *reg, unsigned int cp_gui_command)
{
  reg->bitfields.CP_GUI_COMMAND = cp_gui_command;
  if (reg->bitfields.CP_GUI_COMMAND != cp_gui_command) HSLDPF(E_ERROR_MESSAGE,"CP_GUI_COMMAND::CP_GUI_COMMAND data too large\n");
}
#else
#define set_CP_GUI_COMMAND_cp_gui_command(reg, cp_gui_command) (reg)->bitfields.CP_GUI_COMMAND = cp_gui_command

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_VID_TABLE_ADDR regDMA_VID_TABLE_ADDR;

#ifdef DEBUG
__inline void set_DMA_VID_TABLE_ADDR_cp_sync(regDMA_VID_TABLE_ADDR *reg, unsigned int cp_sync)
{
  reg->bitfields.CP_SYNC = cp_sync;
  if (reg->bitfields.CP_SYNC != cp_sync) HSLDPF(E_ERROR_MESSAGE,"DMA_VID_TABLE_ADDR::CP_SYNC data too large\n");
}
__inline void set_DMA_VID_TABLE_ADDR_table_addr(regDMA_VID_TABLE_ADDR *reg, unsigned int table_addr)
{
  reg->bitfields.TABLE_ADDR = table_addr;
  if (reg->bitfields.TABLE_ADDR != table_addr) HSLDPF(E_ERROR_MESSAGE,"DMA_VID_TABLE_ADDR::TABLE_ADDR data too large\n");
}
#else
#define set_DMA_VID_TABLE_ADDR_cp_sync(reg, cp_sync) (reg)->bitfields.CP_SYNC = cp_sync
#define set_DMA_VID_TABLE_ADDR_table_addr(reg, table_addr) (reg)->bitfields.TABLE_ADDR = table_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_VID_SRC_ADDR regDMA_VID_SRC_ADDR;

#ifdef DEBUG
__inline void set_DMA_VID_SRC_ADDR_src_addr(regDMA_VID_SRC_ADDR *reg, unsigned int src_addr)
{
  reg->bitfields.SRC_ADDR = src_addr;
  if (reg->bitfields.SRC_ADDR != src_addr) HSLDPF(E_ERROR_MESSAGE,"DMA_VID_SRC_ADDR::SRC_ADDR data too large\n");
}
#else
#define set_DMA_VID_SRC_ADDR_src_addr(reg, src_addr) (reg)->bitfields.SRC_ADDR = src_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_VID_DST_ADDR regDMA_VID_DST_ADDR;

#ifdef DEBUG
__inline void set_DMA_VID_DST_ADDR_dst_addr(regDMA_VID_DST_ADDR *reg, unsigned int dst_addr)
{
  reg->bitfields.DST_ADDR = dst_addr;
  if (reg->bitfields.DST_ADDR != dst_addr) HSLDPF(E_ERROR_MESSAGE,"DMA_VID_DST_ADDR::DST_ADDR data too large\n");
}
#else
#define set_DMA_VID_DST_ADDR_dst_addr(reg, dst_addr) (reg)->bitfields.DST_ADDR = dst_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_VID_COMMAND regDMA_VID_COMMAND;

#ifdef DEBUG
__inline void set_DMA_VID_COMMAND_byte_count(regDMA_VID_COMMAND *reg, unsigned int byte_count)
{
  reg->bitfields.BYTE_COUNT = byte_count;
  if (reg->bitfields.BYTE_COUNT != byte_count) HSLDPF(E_ERROR_MESSAGE,"DMA_VID_COMMAND::BYTE_COUNT data too large\n");
}
__inline void set_DMA_VID_COMMAND_src_swap(regDMA_VID_COMMAND *reg, unsigned int src_swap)
{
  reg->bitfields.SRC_SWAP = src_swap;
  if (reg->bitfields.SRC_SWAP != src_swap) HSLDPF(E_ERROR_MESSAGE,"DMA_VID_COMMAND::SRC_SWAP data too large\n");
}
__inline void set_DMA_VID_COMMAND_dst_swap(regDMA_VID_COMMAND *reg, unsigned int dst_swap)
{
  reg->bitfields.DST_SWAP = dst_swap;
  if (reg->bitfields.DST_SWAP != dst_swap) HSLDPF(E_ERROR_MESSAGE,"DMA_VID_COMMAND::DST_SWAP data too large\n");
}
__inline void set_DMA_VID_COMMAND_sas(regDMA_VID_COMMAND *reg, unsigned int sas)
{
  reg->bitfields.SAS = sas;
  if (reg->bitfields.SAS != sas) HSLDPF(E_ERROR_MESSAGE,"DMA_VID_COMMAND::SAS data too large\n");
}
__inline void set_DMA_VID_COMMAND_das(regDMA_VID_COMMAND *reg, unsigned int das)
{
  reg->bitfields.DAS = das;
  if (reg->bitfields.DAS != das) HSLDPF(E_ERROR_MESSAGE,"DMA_VID_COMMAND::DAS data too large\n");
}
__inline void set_DMA_VID_COMMAND_saic(regDMA_VID_COMMAND *reg, unsigned int saic)
{
  reg->bitfields.SAIC = saic;
  if (reg->bitfields.SAIC != saic) HSLDPF(E_ERROR_MESSAGE,"DMA_VID_COMMAND::SAIC data too large\n");
}
__inline void set_DMA_VID_COMMAND_daic(regDMA_VID_COMMAND *reg, unsigned int daic)
{
  reg->bitfields.DAIC = daic;
  if (reg->bitfields.DAIC != daic) HSLDPF(E_ERROR_MESSAGE,"DMA_VID_COMMAND::DAIC data too large\n");
}
__inline void set_DMA_VID_COMMAND_intdis(regDMA_VID_COMMAND *reg, unsigned int intdis)
{
  reg->bitfields.INTDIS = intdis;
  if (reg->bitfields.INTDIS != intdis) HSLDPF(E_ERROR_MESSAGE,"DMA_VID_COMMAND::INTDIS data too large\n");
}
__inline void set_DMA_VID_COMMAND_eol(regDMA_VID_COMMAND *reg, unsigned int eol)
{
  reg->bitfields.EOL = eol;
  if (reg->bitfields.EOL != eol) HSLDPF(E_ERROR_MESSAGE,"DMA_VID_COMMAND::EOL data too large\n");
}
#else
#define set_DMA_VID_COMMAND_byte_count(reg, byte_count) (reg)->bitfields.BYTE_COUNT = byte_count
#define set_DMA_VID_COMMAND_src_swap(reg, src_swap) (reg)->bitfields.SRC_SWAP = src_swap
#define set_DMA_VID_COMMAND_dst_swap(reg, dst_swap) (reg)->bitfields.DST_SWAP = dst_swap
#define set_DMA_VID_COMMAND_sas(reg, sas) (reg)->bitfields.SAS = sas
#define set_DMA_VID_COMMAND_das(reg, das) (reg)->bitfields.DAS = das
#define set_DMA_VID_COMMAND_saic(reg, saic) (reg)->bitfields.SAIC = saic
#define set_DMA_VID_COMMAND_daic(reg, daic) (reg)->bitfields.DAIC = daic
#define set_DMA_VID_COMMAND_intdis(reg, intdis) (reg)->bitfields.INTDIS = intdis
#define set_DMA_VID_COMMAND_eol(reg, eol) (reg)->bitfields.EOL = eol

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_VID_STATUS regDMA_VID_STATUS;

#ifdef DEBUG
__inline void set_DMA_VID_STATUS_dtaq_avail(regDMA_VID_STATUS *reg, unsigned int dtaq_avail)
{
  reg->bitfields.DTAQ_AVAIL = dtaq_avail;
  if (reg->bitfields.DTAQ_AVAIL != dtaq_avail) HSLDPF(E_ERROR_MESSAGE,"DMA_VID_STATUS::DTAQ_AVAIL data too large\n");
}
__inline void set_DMA_VID_STATUS_last_table_num(regDMA_VID_STATUS *reg, unsigned int last_table_num)
{
  reg->bitfields.LAST_TABLE_NUM = last_table_num;
  if (reg->bitfields.LAST_TABLE_NUM != last_table_num) HSLDPF(E_ERROR_MESSAGE,"DMA_VID_STATUS::LAST_TABLE_NUM data too large\n");
}
__inline void set_DMA_VID_STATUS_current_table_num(regDMA_VID_STATUS *reg, unsigned int current_table_num)
{
  reg->bitfields.CURRENT_TABLE_NUM = current_table_num;
  if (reg->bitfields.CURRENT_TABLE_NUM != current_table_num) HSLDPF(E_ERROR_MESSAGE,"DMA_VID_STATUS::CURRENT_TABLE_NUM data too large\n");
}
__inline void set_DMA_VID_STATUS_abort_en(regDMA_VID_STATUS *reg, unsigned int abort_en)
{
  reg->bitfields.ABORT_EN = abort_en;
  if (reg->bitfields.ABORT_EN != abort_en) HSLDPF(E_ERROR_MESSAGE,"DMA_VID_STATUS::ABORT_EN data too large\n");
}
__inline void set_DMA_VID_STATUS_active(regDMA_VID_STATUS *reg, unsigned int active)
{
  reg->bitfields.ACTIVE = active;
  if (reg->bitfields.ACTIVE != active) HSLDPF(E_ERROR_MESSAGE,"DMA_VID_STATUS::ACTIVE data too large\n");
}
__inline void set_DMA_VID_STATUS_swap(regDMA_VID_STATUS *reg, unsigned int swap)
{
  reg->bitfields.SWAP = swap;
  if (reg->bitfields.SWAP != swap) HSLDPF(E_ERROR_MESSAGE,"DMA_VID_STATUS::SWAP data too large\n");
}
#else
#define set_DMA_VID_STATUS_dtaq_avail(reg, dtaq_avail) (reg)->bitfields.DTAQ_AVAIL = dtaq_avail
#define set_DMA_VID_STATUS_last_table_num(reg, last_table_num) (reg)->bitfields.LAST_TABLE_NUM = last_table_num
#define set_DMA_VID_STATUS_current_table_num(reg, current_table_num) (reg)->bitfields.CURRENT_TABLE_NUM = current_table_num
#define set_DMA_VID_STATUS_abort_en(reg, abort_en) (reg)->bitfields.ABORT_EN = abort_en
#define set_DMA_VID_STATUS_active(reg, active) (reg)->bitfields.ACTIVE = active
#define set_DMA_VID_STATUS_swap(reg, swap) (reg)->bitfields.SWAP = swap

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_VID_ACT_DSCRPTR regDMA_VID_ACT_DSCRPTR;

#ifdef DEBUG
__inline void set_DMA_VID_ACT_DSCRPTR_table_addr(regDMA_VID_ACT_DSCRPTR *reg, unsigned int table_addr)
{
  reg->bitfields.TABLE_ADDR = table_addr;
  if (reg->bitfields.TABLE_ADDR != table_addr) HSLDPF(E_ERROR_MESSAGE,"DMA_VID_ACT_DSCRPTR::TABLE_ADDR data too large\n");
}
#else
#define set_DMA_VID_ACT_DSCRPTR_table_addr(reg, table_addr) (reg)->bitfields.TABLE_ADDR = table_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_VID_SRC_ADDR regCP_VID_SRC_ADDR;

#ifdef DEBUG
__inline void set_CP_VID_SRC_ADDR_cp_vid_src_addr(regCP_VID_SRC_ADDR *reg, unsigned int cp_vid_src_addr)
{
  reg->bitfields.CP_VID_SRC_ADDR = cp_vid_src_addr;
  if (reg->bitfields.CP_VID_SRC_ADDR != cp_vid_src_addr) HSLDPF(E_ERROR_MESSAGE,"CP_VID_SRC_ADDR::CP_VID_SRC_ADDR data too large\n");
}
#else
#define set_CP_VID_SRC_ADDR_cp_vid_src_addr(reg, cp_vid_src_addr) (reg)->bitfields.CP_VID_SRC_ADDR = cp_vid_src_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_VID_DST_ADDR regCP_VID_DST_ADDR;

#ifdef DEBUG
__inline void set_CP_VID_DST_ADDR_cp_vid_dst_addr(regCP_VID_DST_ADDR *reg, unsigned int cp_vid_dst_addr)
{
  reg->bitfields.CP_VID_DST_ADDR = cp_vid_dst_addr;
  if (reg->bitfields.CP_VID_DST_ADDR != cp_vid_dst_addr) HSLDPF(E_ERROR_MESSAGE,"CP_VID_DST_ADDR::CP_VID_DST_ADDR data too large\n");
}
#else
#define set_CP_VID_DST_ADDR_cp_vid_dst_addr(reg, cp_vid_dst_addr) (reg)->bitfields.CP_VID_DST_ADDR = cp_vid_dst_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_VID_COMMAND regCP_VID_COMMAND;

#ifdef DEBUG
__inline void set_CP_VID_COMMAND_cp_vid_command(regCP_VID_COMMAND *reg, unsigned int cp_vid_command)
{
  reg->bitfields.CP_VID_COMMAND = cp_vid_command;
  if (reg->bitfields.CP_VID_COMMAND != cp_vid_command) HSLDPF(E_ERROR_MESSAGE,"CP_VID_COMMAND::CP_VID_COMMAND data too large\n");
}
#else
#define set_CP_VID_COMMAND_cp_vid_command(reg, cp_vid_command) (reg)->bitfields.CP_VID_COMMAND = cp_vid_command

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_CSQ2_STAT regCP_CSQ2_STAT;

#ifdef DEBUG
__inline void set_CP_CSQ2_STAT_csq_wptr_indirect(regCP_CSQ2_STAT *reg, unsigned int csq_wptr_indirect)
{
  reg->bitfields.CSQ_WPTR_INDIRECT = csq_wptr_indirect;
  if (reg->bitfields.CSQ_WPTR_INDIRECT != csq_wptr_indirect) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ2_STAT::CSQ_WPTR_INDIRECT data too large\n");
}
__inline void set_CP_CSQ2_STAT_csq_rptr_indirect2(regCP_CSQ2_STAT *reg, unsigned int csq_rptr_indirect2)
{
  reg->bitfields.CSQ_RPTR_INDIRECT2 = csq_rptr_indirect2;
  if (reg->bitfields.CSQ_RPTR_INDIRECT2 != csq_rptr_indirect2) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ2_STAT::CSQ_RPTR_INDIRECT2 data too large\n");
}
__inline void set_CP_CSQ2_STAT_csq_wptr_indirect2(regCP_CSQ2_STAT *reg, unsigned int csq_wptr_indirect2)
{
  reg->bitfields.CSQ_WPTR_INDIRECT2 = csq_wptr_indirect2;
  if (reg->bitfields.CSQ_WPTR_INDIRECT2 != csq_wptr_indirect2) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ2_STAT::CSQ_WPTR_INDIRECT2 data too large\n");
}
#else
#define set_CP_CSQ2_STAT_csq_wptr_indirect(reg, csq_wptr_indirect) (reg)->bitfields.CSQ_WPTR_INDIRECT = csq_wptr_indirect
#define set_CP_CSQ2_STAT_csq_rptr_indirect2(reg, csq_rptr_indirect2) (reg)->bitfields.CSQ_RPTR_INDIRECT2 = csq_rptr_indirect2
#define set_CP_CSQ2_STAT_csq_wptr_indirect2(reg, csq_wptr_indirect2) (reg)->bitfields.CSQ_WPTR_INDIRECT2 = csq_wptr_indirect2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_CSQ_ADDR regCP_CSQ_ADDR;

#ifdef DEBUG
__inline void set_CP_CSQ_ADDR_csq_addr(regCP_CSQ_ADDR *reg, unsigned int csq_addr)
{
  reg->bitfields.CSQ_ADDR = csq_addr;
  if (reg->bitfields.CSQ_ADDR != csq_addr) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ_ADDR::CSQ_ADDR data too large\n");
}
#else
#define set_CP_CSQ_ADDR_csq_addr(reg, csq_addr) (reg)->bitfields.CSQ_ADDR = csq_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_CSQ_DATA regCP_CSQ_DATA;

#ifdef DEBUG
__inline void set_CP_CSQ_DATA_csq_data(regCP_CSQ_DATA *reg, unsigned int csq_data)
{
  reg->bitfields.CSQ_DATA = csq_data;
  if (reg->bitfields.CSQ_DATA != csq_data) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ_DATA::CSQ_DATA data too large\n");
}
#else
#define set_CP_CSQ_DATA_csq_data(reg, csq_data) (reg)->bitfields.CSQ_DATA = csq_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_CSQ_STAT regCP_CSQ_STAT;

#ifdef DEBUG
__inline void set_CP_CSQ_STAT_csq_rptr_primary(regCP_CSQ_STAT *reg, unsigned int csq_rptr_primary)
{
  reg->bitfields.CSQ_RPTR_PRIMARY = csq_rptr_primary;
  if (reg->bitfields.CSQ_RPTR_PRIMARY != csq_rptr_primary) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ_STAT::CSQ_RPTR_PRIMARY data too large\n");
}
__inline void set_CP_CSQ_STAT_csq_wptr_primary(regCP_CSQ_STAT *reg, unsigned int csq_wptr_primary)
{
  reg->bitfields.CSQ_WPTR_PRIMARY = csq_wptr_primary;
  if (reg->bitfields.CSQ_WPTR_PRIMARY != csq_wptr_primary) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ_STAT::CSQ_WPTR_PRIMARY data too large\n");
}
__inline void set_CP_CSQ_STAT_csq_rptr_indirect(regCP_CSQ_STAT *reg, unsigned int csq_rptr_indirect)
{
  reg->bitfields.CSQ_RPTR_INDIRECT = csq_rptr_indirect;
  if (reg->bitfields.CSQ_RPTR_INDIRECT != csq_rptr_indirect) HSLDPF(E_ERROR_MESSAGE,"CP_CSQ_STAT::CSQ_RPTR_INDIRECT data too large\n");
}
#else
#define set_CP_CSQ_STAT_csq_rptr_primary(reg, csq_rptr_primary) (reg)->bitfields.CSQ_RPTR_PRIMARY = csq_rptr_primary
#define set_CP_CSQ_STAT_csq_wptr_primary(reg, csq_wptr_primary) (reg)->bitfields.CSQ_WPTR_PRIMARY = csq_wptr_primary
#define set_CP_CSQ_STAT_csq_rptr_indirect(reg, csq_rptr_indirect) (reg)->bitfields.CSQ_RPTR_INDIRECT = csq_rptr_indirect

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CP_STAT regCP_STAT;

#ifdef DEBUG
__inline void set_CP_STAT_mru_busy(regCP_STAT *reg, unsigned int mru_busy)
{
  reg->bitfields.MRU_BUSY = mru_busy;
  if (reg->bitfields.MRU_BUSY != mru_busy) HSLDPF(E_ERROR_MESSAGE,"CP_STAT::MRU_BUSY data too large\n");
}
__inline void set_CP_STAT_mwu_busy(regCP_STAT *reg, unsigned int mwu_busy)
{
  reg->bitfields.MWU_BUSY = mwu_busy;
  if (reg->bitfields.MWU_BUSY != mwu_busy) HSLDPF(E_ERROR_MESSAGE,"CP_STAT::MWU_BUSY data too large\n");
}
__inline void set_CP_STAT_rsiu_busy(regCP_STAT *reg, unsigned int rsiu_busy)
{
  reg->bitfields.RSIU_BUSY = rsiu_busy;
  if (reg->bitfields.RSIU_BUSY != rsiu_busy) HSLDPF(E_ERROR_MESSAGE,"CP_STAT::RSIU_BUSY data too large\n");
}
__inline void set_CP_STAT_rciu_busy(regCP_STAT *reg, unsigned int rciu_busy)
{
  reg->bitfields.RCIU_BUSY = rciu_busy;
  if (reg->bitfields.RCIU_BUSY != rciu_busy) HSLDPF(E_ERROR_MESSAGE,"CP_STAT::RCIU_BUSY data too large\n");
}
__inline void set_CP_STAT_csf_primary_busy(regCP_STAT *reg, unsigned int csf_primary_busy)
{
  reg->bitfields.CSF_PRIMARY_BUSY = csf_primary_busy;
  if (reg->bitfields.CSF_PRIMARY_BUSY != csf_primary_busy) HSLDPF(E_ERROR_MESSAGE,"CP_STAT::CSF_PRIMARY_BUSY data too large\n");
}
__inline void set_CP_STAT_csf_indirect_busy(regCP_STAT *reg, unsigned int csf_indirect_busy)
{
  reg->bitfields.CSF_INDIRECT_BUSY = csf_indirect_busy;
  if (reg->bitfields.CSF_INDIRECT_BUSY != csf_indirect_busy) HSLDPF(E_ERROR_MESSAGE,"CP_STAT::CSF_INDIRECT_BUSY data too large\n");
}
__inline void set_CP_STAT_csq_primary_busy(regCP_STAT *reg, unsigned int csq_primary_busy)
{
  reg->bitfields.CSQ_PRIMARY_BUSY = csq_primary_busy;
  if (reg->bitfields.CSQ_PRIMARY_BUSY != csq_primary_busy) HSLDPF(E_ERROR_MESSAGE,"CP_STAT::CSQ_PRIMARY_BUSY data too large\n");
}
__inline void set_CP_STAT_csq_indirect_busy(regCP_STAT *reg, unsigned int csq_indirect_busy)
{
  reg->bitfields.CSQ_INDIRECT_BUSY = csq_indirect_busy;
  if (reg->bitfields.CSQ_INDIRECT_BUSY != csq_indirect_busy) HSLDPF(E_ERROR_MESSAGE,"CP_STAT::CSQ_INDIRECT_BUSY data too large\n");
}
__inline void set_CP_STAT_csi_busy(regCP_STAT *reg, unsigned int csi_busy)
{
  reg->bitfields.CSI_BUSY = csi_busy;
  if (reg->bitfields.CSI_BUSY != csi_busy) HSLDPF(E_ERROR_MESSAGE,"CP_STAT::CSI_BUSY data too large\n");
}
__inline void set_CP_STAT_csf_indirect2_busy(regCP_STAT *reg, unsigned int csf_indirect2_busy)
{
  reg->bitfields.CSF_INDIRECT2_BUSY = csf_indirect2_busy;
  if (reg->bitfields.CSF_INDIRECT2_BUSY != csf_indirect2_busy) HSLDPF(E_ERROR_MESSAGE,"CP_STAT::CSF_INDIRECT2_BUSY data too large\n");
}
__inline void set_CP_STAT_csq_indirect2_busy(regCP_STAT *reg, unsigned int csq_indirect2_busy)
{
  reg->bitfields.CSQ_INDIRECT2_BUSY = csq_indirect2_busy;
  if (reg->bitfields.CSQ_INDIRECT2_BUSY != csq_indirect2_busy) HSLDPF(E_ERROR_MESSAGE,"CP_STAT::CSQ_INDIRECT2_BUSY data too large\n");
}
__inline void set_CP_STAT_guidma_busy(regCP_STAT *reg, unsigned int guidma_busy)
{
  reg->bitfields.GUIDMA_BUSY = guidma_busy;
  if (reg->bitfields.GUIDMA_BUSY != guidma_busy) HSLDPF(E_ERROR_MESSAGE,"CP_STAT::GUIDMA_BUSY data too large\n");
}
__inline void set_CP_STAT_viddma_busy(regCP_STAT *reg, unsigned int viddma_busy)
{
  reg->bitfields.VIDDMA_BUSY = viddma_busy;
  if (reg->bitfields.VIDDMA_BUSY != viddma_busy) HSLDPF(E_ERROR_MESSAGE,"CP_STAT::VIDDMA_BUSY data too large\n");
}
__inline void set_CP_STAT_cmdstrm_busy(regCP_STAT *reg, unsigned int cmdstrm_busy)
{
  reg->bitfields.CMDSTRM_BUSY = cmdstrm_busy;
  if (reg->bitfields.CMDSTRM_BUSY != cmdstrm_busy) HSLDPF(E_ERROR_MESSAGE,"CP_STAT::CMDSTRM_BUSY data too large\n");
}
__inline void set_CP_STAT_cp_busy(regCP_STAT *reg, unsigned int cp_busy)
{
  reg->bitfields.CP_BUSY = cp_busy;
  if (reg->bitfields.CP_BUSY != cp_busy) HSLDPF(E_ERROR_MESSAGE,"CP_STAT::CP_BUSY data too large\n");
}
#else
#define set_CP_STAT_mru_busy(reg, mru_busy) (reg)->bitfields.MRU_BUSY = mru_busy
#define set_CP_STAT_mwu_busy(reg, mwu_busy) (reg)->bitfields.MWU_BUSY = mwu_busy
#define set_CP_STAT_rsiu_busy(reg, rsiu_busy) (reg)->bitfields.RSIU_BUSY = rsiu_busy
#define set_CP_STAT_rciu_busy(reg, rciu_busy) (reg)->bitfields.RCIU_BUSY = rciu_busy
#define set_CP_STAT_csf_primary_busy(reg, csf_primary_busy) (reg)->bitfields.CSF_PRIMARY_BUSY = csf_primary_busy
#define set_CP_STAT_csf_indirect_busy(reg, csf_indirect_busy) (reg)->bitfields.CSF_INDIRECT_BUSY = csf_indirect_busy
#define set_CP_STAT_csq_primary_busy(reg, csq_primary_busy) (reg)->bitfields.CSQ_PRIMARY_BUSY = csq_primary_busy
#define set_CP_STAT_csq_indirect_busy(reg, csq_indirect_busy) (reg)->bitfields.CSQ_INDIRECT_BUSY = csq_indirect_busy
#define set_CP_STAT_csi_busy(reg, csi_busy) (reg)->bitfields.CSI_BUSY = csi_busy
#define set_CP_STAT_csf_indirect2_busy(reg, csf_indirect2_busy) (reg)->bitfields.CSF_INDIRECT2_BUSY = csf_indirect2_busy
#define set_CP_STAT_csq_indirect2_busy(reg, csq_indirect2_busy) (reg)->bitfields.CSQ_INDIRECT2_BUSY = csq_indirect2_busy
#define set_CP_STAT_guidma_busy(reg, guidma_busy) (reg)->bitfields.GUIDMA_BUSY = guidma_busy
#define set_CP_STAT_viddma_busy(reg, viddma_busy) (reg)->bitfields.VIDDMA_BUSY = viddma_busy
#define set_CP_STAT_cmdstrm_busy(reg, cmdstrm_busy) (reg)->bitfields.CMDSTRM_BUSY = cmdstrm_busy
#define set_CP_STAT_cp_busy(reg, cp_busy) (reg)->bitfields.CP_BUSY = cp_busy

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_DATA0 regSE_PORT_DATA0;

#ifdef DEBUG
__inline void set_SE_PORT_DATA0_dataport0(regSE_PORT_DATA0 *reg, unsigned int dataport0)
{
  reg->bitfields.DATAPORT0 = dataport0;
  if (reg->bitfields.DATAPORT0 != dataport0) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_DATA0::DATAPORT0 data too large\n");
}
#else
#define set_SE_PORT_DATA0_dataport0(reg, dataport0) (reg)->bitfields.DATAPORT0 = dataport0

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_DATA1 regSE_PORT_DATA1;

#ifdef DEBUG
__inline void set_SE_PORT_DATA1_dataport1(regSE_PORT_DATA1 *reg, unsigned int dataport1)
{
  reg->bitfields.DATAPORT1 = dataport1;
  if (reg->bitfields.DATAPORT1 != dataport1) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_DATA1::DATAPORT1 data too large\n");
}
#else
#define set_SE_PORT_DATA1_dataport1(reg, dataport1) (reg)->bitfields.DATAPORT1 = dataport1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_DATA2 regSE_PORT_DATA2;

#ifdef DEBUG
__inline void set_SE_PORT_DATA2_dataport2(regSE_PORT_DATA2 *reg, unsigned int dataport2)
{
  reg->bitfields.DATAPORT2 = dataport2;
  if (reg->bitfields.DATAPORT2 != dataport2) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_DATA2::DATAPORT2 data too large\n");
}
#else
#define set_SE_PORT_DATA2_dataport2(reg, dataport2) (reg)->bitfields.DATAPORT2 = dataport2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_DATA3 regSE_PORT_DATA3;

#ifdef DEBUG
__inline void set_SE_PORT_DATA3_dataport3(regSE_PORT_DATA3 *reg, unsigned int dataport3)
{
  reg->bitfields.DATAPORT3 = dataport3;
  if (reg->bitfields.DATAPORT3 != dataport3) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_DATA3::DATAPORT3 data too large\n");
}
#else
#define set_SE_PORT_DATA3_dataport3(reg, dataport3) (reg)->bitfields.DATAPORT3 = dataport3

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_DATA4 regSE_PORT_DATA4;

#ifdef DEBUG
__inline void set_SE_PORT_DATA4_dataport4(regSE_PORT_DATA4 *reg, unsigned int dataport4)
{
  reg->bitfields.DATAPORT4 = dataport4;
  if (reg->bitfields.DATAPORT4 != dataport4) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_DATA4::DATAPORT4 data too large\n");
}
#else
#define set_SE_PORT_DATA4_dataport4(reg, dataport4) (reg)->bitfields.DATAPORT4 = dataport4

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_DATA5 regSE_PORT_DATA5;

#ifdef DEBUG
__inline void set_SE_PORT_DATA5_dataport5(regSE_PORT_DATA5 *reg, unsigned int dataport5)
{
  reg->bitfields.DATAPORT5 = dataport5;
  if (reg->bitfields.DATAPORT5 != dataport5) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_DATA5::DATAPORT5 data too large\n");
}
#else
#define set_SE_PORT_DATA5_dataport5(reg, dataport5) (reg)->bitfields.DATAPORT5 = dataport5

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_DATA6 regSE_PORT_DATA6;

#ifdef DEBUG
__inline void set_SE_PORT_DATA6_dataport6(regSE_PORT_DATA6 *reg, unsigned int dataport6)
{
  reg->bitfields.DATAPORT6 = dataport6;
  if (reg->bitfields.DATAPORT6 != dataport6) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_DATA6::DATAPORT6 data too large\n");
}
#else
#define set_SE_PORT_DATA6_dataport6(reg, dataport6) (reg)->bitfields.DATAPORT6 = dataport6

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_DATA7 regSE_PORT_DATA7;

#ifdef DEBUG
__inline void set_SE_PORT_DATA7_dataport7(regSE_PORT_DATA7 *reg, unsigned int dataport7)
{
  reg->bitfields.DATAPORT7 = dataport7;
  if (reg->bitfields.DATAPORT7 != dataport7) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_DATA7::DATAPORT7 data too large\n");
}
#else
#define set_SE_PORT_DATA7_dataport7(reg, dataport7) (reg)->bitfields.DATAPORT7 = dataport7

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_DATA8 regSE_PORT_DATA8;

#ifdef DEBUG
__inline void set_SE_PORT_DATA8_dataport8(regSE_PORT_DATA8 *reg, unsigned int dataport8)
{
  reg->bitfields.DATAPORT8 = dataport8;
  if (reg->bitfields.DATAPORT8 != dataport8) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_DATA8::DATAPORT8 data too large\n");
}
#else
#define set_SE_PORT_DATA8_dataport8(reg, dataport8) (reg)->bitfields.DATAPORT8 = dataport8

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_DATA9 regSE_PORT_DATA9;

#ifdef DEBUG
__inline void set_SE_PORT_DATA9_dataport9(regSE_PORT_DATA9 *reg, unsigned int dataport9)
{
  reg->bitfields.DATAPORT9 = dataport9;
  if (reg->bitfields.DATAPORT9 != dataport9) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_DATA9::DATAPORT9 data too large\n");
}
#else
#define set_SE_PORT_DATA9_dataport9(reg, dataport9) (reg)->bitfields.DATAPORT9 = dataport9

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_DATA10 regSE_PORT_DATA10;

#ifdef DEBUG
__inline void set_SE_PORT_DATA10_dataport10(regSE_PORT_DATA10 *reg, unsigned int dataport10)
{
  reg->bitfields.DATAPORT10 = dataport10;
  if (reg->bitfields.DATAPORT10 != dataport10) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_DATA10::DATAPORT10 data too large\n");
}
#else
#define set_SE_PORT_DATA10_dataport10(reg, dataport10) (reg)->bitfields.DATAPORT10 = dataport10

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_DATA11 regSE_PORT_DATA11;

#ifdef DEBUG
__inline void set_SE_PORT_DATA11_dataport11(regSE_PORT_DATA11 *reg, unsigned int dataport11)
{
  reg->bitfields.DATAPORT11 = dataport11;
  if (reg->bitfields.DATAPORT11 != dataport11) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_DATA11::DATAPORT11 data too large\n");
}
#else
#define set_SE_PORT_DATA11_dataport11(reg, dataport11) (reg)->bitfields.DATAPORT11 = dataport11

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_DATA12 regSE_PORT_DATA12;

#ifdef DEBUG
__inline void set_SE_PORT_DATA12_dataport12(regSE_PORT_DATA12 *reg, unsigned int dataport12)
{
  reg->bitfields.DATAPORT12 = dataport12;
  if (reg->bitfields.DATAPORT12 != dataport12) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_DATA12::DATAPORT12 data too large\n");
}
#else
#define set_SE_PORT_DATA12_dataport12(reg, dataport12) (reg)->bitfields.DATAPORT12 = dataport12

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_DATA13 regSE_PORT_DATA13;

#ifdef DEBUG
__inline void set_SE_PORT_DATA13_dataport13(regSE_PORT_DATA13 *reg, unsigned int dataport13)
{
  reg->bitfields.DATAPORT13 = dataport13;
  if (reg->bitfields.DATAPORT13 != dataport13) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_DATA13::DATAPORT13 data too large\n");
}
#else
#define set_SE_PORT_DATA13_dataport13(reg, dataport13) (reg)->bitfields.DATAPORT13 = dataport13

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_DATA14 regSE_PORT_DATA14;

#ifdef DEBUG
__inline void set_SE_PORT_DATA14_dataport14(regSE_PORT_DATA14 *reg, unsigned int dataport14)
{
  reg->bitfields.DATAPORT14 = dataport14;
  if (reg->bitfields.DATAPORT14 != dataport14) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_DATA14::DATAPORT14 data too large\n");
}
#else
#define set_SE_PORT_DATA14_dataport14(reg, dataport14) (reg)->bitfields.DATAPORT14 = dataport14

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_DATA15 regSE_PORT_DATA15;

#ifdef DEBUG
__inline void set_SE_PORT_DATA15_dataport15(regSE_PORT_DATA15 *reg, unsigned int dataport15)
{
  reg->bitfields.DATAPORT15 = dataport15;
  if (reg->bitfields.DATAPORT15 != dataport15) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_DATA15::DATAPORT15 data too large\n");
}
#else
#define set_SE_PORT_DATA15_dataport15(reg, dataport15) (reg)->bitfields.DATAPORT15 = dataport15

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_IDX0 regSE_PORT_IDX0;

#ifdef DEBUG
__inline void set_SE_PORT_IDX0_idxport0(regSE_PORT_IDX0 *reg, unsigned int idxport0)
{
  reg->bitfields.IDXPORT0 = idxport0;
  if (reg->bitfields.IDXPORT0 != idxport0) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_IDX0::IDXPORT0 data too large\n");
}
#else
#define set_SE_PORT_IDX0_idxport0(reg, idxport0) (reg)->bitfields.IDXPORT0 = idxport0

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_IDX1 regSE_PORT_IDX1;

#ifdef DEBUG
__inline void set_SE_PORT_IDX1_idxport1(regSE_PORT_IDX1 *reg, unsigned int idxport1)
{
  reg->bitfields.IDXPORT1 = idxport1;
  if (reg->bitfields.IDXPORT1 != idxport1) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_IDX1::IDXPORT1 data too large\n");
}
#else
#define set_SE_PORT_IDX1_idxport1(reg, idxport1) (reg)->bitfields.IDXPORT1 = idxport1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_IDX2 regSE_PORT_IDX2;

#ifdef DEBUG
__inline void set_SE_PORT_IDX2_idxport2(regSE_PORT_IDX2 *reg, unsigned int idxport2)
{
  reg->bitfields.IDXPORT2 = idxport2;
  if (reg->bitfields.IDXPORT2 != idxport2) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_IDX2::IDXPORT2 data too large\n");
}
#else
#define set_SE_PORT_IDX2_idxport2(reg, idxport2) (reg)->bitfields.IDXPORT2 = idxport2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_IDX3 regSE_PORT_IDX3;

#ifdef DEBUG
__inline void set_SE_PORT_IDX3_idxport3(regSE_PORT_IDX3 *reg, unsigned int idxport3)
{
  reg->bitfields.IDXPORT3 = idxport3;
  if (reg->bitfields.IDXPORT3 != idxport3) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_IDX3::IDXPORT3 data too large\n");
}
#else
#define set_SE_PORT_IDX3_idxport3(reg, idxport3) (reg)->bitfields.IDXPORT3 = idxport3

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_IDX4 regSE_PORT_IDX4;

#ifdef DEBUG
__inline void set_SE_PORT_IDX4_idxport4(regSE_PORT_IDX4 *reg, unsigned int idxport4)
{
  reg->bitfields.IDXPORT4 = idxport4;
  if (reg->bitfields.IDXPORT4 != idxport4) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_IDX4::IDXPORT4 data too large\n");
}
#else
#define set_SE_PORT_IDX4_idxport4(reg, idxport4) (reg)->bitfields.IDXPORT4 = idxport4

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_IDX5 regSE_PORT_IDX5;

#ifdef DEBUG
__inline void set_SE_PORT_IDX5_idxport5(regSE_PORT_IDX5 *reg, unsigned int idxport5)
{
  reg->bitfields.IDXPORT5 = idxport5;
  if (reg->bitfields.IDXPORT5 != idxport5) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_IDX5::IDXPORT5 data too large\n");
}
#else
#define set_SE_PORT_IDX5_idxport5(reg, idxport5) (reg)->bitfields.IDXPORT5 = idxport5

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_IDX6 regSE_PORT_IDX6;

#ifdef DEBUG
__inline void set_SE_PORT_IDX6_idxport6(regSE_PORT_IDX6 *reg, unsigned int idxport6)
{
  reg->bitfields.IDXPORT6 = idxport6;
  if (reg->bitfields.IDXPORT6 != idxport6) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_IDX6::IDXPORT6 data too large\n");
}
#else
#define set_SE_PORT_IDX6_idxport6(reg, idxport6) (reg)->bitfields.IDXPORT6 = idxport6

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_IDX7 regSE_PORT_IDX7;

#ifdef DEBUG
__inline void set_SE_PORT_IDX7_idxport7(regSE_PORT_IDX7 *reg, unsigned int idxport7)
{
  reg->bitfields.IDXPORT7 = idxport7;
  if (reg->bitfields.IDXPORT7 != idxport7) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_IDX7::IDXPORT7 data too large\n");
}
#else
#define set_SE_PORT_IDX7_idxport7(reg, idxport7) (reg)->bitfields.IDXPORT7 = idxport7

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_IDX8 regSE_PORT_IDX8;

#ifdef DEBUG
__inline void set_SE_PORT_IDX8_idxport8(regSE_PORT_IDX8 *reg, unsigned int idxport8)
{
  reg->bitfields.IDXPORT8 = idxport8;
  if (reg->bitfields.IDXPORT8 != idxport8) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_IDX8::IDXPORT8 data too large\n");
}
#else
#define set_SE_PORT_IDX8_idxport8(reg, idxport8) (reg)->bitfields.IDXPORT8 = idxport8

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_IDX9 regSE_PORT_IDX9;

#ifdef DEBUG
__inline void set_SE_PORT_IDX9_idxport9(regSE_PORT_IDX9 *reg, unsigned int idxport9)
{
  reg->bitfields.IDXPORT9 = idxport9;
  if (reg->bitfields.IDXPORT9 != idxport9) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_IDX9::IDXPORT9 data too large\n");
}
#else
#define set_SE_PORT_IDX9_idxport9(reg, idxport9) (reg)->bitfields.IDXPORT9 = idxport9

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_IDX10 regSE_PORT_IDX10;

#ifdef DEBUG
__inline void set_SE_PORT_IDX10_idxport10(regSE_PORT_IDX10 *reg, unsigned int idxport10)
{
  reg->bitfields.IDXPORT10 = idxport10;
  if (reg->bitfields.IDXPORT10 != idxport10) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_IDX10::IDXPORT10 data too large\n");
}
#else
#define set_SE_PORT_IDX10_idxport10(reg, idxport10) (reg)->bitfields.IDXPORT10 = idxport10

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_IDX11 regSE_PORT_IDX11;

#ifdef DEBUG
__inline void set_SE_PORT_IDX11_idxport11(regSE_PORT_IDX11 *reg, unsigned int idxport11)
{
  reg->bitfields.IDXPORT11 = idxport11;
  if (reg->bitfields.IDXPORT11 != idxport11) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_IDX11::IDXPORT11 data too large\n");
}
#else
#define set_SE_PORT_IDX11_idxport11(reg, idxport11) (reg)->bitfields.IDXPORT11 = idxport11

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_IDX12 regSE_PORT_IDX12;

#ifdef DEBUG
__inline void set_SE_PORT_IDX12_idxport12(regSE_PORT_IDX12 *reg, unsigned int idxport12)
{
  reg->bitfields.IDXPORT12 = idxport12;
  if (reg->bitfields.IDXPORT12 != idxport12) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_IDX12::IDXPORT12 data too large\n");
}
#else
#define set_SE_PORT_IDX12_idxport12(reg, idxport12) (reg)->bitfields.IDXPORT12 = idxport12

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_IDX13 regSE_PORT_IDX13;

#ifdef DEBUG
__inline void set_SE_PORT_IDX13_idxport13(regSE_PORT_IDX13 *reg, unsigned int idxport13)
{
  reg->bitfields.IDXPORT13 = idxport13;
  if (reg->bitfields.IDXPORT13 != idxport13) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_IDX13::IDXPORT13 data too large\n");
}
#else
#define set_SE_PORT_IDX13_idxport13(reg, idxport13) (reg)->bitfields.IDXPORT13 = idxport13

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_IDX14 regSE_PORT_IDX14;

#ifdef DEBUG
__inline void set_SE_PORT_IDX14_idxport14(regSE_PORT_IDX14 *reg, unsigned int idxport14)
{
  reg->bitfields.IDXPORT14 = idxport14;
  if (reg->bitfields.IDXPORT14 != idxport14) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_IDX14::IDXPORT14 data too large\n");
}
#else
#define set_SE_PORT_IDX14_idxport14(reg, idxport14) (reg)->bitfields.IDXPORT14 = idxport14

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PORT_IDX15 regSE_PORT_IDX15;

#ifdef DEBUG
__inline void set_SE_PORT_IDX15_idxport15(regSE_PORT_IDX15 *reg, unsigned int idxport15)
{
  reg->bitfields.IDXPORT15 = idxport15;
  if (reg->bitfields.IDXPORT15 != idxport15) HSLDPF(E_ERROR_MESSAGE,"SE_PORT_IDX15::IDXPORT15 data too large\n");
}
#else
#define set_SE_PORT_IDX15_idxport15(reg, idxport15) (reg)->bitfields.IDXPORT15 = idxport15

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VF_CNTL regSE_VF_CNTL;

#ifdef DEBUG
__inline void set_SE_VF_CNTL_prim_type(regSE_VF_CNTL *reg, unsigned int prim_type)
{
  reg->bitfields.PRIM_TYPE = prim_type;
  if (reg->bitfields.PRIM_TYPE != prim_type) HSLDPF(E_ERROR_MESSAGE,"SE_VF_CNTL::PRIM_TYPE data too large\n");
}
__inline void set_SE_VF_CNTL_prim_walk(regSE_VF_CNTL *reg, unsigned int prim_walk)
{
  reg->bitfields.PRIM_WALK = prim_walk;
  if (reg->bitfields.PRIM_WALK != prim_walk) HSLDPF(E_ERROR_MESSAGE,"SE_VF_CNTL::PRIM_WALK data too large\n");
}
__inline void set_SE_VF_CNTL_color_order(regSE_VF_CNTL *reg, unsigned int color_order)
{
  reg->bitfields.COLOR_ORDER = color_order;
  if (reg->bitfields.COLOR_ORDER != color_order) HSLDPF(E_ERROR_MESSAGE,"SE_VF_CNTL::COLOR_ORDER data too large\n");
}
__inline void set_SE_VF_CNTL_tcl_output_ctl_ena(regSE_VF_CNTL *reg, unsigned int tcl_output_ctl_ena)
{
  reg->bitfields.TCL_OUTPUT_CTL_ENA = tcl_output_ctl_ena;
  if (reg->bitfields.TCL_OUTPUT_CTL_ENA != tcl_output_ctl_ena) HSLDPF(E_ERROR_MESSAGE,"SE_VF_CNTL::TCL_OUTPUT_CTL_ENA data too large\n");
}
__inline void set_SE_VF_CNTL_prog_stream_ena(regSE_VF_CNTL *reg, unsigned int prog_stream_ena)
{
  reg->bitfields.PROG_STREAM_ENA = prog_stream_ena;
  if (reg->bitfields.PROG_STREAM_ENA != prog_stream_ena) HSLDPF(E_ERROR_MESSAGE,"SE_VF_CNTL::PROG_STREAM_ENA data too large\n");
}
__inline void set_SE_VF_CNTL_index_size(regSE_VF_CNTL *reg, unsigned int index_size)
{
  reg->bitfields.INDEX_SIZE = index_size;
  if (reg->bitfields.INDEX_SIZE != index_size) HSLDPF(E_ERROR_MESSAGE,"SE_VF_CNTL::INDEX_SIZE data too large\n");
}
__inline void set_SE_VF_CNTL_num_vertices(regSE_VF_CNTL *reg, unsigned int num_vertices)
{
  reg->bitfields.NUM_VERTICES = num_vertices;
  if (reg->bitfields.NUM_VERTICES != num_vertices) HSLDPF(E_ERROR_MESSAGE,"SE_VF_CNTL::NUM_VERTICES data too large\n");
}
#else
#define set_SE_VF_CNTL_prim_type(reg, prim_type) (reg)->bitfields.PRIM_TYPE = prim_type
#define set_SE_VF_CNTL_prim_walk(reg, prim_walk) (reg)->bitfields.PRIM_WALK = prim_walk
#define set_SE_VF_CNTL_color_order(reg, color_order) (reg)->bitfields.COLOR_ORDER = color_order
#define set_SE_VF_CNTL_tcl_output_ctl_ena(reg, tcl_output_ctl_ena) (reg)->bitfields.TCL_OUTPUT_CTL_ENA = tcl_output_ctl_ena
#define set_SE_VF_CNTL_prog_stream_ena(reg, prog_stream_ena) (reg)->bitfields.PROG_STREAM_ENA = prog_stream_ena
#define set_SE_VF_CNTL_index_size(reg, index_size) (reg)->bitfields.INDEX_SIZE = index_size
#define set_SE_VF_CNTL_num_vertices(reg, num_vertices) (reg)->bitfields.NUM_VERTICES = num_vertices

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_FMT_0 regSE_VTX_FMT_0;

#ifdef DEBUG
__inline void set_SE_VTX_FMT_0_vtx_z0_present(regSE_VTX_FMT_0 *reg, unsigned int vtx_z0_present)
{
  reg->bitfields.VTX_Z0_PRESENT = vtx_z0_present;
  if (reg->bitfields.VTX_Z0_PRESENT != vtx_z0_present) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_0::VTX_Z0_PRESENT data too large\n");
}
__inline void set_SE_VTX_FMT_0_vtx_w0_present(regSE_VTX_FMT_0 *reg, unsigned int vtx_w0_present)
{
  reg->bitfields.VTX_W0_PRESENT = vtx_w0_present;
  if (reg->bitfields.VTX_W0_PRESENT != vtx_w0_present) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_0::VTX_W0_PRESENT data too large\n");
}
__inline void set_SE_VTX_FMT_0_vtx_blend_weight_cnt(regSE_VTX_FMT_0 *reg, unsigned int vtx_blend_weight_cnt)
{
  reg->bitfields.VTX_BLEND_WEIGHT_CNT = vtx_blend_weight_cnt;
  if (reg->bitfields.VTX_BLEND_WEIGHT_CNT != vtx_blend_weight_cnt) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_0::VTX_BLEND_WEIGHT_CNT data too large\n");
}
__inline void set_SE_VTX_FMT_0_vtx_pv_mtx_sel_present(regSE_VTX_FMT_0 *reg, unsigned int vtx_pv_mtx_sel_present)
{
  reg->bitfields.VTX_PV_MTX_SEL_PRESENT = vtx_pv_mtx_sel_present;
  if (reg->bitfields.VTX_PV_MTX_SEL_PRESENT != vtx_pv_mtx_sel_present) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_0::VTX_PV_MTX_SEL_PRESENT data too large\n");
}
__inline void set_SE_VTX_FMT_0_vtx_n0_present(regSE_VTX_FMT_0 *reg, unsigned int vtx_n0_present)
{
  reg->bitfields.VTX_N0_PRESENT = vtx_n0_present;
  if (reg->bitfields.VTX_N0_PRESENT != vtx_n0_present) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_0::VTX_N0_PRESENT data too large\n");
}
__inline void set_SE_VTX_FMT_0_vtx_pt_size_present(regSE_VTX_FMT_0 *reg, unsigned int vtx_pt_size_present)
{
  reg->bitfields.VTX_PT_SIZE_PRESENT = vtx_pt_size_present;
  if (reg->bitfields.VTX_PT_SIZE_PRESENT != vtx_pt_size_present) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_0::VTX_PT_SIZE_PRESENT data too large\n");
}
__inline void set_SE_VTX_FMT_0_vtx_discrete_fog_present(regSE_VTX_FMT_0 *reg, unsigned int vtx_discrete_fog_present)
{
  reg->bitfields.VTX_DISCRETE_FOG_PRESENT = vtx_discrete_fog_present;
  if (reg->bitfields.VTX_DISCRETE_FOG_PRESENT != vtx_discrete_fog_present) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_0::VTX_DISCRETE_FOG_PRESENT data too large\n");
}
__inline void set_SE_VTX_FMT_0_vtx_shininess_0_present(regSE_VTX_FMT_0 *reg, unsigned int vtx_shininess_0_present)
{
  reg->bitfields.VTX_SHININESS_0_PRESENT = vtx_shininess_0_present;
  if (reg->bitfields.VTX_SHININESS_0_PRESENT != vtx_shininess_0_present) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_0::VTX_SHININESS_0_PRESENT data too large\n");
}
__inline void set_SE_VTX_FMT_0_vtx_shininess_1_present(regSE_VTX_FMT_0 *reg, unsigned int vtx_shininess_1_present)
{
  reg->bitfields.VTX_SHININESS_1_PRESENT = vtx_shininess_1_present;
  if (reg->bitfields.VTX_SHININESS_1_PRESENT != vtx_shininess_1_present) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_0::VTX_SHININESS_1_PRESENT data too large\n");
}
__inline void set_SE_VTX_FMT_0_vtx_color_0_fmt(regSE_VTX_FMT_0 *reg, unsigned int vtx_color_0_fmt)
{
  reg->bitfields.VTX_COLOR_0_FMT = vtx_color_0_fmt;
  if (reg->bitfields.VTX_COLOR_0_FMT != vtx_color_0_fmt) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_0::VTX_COLOR_0_FMT data too large\n");
}
__inline void set_SE_VTX_FMT_0_vtx_color_1_fmt(regSE_VTX_FMT_0 *reg, unsigned int vtx_color_1_fmt)
{
  reg->bitfields.VTX_COLOR_1_FMT = vtx_color_1_fmt;
  if (reg->bitfields.VTX_COLOR_1_FMT != vtx_color_1_fmt) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_0::VTX_COLOR_1_FMT data too large\n");
}
__inline void set_SE_VTX_FMT_0_vtx_color_2_fmt(regSE_VTX_FMT_0 *reg, unsigned int vtx_color_2_fmt)
{
  reg->bitfields.VTX_COLOR_2_FMT = vtx_color_2_fmt;
  if (reg->bitfields.VTX_COLOR_2_FMT != vtx_color_2_fmt) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_0::VTX_COLOR_2_FMT data too large\n");
}
__inline void set_SE_VTX_FMT_0_vtx_color_3_fmt(regSE_VTX_FMT_0 *reg, unsigned int vtx_color_3_fmt)
{
  reg->bitfields.VTX_COLOR_3_FMT = vtx_color_3_fmt;
  if (reg->bitfields.VTX_COLOR_3_FMT != vtx_color_3_fmt) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_0::VTX_COLOR_3_FMT data too large\n");
}
__inline void set_SE_VTX_FMT_0_vtx_color_4_fmt(regSE_VTX_FMT_0 *reg, unsigned int vtx_color_4_fmt)
{
  reg->bitfields.VTX_COLOR_4_FMT = vtx_color_4_fmt;
  if (reg->bitfields.VTX_COLOR_4_FMT != vtx_color_4_fmt) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_0::VTX_COLOR_4_FMT data too large\n");
}
__inline void set_SE_VTX_FMT_0_vtx_color_5_fmt(regSE_VTX_FMT_0 *reg, unsigned int vtx_color_5_fmt)
{
  reg->bitfields.VTX_COLOR_5_FMT = vtx_color_5_fmt;
  if (reg->bitfields.VTX_COLOR_5_FMT != vtx_color_5_fmt) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_0::VTX_COLOR_5_FMT data too large\n");
}
__inline void set_SE_VTX_FMT_0_vtx_color_6_fmt(regSE_VTX_FMT_0 *reg, unsigned int vtx_color_6_fmt)
{
  reg->bitfields.VTX_COLOR_6_FMT = vtx_color_6_fmt;
  if (reg->bitfields.VTX_COLOR_6_FMT != vtx_color_6_fmt) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_0::VTX_COLOR_6_FMT data too large\n");
}
__inline void set_SE_VTX_FMT_0_vtx_color_7_fmt(regSE_VTX_FMT_0 *reg, unsigned int vtx_color_7_fmt)
{
  reg->bitfields.VTX_COLOR_7_FMT = vtx_color_7_fmt;
  if (reg->bitfields.VTX_COLOR_7_FMT != vtx_color_7_fmt) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_0::VTX_COLOR_7_FMT data too large\n");
}
__inline void set_SE_VTX_FMT_0_vtx_xy1_present(regSE_VTX_FMT_0 *reg, unsigned int vtx_xy1_present)
{
  reg->bitfields.VTX_XY1_PRESENT = vtx_xy1_present;
  if (reg->bitfields.VTX_XY1_PRESENT != vtx_xy1_present) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_0::VTX_XY1_PRESENT data too large\n");
}
__inline void set_SE_VTX_FMT_0_vtx_z1_present(regSE_VTX_FMT_0 *reg, unsigned int vtx_z1_present)
{
  reg->bitfields.VTX_Z1_PRESENT = vtx_z1_present;
  if (reg->bitfields.VTX_Z1_PRESENT != vtx_z1_present) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_0::VTX_Z1_PRESENT data too large\n");
}
__inline void set_SE_VTX_FMT_0_vtx_w1_present(regSE_VTX_FMT_0 *reg, unsigned int vtx_w1_present)
{
  reg->bitfields.VTX_W1_PRESENT = vtx_w1_present;
  if (reg->bitfields.VTX_W1_PRESENT != vtx_w1_present) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_0::VTX_W1_PRESENT data too large\n");
}
__inline void set_SE_VTX_FMT_0_vtx_n1_present(regSE_VTX_FMT_0 *reg, unsigned int vtx_n1_present)
{
  reg->bitfields.VTX_N1_PRESENT = vtx_n1_present;
  if (reg->bitfields.VTX_N1_PRESENT != vtx_n1_present) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_0::VTX_N1_PRESENT data too large\n");
}
#else
#define set_SE_VTX_FMT_0_vtx_z0_present(reg, vtx_z0_present) (reg)->bitfields.VTX_Z0_PRESENT = vtx_z0_present
#define set_SE_VTX_FMT_0_vtx_w0_present(reg, vtx_w0_present) (reg)->bitfields.VTX_W0_PRESENT = vtx_w0_present
#define set_SE_VTX_FMT_0_vtx_blend_weight_cnt(reg, vtx_blend_weight_cnt) (reg)->bitfields.VTX_BLEND_WEIGHT_CNT = vtx_blend_weight_cnt
#define set_SE_VTX_FMT_0_vtx_pv_mtx_sel_present(reg, vtx_pv_mtx_sel_present) (reg)->bitfields.VTX_PV_MTX_SEL_PRESENT = vtx_pv_mtx_sel_present
#define set_SE_VTX_FMT_0_vtx_n0_present(reg, vtx_n0_present) (reg)->bitfields.VTX_N0_PRESENT = vtx_n0_present
#define set_SE_VTX_FMT_0_vtx_pt_size_present(reg, vtx_pt_size_present) (reg)->bitfields.VTX_PT_SIZE_PRESENT = vtx_pt_size_present
#define set_SE_VTX_FMT_0_vtx_discrete_fog_present(reg, vtx_discrete_fog_present) (reg)->bitfields.VTX_DISCRETE_FOG_PRESENT = vtx_discrete_fog_present
#define set_SE_VTX_FMT_0_vtx_shininess_0_present(reg, vtx_shininess_0_present) (reg)->bitfields.VTX_SHININESS_0_PRESENT = vtx_shininess_0_present
#define set_SE_VTX_FMT_0_vtx_shininess_1_present(reg, vtx_shininess_1_present) (reg)->bitfields.VTX_SHININESS_1_PRESENT = vtx_shininess_1_present
#define set_SE_VTX_FMT_0_vtx_color_0_fmt(reg, vtx_color_0_fmt) (reg)->bitfields.VTX_COLOR_0_FMT = vtx_color_0_fmt
#define set_SE_VTX_FMT_0_vtx_color_1_fmt(reg, vtx_color_1_fmt) (reg)->bitfields.VTX_COLOR_1_FMT = vtx_color_1_fmt
#define set_SE_VTX_FMT_0_vtx_color_2_fmt(reg, vtx_color_2_fmt) (reg)->bitfields.VTX_COLOR_2_FMT = vtx_color_2_fmt
#define set_SE_VTX_FMT_0_vtx_color_3_fmt(reg, vtx_color_3_fmt) (reg)->bitfields.VTX_COLOR_3_FMT = vtx_color_3_fmt
#define set_SE_VTX_FMT_0_vtx_color_4_fmt(reg, vtx_color_4_fmt) (reg)->bitfields.VTX_COLOR_4_FMT = vtx_color_4_fmt
#define set_SE_VTX_FMT_0_vtx_color_5_fmt(reg, vtx_color_5_fmt) (reg)->bitfields.VTX_COLOR_5_FMT = vtx_color_5_fmt
#define set_SE_VTX_FMT_0_vtx_color_6_fmt(reg, vtx_color_6_fmt) (reg)->bitfields.VTX_COLOR_6_FMT = vtx_color_6_fmt
#define set_SE_VTX_FMT_0_vtx_color_7_fmt(reg, vtx_color_7_fmt) (reg)->bitfields.VTX_COLOR_7_FMT = vtx_color_7_fmt
#define set_SE_VTX_FMT_0_vtx_xy1_present(reg, vtx_xy1_present) (reg)->bitfields.VTX_XY1_PRESENT = vtx_xy1_present
#define set_SE_VTX_FMT_0_vtx_z1_present(reg, vtx_z1_present) (reg)->bitfields.VTX_Z1_PRESENT = vtx_z1_present
#define set_SE_VTX_FMT_0_vtx_w1_present(reg, vtx_w1_present) (reg)->bitfields.VTX_W1_PRESENT = vtx_w1_present
#define set_SE_VTX_FMT_0_vtx_n1_present(reg, vtx_n1_present) (reg)->bitfields.VTX_N1_PRESENT = vtx_n1_present

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_FMT_1 regSE_VTX_FMT_1;

#ifdef DEBUG
__inline void set_SE_VTX_FMT_1_tex_0_comp_cnt(regSE_VTX_FMT_1 *reg, unsigned int tex_0_comp_cnt)
{
  reg->bitfields.TEX_0_COMP_CNT = tex_0_comp_cnt;
  if (reg->bitfields.TEX_0_COMP_CNT != tex_0_comp_cnt) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_1::TEX_0_COMP_CNT data too large\n");
}
__inline void set_SE_VTX_FMT_1_tex_1_comp_cnt(regSE_VTX_FMT_1 *reg, unsigned int tex_1_comp_cnt)
{
  reg->bitfields.TEX_1_COMP_CNT = tex_1_comp_cnt;
  if (reg->bitfields.TEX_1_COMP_CNT != tex_1_comp_cnt) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_1::TEX_1_COMP_CNT data too large\n");
}
__inline void set_SE_VTX_FMT_1_tex_2_comp_cnt(regSE_VTX_FMT_1 *reg, unsigned int tex_2_comp_cnt)
{
  reg->bitfields.TEX_2_COMP_CNT = tex_2_comp_cnt;
  if (reg->bitfields.TEX_2_COMP_CNT != tex_2_comp_cnt) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_1::TEX_2_COMP_CNT data too large\n");
}
__inline void set_SE_VTX_FMT_1_tex_3_comp_cnt(regSE_VTX_FMT_1 *reg, unsigned int tex_3_comp_cnt)
{
  reg->bitfields.TEX_3_COMP_CNT = tex_3_comp_cnt;
  if (reg->bitfields.TEX_3_COMP_CNT != tex_3_comp_cnt) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_1::TEX_3_COMP_CNT data too large\n");
}
__inline void set_SE_VTX_FMT_1_tex_4_comp_cnt(regSE_VTX_FMT_1 *reg, unsigned int tex_4_comp_cnt)
{
  reg->bitfields.TEX_4_COMP_CNT = tex_4_comp_cnt;
  if (reg->bitfields.TEX_4_COMP_CNT != tex_4_comp_cnt) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_1::TEX_4_COMP_CNT data too large\n");
}
__inline void set_SE_VTX_FMT_1_tex_5_comp_cnt(regSE_VTX_FMT_1 *reg, unsigned int tex_5_comp_cnt)
{
  reg->bitfields.TEX_5_COMP_CNT = tex_5_comp_cnt;
  if (reg->bitfields.TEX_5_COMP_CNT != tex_5_comp_cnt) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_FMT_1::TEX_5_COMP_CNT data too large\n");
}
#else
#define set_SE_VTX_FMT_1_tex_0_comp_cnt(reg, tex_0_comp_cnt) (reg)->bitfields.TEX_0_COMP_CNT = tex_0_comp_cnt
#define set_SE_VTX_FMT_1_tex_1_comp_cnt(reg, tex_1_comp_cnt) (reg)->bitfields.TEX_1_COMP_CNT = tex_1_comp_cnt
#define set_SE_VTX_FMT_1_tex_2_comp_cnt(reg, tex_2_comp_cnt) (reg)->bitfields.TEX_2_COMP_CNT = tex_2_comp_cnt
#define set_SE_VTX_FMT_1_tex_3_comp_cnt(reg, tex_3_comp_cnt) (reg)->bitfields.TEX_3_COMP_CNT = tex_3_comp_cnt
#define set_SE_VTX_FMT_1_tex_4_comp_cnt(reg, tex_4_comp_cnt) (reg)->bitfields.TEX_4_COMP_CNT = tex_4_comp_cnt
#define set_SE_VTX_FMT_1_tex_5_comp_cnt(reg, tex_5_comp_cnt) (reg)->bitfields.TEX_5_COMP_CNT = tex_5_comp_cnt

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_OUTPUT_VTX_FMT_0 regSE_TCL_OUTPUT_VTX_FMT_0;

#ifdef DEBUG
__inline void set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_z0_present(regSE_TCL_OUTPUT_VTX_FMT_0 *reg, unsigned int vtx_z0_present)
{
  reg->bitfields.VTX_Z0_PRESENT = vtx_z0_present;
  if (reg->bitfields.VTX_Z0_PRESENT != vtx_z0_present) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_0::VTX_Z0_PRESENT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_w0_present(regSE_TCL_OUTPUT_VTX_FMT_0 *reg, unsigned int vtx_w0_present)
{
  reg->bitfields.VTX_W0_PRESENT = vtx_w0_present;
  if (reg->bitfields.VTX_W0_PRESENT != vtx_w0_present) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_0::VTX_W0_PRESENT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_blend_weight_cnt(regSE_TCL_OUTPUT_VTX_FMT_0 *reg, unsigned int vtx_blend_weight_cnt)
{
  reg->bitfields.VTX_BLEND_WEIGHT_CNT = vtx_blend_weight_cnt;
  if (reg->bitfields.VTX_BLEND_WEIGHT_CNT != vtx_blend_weight_cnt) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_0::VTX_BLEND_WEIGHT_CNT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_pv_mtx_sel_present(regSE_TCL_OUTPUT_VTX_FMT_0 *reg, unsigned int vtx_pv_mtx_sel_present)
{
  reg->bitfields.VTX_PV_MTX_SEL_PRESENT = vtx_pv_mtx_sel_present;
  if (reg->bitfields.VTX_PV_MTX_SEL_PRESENT != vtx_pv_mtx_sel_present) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_0::VTX_PV_MTX_SEL_PRESENT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_n0_present(regSE_TCL_OUTPUT_VTX_FMT_0 *reg, unsigned int vtx_n0_present)
{
  reg->bitfields.VTX_N0_PRESENT = vtx_n0_present;
  if (reg->bitfields.VTX_N0_PRESENT != vtx_n0_present) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_0::VTX_N0_PRESENT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_pt_size_present(regSE_TCL_OUTPUT_VTX_FMT_0 *reg, unsigned int vtx_pt_size_present)
{
  reg->bitfields.VTX_PT_SIZE_PRESENT = vtx_pt_size_present;
  if (reg->bitfields.VTX_PT_SIZE_PRESENT != vtx_pt_size_present) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_0::VTX_PT_SIZE_PRESENT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_discrete_fog_present(regSE_TCL_OUTPUT_VTX_FMT_0 *reg, unsigned int vtx_discrete_fog_present)
{
  reg->bitfields.VTX_DISCRETE_FOG_PRESENT = vtx_discrete_fog_present;
  if (reg->bitfields.VTX_DISCRETE_FOG_PRESENT != vtx_discrete_fog_present) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_0::VTX_DISCRETE_FOG_PRESENT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_shininess_0_present(regSE_TCL_OUTPUT_VTX_FMT_0 *reg, unsigned int vtx_shininess_0_present)
{
  reg->bitfields.VTX_SHININESS_0_PRESENT = vtx_shininess_0_present;
  if (reg->bitfields.VTX_SHININESS_0_PRESENT != vtx_shininess_0_present) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_0::VTX_SHININESS_0_PRESENT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_shininess_1_present(regSE_TCL_OUTPUT_VTX_FMT_0 *reg, unsigned int vtx_shininess_1_present)
{
  reg->bitfields.VTX_SHININESS_1_PRESENT = vtx_shininess_1_present;
  if (reg->bitfields.VTX_SHININESS_1_PRESENT != vtx_shininess_1_present) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_0::VTX_SHININESS_1_PRESENT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_color_0_fmt(regSE_TCL_OUTPUT_VTX_FMT_0 *reg, unsigned int vtx_color_0_fmt)
{
  reg->bitfields.VTX_COLOR_0_FMT = vtx_color_0_fmt;
  if (reg->bitfields.VTX_COLOR_0_FMT != vtx_color_0_fmt) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_0::VTX_COLOR_0_FMT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_color_1_fmt(regSE_TCL_OUTPUT_VTX_FMT_0 *reg, unsigned int vtx_color_1_fmt)
{
  reg->bitfields.VTX_COLOR_1_FMT = vtx_color_1_fmt;
  if (reg->bitfields.VTX_COLOR_1_FMT != vtx_color_1_fmt) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_0::VTX_COLOR_1_FMT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_color_2_fmt(regSE_TCL_OUTPUT_VTX_FMT_0 *reg, unsigned int vtx_color_2_fmt)
{
  reg->bitfields.VTX_COLOR_2_FMT = vtx_color_2_fmt;
  if (reg->bitfields.VTX_COLOR_2_FMT != vtx_color_2_fmt) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_0::VTX_COLOR_2_FMT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_color_3_fmt(regSE_TCL_OUTPUT_VTX_FMT_0 *reg, unsigned int vtx_color_3_fmt)
{
  reg->bitfields.VTX_COLOR_3_FMT = vtx_color_3_fmt;
  if (reg->bitfields.VTX_COLOR_3_FMT != vtx_color_3_fmt) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_0::VTX_COLOR_3_FMT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_color_4_fmt(regSE_TCL_OUTPUT_VTX_FMT_0 *reg, unsigned int vtx_color_4_fmt)
{
  reg->bitfields.VTX_COLOR_4_FMT = vtx_color_4_fmt;
  if (reg->bitfields.VTX_COLOR_4_FMT != vtx_color_4_fmt) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_0::VTX_COLOR_4_FMT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_color_5_fmt(regSE_TCL_OUTPUT_VTX_FMT_0 *reg, unsigned int vtx_color_5_fmt)
{
  reg->bitfields.VTX_COLOR_5_FMT = vtx_color_5_fmt;
  if (reg->bitfields.VTX_COLOR_5_FMT != vtx_color_5_fmt) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_0::VTX_COLOR_5_FMT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_color_6_fmt(regSE_TCL_OUTPUT_VTX_FMT_0 *reg, unsigned int vtx_color_6_fmt)
{
  reg->bitfields.VTX_COLOR_6_FMT = vtx_color_6_fmt;
  if (reg->bitfields.VTX_COLOR_6_FMT != vtx_color_6_fmt) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_0::VTX_COLOR_6_FMT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_color_7_fmt(regSE_TCL_OUTPUT_VTX_FMT_0 *reg, unsigned int vtx_color_7_fmt)
{
  reg->bitfields.VTX_COLOR_7_FMT = vtx_color_7_fmt;
  if (reg->bitfields.VTX_COLOR_7_FMT != vtx_color_7_fmt) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_0::VTX_COLOR_7_FMT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_xy1_present(regSE_TCL_OUTPUT_VTX_FMT_0 *reg, unsigned int vtx_xy1_present)
{
  reg->bitfields.VTX_XY1_PRESENT = vtx_xy1_present;
  if (reg->bitfields.VTX_XY1_PRESENT != vtx_xy1_present) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_0::VTX_XY1_PRESENT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_z1_present(regSE_TCL_OUTPUT_VTX_FMT_0 *reg, unsigned int vtx_z1_present)
{
  reg->bitfields.VTX_Z1_PRESENT = vtx_z1_present;
  if (reg->bitfields.VTX_Z1_PRESENT != vtx_z1_present) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_0::VTX_Z1_PRESENT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_w1_present(regSE_TCL_OUTPUT_VTX_FMT_0 *reg, unsigned int vtx_w1_present)
{
  reg->bitfields.VTX_W1_PRESENT = vtx_w1_present;
  if (reg->bitfields.VTX_W1_PRESENT != vtx_w1_present) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_0::VTX_W1_PRESENT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_n1_present(regSE_TCL_OUTPUT_VTX_FMT_0 *reg, unsigned int vtx_n1_present)
{
  reg->bitfields.VTX_N1_PRESENT = vtx_n1_present;
  if (reg->bitfields.VTX_N1_PRESENT != vtx_n1_present) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_0::VTX_N1_PRESENT data too large\n");
}
#else
#define set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_z0_present(reg, vtx_z0_present) (reg)->bitfields.VTX_Z0_PRESENT = vtx_z0_present
#define set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_w0_present(reg, vtx_w0_present) (reg)->bitfields.VTX_W0_PRESENT = vtx_w0_present
#define set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_blend_weight_cnt(reg, vtx_blend_weight_cnt) (reg)->bitfields.VTX_BLEND_WEIGHT_CNT = vtx_blend_weight_cnt
#define set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_pv_mtx_sel_present(reg, vtx_pv_mtx_sel_present) (reg)->bitfields.VTX_PV_MTX_SEL_PRESENT = vtx_pv_mtx_sel_present
#define set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_n0_present(reg, vtx_n0_present) (reg)->bitfields.VTX_N0_PRESENT = vtx_n0_present
#define set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_pt_size_present(reg, vtx_pt_size_present) (reg)->bitfields.VTX_PT_SIZE_PRESENT = vtx_pt_size_present
#define set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_discrete_fog_present(reg, vtx_discrete_fog_present) (reg)->bitfields.VTX_DISCRETE_FOG_PRESENT = vtx_discrete_fog_present
#define set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_shininess_0_present(reg, vtx_shininess_0_present) (reg)->bitfields.VTX_SHININESS_0_PRESENT = vtx_shininess_0_present
#define set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_shininess_1_present(reg, vtx_shininess_1_present) (reg)->bitfields.VTX_SHININESS_1_PRESENT = vtx_shininess_1_present
#define set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_color_0_fmt(reg, vtx_color_0_fmt) (reg)->bitfields.VTX_COLOR_0_FMT = vtx_color_0_fmt
#define set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_color_1_fmt(reg, vtx_color_1_fmt) (reg)->bitfields.VTX_COLOR_1_FMT = vtx_color_1_fmt
#define set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_color_2_fmt(reg, vtx_color_2_fmt) (reg)->bitfields.VTX_COLOR_2_FMT = vtx_color_2_fmt
#define set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_color_3_fmt(reg, vtx_color_3_fmt) (reg)->bitfields.VTX_COLOR_3_FMT = vtx_color_3_fmt
#define set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_color_4_fmt(reg, vtx_color_4_fmt) (reg)->bitfields.VTX_COLOR_4_FMT = vtx_color_4_fmt
#define set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_color_5_fmt(reg, vtx_color_5_fmt) (reg)->bitfields.VTX_COLOR_5_FMT = vtx_color_5_fmt
#define set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_color_6_fmt(reg, vtx_color_6_fmt) (reg)->bitfields.VTX_COLOR_6_FMT = vtx_color_6_fmt
#define set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_color_7_fmt(reg, vtx_color_7_fmt) (reg)->bitfields.VTX_COLOR_7_FMT = vtx_color_7_fmt
#define set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_xy1_present(reg, vtx_xy1_present) (reg)->bitfields.VTX_XY1_PRESENT = vtx_xy1_present
#define set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_z1_present(reg, vtx_z1_present) (reg)->bitfields.VTX_Z1_PRESENT = vtx_z1_present
#define set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_w1_present(reg, vtx_w1_present) (reg)->bitfields.VTX_W1_PRESENT = vtx_w1_present
#define set_SE_TCL_OUTPUT_VTX_FMT_0_vtx_n1_present(reg, vtx_n1_present) (reg)->bitfields.VTX_N1_PRESENT = vtx_n1_present

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_OUTPUT_VTX_FMT_1 regSE_TCL_OUTPUT_VTX_FMT_1;

#ifdef DEBUG
__inline void set_SE_TCL_OUTPUT_VTX_FMT_1_tex_0_comp_cnt(regSE_TCL_OUTPUT_VTX_FMT_1 *reg, unsigned int tex_0_comp_cnt)
{
  reg->bitfields.TEX_0_COMP_CNT = tex_0_comp_cnt;
  if (reg->bitfields.TEX_0_COMP_CNT != tex_0_comp_cnt) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_1::TEX_0_COMP_CNT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_1_tex_1_comp_cnt(regSE_TCL_OUTPUT_VTX_FMT_1 *reg, unsigned int tex_1_comp_cnt)
{
  reg->bitfields.TEX_1_COMP_CNT = tex_1_comp_cnt;
  if (reg->bitfields.TEX_1_COMP_CNT != tex_1_comp_cnt) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_1::TEX_1_COMP_CNT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_1_tex_2_comp_cnt(regSE_TCL_OUTPUT_VTX_FMT_1 *reg, unsigned int tex_2_comp_cnt)
{
  reg->bitfields.TEX_2_COMP_CNT = tex_2_comp_cnt;
  if (reg->bitfields.TEX_2_COMP_CNT != tex_2_comp_cnt) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_1::TEX_2_COMP_CNT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_1_tex_3_comp_cnt(regSE_TCL_OUTPUT_VTX_FMT_1 *reg, unsigned int tex_3_comp_cnt)
{
  reg->bitfields.TEX_3_COMP_CNT = tex_3_comp_cnt;
  if (reg->bitfields.TEX_3_COMP_CNT != tex_3_comp_cnt) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_1::TEX_3_COMP_CNT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_1_tex_4_comp_cnt(regSE_TCL_OUTPUT_VTX_FMT_1 *reg, unsigned int tex_4_comp_cnt)
{
  reg->bitfields.TEX_4_COMP_CNT = tex_4_comp_cnt;
  if (reg->bitfields.TEX_4_COMP_CNT != tex_4_comp_cnt) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_1::TEX_4_COMP_CNT data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_FMT_1_tex_5_comp_cnt(regSE_TCL_OUTPUT_VTX_FMT_1 *reg, unsigned int tex_5_comp_cnt)
{
  reg->bitfields.TEX_5_COMP_CNT = tex_5_comp_cnt;
  if (reg->bitfields.TEX_5_COMP_CNT != tex_5_comp_cnt) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_FMT_1::TEX_5_COMP_CNT data too large\n");
}
#else
#define set_SE_TCL_OUTPUT_VTX_FMT_1_tex_0_comp_cnt(reg, tex_0_comp_cnt) (reg)->bitfields.TEX_0_COMP_CNT = tex_0_comp_cnt
#define set_SE_TCL_OUTPUT_VTX_FMT_1_tex_1_comp_cnt(reg, tex_1_comp_cnt) (reg)->bitfields.TEX_1_COMP_CNT = tex_1_comp_cnt
#define set_SE_TCL_OUTPUT_VTX_FMT_1_tex_2_comp_cnt(reg, tex_2_comp_cnt) (reg)->bitfields.TEX_2_COMP_CNT = tex_2_comp_cnt
#define set_SE_TCL_OUTPUT_VTX_FMT_1_tex_3_comp_cnt(reg, tex_3_comp_cnt) (reg)->bitfields.TEX_3_COMP_CNT = tex_3_comp_cnt
#define set_SE_TCL_OUTPUT_VTX_FMT_1_tex_4_comp_cnt(reg, tex_4_comp_cnt) (reg)->bitfields.TEX_4_COMP_CNT = tex_4_comp_cnt
#define set_SE_TCL_OUTPUT_VTX_FMT_1_tex_5_comp_cnt(reg, tex_5_comp_cnt) (reg)->bitfields.TEX_5_COMP_CNT = tex_5_comp_cnt

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VPORT_XSCALE regSE_VPORT_XSCALE;

#ifdef DEBUG
__inline void set_SE_VPORT_XSCALE_vport_xscale(regSE_VPORT_XSCALE *reg, unsigned int vport_xscale)
{
  reg->bitfields.VPORT_XSCALE = vport_xscale;
  if (reg->bitfields.VPORT_XSCALE != vport_xscale) HSLDPF(E_ERROR_MESSAGE,"SE_VPORT_XSCALE::VPORT_XSCALE data too large\n");
}
#else
#define set_SE_VPORT_XSCALE_vport_xscale(reg, vport_xscale) (reg)->bitfields.VPORT_XSCALE = vport_xscale

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VPORT_XOFFSET regSE_VPORT_XOFFSET;

#ifdef DEBUG
__inline void set_SE_VPORT_XOFFSET_vport_xoffset(regSE_VPORT_XOFFSET *reg, unsigned int vport_xoffset)
{
  reg->bitfields.VPORT_XOFFSET = vport_xoffset;
  if (reg->bitfields.VPORT_XOFFSET != vport_xoffset) HSLDPF(E_ERROR_MESSAGE,"SE_VPORT_XOFFSET::VPORT_XOFFSET data too large\n");
}
#else
#define set_SE_VPORT_XOFFSET_vport_xoffset(reg, vport_xoffset) (reg)->bitfields.VPORT_XOFFSET = vport_xoffset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VPORT_YSCALE regSE_VPORT_YSCALE;

#ifdef DEBUG
__inline void set_SE_VPORT_YSCALE_vport_yscale(regSE_VPORT_YSCALE *reg, unsigned int vport_yscale)
{
  reg->bitfields.VPORT_YSCALE = vport_yscale;
  if (reg->bitfields.VPORT_YSCALE != vport_yscale) HSLDPF(E_ERROR_MESSAGE,"SE_VPORT_YSCALE::VPORT_YSCALE data too large\n");
}
#else
#define set_SE_VPORT_YSCALE_vport_yscale(reg, vport_yscale) (reg)->bitfields.VPORT_YSCALE = vport_yscale

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VPORT_YOFFSET regSE_VPORT_YOFFSET;

#ifdef DEBUG
__inline void set_SE_VPORT_YOFFSET_vport_yoffset(regSE_VPORT_YOFFSET *reg, unsigned int vport_yoffset)
{
  reg->bitfields.VPORT_YOFFSET = vport_yoffset;
  if (reg->bitfields.VPORT_YOFFSET != vport_yoffset) HSLDPF(E_ERROR_MESSAGE,"SE_VPORT_YOFFSET::VPORT_YOFFSET data too large\n");
}
#else
#define set_SE_VPORT_YOFFSET_vport_yoffset(reg, vport_yoffset) (reg)->bitfields.VPORT_YOFFSET = vport_yoffset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VPORT_ZSCALE regSE_VPORT_ZSCALE;

#ifdef DEBUG
__inline void set_SE_VPORT_ZSCALE_vport_zscale(regSE_VPORT_ZSCALE *reg, unsigned int vport_zscale)
{
  reg->bitfields.VPORT_ZSCALE = vport_zscale;
  if (reg->bitfields.VPORT_ZSCALE != vport_zscale) HSLDPF(E_ERROR_MESSAGE,"SE_VPORT_ZSCALE::VPORT_ZSCALE data too large\n");
}
#else
#define set_SE_VPORT_ZSCALE_vport_zscale(reg, vport_zscale) (reg)->bitfields.VPORT_ZSCALE = vport_zscale

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VPORT_ZOFFSET regSE_VPORT_ZOFFSET;

#ifdef DEBUG
__inline void set_SE_VPORT_ZOFFSET_vport_zoffset(regSE_VPORT_ZOFFSET *reg, unsigned int vport_zoffset)
{
  reg->bitfields.VPORT_ZOFFSET = vport_zoffset;
  if (reg->bitfields.VPORT_ZOFFSET != vport_zoffset) HSLDPF(E_ERROR_MESSAGE,"SE_VPORT_ZOFFSET::VPORT_ZOFFSET data too large\n");
}
#else
#define set_SE_VPORT_ZOFFSET_vport_zoffset(reg, vport_zoffset) (reg)->bitfields.VPORT_ZOFFSET = vport_zoffset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTE_CNTL regSE_VTE_CNTL;

#ifdef DEBUG
__inline void set_SE_VTE_CNTL_vport_x_scale_ena(regSE_VTE_CNTL *reg, unsigned int vport_x_scale_ena)
{
  reg->bitfields.VPORT_X_SCALE_ENA = vport_x_scale_ena;
  if (reg->bitfields.VPORT_X_SCALE_ENA != vport_x_scale_ena) HSLDPF(E_ERROR_MESSAGE,"SE_VTE_CNTL::VPORT_X_SCALE_ENA data too large\n");
}
__inline void set_SE_VTE_CNTL_vport_x_offset_ena(regSE_VTE_CNTL *reg, unsigned int vport_x_offset_ena)
{
  reg->bitfields.VPORT_X_OFFSET_ENA = vport_x_offset_ena;
  if (reg->bitfields.VPORT_X_OFFSET_ENA != vport_x_offset_ena) HSLDPF(E_ERROR_MESSAGE,"SE_VTE_CNTL::VPORT_X_OFFSET_ENA data too large\n");
}
__inline void set_SE_VTE_CNTL_vport_y_scale_ena(regSE_VTE_CNTL *reg, unsigned int vport_y_scale_ena)
{
  reg->bitfields.VPORT_Y_SCALE_ENA = vport_y_scale_ena;
  if (reg->bitfields.VPORT_Y_SCALE_ENA != vport_y_scale_ena) HSLDPF(E_ERROR_MESSAGE,"SE_VTE_CNTL::VPORT_Y_SCALE_ENA data too large\n");
}
__inline void set_SE_VTE_CNTL_vport_y_offset_ena(regSE_VTE_CNTL *reg, unsigned int vport_y_offset_ena)
{
  reg->bitfields.VPORT_Y_OFFSET_ENA = vport_y_offset_ena;
  if (reg->bitfields.VPORT_Y_OFFSET_ENA != vport_y_offset_ena) HSLDPF(E_ERROR_MESSAGE,"SE_VTE_CNTL::VPORT_Y_OFFSET_ENA data too large\n");
}
__inline void set_SE_VTE_CNTL_vport_z_scale_ena(regSE_VTE_CNTL *reg, unsigned int vport_z_scale_ena)
{
  reg->bitfields.VPORT_Z_SCALE_ENA = vport_z_scale_ena;
  if (reg->bitfields.VPORT_Z_SCALE_ENA != vport_z_scale_ena) HSLDPF(E_ERROR_MESSAGE,"SE_VTE_CNTL::VPORT_Z_SCALE_ENA data too large\n");
}
__inline void set_SE_VTE_CNTL_vport_z_offset_ena(regSE_VTE_CNTL *reg, unsigned int vport_z_offset_ena)
{
  reg->bitfields.VPORT_Z_OFFSET_ENA = vport_z_offset_ena;
  if (reg->bitfields.VPORT_Z_OFFSET_ENA != vport_z_offset_ena) HSLDPF(E_ERROR_MESSAGE,"SE_VTE_CNTL::VPORT_Z_OFFSET_ENA data too large\n");
}
__inline void set_SE_VTE_CNTL_vtx_xy_fmt(regSE_VTE_CNTL *reg, unsigned int vtx_xy_fmt)
{
  reg->bitfields.VTX_XY_FMT = vtx_xy_fmt;
  if (reg->bitfields.VTX_XY_FMT != vtx_xy_fmt) HSLDPF(E_ERROR_MESSAGE,"SE_VTE_CNTL::VTX_XY_FMT data too large\n");
}
__inline void set_SE_VTE_CNTL_vtx_z_fmt(regSE_VTE_CNTL *reg, unsigned int vtx_z_fmt)
{
  reg->bitfields.VTX_Z_FMT = vtx_z_fmt;
  if (reg->bitfields.VTX_Z_FMT != vtx_z_fmt) HSLDPF(E_ERROR_MESSAGE,"SE_VTE_CNTL::VTX_Z_FMT data too large\n");
}
__inline void set_SE_VTE_CNTL_vtx_w0_fmt(regSE_VTE_CNTL *reg, unsigned int vtx_w0_fmt)
{
  reg->bitfields.VTX_W0_FMT = vtx_w0_fmt;
  if (reg->bitfields.VTX_W0_FMT != vtx_w0_fmt) HSLDPF(E_ERROR_MESSAGE,"SE_VTE_CNTL::VTX_W0_FMT data too large\n");
}
__inline void set_SE_VTE_CNTL_vtx_w0_normalize(regSE_VTE_CNTL *reg, unsigned int vtx_w0_normalize)
{
  reg->bitfields.VTX_W0_NORMALIZE = vtx_w0_normalize;
  if (reg->bitfields.VTX_W0_NORMALIZE != vtx_w0_normalize) HSLDPF(E_ERROR_MESSAGE,"SE_VTE_CNTL::VTX_W0_NORMALIZE data too large\n");
}
__inline void set_SE_VTE_CNTL_vtx_st_denormalized(regSE_VTE_CNTL *reg, unsigned int vtx_st_denormalized)
{
  reg->bitfields.VTX_ST_DENORMALIZED = vtx_st_denormalized;
  if (reg->bitfields.VTX_ST_DENORMALIZED != vtx_st_denormalized) HSLDPF(E_ERROR_MESSAGE,"SE_VTE_CNTL::VTX_ST_DENORMALIZED data too large\n");
}
#else
#define set_SE_VTE_CNTL_vport_x_scale_ena(reg, vport_x_scale_ena) (reg)->bitfields.VPORT_X_SCALE_ENA = vport_x_scale_ena
#define set_SE_VTE_CNTL_vport_x_offset_ena(reg, vport_x_offset_ena) (reg)->bitfields.VPORT_X_OFFSET_ENA = vport_x_offset_ena
#define set_SE_VTE_CNTL_vport_y_scale_ena(reg, vport_y_scale_ena) (reg)->bitfields.VPORT_Y_SCALE_ENA = vport_y_scale_ena
#define set_SE_VTE_CNTL_vport_y_offset_ena(reg, vport_y_offset_ena) (reg)->bitfields.VPORT_Y_OFFSET_ENA = vport_y_offset_ena
#define set_SE_VTE_CNTL_vport_z_scale_ena(reg, vport_z_scale_ena) (reg)->bitfields.VPORT_Z_SCALE_ENA = vport_z_scale_ena
#define set_SE_VTE_CNTL_vport_z_offset_ena(reg, vport_z_offset_ena) (reg)->bitfields.VPORT_Z_OFFSET_ENA = vport_z_offset_ena
#define set_SE_VTE_CNTL_vtx_xy_fmt(reg, vtx_xy_fmt) (reg)->bitfields.VTX_XY_FMT = vtx_xy_fmt
#define set_SE_VTE_CNTL_vtx_z_fmt(reg, vtx_z_fmt) (reg)->bitfields.VTX_Z_FMT = vtx_z_fmt
#define set_SE_VTE_CNTL_vtx_w0_fmt(reg, vtx_w0_fmt) (reg)->bitfields.VTX_W0_FMT = vtx_w0_fmt
#define set_SE_VTE_CNTL_vtx_w0_normalize(reg, vtx_w0_normalize) (reg)->bitfields.VTX_W0_NORMALIZE = vtx_w0_normalize
#define set_SE_VTE_CNTL_vtx_st_denormalized(reg, vtx_st_denormalized) (reg)->bitfields.VTX_ST_DENORMALIZED = vtx_st_denormalized

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_W0_RANGE regSE_W0_RANGE;

#ifdef DEBUG
__inline void set_SE_W0_RANGE_w0_range(regSE_W0_RANGE *reg, unsigned int w0_range)
{
  reg->bitfields.W0_RANGE = w0_range;
  if (reg->bitfields.W0_RANGE != w0_range) HSLDPF(E_ERROR_MESSAGE,"SE_W0_RANGE::W0_RANGE data too large\n");
}
#else
#define set_SE_W0_RANGE_w0_range(reg, w0_range) (reg)->bitfields.W0_RANGE = w0_range

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250SE_VTX_NUM_ARRAYS regrv250SE_VTX_NUM_ARRAYS;

#ifdef DEBUG
__inline void set_rv250SE_VTX_NUM_ARRAYS_vtx_num_arrays(regrv250SE_VTX_NUM_ARRAYS *reg, unsigned int vtx_num_arrays)
{
  reg->bitfields.VTX_NUM_ARRAYS = vtx_num_arrays;
  if (reg->bitfields.VTX_NUM_ARRAYS != vtx_num_arrays) HSLDPF(E_ERROR_MESSAGE,"rv250SE_VTX_NUM_ARRAYS::VTX_NUM_ARRAYS data too large\n");
}
__inline void set_rv250SE_VTX_NUM_ARRAYS_vtx_reuse_disable(regrv250SE_VTX_NUM_ARRAYS *reg, unsigned int vtx_reuse_disable)
{
  reg->bitfields.VTX_REUSE_DISABLE = vtx_reuse_disable;
  if (reg->bitfields.VTX_REUSE_DISABLE != vtx_reuse_disable) HSLDPF(E_ERROR_MESSAGE,"rv250SE_VTX_NUM_ARRAYS::VTX_REUSE_DISABLE data too large\n");
}
__inline void set_rv250SE_VTX_NUM_ARRAYS_vc_pfetch(regrv250SE_VTX_NUM_ARRAYS *reg, unsigned int vc_pfetch)
{
  reg->bitfields.VC_PFETCH = vc_pfetch;
  if (reg->bitfields.VC_PFETCH != vc_pfetch) HSLDPF(E_ERROR_MESSAGE,"rv250SE_VTX_NUM_ARRAYS::VC_PFETCH data too large\n");
}
#else
#define set_rv250SE_VTX_NUM_ARRAYS_vtx_num_arrays(reg, vtx_num_arrays) (reg)->bitfields.VTX_NUM_ARRAYS = vtx_num_arrays
#define set_rv250SE_VTX_NUM_ARRAYS_vtx_reuse_disable(reg, vtx_reuse_disable) (reg)->bitfields.VTX_REUSE_DISABLE = vtx_reuse_disable
#define set_rv250SE_VTX_NUM_ARRAYS_vc_pfetch(reg, vc_pfetch) (reg)->bitfields.VC_PFETCH = vc_pfetch

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_AOS_ATTR01 regSE_VTX_AOS_ATTR01;

#ifdef DEBUG
__inline void set_SE_VTX_AOS_ATTR01_vtx_aos_count0(regSE_VTX_AOS_ATTR01 *reg, unsigned int vtx_aos_count0)
{
  reg->bitfields.VTX_AOS_COUNT0 = vtx_aos_count0;
  if (reg->bitfields.VTX_AOS_COUNT0 != vtx_aos_count0) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR01::VTX_AOS_COUNT0 data too large\n");
}
__inline void set_SE_VTX_AOS_ATTR01_vtx_aos_stride0(regSE_VTX_AOS_ATTR01 *reg, unsigned int vtx_aos_stride0)
{
  reg->bitfields.VTX_AOS_STRIDE0 = vtx_aos_stride0;
  if (reg->bitfields.VTX_AOS_STRIDE0 != vtx_aos_stride0) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR01::VTX_AOS_STRIDE0 data too large\n");
}
__inline void set_SE_VTX_AOS_ATTR01_vtx_aos_count1(regSE_VTX_AOS_ATTR01 *reg, unsigned int vtx_aos_count1)
{
  reg->bitfields.VTX_AOS_COUNT1 = vtx_aos_count1;
  if (reg->bitfields.VTX_AOS_COUNT1 != vtx_aos_count1) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR01::VTX_AOS_COUNT1 data too large\n");
}
__inline void set_SE_VTX_AOS_ATTR01_vtx_aos_stride1(regSE_VTX_AOS_ATTR01 *reg, unsigned int vtx_aos_stride1)
{
  reg->bitfields.VTX_AOS_STRIDE1 = vtx_aos_stride1;
  if (reg->bitfields.VTX_AOS_STRIDE1 != vtx_aos_stride1) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR01::VTX_AOS_STRIDE1 data too large\n");
}
#else
#define set_SE_VTX_AOS_ATTR01_vtx_aos_count0(reg, vtx_aos_count0) (reg)->bitfields.VTX_AOS_COUNT0 = vtx_aos_count0
#define set_SE_VTX_AOS_ATTR01_vtx_aos_stride0(reg, vtx_aos_stride0) (reg)->bitfields.VTX_AOS_STRIDE0 = vtx_aos_stride0
#define set_SE_VTX_AOS_ATTR01_vtx_aos_count1(reg, vtx_aos_count1) (reg)->bitfields.VTX_AOS_COUNT1 = vtx_aos_count1
#define set_SE_VTX_AOS_ATTR01_vtx_aos_stride1(reg, vtx_aos_stride1) (reg)->bitfields.VTX_AOS_STRIDE1 = vtx_aos_stride1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_AOS_ADDR0 regSE_VTX_AOS_ADDR0;

#ifdef DEBUG
__inline void set_SE_VTX_AOS_ADDR0_vtx_aos_addr0(regSE_VTX_AOS_ADDR0 *reg, unsigned int vtx_aos_addr0)
{
  reg->bitfields.VTX_AOS_ADDR0 = vtx_aos_addr0;
  if (reg->bitfields.VTX_AOS_ADDR0 != vtx_aos_addr0) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ADDR0::VTX_AOS_ADDR0 data too large\n");
}
#else
#define set_SE_VTX_AOS_ADDR0_vtx_aos_addr0(reg, vtx_aos_addr0) (reg)->bitfields.VTX_AOS_ADDR0 = vtx_aos_addr0

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_AOS_ADDR1 regSE_VTX_AOS_ADDR1;

#ifdef DEBUG
__inline void set_SE_VTX_AOS_ADDR1_vtx_aos_addr1(regSE_VTX_AOS_ADDR1 *reg, unsigned int vtx_aos_addr1)
{
  reg->bitfields.VTX_AOS_ADDR1 = vtx_aos_addr1;
  if (reg->bitfields.VTX_AOS_ADDR1 != vtx_aos_addr1) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ADDR1::VTX_AOS_ADDR1 data too large\n");
}
#else
#define set_SE_VTX_AOS_ADDR1_vtx_aos_addr1(reg, vtx_aos_addr1) (reg)->bitfields.VTX_AOS_ADDR1 = vtx_aos_addr1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_AOS_ATTR23 regSE_VTX_AOS_ATTR23;

#ifdef DEBUG
__inline void set_SE_VTX_AOS_ATTR23_vtx_aos_count2(regSE_VTX_AOS_ATTR23 *reg, unsigned int vtx_aos_count2)
{
  reg->bitfields.VTX_AOS_COUNT2 = vtx_aos_count2;
  if (reg->bitfields.VTX_AOS_COUNT2 != vtx_aos_count2) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR23::VTX_AOS_COUNT2 data too large\n");
}
__inline void set_SE_VTX_AOS_ATTR23_vtx_aos_stride2(regSE_VTX_AOS_ATTR23 *reg, unsigned int vtx_aos_stride2)
{
  reg->bitfields.VTX_AOS_STRIDE2 = vtx_aos_stride2;
  if (reg->bitfields.VTX_AOS_STRIDE2 != vtx_aos_stride2) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR23::VTX_AOS_STRIDE2 data too large\n");
}
__inline void set_SE_VTX_AOS_ATTR23_vtx_aos_count3(regSE_VTX_AOS_ATTR23 *reg, unsigned int vtx_aos_count3)
{
  reg->bitfields.VTX_AOS_COUNT3 = vtx_aos_count3;
  if (reg->bitfields.VTX_AOS_COUNT3 != vtx_aos_count3) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR23::VTX_AOS_COUNT3 data too large\n");
}
__inline void set_SE_VTX_AOS_ATTR23_vtx_aos_stride3(regSE_VTX_AOS_ATTR23 *reg, unsigned int vtx_aos_stride3)
{
  reg->bitfields.VTX_AOS_STRIDE3 = vtx_aos_stride3;
  if (reg->bitfields.VTX_AOS_STRIDE3 != vtx_aos_stride3) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR23::VTX_AOS_STRIDE3 data too large\n");
}
#else
#define set_SE_VTX_AOS_ATTR23_vtx_aos_count2(reg, vtx_aos_count2) (reg)->bitfields.VTX_AOS_COUNT2 = vtx_aos_count2
#define set_SE_VTX_AOS_ATTR23_vtx_aos_stride2(reg, vtx_aos_stride2) (reg)->bitfields.VTX_AOS_STRIDE2 = vtx_aos_stride2
#define set_SE_VTX_AOS_ATTR23_vtx_aos_count3(reg, vtx_aos_count3) (reg)->bitfields.VTX_AOS_COUNT3 = vtx_aos_count3
#define set_SE_VTX_AOS_ATTR23_vtx_aos_stride3(reg, vtx_aos_stride3) (reg)->bitfields.VTX_AOS_STRIDE3 = vtx_aos_stride3

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_AOS_ADDR2 regSE_VTX_AOS_ADDR2;

#ifdef DEBUG
__inline void set_SE_VTX_AOS_ADDR2_vtx_aos_addr2(regSE_VTX_AOS_ADDR2 *reg, unsigned int vtx_aos_addr2)
{
  reg->bitfields.VTX_AOS_ADDR2 = vtx_aos_addr2;
  if (reg->bitfields.VTX_AOS_ADDR2 != vtx_aos_addr2) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ADDR2::VTX_AOS_ADDR2 data too large\n");
}
#else
#define set_SE_VTX_AOS_ADDR2_vtx_aos_addr2(reg, vtx_aos_addr2) (reg)->bitfields.VTX_AOS_ADDR2 = vtx_aos_addr2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_AOS_ADDR3 regSE_VTX_AOS_ADDR3;

#ifdef DEBUG
__inline void set_SE_VTX_AOS_ADDR3_vtx_aos_addr3(regSE_VTX_AOS_ADDR3 *reg, unsigned int vtx_aos_addr3)
{
  reg->bitfields.VTX_AOS_ADDR3 = vtx_aos_addr3;
  if (reg->bitfields.VTX_AOS_ADDR3 != vtx_aos_addr3) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ADDR3::VTX_AOS_ADDR3 data too large\n");
}
#else
#define set_SE_VTX_AOS_ADDR3_vtx_aos_addr3(reg, vtx_aos_addr3) (reg)->bitfields.VTX_AOS_ADDR3 = vtx_aos_addr3

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_AOS_ATTR45 regSE_VTX_AOS_ATTR45;

#ifdef DEBUG
__inline void set_SE_VTX_AOS_ATTR45_vtx_aos_count4(regSE_VTX_AOS_ATTR45 *reg, unsigned int vtx_aos_count4)
{
  reg->bitfields.VTX_AOS_COUNT4 = vtx_aos_count4;
  if (reg->bitfields.VTX_AOS_COUNT4 != vtx_aos_count4) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR45::VTX_AOS_COUNT4 data too large\n");
}
__inline void set_SE_VTX_AOS_ATTR45_vtx_aos_stride4(regSE_VTX_AOS_ATTR45 *reg, unsigned int vtx_aos_stride4)
{
  reg->bitfields.VTX_AOS_STRIDE4 = vtx_aos_stride4;
  if (reg->bitfields.VTX_AOS_STRIDE4 != vtx_aos_stride4) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR45::VTX_AOS_STRIDE4 data too large\n");
}
__inline void set_SE_VTX_AOS_ATTR45_vtx_aos_count5(regSE_VTX_AOS_ATTR45 *reg, unsigned int vtx_aos_count5)
{
  reg->bitfields.VTX_AOS_COUNT5 = vtx_aos_count5;
  if (reg->bitfields.VTX_AOS_COUNT5 != vtx_aos_count5) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR45::VTX_AOS_COUNT5 data too large\n");
}
__inline void set_SE_VTX_AOS_ATTR45_vtx_aos_stride5(regSE_VTX_AOS_ATTR45 *reg, unsigned int vtx_aos_stride5)
{
  reg->bitfields.VTX_AOS_STRIDE5 = vtx_aos_stride5;
  if (reg->bitfields.VTX_AOS_STRIDE5 != vtx_aos_stride5) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR45::VTX_AOS_STRIDE5 data too large\n");
}
#else
#define set_SE_VTX_AOS_ATTR45_vtx_aos_count4(reg, vtx_aos_count4) (reg)->bitfields.VTX_AOS_COUNT4 = vtx_aos_count4
#define set_SE_VTX_AOS_ATTR45_vtx_aos_stride4(reg, vtx_aos_stride4) (reg)->bitfields.VTX_AOS_STRIDE4 = vtx_aos_stride4
#define set_SE_VTX_AOS_ATTR45_vtx_aos_count5(reg, vtx_aos_count5) (reg)->bitfields.VTX_AOS_COUNT5 = vtx_aos_count5
#define set_SE_VTX_AOS_ATTR45_vtx_aos_stride5(reg, vtx_aos_stride5) (reg)->bitfields.VTX_AOS_STRIDE5 = vtx_aos_stride5

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_AOS_ADDR4 regSE_VTX_AOS_ADDR4;

#ifdef DEBUG
__inline void set_SE_VTX_AOS_ADDR4_vtx_aos_addr4(regSE_VTX_AOS_ADDR4 *reg, unsigned int vtx_aos_addr4)
{
  reg->bitfields.VTX_AOS_ADDR4 = vtx_aos_addr4;
  if (reg->bitfields.VTX_AOS_ADDR4 != vtx_aos_addr4) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ADDR4::VTX_AOS_ADDR4 data too large\n");
}
#else
#define set_SE_VTX_AOS_ADDR4_vtx_aos_addr4(reg, vtx_aos_addr4) (reg)->bitfields.VTX_AOS_ADDR4 = vtx_aos_addr4

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_AOS_ADDR5 regSE_VTX_AOS_ADDR5;

#ifdef DEBUG
__inline void set_SE_VTX_AOS_ADDR5_vtx_aos_addr5(regSE_VTX_AOS_ADDR5 *reg, unsigned int vtx_aos_addr5)
{
  reg->bitfields.VTX_AOS_ADDR5 = vtx_aos_addr5;
  if (reg->bitfields.VTX_AOS_ADDR5 != vtx_aos_addr5) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ADDR5::VTX_AOS_ADDR5 data too large\n");
}
#else
#define set_SE_VTX_AOS_ADDR5_vtx_aos_addr5(reg, vtx_aos_addr5) (reg)->bitfields.VTX_AOS_ADDR5 = vtx_aos_addr5

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_AOS_ATTR67 regSE_VTX_AOS_ATTR67;

#ifdef DEBUG
__inline void set_SE_VTX_AOS_ATTR67_vtx_aos_count6(regSE_VTX_AOS_ATTR67 *reg, unsigned int vtx_aos_count6)
{
  reg->bitfields.VTX_AOS_COUNT6 = vtx_aos_count6;
  if (reg->bitfields.VTX_AOS_COUNT6 != vtx_aos_count6) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR67::VTX_AOS_COUNT6 data too large\n");
}
__inline void set_SE_VTX_AOS_ATTR67_vtx_aos_stride6(regSE_VTX_AOS_ATTR67 *reg, unsigned int vtx_aos_stride6)
{
  reg->bitfields.VTX_AOS_STRIDE6 = vtx_aos_stride6;
  if (reg->bitfields.VTX_AOS_STRIDE6 != vtx_aos_stride6) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR67::VTX_AOS_STRIDE6 data too large\n");
}
__inline void set_SE_VTX_AOS_ATTR67_vtx_aos_count7(regSE_VTX_AOS_ATTR67 *reg, unsigned int vtx_aos_count7)
{
  reg->bitfields.VTX_AOS_COUNT7 = vtx_aos_count7;
  if (reg->bitfields.VTX_AOS_COUNT7 != vtx_aos_count7) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR67::VTX_AOS_COUNT7 data too large\n");
}
__inline void set_SE_VTX_AOS_ATTR67_vtx_aos_stride7(regSE_VTX_AOS_ATTR67 *reg, unsigned int vtx_aos_stride7)
{
  reg->bitfields.VTX_AOS_STRIDE7 = vtx_aos_stride7;
  if (reg->bitfields.VTX_AOS_STRIDE7 != vtx_aos_stride7) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR67::VTX_AOS_STRIDE7 data too large\n");
}
#else
#define set_SE_VTX_AOS_ATTR67_vtx_aos_count6(reg, vtx_aos_count6) (reg)->bitfields.VTX_AOS_COUNT6 = vtx_aos_count6
#define set_SE_VTX_AOS_ATTR67_vtx_aos_stride6(reg, vtx_aos_stride6) (reg)->bitfields.VTX_AOS_STRIDE6 = vtx_aos_stride6
#define set_SE_VTX_AOS_ATTR67_vtx_aos_count7(reg, vtx_aos_count7) (reg)->bitfields.VTX_AOS_COUNT7 = vtx_aos_count7
#define set_SE_VTX_AOS_ATTR67_vtx_aos_stride7(reg, vtx_aos_stride7) (reg)->bitfields.VTX_AOS_STRIDE7 = vtx_aos_stride7

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_AOS_ADDR6 regSE_VTX_AOS_ADDR6;

#ifdef DEBUG
__inline void set_SE_VTX_AOS_ADDR6_vtx_aos_addr6(regSE_VTX_AOS_ADDR6 *reg, unsigned int vtx_aos_addr6)
{
  reg->bitfields.VTX_AOS_ADDR6 = vtx_aos_addr6;
  if (reg->bitfields.VTX_AOS_ADDR6 != vtx_aos_addr6) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ADDR6::VTX_AOS_ADDR6 data too large\n");
}
#else
#define set_SE_VTX_AOS_ADDR6_vtx_aos_addr6(reg, vtx_aos_addr6) (reg)->bitfields.VTX_AOS_ADDR6 = vtx_aos_addr6

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_AOS_ADDR7 regSE_VTX_AOS_ADDR7;

#ifdef DEBUG
__inline void set_SE_VTX_AOS_ADDR7_vtx_aos_addr7(regSE_VTX_AOS_ADDR7 *reg, unsigned int vtx_aos_addr7)
{
  reg->bitfields.VTX_AOS_ADDR7 = vtx_aos_addr7;
  if (reg->bitfields.VTX_AOS_ADDR7 != vtx_aos_addr7) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ADDR7::VTX_AOS_ADDR7 data too large\n");
}
#else
#define set_SE_VTX_AOS_ADDR7_vtx_aos_addr7(reg, vtx_aos_addr7) (reg)->bitfields.VTX_AOS_ADDR7 = vtx_aos_addr7

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_AOS_ATTR89 regSE_VTX_AOS_ATTR89;

#ifdef DEBUG
__inline void set_SE_VTX_AOS_ATTR89_vtx_aos_count8(regSE_VTX_AOS_ATTR89 *reg, unsigned int vtx_aos_count8)
{
  reg->bitfields.VTX_AOS_COUNT8 = vtx_aos_count8;
  if (reg->bitfields.VTX_AOS_COUNT8 != vtx_aos_count8) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR89::VTX_AOS_COUNT8 data too large\n");
}
__inline void set_SE_VTX_AOS_ATTR89_vtx_aos_stride8(regSE_VTX_AOS_ATTR89 *reg, unsigned int vtx_aos_stride8)
{
  reg->bitfields.VTX_AOS_STRIDE8 = vtx_aos_stride8;
  if (reg->bitfields.VTX_AOS_STRIDE8 != vtx_aos_stride8) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR89::VTX_AOS_STRIDE8 data too large\n");
}
__inline void set_SE_VTX_AOS_ATTR89_vtx_aos_count9(regSE_VTX_AOS_ATTR89 *reg, unsigned int vtx_aos_count9)
{
  reg->bitfields.VTX_AOS_COUNT9 = vtx_aos_count9;
  if (reg->bitfields.VTX_AOS_COUNT9 != vtx_aos_count9) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR89::VTX_AOS_COUNT9 data too large\n");
}
__inline void set_SE_VTX_AOS_ATTR89_vtx_aos_stride9(regSE_VTX_AOS_ATTR89 *reg, unsigned int vtx_aos_stride9)
{
  reg->bitfields.VTX_AOS_STRIDE9 = vtx_aos_stride9;
  if (reg->bitfields.VTX_AOS_STRIDE9 != vtx_aos_stride9) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR89::VTX_AOS_STRIDE9 data too large\n");
}
#else
#define set_SE_VTX_AOS_ATTR89_vtx_aos_count8(reg, vtx_aos_count8) (reg)->bitfields.VTX_AOS_COUNT8 = vtx_aos_count8
#define set_SE_VTX_AOS_ATTR89_vtx_aos_stride8(reg, vtx_aos_stride8) (reg)->bitfields.VTX_AOS_STRIDE8 = vtx_aos_stride8
#define set_SE_VTX_AOS_ATTR89_vtx_aos_count9(reg, vtx_aos_count9) (reg)->bitfields.VTX_AOS_COUNT9 = vtx_aos_count9
#define set_SE_VTX_AOS_ATTR89_vtx_aos_stride9(reg, vtx_aos_stride9) (reg)->bitfields.VTX_AOS_STRIDE9 = vtx_aos_stride9

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_AOS_ADDR8 regSE_VTX_AOS_ADDR8;

#ifdef DEBUG
__inline void set_SE_VTX_AOS_ADDR8_vtx_aos_addr8(regSE_VTX_AOS_ADDR8 *reg, unsigned int vtx_aos_addr8)
{
  reg->bitfields.VTX_AOS_ADDR8 = vtx_aos_addr8;
  if (reg->bitfields.VTX_AOS_ADDR8 != vtx_aos_addr8) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ADDR8::VTX_AOS_ADDR8 data too large\n");
}
#else
#define set_SE_VTX_AOS_ADDR8_vtx_aos_addr8(reg, vtx_aos_addr8) (reg)->bitfields.VTX_AOS_ADDR8 = vtx_aos_addr8

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_AOS_ADDR9 regSE_VTX_AOS_ADDR9;

#ifdef DEBUG
__inline void set_SE_VTX_AOS_ADDR9_vtx_aos_addr9(regSE_VTX_AOS_ADDR9 *reg, unsigned int vtx_aos_addr9)
{
  reg->bitfields.VTX_AOS_ADDR9 = vtx_aos_addr9;
  if (reg->bitfields.VTX_AOS_ADDR9 != vtx_aos_addr9) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ADDR9::VTX_AOS_ADDR9 data too large\n");
}
#else
#define set_SE_VTX_AOS_ADDR9_vtx_aos_addr9(reg, vtx_aos_addr9) (reg)->bitfields.VTX_AOS_ADDR9 = vtx_aos_addr9

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_AOS_ATTR1011 regSE_VTX_AOS_ATTR1011;

#ifdef DEBUG
__inline void set_SE_VTX_AOS_ATTR1011_vtx_aos_count10(regSE_VTX_AOS_ATTR1011 *reg, unsigned int vtx_aos_count10)
{
  reg->bitfields.VTX_AOS_COUNT10 = vtx_aos_count10;
  if (reg->bitfields.VTX_AOS_COUNT10 != vtx_aos_count10) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR1011::VTX_AOS_COUNT10 data too large\n");
}
__inline void set_SE_VTX_AOS_ATTR1011_vtx_aos_stride10(regSE_VTX_AOS_ATTR1011 *reg, unsigned int vtx_aos_stride10)
{
  reg->bitfields.VTX_AOS_STRIDE10 = vtx_aos_stride10;
  if (reg->bitfields.VTX_AOS_STRIDE10 != vtx_aos_stride10) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR1011::VTX_AOS_STRIDE10 data too large\n");
}
__inline void set_SE_VTX_AOS_ATTR1011_vtx_aos_count11(regSE_VTX_AOS_ATTR1011 *reg, unsigned int vtx_aos_count11)
{
  reg->bitfields.VTX_AOS_COUNT11 = vtx_aos_count11;
  if (reg->bitfields.VTX_AOS_COUNT11 != vtx_aos_count11) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR1011::VTX_AOS_COUNT11 data too large\n");
}
__inline void set_SE_VTX_AOS_ATTR1011_vtx_aos_stride11(regSE_VTX_AOS_ATTR1011 *reg, unsigned int vtx_aos_stride11)
{
  reg->bitfields.VTX_AOS_STRIDE11 = vtx_aos_stride11;
  if (reg->bitfields.VTX_AOS_STRIDE11 != vtx_aos_stride11) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ATTR1011::VTX_AOS_STRIDE11 data too large\n");
}
#else
#define set_SE_VTX_AOS_ATTR1011_vtx_aos_count10(reg, vtx_aos_count10) (reg)->bitfields.VTX_AOS_COUNT10 = vtx_aos_count10
#define set_SE_VTX_AOS_ATTR1011_vtx_aos_stride10(reg, vtx_aos_stride10) (reg)->bitfields.VTX_AOS_STRIDE10 = vtx_aos_stride10
#define set_SE_VTX_AOS_ATTR1011_vtx_aos_count11(reg, vtx_aos_count11) (reg)->bitfields.VTX_AOS_COUNT11 = vtx_aos_count11
#define set_SE_VTX_AOS_ATTR1011_vtx_aos_stride11(reg, vtx_aos_stride11) (reg)->bitfields.VTX_AOS_STRIDE11 = vtx_aos_stride11

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_AOS_ADDR10 regSE_VTX_AOS_ADDR10;

#ifdef DEBUG
__inline void set_SE_VTX_AOS_ADDR10_vtx_aos_addr10(regSE_VTX_AOS_ADDR10 *reg, unsigned int vtx_aos_addr10)
{
  reg->bitfields.VTX_AOS_ADDR10 = vtx_aos_addr10;
  if (reg->bitfields.VTX_AOS_ADDR10 != vtx_aos_addr10) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ADDR10::VTX_AOS_ADDR10 data too large\n");
}
#else
#define set_SE_VTX_AOS_ADDR10_vtx_aos_addr10(reg, vtx_aos_addr10) (reg)->bitfields.VTX_AOS_ADDR10 = vtx_aos_addr10

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_AOS_ADDR11 regSE_VTX_AOS_ADDR11;

#ifdef DEBUG
__inline void set_SE_VTX_AOS_ADDR11_vtx_aos_addr11(regSE_VTX_AOS_ADDR11 *reg, unsigned int vtx_aos_addr11)
{
  reg->bitfields.VTX_AOS_ADDR11 = vtx_aos_addr11;
  if (reg->bitfields.VTX_AOS_ADDR11 != vtx_aos_addr11) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_AOS_ADDR11::VTX_AOS_ADDR11 data too large\n");
}
#else
#define set_SE_VTX_AOS_ADDR11_vtx_aos_addr11(reg, vtx_aos_addr11) (reg)->bitfields.VTX_AOS_ADDR11 = vtx_aos_addr11

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VF_MAX_VTX_INDX regSE_VF_MAX_VTX_INDX;

#ifdef DEBUG
__inline void set_SE_VF_MAX_VTX_INDX_max_indx(regSE_VF_MAX_VTX_INDX *reg, unsigned int max_indx)
{
  reg->bitfields.MAX_INDX = max_indx;
  if (reg->bitfields.MAX_INDX != max_indx) HSLDPF(E_ERROR_MESSAGE,"SE_VF_MAX_VTX_INDX::MAX_INDX data too large\n");
}
#else
#define set_SE_VF_MAX_VTX_INDX_max_indx(reg, max_indx) (reg)->bitfields.MAX_INDX = max_indx

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VF_MIN_VTX_INDX regSE_VF_MIN_VTX_INDX;

#ifdef DEBUG
__inline void set_SE_VF_MIN_VTX_INDX_min_indx(regSE_VF_MIN_VTX_INDX *reg, unsigned int min_indx)
{
  reg->bitfields.MIN_INDX = min_indx;
  if (reg->bitfields.MIN_INDX != min_indx) HSLDPF(E_ERROR_MESSAGE,"SE_VF_MIN_VTX_INDX::MIN_INDX data too large\n");
}
#else
#define set_SE_VF_MIN_VTX_INDX_min_indx(reg, min_indx) (reg)->bitfields.MIN_INDX = min_indx

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VAP_PERF_CNTL_0 regSE_VAP_PERF_CNTL_0;

#ifdef DEBUG
__inline void set_SE_VAP_PERF_CNTL_0_perf_sel_0(regSE_VAP_PERF_CNTL_0 *reg, unsigned int perf_sel_0)
{
  reg->bitfields.PERF_SEL_0 = perf_sel_0;
  if (reg->bitfields.PERF_SEL_0 != perf_sel_0) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_PERF_CNTL_0::PERF_SEL_0 data too large\n");
}
__inline void set_SE_VAP_PERF_CNTL_0_clr_perf_0(regSE_VAP_PERF_CNTL_0 *reg, unsigned int clr_perf_0)
{
  reg->bitfields.CLR_PERF_0 = clr_perf_0;
  if (reg->bitfields.CLR_PERF_0 != clr_perf_0) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_PERF_CNTL_0::CLR_PERF_0 data too large\n");
}
__inline void set_SE_VAP_PERF_CNTL_0_en_perf_0(regSE_VAP_PERF_CNTL_0 *reg, unsigned int en_perf_0)
{
  reg->bitfields.EN_PERF_0 = en_perf_0;
  if (reg->bitfields.EN_PERF_0 != en_perf_0) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_PERF_CNTL_0::EN_PERF_0 data too large\n");
}
__inline void set_SE_VAP_PERF_CNTL_0_num_verts_to_bypass_0(regSE_VAP_PERF_CNTL_0 *reg, unsigned int num_verts_to_bypass_0)
{
  reg->bitfields.NUM_VERTS_TO_BYPASS_0 = num_verts_to_bypass_0;
  if (reg->bitfields.NUM_VERTS_TO_BYPASS_0 != num_verts_to_bypass_0) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_PERF_CNTL_0::NUM_VERTS_TO_BYPASS_0 data too large\n");
}
__inline void set_SE_VAP_PERF_CNTL_0_num_verts_to_count_0(regSE_VAP_PERF_CNTL_0 *reg, unsigned int num_verts_to_count_0)
{
  reg->bitfields.NUM_VERTS_TO_COUNT_0 = num_verts_to_count_0;
  if (reg->bitfields.NUM_VERTS_TO_COUNT_0 != num_verts_to_count_0) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_PERF_CNTL_0::NUM_VERTS_TO_COUNT_0 data too large\n");
}
#else
#define set_SE_VAP_PERF_CNTL_0_perf_sel_0(reg, perf_sel_0) (reg)->bitfields.PERF_SEL_0 = perf_sel_0
#define set_SE_VAP_PERF_CNTL_0_clr_perf_0(reg, clr_perf_0) (reg)->bitfields.CLR_PERF_0 = clr_perf_0
#define set_SE_VAP_PERF_CNTL_0_en_perf_0(reg, en_perf_0) (reg)->bitfields.EN_PERF_0 = en_perf_0
#define set_SE_VAP_PERF_CNTL_0_num_verts_to_bypass_0(reg, num_verts_to_bypass_0) (reg)->bitfields.NUM_VERTS_TO_BYPASS_0 = num_verts_to_bypass_0
#define set_SE_VAP_PERF_CNTL_0_num_verts_to_count_0(reg, num_verts_to_count_0) (reg)->bitfields.NUM_VERTS_TO_COUNT_0 = num_verts_to_count_0

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VAP_PERF_CNTL_1 regSE_VAP_PERF_CNTL_1;

#ifdef DEBUG
__inline void set_SE_VAP_PERF_CNTL_1_perf_sel_1(regSE_VAP_PERF_CNTL_1 *reg, unsigned int perf_sel_1)
{
  reg->bitfields.PERF_SEL_1 = perf_sel_1;
  if (reg->bitfields.PERF_SEL_1 != perf_sel_1) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_PERF_CNTL_1::PERF_SEL_1 data too large\n");
}
__inline void set_SE_VAP_PERF_CNTL_1_clr_perf_1(regSE_VAP_PERF_CNTL_1 *reg, unsigned int clr_perf_1)
{
  reg->bitfields.CLR_PERF_1 = clr_perf_1;
  if (reg->bitfields.CLR_PERF_1 != clr_perf_1) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_PERF_CNTL_1::CLR_PERF_1 data too large\n");
}
__inline void set_SE_VAP_PERF_CNTL_1_en_perf_1(regSE_VAP_PERF_CNTL_1 *reg, unsigned int en_perf_1)
{
  reg->bitfields.EN_PERF_1 = en_perf_1;
  if (reg->bitfields.EN_PERF_1 != en_perf_1) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_PERF_CNTL_1::EN_PERF_1 data too large\n");
}
__inline void set_SE_VAP_PERF_CNTL_1_num_verts_to_bypass_1(regSE_VAP_PERF_CNTL_1 *reg, unsigned int num_verts_to_bypass_1)
{
  reg->bitfields.NUM_VERTS_TO_BYPASS_1 = num_verts_to_bypass_1;
  if (reg->bitfields.NUM_VERTS_TO_BYPASS_1 != num_verts_to_bypass_1) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_PERF_CNTL_1::NUM_VERTS_TO_BYPASS_1 data too large\n");
}
__inline void set_SE_VAP_PERF_CNTL_1_num_verts_to_count_1(regSE_VAP_PERF_CNTL_1 *reg, unsigned int num_verts_to_count_1)
{
  reg->bitfields.NUM_VERTS_TO_COUNT_1 = num_verts_to_count_1;
  if (reg->bitfields.NUM_VERTS_TO_COUNT_1 != num_verts_to_count_1) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_PERF_CNTL_1::NUM_VERTS_TO_COUNT_1 data too large\n");
}
#else
#define set_SE_VAP_PERF_CNTL_1_perf_sel_1(reg, perf_sel_1) (reg)->bitfields.PERF_SEL_1 = perf_sel_1
#define set_SE_VAP_PERF_CNTL_1_clr_perf_1(reg, clr_perf_1) (reg)->bitfields.CLR_PERF_1 = clr_perf_1
#define set_SE_VAP_PERF_CNTL_1_en_perf_1(reg, en_perf_1) (reg)->bitfields.EN_PERF_1 = en_perf_1
#define set_SE_VAP_PERF_CNTL_1_num_verts_to_bypass_1(reg, num_verts_to_bypass_1) (reg)->bitfields.NUM_VERTS_TO_BYPASS_1 = num_verts_to_bypass_1
#define set_SE_VAP_PERF_CNTL_1_num_verts_to_count_1(reg, num_verts_to_count_1) (reg)->bitfields.NUM_VERTS_TO_COUNT_1 = num_verts_to_count_1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VAP_PERF_COUNT_0 regSE_VAP_PERF_COUNT_0;

#ifdef DEBUG
__inline void set_SE_VAP_PERF_COUNT_0_perf_count_0(regSE_VAP_PERF_COUNT_0 *reg, unsigned int perf_count_0)
{
  reg->bitfields.PERF_COUNT_0 = perf_count_0;
  if (reg->bitfields.PERF_COUNT_0 != perf_count_0) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_PERF_COUNT_0::PERF_COUNT_0 data too large\n");
}
#else
#define set_SE_VAP_PERF_COUNT_0_perf_count_0(reg, perf_count_0) (reg)->bitfields.PERF_COUNT_0 = perf_count_0

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VAP_PERF_COUNT_1 regSE_VAP_PERF_COUNT_1;

#ifdef DEBUG
__inline void set_SE_VAP_PERF_COUNT_1_perf_count_1(regSE_VAP_PERF_COUNT_1 *reg, unsigned int perf_count_1)
{
  reg->bitfields.PERF_COUNT_1 = perf_count_1;
  if (reg->bitfields.PERF_COUNT_1 != perf_count_1) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_PERF_COUNT_1::PERF_COUNT_1 data too large\n");
}
#else
#define set_SE_VAP_PERF_COUNT_1_perf_count_1(reg, perf_count_1) (reg)->bitfields.PERF_COUNT_1 = perf_count_1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_DEBUG regSE_DEBUG;

#ifdef DEBUG
__inline void set_SE_DEBUG_se_debug(regSE_DEBUG *reg, unsigned int se_debug)
{
  reg->bitfields.SE_DEBUG = se_debug;
  if (reg->bitfields.SE_DEBUG != se_debug) HSLDPF(E_ERROR_MESSAGE,"SE_DEBUG::SE_DEBUG data too large\n");
}
#else
#define set_SE_DEBUG_se_debug(reg, se_debug) (reg)->bitfields.SE_DEBUG = se_debug

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VAP_CNTL_STATUS regSE_VAP_CNTL_STATUS;

#ifdef DEBUG
__inline void set_SE_VAP_CNTL_STATUS_vc_swap(regSE_VAP_CNTL_STATUS *reg, unsigned int vc_swap)
{
  reg->bitfields.VC_SWAP = vc_swap;
  if (reg->bitfields.VC_SWAP != vc_swap) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_CNTL_STATUS::VC_SWAP data too large\n");
}
__inline void set_SE_VAP_CNTL_STATUS_tcl_bypass(regSE_VAP_CNTL_STATUS *reg, unsigned int tcl_bypass)
{
  reg->bitfields.TCL_BYPASS = tcl_bypass;
  if (reg->bitfields.TCL_BYPASS != tcl_bypass) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_CNTL_STATUS::TCL_BYPASS data too large\n");
}
__inline void set_SE_VAP_CNTL_STATUS_tcl_busy(regSE_VAP_CNTL_STATUS *reg, unsigned int tcl_busy)
{
  reg->bitfields.TCL_BUSY = tcl_busy;
  if (reg->bitfields.TCL_BUSY != tcl_busy) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_CNTL_STATUS::TCL_BUSY data too large\n");
}
__inline void set_SE_VAP_CNTL_STATUS_perf_busy(regSE_VAP_CNTL_STATUS *reg, unsigned int perf_busy)
{
  reg->bitfields.PERF_BUSY = perf_busy;
  if (reg->bitfields.PERF_BUSY != perf_busy) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_CNTL_STATUS::PERF_BUSY data too large\n");
}
__inline void set_SE_VAP_CNTL_STATUS_primitive_bypass_busy(regSE_VAP_CNTL_STATUS *reg, unsigned int primitive_bypass_busy)
{
  reg->bitfields.PRIMITIVE_BYPASS_BUSY = primitive_bypass_busy;
  if (reg->bitfields.PRIMITIVE_BYPASS_BUSY != primitive_bypass_busy) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_CNTL_STATUS::PRIMITIVE_BYPASS_BUSY data too large\n");
}
__inline void set_SE_VAP_CNTL_STATUS_rcp_busy(regSE_VAP_CNTL_STATUS *reg, unsigned int rcp_busy)
{
  reg->bitfields.RCP_BUSY = rcp_busy;
  if (reg->bitfields.RCP_BUSY != rcp_busy) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_CNTL_STATUS::RCP_BUSY data too large\n");
}
__inline void set_SE_VAP_CNTL_STATUS_vapb_rbiu_slave_busy(regSE_VAP_CNTL_STATUS *reg, unsigned int vapb_rbiu_slave_busy)
{
  reg->bitfields.VAPB_RBIU_SLAVE_BUSY = vapb_rbiu_slave_busy;
  if (reg->bitfields.VAPB_RBIU_SLAVE_BUSY != vapb_rbiu_slave_busy) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_CNTL_STATUS::VAPB_RBIU_SLAVE_BUSY data too large\n");
}
__inline void set_SE_VAP_CNTL_STATUS_miu_busy(regSE_VAP_CNTL_STATUS *reg, unsigned int miu_busy)
{
  reg->bitfields.MIU_BUSY = miu_busy;
  if (reg->bitfields.MIU_BUSY != miu_busy) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_CNTL_STATUS::MIU_BUSY data too large\n");
}
__inline void set_SE_VAP_CNTL_STATUS_vc_busy(regSE_VAP_CNTL_STATUS *reg, unsigned int vc_busy)
{
  reg->bitfields.VC_BUSY = vc_busy;
  if (reg->bitfields.VC_BUSY != vc_busy) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_CNTL_STATUS::VC_BUSY data too large\n");
}
__inline void set_SE_VAP_CNTL_STATUS_vf_busy(regSE_VAP_CNTL_STATUS *reg, unsigned int vf_busy)
{
  reg->bitfields.VF_BUSY = vf_busy;
  if (reg->bitfields.VF_BUSY != vf_busy) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_CNTL_STATUS::VF_BUSY data too large\n");
}
__inline void set_SE_VAP_CNTL_STATUS_regpipe_busy(regSE_VAP_CNTL_STATUS *reg, unsigned int regpipe_busy)
{
  reg->bitfields.REGPIPE_BUSY = regpipe_busy;
  if (reg->bitfields.REGPIPE_BUSY != regpipe_busy) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_CNTL_STATUS::REGPIPE_BUSY data too large\n");
}
__inline void set_SE_VAP_CNTL_STATUS_vap_busy(regSE_VAP_CNTL_STATUS *reg, unsigned int vap_busy)
{
  reg->bitfields.VAP_BUSY = vap_busy;
  if (reg->bitfields.VAP_BUSY != vap_busy) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_CNTL_STATUS::VAP_BUSY data too large\n");
}
#else
#define set_SE_VAP_CNTL_STATUS_vc_swap(reg, vc_swap) (reg)->bitfields.VC_SWAP = vc_swap
#define set_SE_VAP_CNTL_STATUS_tcl_bypass(reg, tcl_bypass) (reg)->bitfields.TCL_BYPASS = tcl_bypass
#define set_SE_VAP_CNTL_STATUS_tcl_busy(reg, tcl_busy) (reg)->bitfields.TCL_BUSY = tcl_busy
#define set_SE_VAP_CNTL_STATUS_perf_busy(reg, perf_busy) (reg)->bitfields.PERF_BUSY = perf_busy
#define set_SE_VAP_CNTL_STATUS_primitive_bypass_busy(reg, primitive_bypass_busy) (reg)->bitfields.PRIMITIVE_BYPASS_BUSY = primitive_bypass_busy
#define set_SE_VAP_CNTL_STATUS_rcp_busy(reg, rcp_busy) (reg)->bitfields.RCP_BUSY = rcp_busy
#define set_SE_VAP_CNTL_STATUS_vapb_rbiu_slave_busy(reg, vapb_rbiu_slave_busy) (reg)->bitfields.VAPB_RBIU_SLAVE_BUSY = vapb_rbiu_slave_busy
#define set_SE_VAP_CNTL_STATUS_miu_busy(reg, miu_busy) (reg)->bitfields.MIU_BUSY = miu_busy
#define set_SE_VAP_CNTL_STATUS_vc_busy(reg, vc_busy) (reg)->bitfields.VC_BUSY = vc_busy
#define set_SE_VAP_CNTL_STATUS_vf_busy(reg, vf_busy) (reg)->bitfields.VF_BUSY = vf_busy
#define set_SE_VAP_CNTL_STATUS_regpipe_busy(reg, regpipe_busy) (reg)->bitfields.REGPIPE_BUSY = regpipe_busy
#define set_SE_VAP_CNTL_STATUS_vap_busy(reg, vap_busy) (reg)->bitfields.VAP_BUSY = vap_busy

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PROG_STREAM_CNTL_0 regSE_PROG_STREAM_CNTL_0;

#ifdef DEBUG
__inline void set_SE_PROG_STREAM_CNTL_0_data_type_0(regSE_PROG_STREAM_CNTL_0 *reg, unsigned int data_type_0)
{
  reg->bitfields.DATA_TYPE_0 = data_type_0;
  if (reg->bitfields.DATA_TYPE_0 != data_type_0) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_0::DATA_TYPE_0 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_0_skip_dwords_0(regSE_PROG_STREAM_CNTL_0 *reg, unsigned int skip_dwords_0)
{
  reg->bitfields.SKIP_DWORDS_0 = skip_dwords_0;
  if (reg->bitfields.SKIP_DWORDS_0 != skip_dwords_0) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_0::SKIP_DWORDS_0 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_0_dst_vec_loc_0(regSE_PROG_STREAM_CNTL_0 *reg, unsigned int dst_vec_loc_0)
{
  reg->bitfields.DST_VEC_LOC_0 = dst_vec_loc_0;
  if (reg->bitfields.DST_VEC_LOC_0 != dst_vec_loc_0) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_0::DST_VEC_LOC_0 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_0_last_vec_0(regSE_PROG_STREAM_CNTL_0 *reg, unsigned int last_vec_0)
{
  reg->bitfields.LAST_VEC_0 = last_vec_0;
  if (reg->bitfields.LAST_VEC_0 != last_vec_0) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_0::LAST_VEC_0 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_0_signed_0(regSE_PROG_STREAM_CNTL_0 *reg, unsigned int signed_0)
{
  reg->bitfields.SIGNED_0 = signed_0;
  if (reg->bitfields.SIGNED_0 != signed_0) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_0::SIGNED_0 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_0_normalize_0(regSE_PROG_STREAM_CNTL_0 *reg, unsigned int normalize_0)
{
  reg->bitfields.NORMALIZE_0 = normalize_0;
  if (reg->bitfields.NORMALIZE_0 != normalize_0) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_0::NORMALIZE_0 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_0_data_type_1(regSE_PROG_STREAM_CNTL_0 *reg, unsigned int data_type_1)
{
  reg->bitfields.DATA_TYPE_1 = data_type_1;
  if (reg->bitfields.DATA_TYPE_1 != data_type_1) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_0::DATA_TYPE_1 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_0_skip_dwords_1(regSE_PROG_STREAM_CNTL_0 *reg, unsigned int skip_dwords_1)
{
  reg->bitfields.SKIP_DWORDS_1 = skip_dwords_1;
  if (reg->bitfields.SKIP_DWORDS_1 != skip_dwords_1) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_0::SKIP_DWORDS_1 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_0_dst_vec_loc_1(regSE_PROG_STREAM_CNTL_0 *reg, unsigned int dst_vec_loc_1)
{
  reg->bitfields.DST_VEC_LOC_1 = dst_vec_loc_1;
  if (reg->bitfields.DST_VEC_LOC_1 != dst_vec_loc_1) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_0::DST_VEC_LOC_1 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_0_last_vec_1(regSE_PROG_STREAM_CNTL_0 *reg, unsigned int last_vec_1)
{
  reg->bitfields.LAST_VEC_1 = last_vec_1;
  if (reg->bitfields.LAST_VEC_1 != last_vec_1) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_0::LAST_VEC_1 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_0_signed_1(regSE_PROG_STREAM_CNTL_0 *reg, unsigned int signed_1)
{
  reg->bitfields.SIGNED_1 = signed_1;
  if (reg->bitfields.SIGNED_1 != signed_1) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_0::SIGNED_1 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_0_normalize_1(regSE_PROG_STREAM_CNTL_0 *reg, unsigned int normalize_1)
{
  reg->bitfields.NORMALIZE_1 = normalize_1;
  if (reg->bitfields.NORMALIZE_1 != normalize_1) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_0::NORMALIZE_1 data too large\n");
}
#else
#define set_SE_PROG_STREAM_CNTL_0_data_type_0(reg, data_type_0) (reg)->bitfields.DATA_TYPE_0 = data_type_0
#define set_SE_PROG_STREAM_CNTL_0_skip_dwords_0(reg, skip_dwords_0) (reg)->bitfields.SKIP_DWORDS_0 = skip_dwords_0
#define set_SE_PROG_STREAM_CNTL_0_dst_vec_loc_0(reg, dst_vec_loc_0) (reg)->bitfields.DST_VEC_LOC_0 = dst_vec_loc_0
#define set_SE_PROG_STREAM_CNTL_0_last_vec_0(reg, last_vec_0) (reg)->bitfields.LAST_VEC_0 = last_vec_0
#define set_SE_PROG_STREAM_CNTL_0_signed_0(reg, signed_0) (reg)->bitfields.SIGNED_0 = signed_0
#define set_SE_PROG_STREAM_CNTL_0_normalize_0(reg, normalize_0) (reg)->bitfields.NORMALIZE_0 = normalize_0
#define set_SE_PROG_STREAM_CNTL_0_data_type_1(reg, data_type_1) (reg)->bitfields.DATA_TYPE_1 = data_type_1
#define set_SE_PROG_STREAM_CNTL_0_skip_dwords_1(reg, skip_dwords_1) (reg)->bitfields.SKIP_DWORDS_1 = skip_dwords_1
#define set_SE_PROG_STREAM_CNTL_0_dst_vec_loc_1(reg, dst_vec_loc_1) (reg)->bitfields.DST_VEC_LOC_1 = dst_vec_loc_1
#define set_SE_PROG_STREAM_CNTL_0_last_vec_1(reg, last_vec_1) (reg)->bitfields.LAST_VEC_1 = last_vec_1
#define set_SE_PROG_STREAM_CNTL_0_signed_1(reg, signed_1) (reg)->bitfields.SIGNED_1 = signed_1
#define set_SE_PROG_STREAM_CNTL_0_normalize_1(reg, normalize_1) (reg)->bitfields.NORMALIZE_1 = normalize_1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PROG_STREAM_CNTL_1 regSE_PROG_STREAM_CNTL_1;

#ifdef DEBUG
__inline void set_SE_PROG_STREAM_CNTL_1_data_type_2(regSE_PROG_STREAM_CNTL_1 *reg, unsigned int data_type_2)
{
  reg->bitfields.DATA_TYPE_2 = data_type_2;
  if (reg->bitfields.DATA_TYPE_2 != data_type_2) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_1::DATA_TYPE_2 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_1_skip_dwords_2(regSE_PROG_STREAM_CNTL_1 *reg, unsigned int skip_dwords_2)
{
  reg->bitfields.SKIP_DWORDS_2 = skip_dwords_2;
  if (reg->bitfields.SKIP_DWORDS_2 != skip_dwords_2) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_1::SKIP_DWORDS_2 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_1_dst_vec_loc_2(regSE_PROG_STREAM_CNTL_1 *reg, unsigned int dst_vec_loc_2)
{
  reg->bitfields.DST_VEC_LOC_2 = dst_vec_loc_2;
  if (reg->bitfields.DST_VEC_LOC_2 != dst_vec_loc_2) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_1::DST_VEC_LOC_2 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_1_last_vec_2(regSE_PROG_STREAM_CNTL_1 *reg, unsigned int last_vec_2)
{
  reg->bitfields.LAST_VEC_2 = last_vec_2;
  if (reg->bitfields.LAST_VEC_2 != last_vec_2) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_1::LAST_VEC_2 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_1_signed_2(regSE_PROG_STREAM_CNTL_1 *reg, unsigned int signed_2)
{
  reg->bitfields.SIGNED_2 = signed_2;
  if (reg->bitfields.SIGNED_2 != signed_2) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_1::SIGNED_2 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_1_normalize_2(regSE_PROG_STREAM_CNTL_1 *reg, unsigned int normalize_2)
{
  reg->bitfields.NORMALIZE_2 = normalize_2;
  if (reg->bitfields.NORMALIZE_2 != normalize_2) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_1::NORMALIZE_2 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_1_data_type_3(regSE_PROG_STREAM_CNTL_1 *reg, unsigned int data_type_3)
{
  reg->bitfields.DATA_TYPE_3 = data_type_3;
  if (reg->bitfields.DATA_TYPE_3 != data_type_3) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_1::DATA_TYPE_3 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_1_skip_dwords_3(regSE_PROG_STREAM_CNTL_1 *reg, unsigned int skip_dwords_3)
{
  reg->bitfields.SKIP_DWORDS_3 = skip_dwords_3;
  if (reg->bitfields.SKIP_DWORDS_3 != skip_dwords_3) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_1::SKIP_DWORDS_3 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_1_dst_vec_loc_3(regSE_PROG_STREAM_CNTL_1 *reg, unsigned int dst_vec_loc_3)
{
  reg->bitfields.DST_VEC_LOC_3 = dst_vec_loc_3;
  if (reg->bitfields.DST_VEC_LOC_3 != dst_vec_loc_3) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_1::DST_VEC_LOC_3 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_1_last_vec_3(regSE_PROG_STREAM_CNTL_1 *reg, unsigned int last_vec_3)
{
  reg->bitfields.LAST_VEC_3 = last_vec_3;
  if (reg->bitfields.LAST_VEC_3 != last_vec_3) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_1::LAST_VEC_3 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_1_signed_3(regSE_PROG_STREAM_CNTL_1 *reg, unsigned int signed_3)
{
  reg->bitfields.SIGNED_3 = signed_3;
  if (reg->bitfields.SIGNED_3 != signed_3) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_1::SIGNED_3 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_1_normalize_3(regSE_PROG_STREAM_CNTL_1 *reg, unsigned int normalize_3)
{
  reg->bitfields.NORMALIZE_3 = normalize_3;
  if (reg->bitfields.NORMALIZE_3 != normalize_3) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_1::NORMALIZE_3 data too large\n");
}
#else
#define set_SE_PROG_STREAM_CNTL_1_data_type_2(reg, data_type_2) (reg)->bitfields.DATA_TYPE_2 = data_type_2
#define set_SE_PROG_STREAM_CNTL_1_skip_dwords_2(reg, skip_dwords_2) (reg)->bitfields.SKIP_DWORDS_2 = skip_dwords_2
#define set_SE_PROG_STREAM_CNTL_1_dst_vec_loc_2(reg, dst_vec_loc_2) (reg)->bitfields.DST_VEC_LOC_2 = dst_vec_loc_2
#define set_SE_PROG_STREAM_CNTL_1_last_vec_2(reg, last_vec_2) (reg)->bitfields.LAST_VEC_2 = last_vec_2
#define set_SE_PROG_STREAM_CNTL_1_signed_2(reg, signed_2) (reg)->bitfields.SIGNED_2 = signed_2
#define set_SE_PROG_STREAM_CNTL_1_normalize_2(reg, normalize_2) (reg)->bitfields.NORMALIZE_2 = normalize_2
#define set_SE_PROG_STREAM_CNTL_1_data_type_3(reg, data_type_3) (reg)->bitfields.DATA_TYPE_3 = data_type_3
#define set_SE_PROG_STREAM_CNTL_1_skip_dwords_3(reg, skip_dwords_3) (reg)->bitfields.SKIP_DWORDS_3 = skip_dwords_3
#define set_SE_PROG_STREAM_CNTL_1_dst_vec_loc_3(reg, dst_vec_loc_3) (reg)->bitfields.DST_VEC_LOC_3 = dst_vec_loc_3
#define set_SE_PROG_STREAM_CNTL_1_last_vec_3(reg, last_vec_3) (reg)->bitfields.LAST_VEC_3 = last_vec_3
#define set_SE_PROG_STREAM_CNTL_1_signed_3(reg, signed_3) (reg)->bitfields.SIGNED_3 = signed_3
#define set_SE_PROG_STREAM_CNTL_1_normalize_3(reg, normalize_3) (reg)->bitfields.NORMALIZE_3 = normalize_3

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PROG_STREAM_CNTL_2 regSE_PROG_STREAM_CNTL_2;

#ifdef DEBUG
__inline void set_SE_PROG_STREAM_CNTL_2_data_type_4(regSE_PROG_STREAM_CNTL_2 *reg, unsigned int data_type_4)
{
  reg->bitfields.DATA_TYPE_4 = data_type_4;
  if (reg->bitfields.DATA_TYPE_4 != data_type_4) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_2::DATA_TYPE_4 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_2_skip_dwords_4(regSE_PROG_STREAM_CNTL_2 *reg, unsigned int skip_dwords_4)
{
  reg->bitfields.SKIP_DWORDS_4 = skip_dwords_4;
  if (reg->bitfields.SKIP_DWORDS_4 != skip_dwords_4) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_2::SKIP_DWORDS_4 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_2_dst_vec_loc_4(regSE_PROG_STREAM_CNTL_2 *reg, unsigned int dst_vec_loc_4)
{
  reg->bitfields.DST_VEC_LOC_4 = dst_vec_loc_4;
  if (reg->bitfields.DST_VEC_LOC_4 != dst_vec_loc_4) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_2::DST_VEC_LOC_4 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_2_last_vec_4(regSE_PROG_STREAM_CNTL_2 *reg, unsigned int last_vec_4)
{
  reg->bitfields.LAST_VEC_4 = last_vec_4;
  if (reg->bitfields.LAST_VEC_4 != last_vec_4) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_2::LAST_VEC_4 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_2_signed_4(regSE_PROG_STREAM_CNTL_2 *reg, unsigned int signed_4)
{
  reg->bitfields.SIGNED_4 = signed_4;
  if (reg->bitfields.SIGNED_4 != signed_4) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_2::SIGNED_4 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_2_normalize_4(regSE_PROG_STREAM_CNTL_2 *reg, unsigned int normalize_4)
{
  reg->bitfields.NORMALIZE_4 = normalize_4;
  if (reg->bitfields.NORMALIZE_4 != normalize_4) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_2::NORMALIZE_4 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_2_data_type_5(regSE_PROG_STREAM_CNTL_2 *reg, unsigned int data_type_5)
{
  reg->bitfields.DATA_TYPE_5 = data_type_5;
  if (reg->bitfields.DATA_TYPE_5 != data_type_5) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_2::DATA_TYPE_5 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_2_skip_dwords_5(regSE_PROG_STREAM_CNTL_2 *reg, unsigned int skip_dwords_5)
{
  reg->bitfields.SKIP_DWORDS_5 = skip_dwords_5;
  if (reg->bitfields.SKIP_DWORDS_5 != skip_dwords_5) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_2::SKIP_DWORDS_5 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_2_dst_vec_loc_5(regSE_PROG_STREAM_CNTL_2 *reg, unsigned int dst_vec_loc_5)
{
  reg->bitfields.DST_VEC_LOC_5 = dst_vec_loc_5;
  if (reg->bitfields.DST_VEC_LOC_5 != dst_vec_loc_5) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_2::DST_VEC_LOC_5 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_2_last_vec_5(regSE_PROG_STREAM_CNTL_2 *reg, unsigned int last_vec_5)
{
  reg->bitfields.LAST_VEC_5 = last_vec_5;
  if (reg->bitfields.LAST_VEC_5 != last_vec_5) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_2::LAST_VEC_5 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_2_signed_5(regSE_PROG_STREAM_CNTL_2 *reg, unsigned int signed_5)
{
  reg->bitfields.SIGNED_5 = signed_5;
  if (reg->bitfields.SIGNED_5 != signed_5) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_2::SIGNED_5 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_2_normalize_5(regSE_PROG_STREAM_CNTL_2 *reg, unsigned int normalize_5)
{
  reg->bitfields.NORMALIZE_5 = normalize_5;
  if (reg->bitfields.NORMALIZE_5 != normalize_5) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_2::NORMALIZE_5 data too large\n");
}
#else
#define set_SE_PROG_STREAM_CNTL_2_data_type_4(reg, data_type_4) (reg)->bitfields.DATA_TYPE_4 = data_type_4
#define set_SE_PROG_STREAM_CNTL_2_skip_dwords_4(reg, skip_dwords_4) (reg)->bitfields.SKIP_DWORDS_4 = skip_dwords_4
#define set_SE_PROG_STREAM_CNTL_2_dst_vec_loc_4(reg, dst_vec_loc_4) (reg)->bitfields.DST_VEC_LOC_4 = dst_vec_loc_4
#define set_SE_PROG_STREAM_CNTL_2_last_vec_4(reg, last_vec_4) (reg)->bitfields.LAST_VEC_4 = last_vec_4
#define set_SE_PROG_STREAM_CNTL_2_signed_4(reg, signed_4) (reg)->bitfields.SIGNED_4 = signed_4
#define set_SE_PROG_STREAM_CNTL_2_normalize_4(reg, normalize_4) (reg)->bitfields.NORMALIZE_4 = normalize_4
#define set_SE_PROG_STREAM_CNTL_2_data_type_5(reg, data_type_5) (reg)->bitfields.DATA_TYPE_5 = data_type_5
#define set_SE_PROG_STREAM_CNTL_2_skip_dwords_5(reg, skip_dwords_5) (reg)->bitfields.SKIP_DWORDS_5 = skip_dwords_5
#define set_SE_PROG_STREAM_CNTL_2_dst_vec_loc_5(reg, dst_vec_loc_5) (reg)->bitfields.DST_VEC_LOC_5 = dst_vec_loc_5
#define set_SE_PROG_STREAM_CNTL_2_last_vec_5(reg, last_vec_5) (reg)->bitfields.LAST_VEC_5 = last_vec_5
#define set_SE_PROG_STREAM_CNTL_2_signed_5(reg, signed_5) (reg)->bitfields.SIGNED_5 = signed_5
#define set_SE_PROG_STREAM_CNTL_2_normalize_5(reg, normalize_5) (reg)->bitfields.NORMALIZE_5 = normalize_5

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PROG_STREAM_CNTL_3 regSE_PROG_STREAM_CNTL_3;

#ifdef DEBUG
__inline void set_SE_PROG_STREAM_CNTL_3_data_type_6(regSE_PROG_STREAM_CNTL_3 *reg, unsigned int data_type_6)
{
  reg->bitfields.DATA_TYPE_6 = data_type_6;
  if (reg->bitfields.DATA_TYPE_6 != data_type_6) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_3::DATA_TYPE_6 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_3_skip_dwords_6(regSE_PROG_STREAM_CNTL_3 *reg, unsigned int skip_dwords_6)
{
  reg->bitfields.SKIP_DWORDS_6 = skip_dwords_6;
  if (reg->bitfields.SKIP_DWORDS_6 != skip_dwords_6) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_3::SKIP_DWORDS_6 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_3_dst_vec_loc_6(regSE_PROG_STREAM_CNTL_3 *reg, unsigned int dst_vec_loc_6)
{
  reg->bitfields.DST_VEC_LOC_6 = dst_vec_loc_6;
  if (reg->bitfields.DST_VEC_LOC_6 != dst_vec_loc_6) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_3::DST_VEC_LOC_6 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_3_last_vec_6(regSE_PROG_STREAM_CNTL_3 *reg, unsigned int last_vec_6)
{
  reg->bitfields.LAST_VEC_6 = last_vec_6;
  if (reg->bitfields.LAST_VEC_6 != last_vec_6) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_3::LAST_VEC_6 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_3_signed_6(regSE_PROG_STREAM_CNTL_3 *reg, unsigned int signed_6)
{
  reg->bitfields.SIGNED_6 = signed_6;
  if (reg->bitfields.SIGNED_6 != signed_6) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_3::SIGNED_6 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_3_normalize_6(regSE_PROG_STREAM_CNTL_3 *reg, unsigned int normalize_6)
{
  reg->bitfields.NORMALIZE_6 = normalize_6;
  if (reg->bitfields.NORMALIZE_6 != normalize_6) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_3::NORMALIZE_6 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_3_data_type_7(regSE_PROG_STREAM_CNTL_3 *reg, unsigned int data_type_7)
{
  reg->bitfields.DATA_TYPE_7 = data_type_7;
  if (reg->bitfields.DATA_TYPE_7 != data_type_7) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_3::DATA_TYPE_7 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_3_skip_dwords_7(regSE_PROG_STREAM_CNTL_3 *reg, unsigned int skip_dwords_7)
{
  reg->bitfields.SKIP_DWORDS_7 = skip_dwords_7;
  if (reg->bitfields.SKIP_DWORDS_7 != skip_dwords_7) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_3::SKIP_DWORDS_7 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_3_dst_vec_loc_7(regSE_PROG_STREAM_CNTL_3 *reg, unsigned int dst_vec_loc_7)
{
  reg->bitfields.DST_VEC_LOC_7 = dst_vec_loc_7;
  if (reg->bitfields.DST_VEC_LOC_7 != dst_vec_loc_7) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_3::DST_VEC_LOC_7 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_3_last_vec_7(regSE_PROG_STREAM_CNTL_3 *reg, unsigned int last_vec_7)
{
  reg->bitfields.LAST_VEC_7 = last_vec_7;
  if (reg->bitfields.LAST_VEC_7 != last_vec_7) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_3::LAST_VEC_7 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_3_signed_7(regSE_PROG_STREAM_CNTL_3 *reg, unsigned int signed_7)
{
  reg->bitfields.SIGNED_7 = signed_7;
  if (reg->bitfields.SIGNED_7 != signed_7) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_3::SIGNED_7 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_3_normalize_7(regSE_PROG_STREAM_CNTL_3 *reg, unsigned int normalize_7)
{
  reg->bitfields.NORMALIZE_7 = normalize_7;
  if (reg->bitfields.NORMALIZE_7 != normalize_7) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_3::NORMALIZE_7 data too large\n");
}
#else
#define set_SE_PROG_STREAM_CNTL_3_data_type_6(reg, data_type_6) (reg)->bitfields.DATA_TYPE_6 = data_type_6
#define set_SE_PROG_STREAM_CNTL_3_skip_dwords_6(reg, skip_dwords_6) (reg)->bitfields.SKIP_DWORDS_6 = skip_dwords_6
#define set_SE_PROG_STREAM_CNTL_3_dst_vec_loc_6(reg, dst_vec_loc_6) (reg)->bitfields.DST_VEC_LOC_6 = dst_vec_loc_6
#define set_SE_PROG_STREAM_CNTL_3_last_vec_6(reg, last_vec_6) (reg)->bitfields.LAST_VEC_6 = last_vec_6
#define set_SE_PROG_STREAM_CNTL_3_signed_6(reg, signed_6) (reg)->bitfields.SIGNED_6 = signed_6
#define set_SE_PROG_STREAM_CNTL_3_normalize_6(reg, normalize_6) (reg)->bitfields.NORMALIZE_6 = normalize_6
#define set_SE_PROG_STREAM_CNTL_3_data_type_7(reg, data_type_7) (reg)->bitfields.DATA_TYPE_7 = data_type_7
#define set_SE_PROG_STREAM_CNTL_3_skip_dwords_7(reg, skip_dwords_7) (reg)->bitfields.SKIP_DWORDS_7 = skip_dwords_7
#define set_SE_PROG_STREAM_CNTL_3_dst_vec_loc_7(reg, dst_vec_loc_7) (reg)->bitfields.DST_VEC_LOC_7 = dst_vec_loc_7
#define set_SE_PROG_STREAM_CNTL_3_last_vec_7(reg, last_vec_7) (reg)->bitfields.LAST_VEC_7 = last_vec_7
#define set_SE_PROG_STREAM_CNTL_3_signed_7(reg, signed_7) (reg)->bitfields.SIGNED_7 = signed_7
#define set_SE_PROG_STREAM_CNTL_3_normalize_7(reg, normalize_7) (reg)->bitfields.NORMALIZE_7 = normalize_7

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PROG_STREAM_CNTL_4 regSE_PROG_STREAM_CNTL_4;

#ifdef DEBUG
__inline void set_SE_PROG_STREAM_CNTL_4_data_type_8(regSE_PROG_STREAM_CNTL_4 *reg, unsigned int data_type_8)
{
  reg->bitfields.DATA_TYPE_8 = data_type_8;
  if (reg->bitfields.DATA_TYPE_8 != data_type_8) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_4::DATA_TYPE_8 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_4_skip_dwords_8(regSE_PROG_STREAM_CNTL_4 *reg, unsigned int skip_dwords_8)
{
  reg->bitfields.SKIP_DWORDS_8 = skip_dwords_8;
  if (reg->bitfields.SKIP_DWORDS_8 != skip_dwords_8) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_4::SKIP_DWORDS_8 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_4_dst_vec_loc_8(regSE_PROG_STREAM_CNTL_4 *reg, unsigned int dst_vec_loc_8)
{
  reg->bitfields.DST_VEC_LOC_8 = dst_vec_loc_8;
  if (reg->bitfields.DST_VEC_LOC_8 != dst_vec_loc_8) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_4::DST_VEC_LOC_8 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_4_last_vec_8(regSE_PROG_STREAM_CNTL_4 *reg, unsigned int last_vec_8)
{
  reg->bitfields.LAST_VEC_8 = last_vec_8;
  if (reg->bitfields.LAST_VEC_8 != last_vec_8) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_4::LAST_VEC_8 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_4_signed_8(regSE_PROG_STREAM_CNTL_4 *reg, unsigned int signed_8)
{
  reg->bitfields.SIGNED_8 = signed_8;
  if (reg->bitfields.SIGNED_8 != signed_8) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_4::SIGNED_8 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_4_normalize_8(regSE_PROG_STREAM_CNTL_4 *reg, unsigned int normalize_8)
{
  reg->bitfields.NORMALIZE_8 = normalize_8;
  if (reg->bitfields.NORMALIZE_8 != normalize_8) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_4::NORMALIZE_8 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_4_data_type_9(regSE_PROG_STREAM_CNTL_4 *reg, unsigned int data_type_9)
{
  reg->bitfields.DATA_TYPE_9 = data_type_9;
  if (reg->bitfields.DATA_TYPE_9 != data_type_9) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_4::DATA_TYPE_9 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_4_skip_dwords_9(regSE_PROG_STREAM_CNTL_4 *reg, unsigned int skip_dwords_9)
{
  reg->bitfields.SKIP_DWORDS_9 = skip_dwords_9;
  if (reg->bitfields.SKIP_DWORDS_9 != skip_dwords_9) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_4::SKIP_DWORDS_9 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_4_dst_vec_loc_9(regSE_PROG_STREAM_CNTL_4 *reg, unsigned int dst_vec_loc_9)
{
  reg->bitfields.DST_VEC_LOC_9 = dst_vec_loc_9;
  if (reg->bitfields.DST_VEC_LOC_9 != dst_vec_loc_9) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_4::DST_VEC_LOC_9 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_4_last_vec_9(regSE_PROG_STREAM_CNTL_4 *reg, unsigned int last_vec_9)
{
  reg->bitfields.LAST_VEC_9 = last_vec_9;
  if (reg->bitfields.LAST_VEC_9 != last_vec_9) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_4::LAST_VEC_9 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_4_signed_9(regSE_PROG_STREAM_CNTL_4 *reg, unsigned int signed_9)
{
  reg->bitfields.SIGNED_9 = signed_9;
  if (reg->bitfields.SIGNED_9 != signed_9) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_4::SIGNED_9 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_4_normalize_9(regSE_PROG_STREAM_CNTL_4 *reg, unsigned int normalize_9)
{
  reg->bitfields.NORMALIZE_9 = normalize_9;
  if (reg->bitfields.NORMALIZE_9 != normalize_9) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_4::NORMALIZE_9 data too large\n");
}
#else
#define set_SE_PROG_STREAM_CNTL_4_data_type_8(reg, data_type_8) (reg)->bitfields.DATA_TYPE_8 = data_type_8
#define set_SE_PROG_STREAM_CNTL_4_skip_dwords_8(reg, skip_dwords_8) (reg)->bitfields.SKIP_DWORDS_8 = skip_dwords_8
#define set_SE_PROG_STREAM_CNTL_4_dst_vec_loc_8(reg, dst_vec_loc_8) (reg)->bitfields.DST_VEC_LOC_8 = dst_vec_loc_8
#define set_SE_PROG_STREAM_CNTL_4_last_vec_8(reg, last_vec_8) (reg)->bitfields.LAST_VEC_8 = last_vec_8
#define set_SE_PROG_STREAM_CNTL_4_signed_8(reg, signed_8) (reg)->bitfields.SIGNED_8 = signed_8
#define set_SE_PROG_STREAM_CNTL_4_normalize_8(reg, normalize_8) (reg)->bitfields.NORMALIZE_8 = normalize_8
#define set_SE_PROG_STREAM_CNTL_4_data_type_9(reg, data_type_9) (reg)->bitfields.DATA_TYPE_9 = data_type_9
#define set_SE_PROG_STREAM_CNTL_4_skip_dwords_9(reg, skip_dwords_9) (reg)->bitfields.SKIP_DWORDS_9 = skip_dwords_9
#define set_SE_PROG_STREAM_CNTL_4_dst_vec_loc_9(reg, dst_vec_loc_9) (reg)->bitfields.DST_VEC_LOC_9 = dst_vec_loc_9
#define set_SE_PROG_STREAM_CNTL_4_last_vec_9(reg, last_vec_9) (reg)->bitfields.LAST_VEC_9 = last_vec_9
#define set_SE_PROG_STREAM_CNTL_4_signed_9(reg, signed_9) (reg)->bitfields.SIGNED_9 = signed_9
#define set_SE_PROG_STREAM_CNTL_4_normalize_9(reg, normalize_9) (reg)->bitfields.NORMALIZE_9 = normalize_9

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PROG_STREAM_CNTL_5 regSE_PROG_STREAM_CNTL_5;

#ifdef DEBUG
__inline void set_SE_PROG_STREAM_CNTL_5_data_type_10(regSE_PROG_STREAM_CNTL_5 *reg, unsigned int data_type_10)
{
  reg->bitfields.DATA_TYPE_10 = data_type_10;
  if (reg->bitfields.DATA_TYPE_10 != data_type_10) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_5::DATA_TYPE_10 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_5_skip_dwords_10(regSE_PROG_STREAM_CNTL_5 *reg, unsigned int skip_dwords_10)
{
  reg->bitfields.SKIP_DWORDS_10 = skip_dwords_10;
  if (reg->bitfields.SKIP_DWORDS_10 != skip_dwords_10) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_5::SKIP_DWORDS_10 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_5_dst_vec_loc_10(regSE_PROG_STREAM_CNTL_5 *reg, unsigned int dst_vec_loc_10)
{
  reg->bitfields.DST_VEC_LOC_10 = dst_vec_loc_10;
  if (reg->bitfields.DST_VEC_LOC_10 != dst_vec_loc_10) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_5::DST_VEC_LOC_10 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_5_last_vec_10(regSE_PROG_STREAM_CNTL_5 *reg, unsigned int last_vec_10)
{
  reg->bitfields.LAST_VEC_10 = last_vec_10;
  if (reg->bitfields.LAST_VEC_10 != last_vec_10) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_5::LAST_VEC_10 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_5_signed_10(regSE_PROG_STREAM_CNTL_5 *reg, unsigned int signed_10)
{
  reg->bitfields.SIGNED_10 = signed_10;
  if (reg->bitfields.SIGNED_10 != signed_10) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_5::SIGNED_10 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_5_normalize_10(regSE_PROG_STREAM_CNTL_5 *reg, unsigned int normalize_10)
{
  reg->bitfields.NORMALIZE_10 = normalize_10;
  if (reg->bitfields.NORMALIZE_10 != normalize_10) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_5::NORMALIZE_10 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_5_data_type_11(regSE_PROG_STREAM_CNTL_5 *reg, unsigned int data_type_11)
{
  reg->bitfields.DATA_TYPE_11 = data_type_11;
  if (reg->bitfields.DATA_TYPE_11 != data_type_11) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_5::DATA_TYPE_11 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_5_skip_dwords_11(regSE_PROG_STREAM_CNTL_5 *reg, unsigned int skip_dwords_11)
{
  reg->bitfields.SKIP_DWORDS_11 = skip_dwords_11;
  if (reg->bitfields.SKIP_DWORDS_11 != skip_dwords_11) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_5::SKIP_DWORDS_11 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_5_dst_vec_loc_11(regSE_PROG_STREAM_CNTL_5 *reg, unsigned int dst_vec_loc_11)
{
  reg->bitfields.DST_VEC_LOC_11 = dst_vec_loc_11;
  if (reg->bitfields.DST_VEC_LOC_11 != dst_vec_loc_11) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_5::DST_VEC_LOC_11 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_5_last_vec_11(regSE_PROG_STREAM_CNTL_5 *reg, unsigned int last_vec_11)
{
  reg->bitfields.LAST_VEC_11 = last_vec_11;
  if (reg->bitfields.LAST_VEC_11 != last_vec_11) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_5::LAST_VEC_11 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_5_signed_11(regSE_PROG_STREAM_CNTL_5 *reg, unsigned int signed_11)
{
  reg->bitfields.SIGNED_11 = signed_11;
  if (reg->bitfields.SIGNED_11 != signed_11) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_5::SIGNED_11 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_5_normalize_11(regSE_PROG_STREAM_CNTL_5 *reg, unsigned int normalize_11)
{
  reg->bitfields.NORMALIZE_11 = normalize_11;
  if (reg->bitfields.NORMALIZE_11 != normalize_11) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_5::NORMALIZE_11 data too large\n");
}
#else
#define set_SE_PROG_STREAM_CNTL_5_data_type_10(reg, data_type_10) (reg)->bitfields.DATA_TYPE_10 = data_type_10
#define set_SE_PROG_STREAM_CNTL_5_skip_dwords_10(reg, skip_dwords_10) (reg)->bitfields.SKIP_DWORDS_10 = skip_dwords_10
#define set_SE_PROG_STREAM_CNTL_5_dst_vec_loc_10(reg, dst_vec_loc_10) (reg)->bitfields.DST_VEC_LOC_10 = dst_vec_loc_10
#define set_SE_PROG_STREAM_CNTL_5_last_vec_10(reg, last_vec_10) (reg)->bitfields.LAST_VEC_10 = last_vec_10
#define set_SE_PROG_STREAM_CNTL_5_signed_10(reg, signed_10) (reg)->bitfields.SIGNED_10 = signed_10
#define set_SE_PROG_STREAM_CNTL_5_normalize_10(reg, normalize_10) (reg)->bitfields.NORMALIZE_10 = normalize_10
#define set_SE_PROG_STREAM_CNTL_5_data_type_11(reg, data_type_11) (reg)->bitfields.DATA_TYPE_11 = data_type_11
#define set_SE_PROG_STREAM_CNTL_5_skip_dwords_11(reg, skip_dwords_11) (reg)->bitfields.SKIP_DWORDS_11 = skip_dwords_11
#define set_SE_PROG_STREAM_CNTL_5_dst_vec_loc_11(reg, dst_vec_loc_11) (reg)->bitfields.DST_VEC_LOC_11 = dst_vec_loc_11
#define set_SE_PROG_STREAM_CNTL_5_last_vec_11(reg, last_vec_11) (reg)->bitfields.LAST_VEC_11 = last_vec_11
#define set_SE_PROG_STREAM_CNTL_5_signed_11(reg, signed_11) (reg)->bitfields.SIGNED_11 = signed_11
#define set_SE_PROG_STREAM_CNTL_5_normalize_11(reg, normalize_11) (reg)->bitfields.NORMALIZE_11 = normalize_11

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PROG_STREAM_CNTL_6 regSE_PROG_STREAM_CNTL_6;

#ifdef DEBUG
__inline void set_SE_PROG_STREAM_CNTL_6_data_type_12(regSE_PROG_STREAM_CNTL_6 *reg, unsigned int data_type_12)
{
  reg->bitfields.DATA_TYPE_12 = data_type_12;
  if (reg->bitfields.DATA_TYPE_12 != data_type_12) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_6::DATA_TYPE_12 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_6_skip_dwords_12(regSE_PROG_STREAM_CNTL_6 *reg, unsigned int skip_dwords_12)
{
  reg->bitfields.SKIP_DWORDS_12 = skip_dwords_12;
  if (reg->bitfields.SKIP_DWORDS_12 != skip_dwords_12) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_6::SKIP_DWORDS_12 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_6_dst_vec_loc_12(regSE_PROG_STREAM_CNTL_6 *reg, unsigned int dst_vec_loc_12)
{
  reg->bitfields.DST_VEC_LOC_12 = dst_vec_loc_12;
  if (reg->bitfields.DST_VEC_LOC_12 != dst_vec_loc_12) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_6::DST_VEC_LOC_12 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_6_last_vec_12(regSE_PROG_STREAM_CNTL_6 *reg, unsigned int last_vec_12)
{
  reg->bitfields.LAST_VEC_12 = last_vec_12;
  if (reg->bitfields.LAST_VEC_12 != last_vec_12) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_6::LAST_VEC_12 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_6_signed_12(regSE_PROG_STREAM_CNTL_6 *reg, unsigned int signed_12)
{
  reg->bitfields.SIGNED_12 = signed_12;
  if (reg->bitfields.SIGNED_12 != signed_12) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_6::SIGNED_12 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_6_normalize_12(regSE_PROG_STREAM_CNTL_6 *reg, unsigned int normalize_12)
{
  reg->bitfields.NORMALIZE_12 = normalize_12;
  if (reg->bitfields.NORMALIZE_12 != normalize_12) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_6::NORMALIZE_12 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_6_data_type_13(regSE_PROG_STREAM_CNTL_6 *reg, unsigned int data_type_13)
{
  reg->bitfields.DATA_TYPE_13 = data_type_13;
  if (reg->bitfields.DATA_TYPE_13 != data_type_13) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_6::DATA_TYPE_13 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_6_skip_dwords_13(regSE_PROG_STREAM_CNTL_6 *reg, unsigned int skip_dwords_13)
{
  reg->bitfields.SKIP_DWORDS_13 = skip_dwords_13;
  if (reg->bitfields.SKIP_DWORDS_13 != skip_dwords_13) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_6::SKIP_DWORDS_13 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_6_dst_vec_loc_13(regSE_PROG_STREAM_CNTL_6 *reg, unsigned int dst_vec_loc_13)
{
  reg->bitfields.DST_VEC_LOC_13 = dst_vec_loc_13;
  if (reg->bitfields.DST_VEC_LOC_13 != dst_vec_loc_13) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_6::DST_VEC_LOC_13 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_6_last_vec_13(regSE_PROG_STREAM_CNTL_6 *reg, unsigned int last_vec_13)
{
  reg->bitfields.LAST_VEC_13 = last_vec_13;
  if (reg->bitfields.LAST_VEC_13 != last_vec_13) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_6::LAST_VEC_13 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_6_signed_13(regSE_PROG_STREAM_CNTL_6 *reg, unsigned int signed_13)
{
  reg->bitfields.SIGNED_13 = signed_13;
  if (reg->bitfields.SIGNED_13 != signed_13) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_6::SIGNED_13 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_6_normalize_13(regSE_PROG_STREAM_CNTL_6 *reg, unsigned int normalize_13)
{
  reg->bitfields.NORMALIZE_13 = normalize_13;
  if (reg->bitfields.NORMALIZE_13 != normalize_13) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_6::NORMALIZE_13 data too large\n");
}
#else
#define set_SE_PROG_STREAM_CNTL_6_data_type_12(reg, data_type_12) (reg)->bitfields.DATA_TYPE_12 = data_type_12
#define set_SE_PROG_STREAM_CNTL_6_skip_dwords_12(reg, skip_dwords_12) (reg)->bitfields.SKIP_DWORDS_12 = skip_dwords_12
#define set_SE_PROG_STREAM_CNTL_6_dst_vec_loc_12(reg, dst_vec_loc_12) (reg)->bitfields.DST_VEC_LOC_12 = dst_vec_loc_12
#define set_SE_PROG_STREAM_CNTL_6_last_vec_12(reg, last_vec_12) (reg)->bitfields.LAST_VEC_12 = last_vec_12
#define set_SE_PROG_STREAM_CNTL_6_signed_12(reg, signed_12) (reg)->bitfields.SIGNED_12 = signed_12
#define set_SE_PROG_STREAM_CNTL_6_normalize_12(reg, normalize_12) (reg)->bitfields.NORMALIZE_12 = normalize_12
#define set_SE_PROG_STREAM_CNTL_6_data_type_13(reg, data_type_13) (reg)->bitfields.DATA_TYPE_13 = data_type_13
#define set_SE_PROG_STREAM_CNTL_6_skip_dwords_13(reg, skip_dwords_13) (reg)->bitfields.SKIP_DWORDS_13 = skip_dwords_13
#define set_SE_PROG_STREAM_CNTL_6_dst_vec_loc_13(reg, dst_vec_loc_13) (reg)->bitfields.DST_VEC_LOC_13 = dst_vec_loc_13
#define set_SE_PROG_STREAM_CNTL_6_last_vec_13(reg, last_vec_13) (reg)->bitfields.LAST_VEC_13 = last_vec_13
#define set_SE_PROG_STREAM_CNTL_6_signed_13(reg, signed_13) (reg)->bitfields.SIGNED_13 = signed_13
#define set_SE_PROG_STREAM_CNTL_6_normalize_13(reg, normalize_13) (reg)->bitfields.NORMALIZE_13 = normalize_13

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PROG_STREAM_CNTL_7 regSE_PROG_STREAM_CNTL_7;

#ifdef DEBUG
__inline void set_SE_PROG_STREAM_CNTL_7_data_type_14(regSE_PROG_STREAM_CNTL_7 *reg, unsigned int data_type_14)
{
  reg->bitfields.DATA_TYPE_14 = data_type_14;
  if (reg->bitfields.DATA_TYPE_14 != data_type_14) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_7::DATA_TYPE_14 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_7_skip_dwords_14(regSE_PROG_STREAM_CNTL_7 *reg, unsigned int skip_dwords_14)
{
  reg->bitfields.SKIP_DWORDS_14 = skip_dwords_14;
  if (reg->bitfields.SKIP_DWORDS_14 != skip_dwords_14) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_7::SKIP_DWORDS_14 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_7_dst_vec_loc_14(regSE_PROG_STREAM_CNTL_7 *reg, unsigned int dst_vec_loc_14)
{
  reg->bitfields.DST_VEC_LOC_14 = dst_vec_loc_14;
  if (reg->bitfields.DST_VEC_LOC_14 != dst_vec_loc_14) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_7::DST_VEC_LOC_14 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_7_last_vec_14(regSE_PROG_STREAM_CNTL_7 *reg, unsigned int last_vec_14)
{
  reg->bitfields.LAST_VEC_14 = last_vec_14;
  if (reg->bitfields.LAST_VEC_14 != last_vec_14) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_7::LAST_VEC_14 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_7_signed_14(regSE_PROG_STREAM_CNTL_7 *reg, unsigned int signed_14)
{
  reg->bitfields.SIGNED_14 = signed_14;
  if (reg->bitfields.SIGNED_14 != signed_14) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_7::SIGNED_14 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_7_normalize_14(regSE_PROG_STREAM_CNTL_7 *reg, unsigned int normalize_14)
{
  reg->bitfields.NORMALIZE_14 = normalize_14;
  if (reg->bitfields.NORMALIZE_14 != normalize_14) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_7::NORMALIZE_14 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_7_data_type_15(regSE_PROG_STREAM_CNTL_7 *reg, unsigned int data_type_15)
{
  reg->bitfields.DATA_TYPE_15 = data_type_15;
  if (reg->bitfields.DATA_TYPE_15 != data_type_15) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_7::DATA_TYPE_15 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_7_skip_dwords_15(regSE_PROG_STREAM_CNTL_7 *reg, unsigned int skip_dwords_15)
{
  reg->bitfields.SKIP_DWORDS_15 = skip_dwords_15;
  if (reg->bitfields.SKIP_DWORDS_15 != skip_dwords_15) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_7::SKIP_DWORDS_15 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_7_dst_vec_loc_15(regSE_PROG_STREAM_CNTL_7 *reg, unsigned int dst_vec_loc_15)
{
  reg->bitfields.DST_VEC_LOC_15 = dst_vec_loc_15;
  if (reg->bitfields.DST_VEC_LOC_15 != dst_vec_loc_15) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_7::DST_VEC_LOC_15 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_7_last_vec_15(regSE_PROG_STREAM_CNTL_7 *reg, unsigned int last_vec_15)
{
  reg->bitfields.LAST_VEC_15 = last_vec_15;
  if (reg->bitfields.LAST_VEC_15 != last_vec_15) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_7::LAST_VEC_15 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_7_signed_15(regSE_PROG_STREAM_CNTL_7 *reg, unsigned int signed_15)
{
  reg->bitfields.SIGNED_15 = signed_15;
  if (reg->bitfields.SIGNED_15 != signed_15) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_7::SIGNED_15 data too large\n");
}
__inline void set_SE_PROG_STREAM_CNTL_7_normalize_15(regSE_PROG_STREAM_CNTL_7 *reg, unsigned int normalize_15)
{
  reg->bitfields.NORMALIZE_15 = normalize_15;
  if (reg->bitfields.NORMALIZE_15 != normalize_15) HSLDPF(E_ERROR_MESSAGE,"SE_PROG_STREAM_CNTL_7::NORMALIZE_15 data too large\n");
}
#else
#define set_SE_PROG_STREAM_CNTL_7_data_type_14(reg, data_type_14) (reg)->bitfields.DATA_TYPE_14 = data_type_14
#define set_SE_PROG_STREAM_CNTL_7_skip_dwords_14(reg, skip_dwords_14) (reg)->bitfields.SKIP_DWORDS_14 = skip_dwords_14
#define set_SE_PROG_STREAM_CNTL_7_dst_vec_loc_14(reg, dst_vec_loc_14) (reg)->bitfields.DST_VEC_LOC_14 = dst_vec_loc_14
#define set_SE_PROG_STREAM_CNTL_7_last_vec_14(reg, last_vec_14) (reg)->bitfields.LAST_VEC_14 = last_vec_14
#define set_SE_PROG_STREAM_CNTL_7_signed_14(reg, signed_14) (reg)->bitfields.SIGNED_14 = signed_14
#define set_SE_PROG_STREAM_CNTL_7_normalize_14(reg, normalize_14) (reg)->bitfields.NORMALIZE_14 = normalize_14
#define set_SE_PROG_STREAM_CNTL_7_data_type_15(reg, data_type_15) (reg)->bitfields.DATA_TYPE_15 = data_type_15
#define set_SE_PROG_STREAM_CNTL_7_skip_dwords_15(reg, skip_dwords_15) (reg)->bitfields.SKIP_DWORDS_15 = skip_dwords_15
#define set_SE_PROG_STREAM_CNTL_7_dst_vec_loc_15(reg, dst_vec_loc_15) (reg)->bitfields.DST_VEC_LOC_15 = dst_vec_loc_15
#define set_SE_PROG_STREAM_CNTL_7_last_vec_15(reg, last_vec_15) (reg)->bitfields.LAST_VEC_15 = last_vec_15
#define set_SE_PROG_STREAM_CNTL_7_signed_15(reg, signed_15) (reg)->bitfields.SIGNED_15 = signed_15
#define set_SE_PROG_STREAM_CNTL_7_normalize_15(reg, normalize_15) (reg)->bitfields.NORMALIZE_15 = normalize_15

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_STATE_CNTL regSE_VTX_STATE_CNTL;

#ifdef DEBUG
__inline void set_SE_VTX_STATE_CNTL_color_0_assembly_cntl(regSE_VTX_STATE_CNTL *reg, unsigned int color_0_assembly_cntl)
{
  reg->bitfields.COLOR_0_ASSEMBLY_CNTL = color_0_assembly_cntl;
  if (reg->bitfields.COLOR_0_ASSEMBLY_CNTL != color_0_assembly_cntl) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_CNTL::COLOR_0_ASSEMBLY_CNTL data too large\n");
}
__inline void set_SE_VTX_STATE_CNTL_color_1_assembly_cntl(regSE_VTX_STATE_CNTL *reg, unsigned int color_1_assembly_cntl)
{
  reg->bitfields.COLOR_1_ASSEMBLY_CNTL = color_1_assembly_cntl;
  if (reg->bitfields.COLOR_1_ASSEMBLY_CNTL != color_1_assembly_cntl) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_CNTL::COLOR_1_ASSEMBLY_CNTL data too large\n");
}
__inline void set_SE_VTX_STATE_CNTL_color_2_assembly_cntl(regSE_VTX_STATE_CNTL *reg, unsigned int color_2_assembly_cntl)
{
  reg->bitfields.COLOR_2_ASSEMBLY_CNTL = color_2_assembly_cntl;
  if (reg->bitfields.COLOR_2_ASSEMBLY_CNTL != color_2_assembly_cntl) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_CNTL::COLOR_2_ASSEMBLY_CNTL data too large\n");
}
__inline void set_SE_VTX_STATE_CNTL_color_3_assembly_cntl(regSE_VTX_STATE_CNTL *reg, unsigned int color_3_assembly_cntl)
{
  reg->bitfields.COLOR_3_ASSEMBLY_CNTL = color_3_assembly_cntl;
  if (reg->bitfields.COLOR_3_ASSEMBLY_CNTL != color_3_assembly_cntl) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_CNTL::COLOR_3_ASSEMBLY_CNTL data too large\n");
}
__inline void set_SE_VTX_STATE_CNTL_color_4_assembly_cntl(regSE_VTX_STATE_CNTL *reg, unsigned int color_4_assembly_cntl)
{
  reg->bitfields.COLOR_4_ASSEMBLY_CNTL = color_4_assembly_cntl;
  if (reg->bitfields.COLOR_4_ASSEMBLY_CNTL != color_4_assembly_cntl) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_CNTL::COLOR_4_ASSEMBLY_CNTL data too large\n");
}
__inline void set_SE_VTX_STATE_CNTL_color_5_assembly_cntl(regSE_VTX_STATE_CNTL *reg, unsigned int color_5_assembly_cntl)
{
  reg->bitfields.COLOR_5_ASSEMBLY_CNTL = color_5_assembly_cntl;
  if (reg->bitfields.COLOR_5_ASSEMBLY_CNTL != color_5_assembly_cntl) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_CNTL::COLOR_5_ASSEMBLY_CNTL data too large\n");
}
__inline void set_SE_VTX_STATE_CNTL_color_6_assembly_cntl(regSE_VTX_STATE_CNTL *reg, unsigned int color_6_assembly_cntl)
{
  reg->bitfields.COLOR_6_ASSEMBLY_CNTL = color_6_assembly_cntl;
  if (reg->bitfields.COLOR_6_ASSEMBLY_CNTL != color_6_assembly_cntl) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_CNTL::COLOR_6_ASSEMBLY_CNTL data too large\n");
}
__inline void set_SE_VTX_STATE_CNTL_color_7_assembly_cntl(regSE_VTX_STATE_CNTL *reg, unsigned int color_7_assembly_cntl)
{
  reg->bitfields.COLOR_7_ASSEMBLY_CNTL = color_7_assembly_cntl;
  if (reg->bitfields.COLOR_7_ASSEMBLY_CNTL != color_7_assembly_cntl) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_CNTL::COLOR_7_ASSEMBLY_CNTL data too large\n");
}
__inline void set_SE_VTX_STATE_CNTL_update_user_color_0_ena(regSE_VTX_STATE_CNTL *reg, unsigned int update_user_color_0_ena)
{
  reg->bitfields.UPDATE_USER_COLOR_0_ENA = update_user_color_0_ena;
  if (reg->bitfields.UPDATE_USER_COLOR_0_ENA != update_user_color_0_ena) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_CNTL::UPDATE_USER_COLOR_0_ENA data too large\n");
}
__inline void set_SE_VTX_STATE_CNTL_update_user_color_1_ena(regSE_VTX_STATE_CNTL *reg, unsigned int update_user_color_1_ena)
{
  reg->bitfields.UPDATE_USER_COLOR_1_ENA = update_user_color_1_ena;
  if (reg->bitfields.UPDATE_USER_COLOR_1_ENA != update_user_color_1_ena) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_CNTL::UPDATE_USER_COLOR_1_ENA data too large\n");
}
__inline void set_SE_VTX_STATE_CNTL_use_addr_ind_tbl(regSE_VTX_STATE_CNTL *reg, unsigned int use_addr_ind_tbl)
{
  reg->bitfields.USE_ADDR_IND_TBL = use_addr_ind_tbl;
  if (reg->bitfields.USE_ADDR_IND_TBL != use_addr_ind_tbl) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_CNTL::USE_ADDR_IND_TBL data too large\n");
}
#else
#define set_SE_VTX_STATE_CNTL_color_0_assembly_cntl(reg, color_0_assembly_cntl) (reg)->bitfields.COLOR_0_ASSEMBLY_CNTL = color_0_assembly_cntl
#define set_SE_VTX_STATE_CNTL_color_1_assembly_cntl(reg, color_1_assembly_cntl) (reg)->bitfields.COLOR_1_ASSEMBLY_CNTL = color_1_assembly_cntl
#define set_SE_VTX_STATE_CNTL_color_2_assembly_cntl(reg, color_2_assembly_cntl) (reg)->bitfields.COLOR_2_ASSEMBLY_CNTL = color_2_assembly_cntl
#define set_SE_VTX_STATE_CNTL_color_3_assembly_cntl(reg, color_3_assembly_cntl) (reg)->bitfields.COLOR_3_ASSEMBLY_CNTL = color_3_assembly_cntl
#define set_SE_VTX_STATE_CNTL_color_4_assembly_cntl(reg, color_4_assembly_cntl) (reg)->bitfields.COLOR_4_ASSEMBLY_CNTL = color_4_assembly_cntl
#define set_SE_VTX_STATE_CNTL_color_5_assembly_cntl(reg, color_5_assembly_cntl) (reg)->bitfields.COLOR_5_ASSEMBLY_CNTL = color_5_assembly_cntl
#define set_SE_VTX_STATE_CNTL_color_6_assembly_cntl(reg, color_6_assembly_cntl) (reg)->bitfields.COLOR_6_ASSEMBLY_CNTL = color_6_assembly_cntl
#define set_SE_VTX_STATE_CNTL_color_7_assembly_cntl(reg, color_7_assembly_cntl) (reg)->bitfields.COLOR_7_ASSEMBLY_CNTL = color_7_assembly_cntl
#define set_SE_VTX_STATE_CNTL_update_user_color_0_ena(reg, update_user_color_0_ena) (reg)->bitfields.UPDATE_USER_COLOR_0_ENA = update_user_color_0_ena
#define set_SE_VTX_STATE_CNTL_update_user_color_1_ena(reg, update_user_color_1_ena) (reg)->bitfields.UPDATE_USER_COLOR_1_ENA = update_user_color_1_ena
#define set_SE_VTX_STATE_CNTL_use_addr_ind_tbl(reg, use_addr_ind_tbl) (reg)->bitfields.USE_ADDR_IND_TBL = use_addr_ind_tbl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_STATE_IND_REG_0 regSE_VTX_STATE_IND_REG_0;

#ifdef DEBUG
__inline void set_SE_VTX_STATE_IND_REG_0_addr_0(regSE_VTX_STATE_IND_REG_0 *reg, unsigned int addr_0)
{
  reg->bitfields.ADDR_0 = addr_0;
  if (reg->bitfields.ADDR_0 != addr_0) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_0::ADDR_0 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_0_addr_1(regSE_VTX_STATE_IND_REG_0 *reg, unsigned int addr_1)
{
  reg->bitfields.ADDR_1 = addr_1;
  if (reg->bitfields.ADDR_1 != addr_1) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_0::ADDR_1 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_0_addr_2(regSE_VTX_STATE_IND_REG_0 *reg, unsigned int addr_2)
{
  reg->bitfields.ADDR_2 = addr_2;
  if (reg->bitfields.ADDR_2 != addr_2) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_0::ADDR_2 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_0_addr_3(regSE_VTX_STATE_IND_REG_0 *reg, unsigned int addr_3)
{
  reg->bitfields.ADDR_3 = addr_3;
  if (reg->bitfields.ADDR_3 != addr_3) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_0::ADDR_3 data too large\n");
}
#else
#define set_SE_VTX_STATE_IND_REG_0_addr_0(reg, addr_0) (reg)->bitfields.ADDR_0 = addr_0
#define set_SE_VTX_STATE_IND_REG_0_addr_1(reg, addr_1) (reg)->bitfields.ADDR_1 = addr_1
#define set_SE_VTX_STATE_IND_REG_0_addr_2(reg, addr_2) (reg)->bitfields.ADDR_2 = addr_2
#define set_SE_VTX_STATE_IND_REG_0_addr_3(reg, addr_3) (reg)->bitfields.ADDR_3 = addr_3

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_STATE_IND_REG_1 regSE_VTX_STATE_IND_REG_1;

#ifdef DEBUG
__inline void set_SE_VTX_STATE_IND_REG_1_addr_4(regSE_VTX_STATE_IND_REG_1 *reg, unsigned int addr_4)
{
  reg->bitfields.ADDR_4 = addr_4;
  if (reg->bitfields.ADDR_4 != addr_4) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_1::ADDR_4 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_1_addr_5(regSE_VTX_STATE_IND_REG_1 *reg, unsigned int addr_5)
{
  reg->bitfields.ADDR_5 = addr_5;
  if (reg->bitfields.ADDR_5 != addr_5) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_1::ADDR_5 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_1_addr_6(regSE_VTX_STATE_IND_REG_1 *reg, unsigned int addr_6)
{
  reg->bitfields.ADDR_6 = addr_6;
  if (reg->bitfields.ADDR_6 != addr_6) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_1::ADDR_6 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_1_addr_7(regSE_VTX_STATE_IND_REG_1 *reg, unsigned int addr_7)
{
  reg->bitfields.ADDR_7 = addr_7;
  if (reg->bitfields.ADDR_7 != addr_7) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_1::ADDR_7 data too large\n");
}
#else
#define set_SE_VTX_STATE_IND_REG_1_addr_4(reg, addr_4) (reg)->bitfields.ADDR_4 = addr_4
#define set_SE_VTX_STATE_IND_REG_1_addr_5(reg, addr_5) (reg)->bitfields.ADDR_5 = addr_5
#define set_SE_VTX_STATE_IND_REG_1_addr_6(reg, addr_6) (reg)->bitfields.ADDR_6 = addr_6
#define set_SE_VTX_STATE_IND_REG_1_addr_7(reg, addr_7) (reg)->bitfields.ADDR_7 = addr_7

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_STATE_IND_REG_2 regSE_VTX_STATE_IND_REG_2;

#ifdef DEBUG
__inline void set_SE_VTX_STATE_IND_REG_2_addr_8(regSE_VTX_STATE_IND_REG_2 *reg, unsigned int addr_8)
{
  reg->bitfields.ADDR_8 = addr_8;
  if (reg->bitfields.ADDR_8 != addr_8) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_2::ADDR_8 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_2_addr_9(regSE_VTX_STATE_IND_REG_2 *reg, unsigned int addr_9)
{
  reg->bitfields.ADDR_9 = addr_9;
  if (reg->bitfields.ADDR_9 != addr_9) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_2::ADDR_9 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_2_addr_10(regSE_VTX_STATE_IND_REG_2 *reg, unsigned int addr_10)
{
  reg->bitfields.ADDR_10 = addr_10;
  if (reg->bitfields.ADDR_10 != addr_10) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_2::ADDR_10 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_2_addr_11(regSE_VTX_STATE_IND_REG_2 *reg, unsigned int addr_11)
{
  reg->bitfields.ADDR_11 = addr_11;
  if (reg->bitfields.ADDR_11 != addr_11) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_2::ADDR_11 data too large\n");
}
#else
#define set_SE_VTX_STATE_IND_REG_2_addr_8(reg, addr_8) (reg)->bitfields.ADDR_8 = addr_8
#define set_SE_VTX_STATE_IND_REG_2_addr_9(reg, addr_9) (reg)->bitfields.ADDR_9 = addr_9
#define set_SE_VTX_STATE_IND_REG_2_addr_10(reg, addr_10) (reg)->bitfields.ADDR_10 = addr_10
#define set_SE_VTX_STATE_IND_REG_2_addr_11(reg, addr_11) (reg)->bitfields.ADDR_11 = addr_11

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_STATE_IND_REG_3 regSE_VTX_STATE_IND_REG_3;

#ifdef DEBUG
__inline void set_SE_VTX_STATE_IND_REG_3_addr_12(regSE_VTX_STATE_IND_REG_3 *reg, unsigned int addr_12)
{
  reg->bitfields.ADDR_12 = addr_12;
  if (reg->bitfields.ADDR_12 != addr_12) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_3::ADDR_12 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_3_addr_13(regSE_VTX_STATE_IND_REG_3 *reg, unsigned int addr_13)
{
  reg->bitfields.ADDR_13 = addr_13;
  if (reg->bitfields.ADDR_13 != addr_13) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_3::ADDR_13 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_3_addr_14(regSE_VTX_STATE_IND_REG_3 *reg, unsigned int addr_14)
{
  reg->bitfields.ADDR_14 = addr_14;
  if (reg->bitfields.ADDR_14 != addr_14) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_3::ADDR_14 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_3_addr_15(regSE_VTX_STATE_IND_REG_3 *reg, unsigned int addr_15)
{
  reg->bitfields.ADDR_15 = addr_15;
  if (reg->bitfields.ADDR_15 != addr_15) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_3::ADDR_15 data too large\n");
}
#else
#define set_SE_VTX_STATE_IND_REG_3_addr_12(reg, addr_12) (reg)->bitfields.ADDR_12 = addr_12
#define set_SE_VTX_STATE_IND_REG_3_addr_13(reg, addr_13) (reg)->bitfields.ADDR_13 = addr_13
#define set_SE_VTX_STATE_IND_REG_3_addr_14(reg, addr_14) (reg)->bitfields.ADDR_14 = addr_14
#define set_SE_VTX_STATE_IND_REG_3_addr_15(reg, addr_15) (reg)->bitfields.ADDR_15 = addr_15

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_STATE_IND_REG_4 regSE_VTX_STATE_IND_REG_4;

#ifdef DEBUG
__inline void set_SE_VTX_STATE_IND_REG_4_addr_16(regSE_VTX_STATE_IND_REG_4 *reg, unsigned int addr_16)
{
  reg->bitfields.ADDR_16 = addr_16;
  if (reg->bitfields.ADDR_16 != addr_16) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_4::ADDR_16 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_4_addr_17(regSE_VTX_STATE_IND_REG_4 *reg, unsigned int addr_17)
{
  reg->bitfields.ADDR_17 = addr_17;
  if (reg->bitfields.ADDR_17 != addr_17) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_4::ADDR_17 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_4_addr_18(regSE_VTX_STATE_IND_REG_4 *reg, unsigned int addr_18)
{
  reg->bitfields.ADDR_18 = addr_18;
  if (reg->bitfields.ADDR_18 != addr_18) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_4::ADDR_18 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_4_addr_19(regSE_VTX_STATE_IND_REG_4 *reg, unsigned int addr_19)
{
  reg->bitfields.ADDR_19 = addr_19;
  if (reg->bitfields.ADDR_19 != addr_19) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_4::ADDR_19 data too large\n");
}
#else
#define set_SE_VTX_STATE_IND_REG_4_addr_16(reg, addr_16) (reg)->bitfields.ADDR_16 = addr_16
#define set_SE_VTX_STATE_IND_REG_4_addr_17(reg, addr_17) (reg)->bitfields.ADDR_17 = addr_17
#define set_SE_VTX_STATE_IND_REG_4_addr_18(reg, addr_18) (reg)->bitfields.ADDR_18 = addr_18
#define set_SE_VTX_STATE_IND_REG_4_addr_19(reg, addr_19) (reg)->bitfields.ADDR_19 = addr_19

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_STATE_IND_REG_5 regSE_VTX_STATE_IND_REG_5;

#ifdef DEBUG
__inline void set_SE_VTX_STATE_IND_REG_5_addr_20(regSE_VTX_STATE_IND_REG_5 *reg, unsigned int addr_20)
{
  reg->bitfields.ADDR_20 = addr_20;
  if (reg->bitfields.ADDR_20 != addr_20) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_5::ADDR_20 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_5_addr_21(regSE_VTX_STATE_IND_REG_5 *reg, unsigned int addr_21)
{
  reg->bitfields.ADDR_21 = addr_21;
  if (reg->bitfields.ADDR_21 != addr_21) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_5::ADDR_21 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_5_addr_22(regSE_VTX_STATE_IND_REG_5 *reg, unsigned int addr_22)
{
  reg->bitfields.ADDR_22 = addr_22;
  if (reg->bitfields.ADDR_22 != addr_22) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_5::ADDR_22 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_5_addr_23(regSE_VTX_STATE_IND_REG_5 *reg, unsigned int addr_23)
{
  reg->bitfields.ADDR_23 = addr_23;
  if (reg->bitfields.ADDR_23 != addr_23) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_5::ADDR_23 data too large\n");
}
#else
#define set_SE_VTX_STATE_IND_REG_5_addr_20(reg, addr_20) (reg)->bitfields.ADDR_20 = addr_20
#define set_SE_VTX_STATE_IND_REG_5_addr_21(reg, addr_21) (reg)->bitfields.ADDR_21 = addr_21
#define set_SE_VTX_STATE_IND_REG_5_addr_22(reg, addr_22) (reg)->bitfields.ADDR_22 = addr_22
#define set_SE_VTX_STATE_IND_REG_5_addr_23(reg, addr_23) (reg)->bitfields.ADDR_23 = addr_23

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_STATE_IND_REG_6 regSE_VTX_STATE_IND_REG_6;

#ifdef DEBUG
__inline void set_SE_VTX_STATE_IND_REG_6_addr_24(regSE_VTX_STATE_IND_REG_6 *reg, unsigned int addr_24)
{
  reg->bitfields.ADDR_24 = addr_24;
  if (reg->bitfields.ADDR_24 != addr_24) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_6::ADDR_24 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_6_addr_25(regSE_VTX_STATE_IND_REG_6 *reg, unsigned int addr_25)
{
  reg->bitfields.ADDR_25 = addr_25;
  if (reg->bitfields.ADDR_25 != addr_25) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_6::ADDR_25 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_6_addr_26(regSE_VTX_STATE_IND_REG_6 *reg, unsigned int addr_26)
{
  reg->bitfields.ADDR_26 = addr_26;
  if (reg->bitfields.ADDR_26 != addr_26) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_6::ADDR_26 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_6_addr_27(regSE_VTX_STATE_IND_REG_6 *reg, unsigned int addr_27)
{
  reg->bitfields.ADDR_27 = addr_27;
  if (reg->bitfields.ADDR_27 != addr_27) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_6::ADDR_27 data too large\n");
}
#else
#define set_SE_VTX_STATE_IND_REG_6_addr_24(reg, addr_24) (reg)->bitfields.ADDR_24 = addr_24
#define set_SE_VTX_STATE_IND_REG_6_addr_25(reg, addr_25) (reg)->bitfields.ADDR_25 = addr_25
#define set_SE_VTX_STATE_IND_REG_6_addr_26(reg, addr_26) (reg)->bitfields.ADDR_26 = addr_26
#define set_SE_VTX_STATE_IND_REG_6_addr_27(reg, addr_27) (reg)->bitfields.ADDR_27 = addr_27

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_STATE_IND_REG_7 regSE_VTX_STATE_IND_REG_7;

#ifdef DEBUG
__inline void set_SE_VTX_STATE_IND_REG_7_addr_28(regSE_VTX_STATE_IND_REG_7 *reg, unsigned int addr_28)
{
  reg->bitfields.ADDR_28 = addr_28;
  if (reg->bitfields.ADDR_28 != addr_28) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_7::ADDR_28 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_7_addr_29(regSE_VTX_STATE_IND_REG_7 *reg, unsigned int addr_29)
{
  reg->bitfields.ADDR_29 = addr_29;
  if (reg->bitfields.ADDR_29 != addr_29) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_7::ADDR_29 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_7_addr_30(regSE_VTX_STATE_IND_REG_7 *reg, unsigned int addr_30)
{
  reg->bitfields.ADDR_30 = addr_30;
  if (reg->bitfields.ADDR_30 != addr_30) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_7::ADDR_30 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_7_addr_31(regSE_VTX_STATE_IND_REG_7 *reg, unsigned int addr_31)
{
  reg->bitfields.ADDR_31 = addr_31;
  if (reg->bitfields.ADDR_31 != addr_31) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_7::ADDR_31 data too large\n");
}
#else
#define set_SE_VTX_STATE_IND_REG_7_addr_28(reg, addr_28) (reg)->bitfields.ADDR_28 = addr_28
#define set_SE_VTX_STATE_IND_REG_7_addr_29(reg, addr_29) (reg)->bitfields.ADDR_29 = addr_29
#define set_SE_VTX_STATE_IND_REG_7_addr_30(reg, addr_30) (reg)->bitfields.ADDR_30 = addr_30
#define set_SE_VTX_STATE_IND_REG_7_addr_31(reg, addr_31) (reg)->bitfields.ADDR_31 = addr_31

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_STATE_IND_REG_8 regSE_VTX_STATE_IND_REG_8;

#ifdef DEBUG
__inline void set_SE_VTX_STATE_IND_REG_8_addr_32(regSE_VTX_STATE_IND_REG_8 *reg, unsigned int addr_32)
{
  reg->bitfields.ADDR_32 = addr_32;
  if (reg->bitfields.ADDR_32 != addr_32) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_8::ADDR_32 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_8_addr_33(regSE_VTX_STATE_IND_REG_8 *reg, unsigned int addr_33)
{
  reg->bitfields.ADDR_33 = addr_33;
  if (reg->bitfields.ADDR_33 != addr_33) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_8::ADDR_33 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_8_addr_34(regSE_VTX_STATE_IND_REG_8 *reg, unsigned int addr_34)
{
  reg->bitfields.ADDR_34 = addr_34;
  if (reg->bitfields.ADDR_34 != addr_34) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_8::ADDR_34 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_8_addr_35(regSE_VTX_STATE_IND_REG_8 *reg, unsigned int addr_35)
{
  reg->bitfields.ADDR_35 = addr_35;
  if (reg->bitfields.ADDR_35 != addr_35) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_8::ADDR_35 data too large\n");
}
#else
#define set_SE_VTX_STATE_IND_REG_8_addr_32(reg, addr_32) (reg)->bitfields.ADDR_32 = addr_32
#define set_SE_VTX_STATE_IND_REG_8_addr_33(reg, addr_33) (reg)->bitfields.ADDR_33 = addr_33
#define set_SE_VTX_STATE_IND_REG_8_addr_34(reg, addr_34) (reg)->bitfields.ADDR_34 = addr_34
#define set_SE_VTX_STATE_IND_REG_8_addr_35(reg, addr_35) (reg)->bitfields.ADDR_35 = addr_35

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_STATE_IND_REG_9 regSE_VTX_STATE_IND_REG_9;

#ifdef DEBUG
__inline void set_SE_VTX_STATE_IND_REG_9_addr_36(regSE_VTX_STATE_IND_REG_9 *reg, unsigned int addr_36)
{
  reg->bitfields.ADDR_36 = addr_36;
  if (reg->bitfields.ADDR_36 != addr_36) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_9::ADDR_36 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_9_addr_37(regSE_VTX_STATE_IND_REG_9 *reg, unsigned int addr_37)
{
  reg->bitfields.ADDR_37 = addr_37;
  if (reg->bitfields.ADDR_37 != addr_37) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_9::ADDR_37 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_9_addr_38(regSE_VTX_STATE_IND_REG_9 *reg, unsigned int addr_38)
{
  reg->bitfields.ADDR_38 = addr_38;
  if (reg->bitfields.ADDR_38 != addr_38) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_9::ADDR_38 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_9_addr_39(regSE_VTX_STATE_IND_REG_9 *reg, unsigned int addr_39)
{
  reg->bitfields.ADDR_39 = addr_39;
  if (reg->bitfields.ADDR_39 != addr_39) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_9::ADDR_39 data too large\n");
}
#else
#define set_SE_VTX_STATE_IND_REG_9_addr_36(reg, addr_36) (reg)->bitfields.ADDR_36 = addr_36
#define set_SE_VTX_STATE_IND_REG_9_addr_37(reg, addr_37) (reg)->bitfields.ADDR_37 = addr_37
#define set_SE_VTX_STATE_IND_REG_9_addr_38(reg, addr_38) (reg)->bitfields.ADDR_38 = addr_38
#define set_SE_VTX_STATE_IND_REG_9_addr_39(reg, addr_39) (reg)->bitfields.ADDR_39 = addr_39

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_STATE_IND_REG_10 regSE_VTX_STATE_IND_REG_10;

#ifdef DEBUG
__inline void set_SE_VTX_STATE_IND_REG_10_addr_40(regSE_VTX_STATE_IND_REG_10 *reg, unsigned int addr_40)
{
  reg->bitfields.ADDR_40 = addr_40;
  if (reg->bitfields.ADDR_40 != addr_40) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_10::ADDR_40 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_10_addr_41(regSE_VTX_STATE_IND_REG_10 *reg, unsigned int addr_41)
{
  reg->bitfields.ADDR_41 = addr_41;
  if (reg->bitfields.ADDR_41 != addr_41) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_10::ADDR_41 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_10_addr_42(regSE_VTX_STATE_IND_REG_10 *reg, unsigned int addr_42)
{
  reg->bitfields.ADDR_42 = addr_42;
  if (reg->bitfields.ADDR_42 != addr_42) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_10::ADDR_42 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_10_addr_43(regSE_VTX_STATE_IND_REG_10 *reg, unsigned int addr_43)
{
  reg->bitfields.ADDR_43 = addr_43;
  if (reg->bitfields.ADDR_43 != addr_43) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_10::ADDR_43 data too large\n");
}
#else
#define set_SE_VTX_STATE_IND_REG_10_addr_40(reg, addr_40) (reg)->bitfields.ADDR_40 = addr_40
#define set_SE_VTX_STATE_IND_REG_10_addr_41(reg, addr_41) (reg)->bitfields.ADDR_41 = addr_41
#define set_SE_VTX_STATE_IND_REG_10_addr_42(reg, addr_42) (reg)->bitfields.ADDR_42 = addr_42
#define set_SE_VTX_STATE_IND_REG_10_addr_43(reg, addr_43) (reg)->bitfields.ADDR_43 = addr_43

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_STATE_IND_REG_11 regSE_VTX_STATE_IND_REG_11;

#ifdef DEBUG
__inline void set_SE_VTX_STATE_IND_REG_11_addr_44(regSE_VTX_STATE_IND_REG_11 *reg, unsigned int addr_44)
{
  reg->bitfields.ADDR_44 = addr_44;
  if (reg->bitfields.ADDR_44 != addr_44) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_11::ADDR_44 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_11_addr_45(regSE_VTX_STATE_IND_REG_11 *reg, unsigned int addr_45)
{
  reg->bitfields.ADDR_45 = addr_45;
  if (reg->bitfields.ADDR_45 != addr_45) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_11::ADDR_45 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_11_addr_46(regSE_VTX_STATE_IND_REG_11 *reg, unsigned int addr_46)
{
  reg->bitfields.ADDR_46 = addr_46;
  if (reg->bitfields.ADDR_46 != addr_46) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_11::ADDR_46 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_11_addr_47(regSE_VTX_STATE_IND_REG_11 *reg, unsigned int addr_47)
{
  reg->bitfields.ADDR_47 = addr_47;
  if (reg->bitfields.ADDR_47 != addr_47) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_11::ADDR_47 data too large\n");
}
#else
#define set_SE_VTX_STATE_IND_REG_11_addr_44(reg, addr_44) (reg)->bitfields.ADDR_44 = addr_44
#define set_SE_VTX_STATE_IND_REG_11_addr_45(reg, addr_45) (reg)->bitfields.ADDR_45 = addr_45
#define set_SE_VTX_STATE_IND_REG_11_addr_46(reg, addr_46) (reg)->bitfields.ADDR_46 = addr_46
#define set_SE_VTX_STATE_IND_REG_11_addr_47(reg, addr_47) (reg)->bitfields.ADDR_47 = addr_47

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_STATE_IND_REG_12 regSE_VTX_STATE_IND_REG_12;

#ifdef DEBUG
__inline void set_SE_VTX_STATE_IND_REG_12_addr_48(regSE_VTX_STATE_IND_REG_12 *reg, unsigned int addr_48)
{
  reg->bitfields.ADDR_48 = addr_48;
  if (reg->bitfields.ADDR_48 != addr_48) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_12::ADDR_48 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_12_addr_49(regSE_VTX_STATE_IND_REG_12 *reg, unsigned int addr_49)
{
  reg->bitfields.ADDR_49 = addr_49;
  if (reg->bitfields.ADDR_49 != addr_49) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_12::ADDR_49 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_12_addr_50(regSE_VTX_STATE_IND_REG_12 *reg, unsigned int addr_50)
{
  reg->bitfields.ADDR_50 = addr_50;
  if (reg->bitfields.ADDR_50 != addr_50) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_12::ADDR_50 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_12_addr_51(regSE_VTX_STATE_IND_REG_12 *reg, unsigned int addr_51)
{
  reg->bitfields.ADDR_51 = addr_51;
  if (reg->bitfields.ADDR_51 != addr_51) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_12::ADDR_51 data too large\n");
}
#else
#define set_SE_VTX_STATE_IND_REG_12_addr_48(reg, addr_48) (reg)->bitfields.ADDR_48 = addr_48
#define set_SE_VTX_STATE_IND_REG_12_addr_49(reg, addr_49) (reg)->bitfields.ADDR_49 = addr_49
#define set_SE_VTX_STATE_IND_REG_12_addr_50(reg, addr_50) (reg)->bitfields.ADDR_50 = addr_50
#define set_SE_VTX_STATE_IND_REG_12_addr_51(reg, addr_51) (reg)->bitfields.ADDR_51 = addr_51

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_STATE_IND_REG_13 regSE_VTX_STATE_IND_REG_13;

#ifdef DEBUG
__inline void set_SE_VTX_STATE_IND_REG_13_addr_52(regSE_VTX_STATE_IND_REG_13 *reg, unsigned int addr_52)
{
  reg->bitfields.ADDR_52 = addr_52;
  if (reg->bitfields.ADDR_52 != addr_52) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_13::ADDR_52 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_13_addr_53(regSE_VTX_STATE_IND_REG_13 *reg, unsigned int addr_53)
{
  reg->bitfields.ADDR_53 = addr_53;
  if (reg->bitfields.ADDR_53 != addr_53) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_13::ADDR_53 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_13_addr_54(regSE_VTX_STATE_IND_REG_13 *reg, unsigned int addr_54)
{
  reg->bitfields.ADDR_54 = addr_54;
  if (reg->bitfields.ADDR_54 != addr_54) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_13::ADDR_54 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_13_addr_55(regSE_VTX_STATE_IND_REG_13 *reg, unsigned int addr_55)
{
  reg->bitfields.ADDR_55 = addr_55;
  if (reg->bitfields.ADDR_55 != addr_55) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_13::ADDR_55 data too large\n");
}
#else
#define set_SE_VTX_STATE_IND_REG_13_addr_52(reg, addr_52) (reg)->bitfields.ADDR_52 = addr_52
#define set_SE_VTX_STATE_IND_REG_13_addr_53(reg, addr_53) (reg)->bitfields.ADDR_53 = addr_53
#define set_SE_VTX_STATE_IND_REG_13_addr_54(reg, addr_54) (reg)->bitfields.ADDR_54 = addr_54
#define set_SE_VTX_STATE_IND_REG_13_addr_55(reg, addr_55) (reg)->bitfields.ADDR_55 = addr_55

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_STATE_IND_REG_14 regSE_VTX_STATE_IND_REG_14;

#ifdef DEBUG
__inline void set_SE_VTX_STATE_IND_REG_14_addr_56(regSE_VTX_STATE_IND_REG_14 *reg, unsigned int addr_56)
{
  reg->bitfields.ADDR_56 = addr_56;
  if (reg->bitfields.ADDR_56 != addr_56) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_14::ADDR_56 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_14_addr_57(regSE_VTX_STATE_IND_REG_14 *reg, unsigned int addr_57)
{
  reg->bitfields.ADDR_57 = addr_57;
  if (reg->bitfields.ADDR_57 != addr_57) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_14::ADDR_57 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_14_addr_58(regSE_VTX_STATE_IND_REG_14 *reg, unsigned int addr_58)
{
  reg->bitfields.ADDR_58 = addr_58;
  if (reg->bitfields.ADDR_58 != addr_58) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_14::ADDR_58 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_14_addr_59(regSE_VTX_STATE_IND_REG_14 *reg, unsigned int addr_59)
{
  reg->bitfields.ADDR_59 = addr_59;
  if (reg->bitfields.ADDR_59 != addr_59) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_14::ADDR_59 data too large\n");
}
#else
#define set_SE_VTX_STATE_IND_REG_14_addr_56(reg, addr_56) (reg)->bitfields.ADDR_56 = addr_56
#define set_SE_VTX_STATE_IND_REG_14_addr_57(reg, addr_57) (reg)->bitfields.ADDR_57 = addr_57
#define set_SE_VTX_STATE_IND_REG_14_addr_58(reg, addr_58) (reg)->bitfields.ADDR_58 = addr_58
#define set_SE_VTX_STATE_IND_REG_14_addr_59(reg, addr_59) (reg)->bitfields.ADDR_59 = addr_59

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_STATE_IND_REG_15 regSE_VTX_STATE_IND_REG_15;

#ifdef DEBUG
__inline void set_SE_VTX_STATE_IND_REG_15_addr_60(regSE_VTX_STATE_IND_REG_15 *reg, unsigned int addr_60)
{
  reg->bitfields.ADDR_60 = addr_60;
  if (reg->bitfields.ADDR_60 != addr_60) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_15::ADDR_60 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_15_addr_61(regSE_VTX_STATE_IND_REG_15 *reg, unsigned int addr_61)
{
  reg->bitfields.ADDR_61 = addr_61;
  if (reg->bitfields.ADDR_61 != addr_61) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_15::ADDR_61 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_15_addr_62(regSE_VTX_STATE_IND_REG_15 *reg, unsigned int addr_62)
{
  reg->bitfields.ADDR_62 = addr_62;
  if (reg->bitfields.ADDR_62 != addr_62) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_15::ADDR_62 data too large\n");
}
__inline void set_SE_VTX_STATE_IND_REG_15_addr_63(regSE_VTX_STATE_IND_REG_15 *reg, unsigned int addr_63)
{
  reg->bitfields.ADDR_63 = addr_63;
  if (reg->bitfields.ADDR_63 != addr_63) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_STATE_IND_REG_15::ADDR_63 data too large\n");
}
#else
#define set_SE_VTX_STATE_IND_REG_15_addr_60(reg, addr_60) (reg)->bitfields.ADDR_60 = addr_60
#define set_SE_VTX_STATE_IND_REG_15_addr_61(reg, addr_61) (reg)->bitfields.ADDR_61 = addr_61
#define set_SE_VTX_STATE_IND_REG_15_addr_62(reg, addr_62) (reg)->bitfields.ADDR_62 = addr_62
#define set_SE_VTX_STATE_IND_REG_15_addr_63(reg, addr_63) (reg)->bitfields.ADDR_63 = addr_63

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_VECTOR_INDX_REG regSE_TCL_VECTOR_INDX_REG;

#ifdef DEBUG
__inline void set_SE_TCL_VECTOR_INDX_REG_octword_offset(regSE_TCL_VECTOR_INDX_REG *reg, unsigned int octword_offset)
{
  reg->bitfields.OCTWORD_OFFSET = octword_offset;
  if (reg->bitfields.OCTWORD_OFFSET != octword_offset) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_VECTOR_INDX_REG::OCTWORD_OFFSET data too large\n");
}
__inline void set_SE_TCL_VECTOR_INDX_REG_octword_stride(regSE_TCL_VECTOR_INDX_REG *reg, unsigned int octword_stride)
{
  reg->bitfields.OCTWORD_STRIDE = octword_stride;
  if (reg->bitfields.OCTWORD_STRIDE != octword_stride) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_VECTOR_INDX_REG::OCTWORD_STRIDE data too large\n");
}
__inline void set_SE_TCL_VECTOR_INDX_REG_dword_count(regSE_TCL_VECTOR_INDX_REG *reg, unsigned int dword_count)
{
  reg->bitfields.DWORD_COUNT = dword_count;
  if (reg->bitfields.DWORD_COUNT != dword_count) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_VECTOR_INDX_REG::DWORD_COUNT data too large\n");
}
#else
#define set_SE_TCL_VECTOR_INDX_REG_octword_offset(reg, octword_offset) (reg)->bitfields.OCTWORD_OFFSET = octword_offset
#define set_SE_TCL_VECTOR_INDX_REG_octword_stride(reg, octword_stride) (reg)->bitfields.OCTWORD_STRIDE = octword_stride
#define set_SE_TCL_VECTOR_INDX_REG_dword_count(reg, dword_count) (reg)->bitfields.DWORD_COUNT = dword_count

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_VECTOR_DATA_REG regSE_TCL_VECTOR_DATA_REG;

#ifdef DEBUG
__inline void set_SE_TCL_VECTOR_DATA_REG_data_register(regSE_TCL_VECTOR_DATA_REG *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_VECTOR_DATA_REG::DATA_REGISTER data too large\n");
}
#else
#define set_SE_TCL_VECTOR_DATA_REG_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_SCALAR_INDX_REG regSE_TCL_SCALAR_INDX_REG;

#ifdef DEBUG
__inline void set_SE_TCL_SCALAR_INDX_REG_dword_offset(regSE_TCL_SCALAR_INDX_REG *reg, unsigned int dword_offset)
{
  reg->bitfields.DWORD_OFFSET = dword_offset;
  if (reg->bitfields.DWORD_OFFSET != dword_offset) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_SCALAR_INDX_REG::DWORD_OFFSET data too large\n");
}
__inline void set_SE_TCL_SCALAR_INDX_REG_dword_stride(regSE_TCL_SCALAR_INDX_REG *reg, unsigned int dword_stride)
{
  reg->bitfields.DWORD_STRIDE = dword_stride;
  if (reg->bitfields.DWORD_STRIDE != dword_stride) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_SCALAR_INDX_REG::DWORD_STRIDE data too large\n");
}
#else
#define set_SE_TCL_SCALAR_INDX_REG_dword_offset(reg, dword_offset) (reg)->bitfields.DWORD_OFFSET = dword_offset
#define set_SE_TCL_SCALAR_INDX_REG_dword_stride(reg, dword_stride) (reg)->bitfields.DWORD_STRIDE = dword_stride

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_SCALAR_DATA_REG regSE_TCL_SCALAR_DATA_REG;

#ifdef DEBUG
__inline void set_SE_TCL_SCALAR_DATA_REG_data_register(regSE_TCL_SCALAR_DATA_REG *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_SCALAR_DATA_REG::DATA_REGISTER data too large\n");
}
#else
#define set_SE_TCL_SCALAR_DATA_REG_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_MATRIX_SEL_0 regSE_TCL_MATRIX_SEL_0;

#ifdef DEBUG
__inline void set_SE_TCL_MATRIX_SEL_0_modelview_mtx_0_sel(regSE_TCL_MATRIX_SEL_0 *reg, unsigned int modelview_mtx_0_sel)
{
  reg->bitfields.MODELVIEW_MTX_0_SEL = modelview_mtx_0_sel;
  if (reg->bitfields.MODELVIEW_MTX_0_SEL != modelview_mtx_0_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_MATRIX_SEL_0::MODELVIEW_MTX_0_SEL data too large\n");
}
__inline void set_SE_TCL_MATRIX_SEL_0_modelview_mtx_1_sel(regSE_TCL_MATRIX_SEL_0 *reg, unsigned int modelview_mtx_1_sel)
{
  reg->bitfields.MODELVIEW_MTX_1_SEL = modelview_mtx_1_sel;
  if (reg->bitfields.MODELVIEW_MTX_1_SEL != modelview_mtx_1_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_MATRIX_SEL_0::MODELVIEW_MTX_1_SEL data too large\n");
}
__inline void set_SE_TCL_MATRIX_SEL_0_modelview_mtx_2_sel(regSE_TCL_MATRIX_SEL_0 *reg, unsigned int modelview_mtx_2_sel)
{
  reg->bitfields.MODELVIEW_MTX_2_SEL = modelview_mtx_2_sel;
  if (reg->bitfields.MODELVIEW_MTX_2_SEL != modelview_mtx_2_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_MATRIX_SEL_0::MODELVIEW_MTX_2_SEL data too large\n");
}
__inline void set_SE_TCL_MATRIX_SEL_0_modelview_mtx_3_sel(regSE_TCL_MATRIX_SEL_0 *reg, unsigned int modelview_mtx_3_sel)
{
  reg->bitfields.MODELVIEW_MTX_3_SEL = modelview_mtx_3_sel;
  if (reg->bitfields.MODELVIEW_MTX_3_SEL != modelview_mtx_3_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_MATRIX_SEL_0::MODELVIEW_MTX_3_SEL data too large\n");
}
#else
#define set_SE_TCL_MATRIX_SEL_0_modelview_mtx_0_sel(reg, modelview_mtx_0_sel) (reg)->bitfields.MODELVIEW_MTX_0_SEL = modelview_mtx_0_sel
#define set_SE_TCL_MATRIX_SEL_0_modelview_mtx_1_sel(reg, modelview_mtx_1_sel) (reg)->bitfields.MODELVIEW_MTX_1_SEL = modelview_mtx_1_sel
#define set_SE_TCL_MATRIX_SEL_0_modelview_mtx_2_sel(reg, modelview_mtx_2_sel) (reg)->bitfields.MODELVIEW_MTX_2_SEL = modelview_mtx_2_sel
#define set_SE_TCL_MATRIX_SEL_0_modelview_mtx_3_sel(reg, modelview_mtx_3_sel) (reg)->bitfields.MODELVIEW_MTX_3_SEL = modelview_mtx_3_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_MATRIX_SEL_1 regSE_TCL_MATRIX_SEL_1;

#ifdef DEBUG
__inline void set_SE_TCL_MATRIX_SEL_1_it_modelview_mtx_0_sel(regSE_TCL_MATRIX_SEL_1 *reg, unsigned int it_modelview_mtx_0_sel)
{
  reg->bitfields.IT_MODELVIEW_MTX_0_SEL = it_modelview_mtx_0_sel;
  if (reg->bitfields.IT_MODELVIEW_MTX_0_SEL != it_modelview_mtx_0_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_MATRIX_SEL_1::IT_MODELVIEW_MTX_0_SEL data too large\n");
}
__inline void set_SE_TCL_MATRIX_SEL_1_it_modelview_mtx_1_sel(regSE_TCL_MATRIX_SEL_1 *reg, unsigned int it_modelview_mtx_1_sel)
{
  reg->bitfields.IT_MODELVIEW_MTX_1_SEL = it_modelview_mtx_1_sel;
  if (reg->bitfields.IT_MODELVIEW_MTX_1_SEL != it_modelview_mtx_1_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_MATRIX_SEL_1::IT_MODELVIEW_MTX_1_SEL data too large\n");
}
__inline void set_SE_TCL_MATRIX_SEL_1_it_modelview_mtx_2_sel(regSE_TCL_MATRIX_SEL_1 *reg, unsigned int it_modelview_mtx_2_sel)
{
  reg->bitfields.IT_MODELVIEW_MTX_2_SEL = it_modelview_mtx_2_sel;
  if (reg->bitfields.IT_MODELVIEW_MTX_2_SEL != it_modelview_mtx_2_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_MATRIX_SEL_1::IT_MODELVIEW_MTX_2_SEL data too large\n");
}
__inline void set_SE_TCL_MATRIX_SEL_1_it_modelview_mtx_3_sel(regSE_TCL_MATRIX_SEL_1 *reg, unsigned int it_modelview_mtx_3_sel)
{
  reg->bitfields.IT_MODELVIEW_MTX_3_SEL = it_modelview_mtx_3_sel;
  if (reg->bitfields.IT_MODELVIEW_MTX_3_SEL != it_modelview_mtx_3_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_MATRIX_SEL_1::IT_MODELVIEW_MTX_3_SEL data too large\n");
}
#else
#define set_SE_TCL_MATRIX_SEL_1_it_modelview_mtx_0_sel(reg, it_modelview_mtx_0_sel) (reg)->bitfields.IT_MODELVIEW_MTX_0_SEL = it_modelview_mtx_0_sel
#define set_SE_TCL_MATRIX_SEL_1_it_modelview_mtx_1_sel(reg, it_modelview_mtx_1_sel) (reg)->bitfields.IT_MODELVIEW_MTX_1_SEL = it_modelview_mtx_1_sel
#define set_SE_TCL_MATRIX_SEL_1_it_modelview_mtx_2_sel(reg, it_modelview_mtx_2_sel) (reg)->bitfields.IT_MODELVIEW_MTX_2_SEL = it_modelview_mtx_2_sel
#define set_SE_TCL_MATRIX_SEL_1_it_modelview_mtx_3_sel(reg, it_modelview_mtx_3_sel) (reg)->bitfields.IT_MODELVIEW_MTX_3_SEL = it_modelview_mtx_3_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_MATRIX_SEL_2 regSE_TCL_MATRIX_SEL_2;

#ifdef DEBUG
__inline void set_SE_TCL_MATRIX_SEL_2_model2clip_mtx_0_sel(regSE_TCL_MATRIX_SEL_2 *reg, unsigned int model2clip_mtx_0_sel)
{
  reg->bitfields.MODEL2CLIP_MTX_0_SEL = model2clip_mtx_0_sel;
  if (reg->bitfields.MODEL2CLIP_MTX_0_SEL != model2clip_mtx_0_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_MATRIX_SEL_2::MODEL2CLIP_MTX_0_SEL data too large\n");
}
__inline void set_SE_TCL_MATRIX_SEL_2_model2clip_mtx_1_sel(regSE_TCL_MATRIX_SEL_2 *reg, unsigned int model2clip_mtx_1_sel)
{
  reg->bitfields.MODEL2CLIP_MTX_1_SEL = model2clip_mtx_1_sel;
  if (reg->bitfields.MODEL2CLIP_MTX_1_SEL != model2clip_mtx_1_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_MATRIX_SEL_2::MODEL2CLIP_MTX_1_SEL data too large\n");
}
__inline void set_SE_TCL_MATRIX_SEL_2_model2clip_mtx_2_sel(regSE_TCL_MATRIX_SEL_2 *reg, unsigned int model2clip_mtx_2_sel)
{
  reg->bitfields.MODEL2CLIP_MTX_2_SEL = model2clip_mtx_2_sel;
  if (reg->bitfields.MODEL2CLIP_MTX_2_SEL != model2clip_mtx_2_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_MATRIX_SEL_2::MODEL2CLIP_MTX_2_SEL data too large\n");
}
__inline void set_SE_TCL_MATRIX_SEL_2_model2clip_mtx_3_sel(regSE_TCL_MATRIX_SEL_2 *reg, unsigned int model2clip_mtx_3_sel)
{
  reg->bitfields.MODEL2CLIP_MTX_3_SEL = model2clip_mtx_3_sel;
  if (reg->bitfields.MODEL2CLIP_MTX_3_SEL != model2clip_mtx_3_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_MATRIX_SEL_2::MODEL2CLIP_MTX_3_SEL data too large\n");
}
#else
#define set_SE_TCL_MATRIX_SEL_2_model2clip_mtx_0_sel(reg, model2clip_mtx_0_sel) (reg)->bitfields.MODEL2CLIP_MTX_0_SEL = model2clip_mtx_0_sel
#define set_SE_TCL_MATRIX_SEL_2_model2clip_mtx_1_sel(reg, model2clip_mtx_1_sel) (reg)->bitfields.MODEL2CLIP_MTX_1_SEL = model2clip_mtx_1_sel
#define set_SE_TCL_MATRIX_SEL_2_model2clip_mtx_2_sel(reg, model2clip_mtx_2_sel) (reg)->bitfields.MODEL2CLIP_MTX_2_SEL = model2clip_mtx_2_sel
#define set_SE_TCL_MATRIX_SEL_2_model2clip_mtx_3_sel(reg, model2clip_mtx_3_sel) (reg)->bitfields.MODEL2CLIP_MTX_3_SEL = model2clip_mtx_3_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_MATRIX_SEL_3 regSE_TCL_MATRIX_SEL_3;

#ifdef DEBUG
__inline void set_SE_TCL_MATRIX_SEL_3_tex_xform_mtx_0_sel(regSE_TCL_MATRIX_SEL_3 *reg, unsigned int tex_xform_mtx_0_sel)
{
  reg->bitfields.TEX_XFORM_MTX_0_SEL = tex_xform_mtx_0_sel;
  if (reg->bitfields.TEX_XFORM_MTX_0_SEL != tex_xform_mtx_0_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_MATRIX_SEL_3::TEX_XFORM_MTX_0_SEL data too large\n");
}
__inline void set_SE_TCL_MATRIX_SEL_3_tex_xform_mtx_1_sel(regSE_TCL_MATRIX_SEL_3 *reg, unsigned int tex_xform_mtx_1_sel)
{
  reg->bitfields.TEX_XFORM_MTX_1_SEL = tex_xform_mtx_1_sel;
  if (reg->bitfields.TEX_XFORM_MTX_1_SEL != tex_xform_mtx_1_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_MATRIX_SEL_3::TEX_XFORM_MTX_1_SEL data too large\n");
}
__inline void set_SE_TCL_MATRIX_SEL_3_tex_xform_mtx_2_sel(regSE_TCL_MATRIX_SEL_3 *reg, unsigned int tex_xform_mtx_2_sel)
{
  reg->bitfields.TEX_XFORM_MTX_2_SEL = tex_xform_mtx_2_sel;
  if (reg->bitfields.TEX_XFORM_MTX_2_SEL != tex_xform_mtx_2_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_MATRIX_SEL_3::TEX_XFORM_MTX_2_SEL data too large\n");
}
__inline void set_SE_TCL_MATRIX_SEL_3_tex_xform_mtx_3_sel(regSE_TCL_MATRIX_SEL_3 *reg, unsigned int tex_xform_mtx_3_sel)
{
  reg->bitfields.TEX_XFORM_MTX_3_SEL = tex_xform_mtx_3_sel;
  if (reg->bitfields.TEX_XFORM_MTX_3_SEL != tex_xform_mtx_3_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_MATRIX_SEL_3::TEX_XFORM_MTX_3_SEL data too large\n");
}
#else
#define set_SE_TCL_MATRIX_SEL_3_tex_xform_mtx_0_sel(reg, tex_xform_mtx_0_sel) (reg)->bitfields.TEX_XFORM_MTX_0_SEL = tex_xform_mtx_0_sel
#define set_SE_TCL_MATRIX_SEL_3_tex_xform_mtx_1_sel(reg, tex_xform_mtx_1_sel) (reg)->bitfields.TEX_XFORM_MTX_1_SEL = tex_xform_mtx_1_sel
#define set_SE_TCL_MATRIX_SEL_3_tex_xform_mtx_2_sel(reg, tex_xform_mtx_2_sel) (reg)->bitfields.TEX_XFORM_MTX_2_SEL = tex_xform_mtx_2_sel
#define set_SE_TCL_MATRIX_SEL_3_tex_xform_mtx_3_sel(reg, tex_xform_mtx_3_sel) (reg)->bitfields.TEX_XFORM_MTX_3_SEL = tex_xform_mtx_3_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_MATRIX_SEL_4 regSE_TCL_MATRIX_SEL_4;

#ifdef DEBUG
__inline void set_SE_TCL_MATRIX_SEL_4_tex_xform_mtx_4_sel(regSE_TCL_MATRIX_SEL_4 *reg, unsigned int tex_xform_mtx_4_sel)
{
  reg->bitfields.TEX_XFORM_MTX_4_SEL = tex_xform_mtx_4_sel;
  if (reg->bitfields.TEX_XFORM_MTX_4_SEL != tex_xform_mtx_4_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_MATRIX_SEL_4::TEX_XFORM_MTX_4_SEL data too large\n");
}
__inline void set_SE_TCL_MATRIX_SEL_4_tex_xform_mtx_5_sel(regSE_TCL_MATRIX_SEL_4 *reg, unsigned int tex_xform_mtx_5_sel)
{
  reg->bitfields.TEX_XFORM_MTX_5_SEL = tex_xform_mtx_5_sel;
  if (reg->bitfields.TEX_XFORM_MTX_5_SEL != tex_xform_mtx_5_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_MATRIX_SEL_4::TEX_XFORM_MTX_5_SEL data too large\n");
}
#else
#define set_SE_TCL_MATRIX_SEL_4_tex_xform_mtx_4_sel(reg, tex_xform_mtx_4_sel) (reg)->bitfields.TEX_XFORM_MTX_4_SEL = tex_xform_mtx_4_sel
#define set_SE_TCL_MATRIX_SEL_4_tex_xform_mtx_5_sel(reg, tex_xform_mtx_5_sel) (reg)->bitfields.TEX_XFORM_MTX_5_SEL = tex_xform_mtx_5_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_PER_VTX_MTX_CNTL regSE_TCL_PER_VTX_MTX_CNTL;

#ifdef DEBUG
__inline void set_SE_TCL_PER_VTX_MTX_CNTL_mv_mtx_0_indx(regSE_TCL_PER_VTX_MTX_CNTL *reg, unsigned int mv_mtx_0_indx)
{
  reg->bitfields.MV_MTX_0_INDX = mv_mtx_0_indx;
  if (reg->bitfields.MV_MTX_0_INDX != mv_mtx_0_indx) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_VTX_MTX_CNTL::MV_MTX_0_INDX data too large\n");
}
__inline void set_SE_TCL_PER_VTX_MTX_CNTL_itmv_mtx_0_indx(regSE_TCL_PER_VTX_MTX_CNTL *reg, unsigned int itmv_mtx_0_indx)
{
  reg->bitfields.ITMV_MTX_0_INDX = itmv_mtx_0_indx;
  if (reg->bitfields.ITMV_MTX_0_INDX != itmv_mtx_0_indx) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_VTX_MTX_CNTL::ITMV_MTX_0_INDX data too large\n");
}
__inline void set_SE_TCL_PER_VTX_MTX_CNTL_m2c_mtx_0_indx(regSE_TCL_PER_VTX_MTX_CNTL *reg, unsigned int m2c_mtx_0_indx)
{
  reg->bitfields.M2C_MTX_0_INDX = m2c_mtx_0_indx;
  if (reg->bitfields.M2C_MTX_0_INDX != m2c_mtx_0_indx) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_VTX_MTX_CNTL::M2C_MTX_0_INDX data too large\n");
}
#else
#define set_SE_TCL_PER_VTX_MTX_CNTL_mv_mtx_0_indx(reg, mv_mtx_0_indx) (reg)->bitfields.MV_MTX_0_INDX = mv_mtx_0_indx
#define set_SE_TCL_PER_VTX_MTX_CNTL_itmv_mtx_0_indx(reg, itmv_mtx_0_indx) (reg)->bitfields.ITMV_MTX_0_INDX = itmv_mtx_0_indx
#define set_SE_TCL_PER_VTX_MTX_CNTL_m2c_mtx_0_indx(reg, m2c_mtx_0_indx) (reg)->bitfields.M2C_MTX_0_INDX = m2c_mtx_0_indx

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_OUTPUT_VTX_COMP_SEL regSE_TCL_OUTPUT_VTX_COMP_SEL;

#ifdef DEBUG
__inline void set_SE_TCL_OUTPUT_VTX_COMP_SEL_vtx_xyzw_sel(regSE_TCL_OUTPUT_VTX_COMP_SEL *reg, unsigned int vtx_xyzw_sel)
{
  reg->bitfields.VTX_XYZW_SEL = vtx_xyzw_sel;
  if (reg->bitfields.VTX_XYZW_SEL != vtx_xyzw_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_COMP_SEL::VTX_XYZW_SEL data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_COMP_SEL_vtx_color_0_sel(regSE_TCL_OUTPUT_VTX_COMP_SEL *reg, unsigned int vtx_color_0_sel)
{
  reg->bitfields.VTX_COLOR_0_SEL = vtx_color_0_sel;
  if (reg->bitfields.VTX_COLOR_0_SEL != vtx_color_0_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_COMP_SEL::VTX_COLOR_0_SEL data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_COMP_SEL_vtx_color_1_sel(regSE_TCL_OUTPUT_VTX_COMP_SEL *reg, unsigned int vtx_color_1_sel)
{
  reg->bitfields.VTX_COLOR_1_SEL = vtx_color_1_sel;
  if (reg->bitfields.VTX_COLOR_1_SEL != vtx_color_1_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_COMP_SEL::VTX_COLOR_1_SEL data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_COMP_SEL_vtx_tex_0_sel(regSE_TCL_OUTPUT_VTX_COMP_SEL *reg, unsigned int vtx_tex_0_sel)
{
  reg->bitfields.VTX_TEX_0_SEL = vtx_tex_0_sel;
  if (reg->bitfields.VTX_TEX_0_SEL != vtx_tex_0_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_COMP_SEL::VTX_TEX_0_SEL data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_COMP_SEL_vtx_tex_1_sel(regSE_TCL_OUTPUT_VTX_COMP_SEL *reg, unsigned int vtx_tex_1_sel)
{
  reg->bitfields.VTX_TEX_1_SEL = vtx_tex_1_sel;
  if (reg->bitfields.VTX_TEX_1_SEL != vtx_tex_1_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_COMP_SEL::VTX_TEX_1_SEL data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_COMP_SEL_vtx_tex_2_sel(regSE_TCL_OUTPUT_VTX_COMP_SEL *reg, unsigned int vtx_tex_2_sel)
{
  reg->bitfields.VTX_TEX_2_SEL = vtx_tex_2_sel;
  if (reg->bitfields.VTX_TEX_2_SEL != vtx_tex_2_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_COMP_SEL::VTX_TEX_2_SEL data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_COMP_SEL_vtx_tex_3_sel(regSE_TCL_OUTPUT_VTX_COMP_SEL *reg, unsigned int vtx_tex_3_sel)
{
  reg->bitfields.VTX_TEX_3_SEL = vtx_tex_3_sel;
  if (reg->bitfields.VTX_TEX_3_SEL != vtx_tex_3_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_COMP_SEL::VTX_TEX_3_SEL data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_COMP_SEL_vtx_tex_4_sel(regSE_TCL_OUTPUT_VTX_COMP_SEL *reg, unsigned int vtx_tex_4_sel)
{
  reg->bitfields.VTX_TEX_4_SEL = vtx_tex_4_sel;
  if (reg->bitfields.VTX_TEX_4_SEL != vtx_tex_4_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_COMP_SEL::VTX_TEX_4_SEL data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_COMP_SEL_vtx_tex_5_sel(regSE_TCL_OUTPUT_VTX_COMP_SEL *reg, unsigned int vtx_tex_5_sel)
{
  reg->bitfields.VTX_TEX_5_SEL = vtx_tex_5_sel;
  if (reg->bitfields.VTX_TEX_5_SEL != vtx_tex_5_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_COMP_SEL::VTX_TEX_5_SEL data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_COMP_SEL_vtx_discrete_fog_sel(regSE_TCL_OUTPUT_VTX_COMP_SEL *reg, unsigned int vtx_discrete_fog_sel)
{
  reg->bitfields.VTX_DISCRETE_FOG_SEL = vtx_discrete_fog_sel;
  if (reg->bitfields.VTX_DISCRETE_FOG_SEL != vtx_discrete_fog_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_COMP_SEL::VTX_DISCRETE_FOG_SEL data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_COMP_SEL_vtx_pt_size_sel(regSE_TCL_OUTPUT_VTX_COMP_SEL *reg, unsigned int vtx_pt_size_sel)
{
  reg->bitfields.VTX_PT_SIZE_SEL = vtx_pt_size_sel;
  if (reg->bitfields.VTX_PT_SIZE_SEL != vtx_pt_size_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_COMP_SEL::VTX_PT_SIZE_SEL data too large\n");
}
__inline void set_SE_TCL_OUTPUT_VTX_COMP_SEL_force_in_order_proc(regSE_TCL_OUTPUT_VTX_COMP_SEL *reg, unsigned int force_in_order_proc)
{
  reg->bitfields.FORCE_IN_ORDER_PROC = force_in_order_proc;
  if (reg->bitfields.FORCE_IN_ORDER_PROC != force_in_order_proc) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_OUTPUT_VTX_COMP_SEL::FORCE_IN_ORDER_PROC data too large\n");
}
#else
#define set_SE_TCL_OUTPUT_VTX_COMP_SEL_vtx_xyzw_sel(reg, vtx_xyzw_sel) (reg)->bitfields.VTX_XYZW_SEL = vtx_xyzw_sel
#define set_SE_TCL_OUTPUT_VTX_COMP_SEL_vtx_color_0_sel(reg, vtx_color_0_sel) (reg)->bitfields.VTX_COLOR_0_SEL = vtx_color_0_sel
#define set_SE_TCL_OUTPUT_VTX_COMP_SEL_vtx_color_1_sel(reg, vtx_color_1_sel) (reg)->bitfields.VTX_COLOR_1_SEL = vtx_color_1_sel
#define set_SE_TCL_OUTPUT_VTX_COMP_SEL_vtx_tex_0_sel(reg, vtx_tex_0_sel) (reg)->bitfields.VTX_TEX_0_SEL = vtx_tex_0_sel
#define set_SE_TCL_OUTPUT_VTX_COMP_SEL_vtx_tex_1_sel(reg, vtx_tex_1_sel) (reg)->bitfields.VTX_TEX_1_SEL = vtx_tex_1_sel
#define set_SE_TCL_OUTPUT_VTX_COMP_SEL_vtx_tex_2_sel(reg, vtx_tex_2_sel) (reg)->bitfields.VTX_TEX_2_SEL = vtx_tex_2_sel
#define set_SE_TCL_OUTPUT_VTX_COMP_SEL_vtx_tex_3_sel(reg, vtx_tex_3_sel) (reg)->bitfields.VTX_TEX_3_SEL = vtx_tex_3_sel
#define set_SE_TCL_OUTPUT_VTX_COMP_SEL_vtx_tex_4_sel(reg, vtx_tex_4_sel) (reg)->bitfields.VTX_TEX_4_SEL = vtx_tex_4_sel
#define set_SE_TCL_OUTPUT_VTX_COMP_SEL_vtx_tex_5_sel(reg, vtx_tex_5_sel) (reg)->bitfields.VTX_TEX_5_SEL = vtx_tex_5_sel
#define set_SE_TCL_OUTPUT_VTX_COMP_SEL_vtx_discrete_fog_sel(reg, vtx_discrete_fog_sel) (reg)->bitfields.VTX_DISCRETE_FOG_SEL = vtx_discrete_fog_sel
#define set_SE_TCL_OUTPUT_VTX_COMP_SEL_vtx_pt_size_sel(reg, vtx_pt_size_sel) (reg)->bitfields.VTX_PT_SIZE_SEL = vtx_pt_size_sel
#define set_SE_TCL_OUTPUT_VTX_COMP_SEL_force_in_order_proc(reg, force_in_order_proc) (reg)->bitfields.FORCE_IN_ORDER_PROC = force_in_order_proc

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_INPUT_VTX_VECTOR_ADDR_0 regSE_TCL_INPUT_VTX_VECTOR_ADDR_0;

#ifdef DEBUG
__inline void set_SE_TCL_INPUT_VTX_VECTOR_ADDR_0_vertex_position_addr(regSE_TCL_INPUT_VTX_VECTOR_ADDR_0 *reg, unsigned int vertex_position_addr)
{
  reg->bitfields.VERTEX_POSITION_ADDR = vertex_position_addr;
  if (reg->bitfields.VERTEX_POSITION_ADDR != vertex_position_addr) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_INPUT_VTX_VECTOR_ADDR_0::VERTEX_POSITION_ADDR data too large\n");
}
#else
#define set_SE_TCL_INPUT_VTX_VECTOR_ADDR_0_vertex_position_addr(reg, vertex_position_addr) (reg)->bitfields.VERTEX_POSITION_ADDR = vertex_position_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_INPUT_VTX_VECTOR_ADDR_1 regSE_TCL_INPUT_VTX_VECTOR_ADDR_1;

#ifdef DEBUG
__inline void set_SE_TCL_INPUT_VTX_VECTOR_ADDR_1_vtx_color_0_addr(regSE_TCL_INPUT_VTX_VECTOR_ADDR_1 *reg, unsigned int vtx_color_0_addr)
{
  reg->bitfields.VTX_COLOR_0_ADDR = vtx_color_0_addr;
  if (reg->bitfields.VTX_COLOR_0_ADDR != vtx_color_0_addr) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_INPUT_VTX_VECTOR_ADDR_1::VTX_COLOR_0_ADDR data too large\n");
}
__inline void set_SE_TCL_INPUT_VTX_VECTOR_ADDR_1_vtx_color_1_addr(regSE_TCL_INPUT_VTX_VECTOR_ADDR_1 *reg, unsigned int vtx_color_1_addr)
{
  reg->bitfields.VTX_COLOR_1_ADDR = vtx_color_1_addr;
  if (reg->bitfields.VTX_COLOR_1_ADDR != vtx_color_1_addr) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_INPUT_VTX_VECTOR_ADDR_1::VTX_COLOR_1_ADDR data too large\n");
}
#else
#define set_SE_TCL_INPUT_VTX_VECTOR_ADDR_1_vtx_color_0_addr(reg, vtx_color_0_addr) (reg)->bitfields.VTX_COLOR_0_ADDR = vtx_color_0_addr
#define set_SE_TCL_INPUT_VTX_VECTOR_ADDR_1_vtx_color_1_addr(reg, vtx_color_1_addr) (reg)->bitfields.VTX_COLOR_1_ADDR = vtx_color_1_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_INPUT_VTX_VECTOR_ADDR_2 regSE_TCL_INPUT_VTX_VECTOR_ADDR_2;

#ifdef DEBUG
__inline void set_SE_TCL_INPUT_VTX_VECTOR_ADDR_2_vtx_tex_0_addr(regSE_TCL_INPUT_VTX_VECTOR_ADDR_2 *reg, unsigned int vtx_tex_0_addr)
{
  reg->bitfields.VTX_TEX_0_ADDR = vtx_tex_0_addr;
  if (reg->bitfields.VTX_TEX_0_ADDR != vtx_tex_0_addr) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_INPUT_VTX_VECTOR_ADDR_2::VTX_TEX_0_ADDR data too large\n");
}
__inline void set_SE_TCL_INPUT_VTX_VECTOR_ADDR_2_vtx_tex_1_addr(regSE_TCL_INPUT_VTX_VECTOR_ADDR_2 *reg, unsigned int vtx_tex_1_addr)
{
  reg->bitfields.VTX_TEX_1_ADDR = vtx_tex_1_addr;
  if (reg->bitfields.VTX_TEX_1_ADDR != vtx_tex_1_addr) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_INPUT_VTX_VECTOR_ADDR_2::VTX_TEX_1_ADDR data too large\n");
}
__inline void set_SE_TCL_INPUT_VTX_VECTOR_ADDR_2_vtx_tex_2_addr(regSE_TCL_INPUT_VTX_VECTOR_ADDR_2 *reg, unsigned int vtx_tex_2_addr)
{
  reg->bitfields.VTX_TEX_2_ADDR = vtx_tex_2_addr;
  if (reg->bitfields.VTX_TEX_2_ADDR != vtx_tex_2_addr) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_INPUT_VTX_VECTOR_ADDR_2::VTX_TEX_2_ADDR data too large\n");
}
__inline void set_SE_TCL_INPUT_VTX_VECTOR_ADDR_2_vtx_tex_3_addr(regSE_TCL_INPUT_VTX_VECTOR_ADDR_2 *reg, unsigned int vtx_tex_3_addr)
{
  reg->bitfields.VTX_TEX_3_ADDR = vtx_tex_3_addr;
  if (reg->bitfields.VTX_TEX_3_ADDR != vtx_tex_3_addr) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_INPUT_VTX_VECTOR_ADDR_2::VTX_TEX_3_ADDR data too large\n");
}
#else
#define set_SE_TCL_INPUT_VTX_VECTOR_ADDR_2_vtx_tex_0_addr(reg, vtx_tex_0_addr) (reg)->bitfields.VTX_TEX_0_ADDR = vtx_tex_0_addr
#define set_SE_TCL_INPUT_VTX_VECTOR_ADDR_2_vtx_tex_1_addr(reg, vtx_tex_1_addr) (reg)->bitfields.VTX_TEX_1_ADDR = vtx_tex_1_addr
#define set_SE_TCL_INPUT_VTX_VECTOR_ADDR_2_vtx_tex_2_addr(reg, vtx_tex_2_addr) (reg)->bitfields.VTX_TEX_2_ADDR = vtx_tex_2_addr
#define set_SE_TCL_INPUT_VTX_VECTOR_ADDR_2_vtx_tex_3_addr(reg, vtx_tex_3_addr) (reg)->bitfields.VTX_TEX_3_ADDR = vtx_tex_3_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_INPUT_VTX_VECTOR_ADDR_3 regSE_TCL_INPUT_VTX_VECTOR_ADDR_3;

#ifdef DEBUG
__inline void set_SE_TCL_INPUT_VTX_VECTOR_ADDR_3_vtx_tex_4_addr(regSE_TCL_INPUT_VTX_VECTOR_ADDR_3 *reg, unsigned int vtx_tex_4_addr)
{
  reg->bitfields.VTX_TEX_4_ADDR = vtx_tex_4_addr;
  if (reg->bitfields.VTX_TEX_4_ADDR != vtx_tex_4_addr) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_INPUT_VTX_VECTOR_ADDR_3::VTX_TEX_4_ADDR data too large\n");
}
__inline void set_SE_TCL_INPUT_VTX_VECTOR_ADDR_3_vtx_tex_5_addr(regSE_TCL_INPUT_VTX_VECTOR_ADDR_3 *reg, unsigned int vtx_tex_5_addr)
{
  reg->bitfields.VTX_TEX_5_ADDR = vtx_tex_5_addr;
  if (reg->bitfields.VTX_TEX_5_ADDR != vtx_tex_5_addr) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_INPUT_VTX_VECTOR_ADDR_3::VTX_TEX_5_ADDR data too large\n");
}
#else
#define set_SE_TCL_INPUT_VTX_VECTOR_ADDR_3_vtx_tex_4_addr(reg, vtx_tex_4_addr) (reg)->bitfields.VTX_TEX_4_ADDR = vtx_tex_4_addr
#define set_SE_TCL_INPUT_VTX_VECTOR_ADDR_3_vtx_tex_5_addr(reg, vtx_tex_5_addr) (reg)->bitfields.VTX_TEX_5_ADDR = vtx_tex_5_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_LIGHT_MODEL_CNTL_0 regSE_TCL_LIGHT_MODEL_CNTL_0;

#ifdef DEBUG
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_0_lighting_ena(regSE_TCL_LIGHT_MODEL_CNTL_0 *reg, unsigned int lighting_ena)
{
  reg->bitfields.LIGHTING_ENA = lighting_ena;
  if (reg->bitfields.LIGHTING_ENA != lighting_ena) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_0::LIGHTING_ENA data too large\n");
}
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_0_lighting_in_model(regSE_TCL_LIGHT_MODEL_CNTL_0 *reg, unsigned int lighting_in_model)
{
  reg->bitfields.LIGHTING_IN_MODEL = lighting_in_model;
  if (reg->bitfields.LIGHTING_IN_MODEL != lighting_in_model) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_0::LIGHTING_IN_MODEL data too large\n");
}
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_0_local_viewer(regSE_TCL_LIGHT_MODEL_CNTL_0 *reg, unsigned int local_viewer)
{
  reg->bitfields.LOCAL_VIEWER = local_viewer;
  if (reg->bitfields.LOCAL_VIEWER != local_viewer) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_0::LOCAL_VIEWER data too large\n");
}
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_0_normalize_normal(regSE_TCL_LIGHT_MODEL_CNTL_0 *reg, unsigned int normalize_normal)
{
  reg->bitfields.NORMALIZE_NORMAL = normalize_normal;
  if (reg->bitfields.NORMALIZE_NORMAL != normalize_normal) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_0::NORMALIZE_NORMAL data too large\n");
}
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_0_rescale_normal(regSE_TCL_LIGHT_MODEL_CNTL_0 *reg, unsigned int rescale_normal)
{
  reg->bitfields.RESCALE_NORMAL = rescale_normal;
  if (reg->bitfields.RESCALE_NORMAL != rescale_normal) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_0::RESCALE_NORMAL data too large\n");
}
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_0_specular_ena(regSE_TCL_LIGHT_MODEL_CNTL_0 *reg, unsigned int specular_ena)
{
  reg->bitfields.SPECULAR_ENA = specular_ena;
  if (reg->bitfields.SPECULAR_ENA != specular_ena) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_0::SPECULAR_ENA data too large\n");
}
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_0_diffuse_specular_combine(regSE_TCL_LIGHT_MODEL_CNTL_0 *reg, unsigned int diffuse_specular_combine)
{
  reg->bitfields.DIFFUSE_SPECULAR_COMBINE = diffuse_specular_combine;
  if (reg->bitfields.DIFFUSE_SPECULAR_COMBINE != diffuse_specular_combine) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_0::DIFFUSE_SPECULAR_COMBINE data too large\n");
}
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_0_alpha_lighting(regSE_TCL_LIGHT_MODEL_CNTL_0 *reg, unsigned int alpha_lighting)
{
  reg->bitfields.ALPHA_LIGHTING = alpha_lighting;
  if (reg->bitfields.ALPHA_LIGHTING != alpha_lighting) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_0::ALPHA_LIGHTING data too large\n");
}
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_0_loc_light_w_scale_sub(regSE_TCL_LIGHT_MODEL_CNTL_0 *reg, unsigned int loc_light_w_scale_sub)
{
  reg->bitfields.LOC_LIGHT_W_SCALE_SUB = loc_light_w_scale_sub;
  if (reg->bitfields.LOC_LIGHT_W_SCALE_SUB != loc_light_w_scale_sub) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_0::LOC_LIGHT_W_SCALE_SUB data too large\n");
}
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_0_no_normal_do_amb_only(regSE_TCL_LIGHT_MODEL_CNTL_0 *reg, unsigned int no_normal_do_amb_only)
{
  reg->bitfields.NO_NORMAL_DO_AMB_ONLY = no_normal_do_amb_only;
  if (reg->bitfields.NO_NORMAL_DO_AMB_ONLY != no_normal_do_amb_only) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_0::NO_NORMAL_DO_AMB_ONLY data too large\n");
}
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_0_two_sided_lighting_ena(regSE_TCL_LIGHT_MODEL_CNTL_0 *reg, unsigned int two_sided_lighting_ena)
{
  reg->bitfields.TWO_SIDED_LIGHTING_ENA = two_sided_lighting_ena;
  if (reg->bitfields.TWO_SIDED_LIGHTING_ENA != two_sided_lighting_ena) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_0::TWO_SIDED_LIGHTING_ENA data too large\n");
}
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_0_front_shininess_src(regSE_TCL_LIGHT_MODEL_CNTL_0 *reg, unsigned int front_shininess_src)
{
  reg->bitfields.FRONT_SHININESS_SRC = front_shininess_src;
  if (reg->bitfields.FRONT_SHININESS_SRC != front_shininess_src) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_0::FRONT_SHININESS_SRC data too large\n");
}
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_0_back_shininess_src(regSE_TCL_LIGHT_MODEL_CNTL_0 *reg, unsigned int back_shininess_src)
{
  reg->bitfields.BACK_SHININESS_SRC = back_shininess_src;
  if (reg->bitfields.BACK_SHININESS_SRC != back_shininess_src) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_0::BACK_SHININESS_SRC data too large\n");
}
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_0_wait_on_clip_dis(regSE_TCL_LIGHT_MODEL_CNTL_0 *reg, unsigned int wait_on_clip_dis)
{
  reg->bitfields.WAIT_ON_CLIP_DIS = wait_on_clip_dis;
  if (reg->bitfields.WAIT_ON_CLIP_DIS != wait_on_clip_dis) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_0::WAIT_ON_CLIP_DIS data too large\n");
}
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_0_clip_dbl_buf_ena(regSE_TCL_LIGHT_MODEL_CNTL_0 *reg, unsigned int clip_dbl_buf_ena)
{
  reg->bitfields.CLIP_DBL_BUF_ENA = clip_dbl_buf_ena;
  if (reg->bitfields.CLIP_DBL_BUF_ENA != clip_dbl_buf_ena) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_0::CLIP_DBL_BUF_ENA data too large\n");
}
#else
#define set_SE_TCL_LIGHT_MODEL_CNTL_0_lighting_ena(reg, lighting_ena) (reg)->bitfields.LIGHTING_ENA = lighting_ena
#define set_SE_TCL_LIGHT_MODEL_CNTL_0_lighting_in_model(reg, lighting_in_model) (reg)->bitfields.LIGHTING_IN_MODEL = lighting_in_model
#define set_SE_TCL_LIGHT_MODEL_CNTL_0_local_viewer(reg, local_viewer) (reg)->bitfields.LOCAL_VIEWER = local_viewer
#define set_SE_TCL_LIGHT_MODEL_CNTL_0_normalize_normal(reg, normalize_normal) (reg)->bitfields.NORMALIZE_NORMAL = normalize_normal
#define set_SE_TCL_LIGHT_MODEL_CNTL_0_rescale_normal(reg, rescale_normal) (reg)->bitfields.RESCALE_NORMAL = rescale_normal
#define set_SE_TCL_LIGHT_MODEL_CNTL_0_specular_ena(reg, specular_ena) (reg)->bitfields.SPECULAR_ENA = specular_ena
#define set_SE_TCL_LIGHT_MODEL_CNTL_0_diffuse_specular_combine(reg, diffuse_specular_combine) (reg)->bitfields.DIFFUSE_SPECULAR_COMBINE = diffuse_specular_combine
#define set_SE_TCL_LIGHT_MODEL_CNTL_0_alpha_lighting(reg, alpha_lighting) (reg)->bitfields.ALPHA_LIGHTING = alpha_lighting
#define set_SE_TCL_LIGHT_MODEL_CNTL_0_loc_light_w_scale_sub(reg, loc_light_w_scale_sub) (reg)->bitfields.LOC_LIGHT_W_SCALE_SUB = loc_light_w_scale_sub
#define set_SE_TCL_LIGHT_MODEL_CNTL_0_no_normal_do_amb_only(reg, no_normal_do_amb_only) (reg)->bitfields.NO_NORMAL_DO_AMB_ONLY = no_normal_do_amb_only
#define set_SE_TCL_LIGHT_MODEL_CNTL_0_two_sided_lighting_ena(reg, two_sided_lighting_ena) (reg)->bitfields.TWO_SIDED_LIGHTING_ENA = two_sided_lighting_ena
#define set_SE_TCL_LIGHT_MODEL_CNTL_0_front_shininess_src(reg, front_shininess_src) (reg)->bitfields.FRONT_SHININESS_SRC = front_shininess_src
#define set_SE_TCL_LIGHT_MODEL_CNTL_0_back_shininess_src(reg, back_shininess_src) (reg)->bitfields.BACK_SHININESS_SRC = back_shininess_src
#define set_SE_TCL_LIGHT_MODEL_CNTL_0_wait_on_clip_dis(reg, wait_on_clip_dis) (reg)->bitfields.WAIT_ON_CLIP_DIS = wait_on_clip_dis
#define set_SE_TCL_LIGHT_MODEL_CNTL_0_clip_dbl_buf_ena(reg, clip_dbl_buf_ena) (reg)->bitfields.CLIP_DBL_BUF_ENA = clip_dbl_buf_ena

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_LIGHT_MODEL_CNTL_1 regSE_TCL_LIGHT_MODEL_CNTL_1;

#ifdef DEBUG
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_1_front_emissive_src(regSE_TCL_LIGHT_MODEL_CNTL_1 *reg, unsigned int front_emissive_src)
{
  reg->bitfields.FRONT_EMISSIVE_SRC = front_emissive_src;
  if (reg->bitfields.FRONT_EMISSIVE_SRC != front_emissive_src) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_1::FRONT_EMISSIVE_SRC data too large\n");
}
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_1_front_ambient_src(regSE_TCL_LIGHT_MODEL_CNTL_1 *reg, unsigned int front_ambient_src)
{
  reg->bitfields.FRONT_AMBIENT_SRC = front_ambient_src;
  if (reg->bitfields.FRONT_AMBIENT_SRC != front_ambient_src) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_1::FRONT_AMBIENT_SRC data too large\n");
}
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_1_front_diffuse_src(regSE_TCL_LIGHT_MODEL_CNTL_1 *reg, unsigned int front_diffuse_src)
{
  reg->bitfields.FRONT_DIFFUSE_SRC = front_diffuse_src;
  if (reg->bitfields.FRONT_DIFFUSE_SRC != front_diffuse_src) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_1::FRONT_DIFFUSE_SRC data too large\n");
}
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_1_front_specular_src(regSE_TCL_LIGHT_MODEL_CNTL_1 *reg, unsigned int front_specular_src)
{
  reg->bitfields.FRONT_SPECULAR_SRC = front_specular_src;
  if (reg->bitfields.FRONT_SPECULAR_SRC != front_specular_src) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_1::FRONT_SPECULAR_SRC data too large\n");
}
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_1_back_emissive_src(regSE_TCL_LIGHT_MODEL_CNTL_1 *reg, unsigned int back_emissive_src)
{
  reg->bitfields.BACK_EMISSIVE_SRC = back_emissive_src;
  if (reg->bitfields.BACK_EMISSIVE_SRC != back_emissive_src) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_1::BACK_EMISSIVE_SRC data too large\n");
}
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_1_back_ambient_src(regSE_TCL_LIGHT_MODEL_CNTL_1 *reg, unsigned int back_ambient_src)
{
  reg->bitfields.BACK_AMBIENT_SRC = back_ambient_src;
  if (reg->bitfields.BACK_AMBIENT_SRC != back_ambient_src) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_1::BACK_AMBIENT_SRC data too large\n");
}
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_1_back_diffuse_src(regSE_TCL_LIGHT_MODEL_CNTL_1 *reg, unsigned int back_diffuse_src)
{
  reg->bitfields.BACK_DIFFUSE_SRC = back_diffuse_src;
  if (reg->bitfields.BACK_DIFFUSE_SRC != back_diffuse_src) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_1::BACK_DIFFUSE_SRC data too large\n");
}
__inline void set_SE_TCL_LIGHT_MODEL_CNTL_1_back_specular_src(regSE_TCL_LIGHT_MODEL_CNTL_1 *reg, unsigned int back_specular_src)
{
  reg->bitfields.BACK_SPECULAR_SRC = back_specular_src;
  if (reg->bitfields.BACK_SPECULAR_SRC != back_specular_src) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_LIGHT_MODEL_CNTL_1::BACK_SPECULAR_SRC data too large\n");
}
#else
#define set_SE_TCL_LIGHT_MODEL_CNTL_1_front_emissive_src(reg, front_emissive_src) (reg)->bitfields.FRONT_EMISSIVE_SRC = front_emissive_src
#define set_SE_TCL_LIGHT_MODEL_CNTL_1_front_ambient_src(reg, front_ambient_src) (reg)->bitfields.FRONT_AMBIENT_SRC = front_ambient_src
#define set_SE_TCL_LIGHT_MODEL_CNTL_1_front_diffuse_src(reg, front_diffuse_src) (reg)->bitfields.FRONT_DIFFUSE_SRC = front_diffuse_src
#define set_SE_TCL_LIGHT_MODEL_CNTL_1_front_specular_src(reg, front_specular_src) (reg)->bitfields.FRONT_SPECULAR_SRC = front_specular_src
#define set_SE_TCL_LIGHT_MODEL_CNTL_1_back_emissive_src(reg, back_emissive_src) (reg)->bitfields.BACK_EMISSIVE_SRC = back_emissive_src
#define set_SE_TCL_LIGHT_MODEL_CNTL_1_back_ambient_src(reg, back_ambient_src) (reg)->bitfields.BACK_AMBIENT_SRC = back_ambient_src
#define set_SE_TCL_LIGHT_MODEL_CNTL_1_back_diffuse_src(reg, back_diffuse_src) (reg)->bitfields.BACK_DIFFUSE_SRC = back_diffuse_src
#define set_SE_TCL_LIGHT_MODEL_CNTL_1_back_specular_src(reg, back_specular_src) (reg)->bitfields.BACK_SPECULAR_SRC = back_specular_src

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_PER_LIGHT_CNTL_0 regSE_TCL_PER_LIGHT_CNTL_0;

#ifdef DEBUG
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_light_ena_0(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int light_ena_0)
{
  reg->bitfields.LIGHT_ENA_0 = light_ena_0;
  if (reg->bitfields.LIGHT_ENA_0 != light_ena_0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::LIGHT_ENA_0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_ambient_ena_0(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int ambient_ena_0)
{
  reg->bitfields.AMBIENT_ENA_0 = ambient_ena_0;
  if (reg->bitfields.AMBIENT_ENA_0 != ambient_ena_0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::AMBIENT_ENA_0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_specular_ena_0(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int specular_ena_0)
{
  reg->bitfields.SPECULAR_ENA_0 = specular_ena_0;
  if (reg->bitfields.SPECULAR_ENA_0 != specular_ena_0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::SPECULAR_ENA_0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_local_light_0(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int local_light_0)
{
  reg->bitfields.LOCAL_LIGHT_0 = local_light_0;
  if (reg->bitfields.LOCAL_LIGHT_0 != local_light_0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::LOCAL_LIGHT_0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_spot_ena_0(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int spot_ena_0)
{
  reg->bitfields.SPOT_ENA_0 = spot_ena_0;
  if (reg->bitfields.SPOT_ENA_0 != spot_ena_0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::SPOT_ENA_0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_spot_dual_cone_0(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int spot_dual_cone_0)
{
  reg->bitfields.SPOT_DUAL_CONE_0 = spot_dual_cone_0;
  if (reg->bitfields.SPOT_DUAL_CONE_0 != spot_dual_cone_0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::SPOT_DUAL_CONE_0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_rng_att_ena_0(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int rng_att_ena_0)
{
  reg->bitfields.RNG_ATT_ENA_0 = rng_att_ena_0;
  if (reg->bitfields.RNG_ATT_ENA_0 != rng_att_ena_0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::RNG_ATT_ENA_0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_rng_att_constant_ena_0(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int rng_att_constant_ena_0)
{
  reg->bitfields.RNG_ATT_CONSTANT_ENA_0 = rng_att_constant_ena_0;
  if (reg->bitfields.RNG_ATT_CONSTANT_ENA_0 != rng_att_constant_ena_0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::RNG_ATT_CONSTANT_ENA_0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt0_1bit_num0(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int rsvd_lt0_1bit_num0)
{
  reg->bitfields.RSVD_LT0_1BIT_NUM0 = rsvd_lt0_1bit_num0;
  if (reg->bitfields.RSVD_LT0_1BIT_NUM0 != rsvd_lt0_1bit_num0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::RSVD_LT0_1BIT_NUM0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt0_1bit_num1(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int rsvd_lt0_1bit_num1)
{
  reg->bitfields.RSVD_LT0_1BIT_NUM1 = rsvd_lt0_1bit_num1;
  if (reg->bitfields.RSVD_LT0_1BIT_NUM1 != rsvd_lt0_1bit_num1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::RSVD_LT0_1BIT_NUM1 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt0_1bit_num2(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int rsvd_lt0_1bit_num2)
{
  reg->bitfields.RSVD_LT0_1BIT_NUM2 = rsvd_lt0_1bit_num2;
  if (reg->bitfields.RSVD_LT0_1BIT_NUM2 != rsvd_lt0_1bit_num2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::RSVD_LT0_1BIT_NUM2 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt0_1bit_num3(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int rsvd_lt0_1bit_num3)
{
  reg->bitfields.RSVD_LT0_1BIT_NUM3 = rsvd_lt0_1bit_num3;
  if (reg->bitfields.RSVD_LT0_1BIT_NUM3 != rsvd_lt0_1bit_num3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::RSVD_LT0_1BIT_NUM3 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt0_2bit_num0(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int rsvd_lt0_2bit_num0)
{
  reg->bitfields.RSVD_LT0_2BIT_NUM0 = rsvd_lt0_2bit_num0;
  if (reg->bitfields.RSVD_LT0_2BIT_NUM0 != rsvd_lt0_2bit_num0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::RSVD_LT0_2BIT_NUM0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt0_2bit_num1(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int rsvd_lt0_2bit_num1)
{
  reg->bitfields.RSVD_LT0_2BIT_NUM1 = rsvd_lt0_2bit_num1;
  if (reg->bitfields.RSVD_LT0_2BIT_NUM1 != rsvd_lt0_2bit_num1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::RSVD_LT0_2BIT_NUM1 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_light_ena_1(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int light_ena_1)
{
  reg->bitfields.LIGHT_ENA_1 = light_ena_1;
  if (reg->bitfields.LIGHT_ENA_1 != light_ena_1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::LIGHT_ENA_1 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_ambient_ena_1(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int ambient_ena_1)
{
  reg->bitfields.AMBIENT_ENA_1 = ambient_ena_1;
  if (reg->bitfields.AMBIENT_ENA_1 != ambient_ena_1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::AMBIENT_ENA_1 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_specular_ena_1(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int specular_ena_1)
{
  reg->bitfields.SPECULAR_ENA_1 = specular_ena_1;
  if (reg->bitfields.SPECULAR_ENA_1 != specular_ena_1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::SPECULAR_ENA_1 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_local_light_1(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int local_light_1)
{
  reg->bitfields.LOCAL_LIGHT_1 = local_light_1;
  if (reg->bitfields.LOCAL_LIGHT_1 != local_light_1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::LOCAL_LIGHT_1 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_spot_ena_1(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int spot_ena_1)
{
  reg->bitfields.SPOT_ENA_1 = spot_ena_1;
  if (reg->bitfields.SPOT_ENA_1 != spot_ena_1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::SPOT_ENA_1 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_spot_dual_cone_1(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int spot_dual_cone_1)
{
  reg->bitfields.SPOT_DUAL_CONE_1 = spot_dual_cone_1;
  if (reg->bitfields.SPOT_DUAL_CONE_1 != spot_dual_cone_1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::SPOT_DUAL_CONE_1 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_rng_att_ena_1(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int rng_att_ena_1)
{
  reg->bitfields.RNG_ATT_ENA_1 = rng_att_ena_1;
  if (reg->bitfields.RNG_ATT_ENA_1 != rng_att_ena_1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::RNG_ATT_ENA_1 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_rng_att_constant_ena_1(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int rng_att_constant_ena_1)
{
  reg->bitfields.RNG_ATT_CONSTANT_ENA_1 = rng_att_constant_ena_1;
  if (reg->bitfields.RNG_ATT_CONSTANT_ENA_1 != rng_att_constant_ena_1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::RNG_ATT_CONSTANT_ENA_1 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt1_1bit_num0(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int rsvd_lt1_1bit_num0)
{
  reg->bitfields.RSVD_LT1_1BIT_NUM0 = rsvd_lt1_1bit_num0;
  if (reg->bitfields.RSVD_LT1_1BIT_NUM0 != rsvd_lt1_1bit_num0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::RSVD_LT1_1BIT_NUM0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt1_1bit_num1(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int rsvd_lt1_1bit_num1)
{
  reg->bitfields.RSVD_LT1_1BIT_NUM1 = rsvd_lt1_1bit_num1;
  if (reg->bitfields.RSVD_LT1_1BIT_NUM1 != rsvd_lt1_1bit_num1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::RSVD_LT1_1BIT_NUM1 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt1_1bit_num2(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int rsvd_lt1_1bit_num2)
{
  reg->bitfields.RSVD_LT1_1BIT_NUM2 = rsvd_lt1_1bit_num2;
  if (reg->bitfields.RSVD_LT1_1BIT_NUM2 != rsvd_lt1_1bit_num2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::RSVD_LT1_1BIT_NUM2 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt1_1bit_num3(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int rsvd_lt1_1bit_num3)
{
  reg->bitfields.RSVD_LT1_1BIT_NUM3 = rsvd_lt1_1bit_num3;
  if (reg->bitfields.RSVD_LT1_1BIT_NUM3 != rsvd_lt1_1bit_num3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::RSVD_LT1_1BIT_NUM3 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt1_2bit_num0(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int rsvd_lt1_2bit_num0)
{
  reg->bitfields.RSVD_LT1_2BIT_NUM0 = rsvd_lt1_2bit_num0;
  if (reg->bitfields.RSVD_LT1_2BIT_NUM0 != rsvd_lt1_2bit_num0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::RSVD_LT1_2BIT_NUM0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt1_2bit_num1(regSE_TCL_PER_LIGHT_CNTL_0 *reg, unsigned int rsvd_lt1_2bit_num1)
{
  reg->bitfields.RSVD_LT1_2BIT_NUM1 = rsvd_lt1_2bit_num1;
  if (reg->bitfields.RSVD_LT1_2BIT_NUM1 != rsvd_lt1_2bit_num1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_0::RSVD_LT1_2BIT_NUM1 data too large\n");
}
#else
#define set_SE_TCL_PER_LIGHT_CNTL_0_light_ena_0(reg, light_ena_0) (reg)->bitfields.LIGHT_ENA_0 = light_ena_0
#define set_SE_TCL_PER_LIGHT_CNTL_0_ambient_ena_0(reg, ambient_ena_0) (reg)->bitfields.AMBIENT_ENA_0 = ambient_ena_0
#define set_SE_TCL_PER_LIGHT_CNTL_0_specular_ena_0(reg, specular_ena_0) (reg)->bitfields.SPECULAR_ENA_0 = specular_ena_0
#define set_SE_TCL_PER_LIGHT_CNTL_0_local_light_0(reg, local_light_0) (reg)->bitfields.LOCAL_LIGHT_0 = local_light_0
#define set_SE_TCL_PER_LIGHT_CNTL_0_spot_ena_0(reg, spot_ena_0) (reg)->bitfields.SPOT_ENA_0 = spot_ena_0
#define set_SE_TCL_PER_LIGHT_CNTL_0_spot_dual_cone_0(reg, spot_dual_cone_0) (reg)->bitfields.SPOT_DUAL_CONE_0 = spot_dual_cone_0
#define set_SE_TCL_PER_LIGHT_CNTL_0_rng_att_ena_0(reg, rng_att_ena_0) (reg)->bitfields.RNG_ATT_ENA_0 = rng_att_ena_0
#define set_SE_TCL_PER_LIGHT_CNTL_0_rng_att_constant_ena_0(reg, rng_att_constant_ena_0) (reg)->bitfields.RNG_ATT_CONSTANT_ENA_0 = rng_att_constant_ena_0
#define set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt0_1bit_num0(reg, rsvd_lt0_1bit_num0) (reg)->bitfields.RSVD_LT0_1BIT_NUM0 = rsvd_lt0_1bit_num0
#define set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt0_1bit_num1(reg, rsvd_lt0_1bit_num1) (reg)->bitfields.RSVD_LT0_1BIT_NUM1 = rsvd_lt0_1bit_num1
#define set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt0_1bit_num2(reg, rsvd_lt0_1bit_num2) (reg)->bitfields.RSVD_LT0_1BIT_NUM2 = rsvd_lt0_1bit_num2
#define set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt0_1bit_num3(reg, rsvd_lt0_1bit_num3) (reg)->bitfields.RSVD_LT0_1BIT_NUM3 = rsvd_lt0_1bit_num3
#define set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt0_2bit_num0(reg, rsvd_lt0_2bit_num0) (reg)->bitfields.RSVD_LT0_2BIT_NUM0 = rsvd_lt0_2bit_num0
#define set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt0_2bit_num1(reg, rsvd_lt0_2bit_num1) (reg)->bitfields.RSVD_LT0_2BIT_NUM1 = rsvd_lt0_2bit_num1
#define set_SE_TCL_PER_LIGHT_CNTL_0_light_ena_1(reg, light_ena_1) (reg)->bitfields.LIGHT_ENA_1 = light_ena_1
#define set_SE_TCL_PER_LIGHT_CNTL_0_ambient_ena_1(reg, ambient_ena_1) (reg)->bitfields.AMBIENT_ENA_1 = ambient_ena_1
#define set_SE_TCL_PER_LIGHT_CNTL_0_specular_ena_1(reg, specular_ena_1) (reg)->bitfields.SPECULAR_ENA_1 = specular_ena_1
#define set_SE_TCL_PER_LIGHT_CNTL_0_local_light_1(reg, local_light_1) (reg)->bitfields.LOCAL_LIGHT_1 = local_light_1
#define set_SE_TCL_PER_LIGHT_CNTL_0_spot_ena_1(reg, spot_ena_1) (reg)->bitfields.SPOT_ENA_1 = spot_ena_1
#define set_SE_TCL_PER_LIGHT_CNTL_0_spot_dual_cone_1(reg, spot_dual_cone_1) (reg)->bitfields.SPOT_DUAL_CONE_1 = spot_dual_cone_1
#define set_SE_TCL_PER_LIGHT_CNTL_0_rng_att_ena_1(reg, rng_att_ena_1) (reg)->bitfields.RNG_ATT_ENA_1 = rng_att_ena_1
#define set_SE_TCL_PER_LIGHT_CNTL_0_rng_att_constant_ena_1(reg, rng_att_constant_ena_1) (reg)->bitfields.RNG_ATT_CONSTANT_ENA_1 = rng_att_constant_ena_1
#define set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt1_1bit_num0(reg, rsvd_lt1_1bit_num0) (reg)->bitfields.RSVD_LT1_1BIT_NUM0 = rsvd_lt1_1bit_num0
#define set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt1_1bit_num1(reg, rsvd_lt1_1bit_num1) (reg)->bitfields.RSVD_LT1_1BIT_NUM1 = rsvd_lt1_1bit_num1
#define set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt1_1bit_num2(reg, rsvd_lt1_1bit_num2) (reg)->bitfields.RSVD_LT1_1BIT_NUM2 = rsvd_lt1_1bit_num2
#define set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt1_1bit_num3(reg, rsvd_lt1_1bit_num3) (reg)->bitfields.RSVD_LT1_1BIT_NUM3 = rsvd_lt1_1bit_num3
#define set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt1_2bit_num0(reg, rsvd_lt1_2bit_num0) (reg)->bitfields.RSVD_LT1_2BIT_NUM0 = rsvd_lt1_2bit_num0
#define set_SE_TCL_PER_LIGHT_CNTL_0_rsvd_lt1_2bit_num1(reg, rsvd_lt1_2bit_num1) (reg)->bitfields.RSVD_LT1_2BIT_NUM1 = rsvd_lt1_2bit_num1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_PER_LIGHT_CNTL_1 regSE_TCL_PER_LIGHT_CNTL_1;

#ifdef DEBUG
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_light_ena_2(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int light_ena_2)
{
  reg->bitfields.LIGHT_ENA_2 = light_ena_2;
  if (reg->bitfields.LIGHT_ENA_2 != light_ena_2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::LIGHT_ENA_2 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_ambient_ena_2(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int ambient_ena_2)
{
  reg->bitfields.AMBIENT_ENA_2 = ambient_ena_2;
  if (reg->bitfields.AMBIENT_ENA_2 != ambient_ena_2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::AMBIENT_ENA_2 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_specular_ena_2(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int specular_ena_2)
{
  reg->bitfields.SPECULAR_ENA_2 = specular_ena_2;
  if (reg->bitfields.SPECULAR_ENA_2 != specular_ena_2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::SPECULAR_ENA_2 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_local_light_2(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int local_light_2)
{
  reg->bitfields.LOCAL_LIGHT_2 = local_light_2;
  if (reg->bitfields.LOCAL_LIGHT_2 != local_light_2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::LOCAL_LIGHT_2 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_spot_ena_2(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int spot_ena_2)
{
  reg->bitfields.SPOT_ENA_2 = spot_ena_2;
  if (reg->bitfields.SPOT_ENA_2 != spot_ena_2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::SPOT_ENA_2 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_spot_dual_cone_2(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int spot_dual_cone_2)
{
  reg->bitfields.SPOT_DUAL_CONE_2 = spot_dual_cone_2;
  if (reg->bitfields.SPOT_DUAL_CONE_2 != spot_dual_cone_2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::SPOT_DUAL_CONE_2 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_rng_att_ena_2(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int rng_att_ena_2)
{
  reg->bitfields.RNG_ATT_ENA_2 = rng_att_ena_2;
  if (reg->bitfields.RNG_ATT_ENA_2 != rng_att_ena_2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::RNG_ATT_ENA_2 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_rng_att_constant_ena_2(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int rng_att_constant_ena_2)
{
  reg->bitfields.RNG_ATT_CONSTANT_ENA_2 = rng_att_constant_ena_2;
  if (reg->bitfields.RNG_ATT_CONSTANT_ENA_2 != rng_att_constant_ena_2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::RNG_ATT_CONSTANT_ENA_2 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt2_1bit_num0(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int rsvd_lt2_1bit_num0)
{
  reg->bitfields.RSVD_LT2_1BIT_NUM0 = rsvd_lt2_1bit_num0;
  if (reg->bitfields.RSVD_LT2_1BIT_NUM0 != rsvd_lt2_1bit_num0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::RSVD_LT2_1BIT_NUM0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt2_1bit_num1(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int rsvd_lt2_1bit_num1)
{
  reg->bitfields.RSVD_LT2_1BIT_NUM1 = rsvd_lt2_1bit_num1;
  if (reg->bitfields.RSVD_LT2_1BIT_NUM1 != rsvd_lt2_1bit_num1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::RSVD_LT2_1BIT_NUM1 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt2_1bit_num2(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int rsvd_lt2_1bit_num2)
{
  reg->bitfields.RSVD_LT2_1BIT_NUM2 = rsvd_lt2_1bit_num2;
  if (reg->bitfields.RSVD_LT2_1BIT_NUM2 != rsvd_lt2_1bit_num2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::RSVD_LT2_1BIT_NUM2 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt2_1bit_num3(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int rsvd_lt2_1bit_num3)
{
  reg->bitfields.RSVD_LT2_1BIT_NUM3 = rsvd_lt2_1bit_num3;
  if (reg->bitfields.RSVD_LT2_1BIT_NUM3 != rsvd_lt2_1bit_num3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::RSVD_LT2_1BIT_NUM3 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt2_2bit_num0(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int rsvd_lt2_2bit_num0)
{
  reg->bitfields.RSVD_LT2_2BIT_NUM0 = rsvd_lt2_2bit_num0;
  if (reg->bitfields.RSVD_LT2_2BIT_NUM0 != rsvd_lt2_2bit_num0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::RSVD_LT2_2BIT_NUM0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt2_2bit_num1(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int rsvd_lt2_2bit_num1)
{
  reg->bitfields.RSVD_LT2_2BIT_NUM1 = rsvd_lt2_2bit_num1;
  if (reg->bitfields.RSVD_LT2_2BIT_NUM1 != rsvd_lt2_2bit_num1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::RSVD_LT2_2BIT_NUM1 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_light_ena_3(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int light_ena_3)
{
  reg->bitfields.LIGHT_ENA_3 = light_ena_3;
  if (reg->bitfields.LIGHT_ENA_3 != light_ena_3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::LIGHT_ENA_3 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_ambient_ena_3(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int ambient_ena_3)
{
  reg->bitfields.AMBIENT_ENA_3 = ambient_ena_3;
  if (reg->bitfields.AMBIENT_ENA_3 != ambient_ena_3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::AMBIENT_ENA_3 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_specular_ena_3(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int specular_ena_3)
{
  reg->bitfields.SPECULAR_ENA_3 = specular_ena_3;
  if (reg->bitfields.SPECULAR_ENA_3 != specular_ena_3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::SPECULAR_ENA_3 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_local_light_3(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int local_light_3)
{
  reg->bitfields.LOCAL_LIGHT_3 = local_light_3;
  if (reg->bitfields.LOCAL_LIGHT_3 != local_light_3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::LOCAL_LIGHT_3 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_spot_ena_3(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int spot_ena_3)
{
  reg->bitfields.SPOT_ENA_3 = spot_ena_3;
  if (reg->bitfields.SPOT_ENA_3 != spot_ena_3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::SPOT_ENA_3 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_spot_dual_cone_3(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int spot_dual_cone_3)
{
  reg->bitfields.SPOT_DUAL_CONE_3 = spot_dual_cone_3;
  if (reg->bitfields.SPOT_DUAL_CONE_3 != spot_dual_cone_3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::SPOT_DUAL_CONE_3 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_rng_att_ena_3(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int rng_att_ena_3)
{
  reg->bitfields.RNG_ATT_ENA_3 = rng_att_ena_3;
  if (reg->bitfields.RNG_ATT_ENA_3 != rng_att_ena_3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::RNG_ATT_ENA_3 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_rng_att_constant_ena_3(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int rng_att_constant_ena_3)
{
  reg->bitfields.RNG_ATT_CONSTANT_ENA_3 = rng_att_constant_ena_3;
  if (reg->bitfields.RNG_ATT_CONSTANT_ENA_3 != rng_att_constant_ena_3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::RNG_ATT_CONSTANT_ENA_3 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt3_1bit_num0(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int rsvd_lt3_1bit_num0)
{
  reg->bitfields.RSVD_LT3_1BIT_NUM0 = rsvd_lt3_1bit_num0;
  if (reg->bitfields.RSVD_LT3_1BIT_NUM0 != rsvd_lt3_1bit_num0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::RSVD_LT3_1BIT_NUM0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt3_1bit_num1(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int rsvd_lt3_1bit_num1)
{
  reg->bitfields.RSVD_LT3_1BIT_NUM1 = rsvd_lt3_1bit_num1;
  if (reg->bitfields.RSVD_LT3_1BIT_NUM1 != rsvd_lt3_1bit_num1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::RSVD_LT3_1BIT_NUM1 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt3_1bit_num2(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int rsvd_lt3_1bit_num2)
{
  reg->bitfields.RSVD_LT3_1BIT_NUM2 = rsvd_lt3_1bit_num2;
  if (reg->bitfields.RSVD_LT3_1BIT_NUM2 != rsvd_lt3_1bit_num2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::RSVD_LT3_1BIT_NUM2 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt3_1bit_num3(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int rsvd_lt3_1bit_num3)
{
  reg->bitfields.RSVD_LT3_1BIT_NUM3 = rsvd_lt3_1bit_num3;
  if (reg->bitfields.RSVD_LT3_1BIT_NUM3 != rsvd_lt3_1bit_num3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::RSVD_LT3_1BIT_NUM3 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt3_2bit_num0(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int rsvd_lt3_2bit_num0)
{
  reg->bitfields.RSVD_LT3_2BIT_NUM0 = rsvd_lt3_2bit_num0;
  if (reg->bitfields.RSVD_LT3_2BIT_NUM0 != rsvd_lt3_2bit_num0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::RSVD_LT3_2BIT_NUM0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt3_2bit_num1(regSE_TCL_PER_LIGHT_CNTL_1 *reg, unsigned int rsvd_lt3_2bit_num1)
{
  reg->bitfields.RSVD_LT3_2BIT_NUM1 = rsvd_lt3_2bit_num1;
  if (reg->bitfields.RSVD_LT3_2BIT_NUM1 != rsvd_lt3_2bit_num1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_1::RSVD_LT3_2BIT_NUM1 data too large\n");
}
#else
#define set_SE_TCL_PER_LIGHT_CNTL_1_light_ena_2(reg, light_ena_2) (reg)->bitfields.LIGHT_ENA_2 = light_ena_2
#define set_SE_TCL_PER_LIGHT_CNTL_1_ambient_ena_2(reg, ambient_ena_2) (reg)->bitfields.AMBIENT_ENA_2 = ambient_ena_2
#define set_SE_TCL_PER_LIGHT_CNTL_1_specular_ena_2(reg, specular_ena_2) (reg)->bitfields.SPECULAR_ENA_2 = specular_ena_2
#define set_SE_TCL_PER_LIGHT_CNTL_1_local_light_2(reg, local_light_2) (reg)->bitfields.LOCAL_LIGHT_2 = local_light_2
#define set_SE_TCL_PER_LIGHT_CNTL_1_spot_ena_2(reg, spot_ena_2) (reg)->bitfields.SPOT_ENA_2 = spot_ena_2
#define set_SE_TCL_PER_LIGHT_CNTL_1_spot_dual_cone_2(reg, spot_dual_cone_2) (reg)->bitfields.SPOT_DUAL_CONE_2 = spot_dual_cone_2
#define set_SE_TCL_PER_LIGHT_CNTL_1_rng_att_ena_2(reg, rng_att_ena_2) (reg)->bitfields.RNG_ATT_ENA_2 = rng_att_ena_2
#define set_SE_TCL_PER_LIGHT_CNTL_1_rng_att_constant_ena_2(reg, rng_att_constant_ena_2) (reg)->bitfields.RNG_ATT_CONSTANT_ENA_2 = rng_att_constant_ena_2
#define set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt2_1bit_num0(reg, rsvd_lt2_1bit_num0) (reg)->bitfields.RSVD_LT2_1BIT_NUM0 = rsvd_lt2_1bit_num0
#define set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt2_1bit_num1(reg, rsvd_lt2_1bit_num1) (reg)->bitfields.RSVD_LT2_1BIT_NUM1 = rsvd_lt2_1bit_num1
#define set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt2_1bit_num2(reg, rsvd_lt2_1bit_num2) (reg)->bitfields.RSVD_LT2_1BIT_NUM2 = rsvd_lt2_1bit_num2
#define set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt2_1bit_num3(reg, rsvd_lt2_1bit_num3) (reg)->bitfields.RSVD_LT2_1BIT_NUM3 = rsvd_lt2_1bit_num3
#define set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt2_2bit_num0(reg, rsvd_lt2_2bit_num0) (reg)->bitfields.RSVD_LT2_2BIT_NUM0 = rsvd_lt2_2bit_num0
#define set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt2_2bit_num1(reg, rsvd_lt2_2bit_num1) (reg)->bitfields.RSVD_LT2_2BIT_NUM1 = rsvd_lt2_2bit_num1
#define set_SE_TCL_PER_LIGHT_CNTL_1_light_ena_3(reg, light_ena_3) (reg)->bitfields.LIGHT_ENA_3 = light_ena_3
#define set_SE_TCL_PER_LIGHT_CNTL_1_ambient_ena_3(reg, ambient_ena_3) (reg)->bitfields.AMBIENT_ENA_3 = ambient_ena_3
#define set_SE_TCL_PER_LIGHT_CNTL_1_specular_ena_3(reg, specular_ena_3) (reg)->bitfields.SPECULAR_ENA_3 = specular_ena_3
#define set_SE_TCL_PER_LIGHT_CNTL_1_local_light_3(reg, local_light_3) (reg)->bitfields.LOCAL_LIGHT_3 = local_light_3
#define set_SE_TCL_PER_LIGHT_CNTL_1_spot_ena_3(reg, spot_ena_3) (reg)->bitfields.SPOT_ENA_3 = spot_ena_3
#define set_SE_TCL_PER_LIGHT_CNTL_1_spot_dual_cone_3(reg, spot_dual_cone_3) (reg)->bitfields.SPOT_DUAL_CONE_3 = spot_dual_cone_3
#define set_SE_TCL_PER_LIGHT_CNTL_1_rng_att_ena_3(reg, rng_att_ena_3) (reg)->bitfields.RNG_ATT_ENA_3 = rng_att_ena_3
#define set_SE_TCL_PER_LIGHT_CNTL_1_rng_att_constant_ena_3(reg, rng_att_constant_ena_3) (reg)->bitfields.RNG_ATT_CONSTANT_ENA_3 = rng_att_constant_ena_3
#define set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt3_1bit_num0(reg, rsvd_lt3_1bit_num0) (reg)->bitfields.RSVD_LT3_1BIT_NUM0 = rsvd_lt3_1bit_num0
#define set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt3_1bit_num1(reg, rsvd_lt3_1bit_num1) (reg)->bitfields.RSVD_LT3_1BIT_NUM1 = rsvd_lt3_1bit_num1
#define set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt3_1bit_num2(reg, rsvd_lt3_1bit_num2) (reg)->bitfields.RSVD_LT3_1BIT_NUM2 = rsvd_lt3_1bit_num2
#define set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt3_1bit_num3(reg, rsvd_lt3_1bit_num3) (reg)->bitfields.RSVD_LT3_1BIT_NUM3 = rsvd_lt3_1bit_num3
#define set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt3_2bit_num0(reg, rsvd_lt3_2bit_num0) (reg)->bitfields.RSVD_LT3_2BIT_NUM0 = rsvd_lt3_2bit_num0
#define set_SE_TCL_PER_LIGHT_CNTL_1_rsvd_lt3_2bit_num1(reg, rsvd_lt3_2bit_num1) (reg)->bitfields.RSVD_LT3_2BIT_NUM1 = rsvd_lt3_2bit_num1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_PER_LIGHT_CNTL_2 regSE_TCL_PER_LIGHT_CNTL_2;

#ifdef DEBUG
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_light_ena_4(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int light_ena_4)
{
  reg->bitfields.LIGHT_ENA_4 = light_ena_4;
  if (reg->bitfields.LIGHT_ENA_4 != light_ena_4) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::LIGHT_ENA_4 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_ambient_ena_4(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int ambient_ena_4)
{
  reg->bitfields.AMBIENT_ENA_4 = ambient_ena_4;
  if (reg->bitfields.AMBIENT_ENA_4 != ambient_ena_4) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::AMBIENT_ENA_4 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_specular_ena_4(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int specular_ena_4)
{
  reg->bitfields.SPECULAR_ENA_4 = specular_ena_4;
  if (reg->bitfields.SPECULAR_ENA_4 != specular_ena_4) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::SPECULAR_ENA_4 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_local_light_4(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int local_light_4)
{
  reg->bitfields.LOCAL_LIGHT_4 = local_light_4;
  if (reg->bitfields.LOCAL_LIGHT_4 != local_light_4) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::LOCAL_LIGHT_4 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_spot_ena_4(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int spot_ena_4)
{
  reg->bitfields.SPOT_ENA_4 = spot_ena_4;
  if (reg->bitfields.SPOT_ENA_4 != spot_ena_4) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::SPOT_ENA_4 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_spot_dual_cone_4(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int spot_dual_cone_4)
{
  reg->bitfields.SPOT_DUAL_CONE_4 = spot_dual_cone_4;
  if (reg->bitfields.SPOT_DUAL_CONE_4 != spot_dual_cone_4) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::SPOT_DUAL_CONE_4 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_rng_att_ena_4(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int rng_att_ena_4)
{
  reg->bitfields.RNG_ATT_ENA_4 = rng_att_ena_4;
  if (reg->bitfields.RNG_ATT_ENA_4 != rng_att_ena_4) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::RNG_ATT_ENA_4 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_rng_att_constant_ena_4(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int rng_att_constant_ena_4)
{
  reg->bitfields.RNG_ATT_CONSTANT_ENA_4 = rng_att_constant_ena_4;
  if (reg->bitfields.RNG_ATT_CONSTANT_ENA_4 != rng_att_constant_ena_4) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::RNG_ATT_CONSTANT_ENA_4 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt4_1bit_num0(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int rsvd_lt4_1bit_num0)
{
  reg->bitfields.RSVD_LT4_1BIT_NUM0 = rsvd_lt4_1bit_num0;
  if (reg->bitfields.RSVD_LT4_1BIT_NUM0 != rsvd_lt4_1bit_num0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::RSVD_LT4_1BIT_NUM0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt4_1bit_num1(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int rsvd_lt4_1bit_num1)
{
  reg->bitfields.RSVD_LT4_1BIT_NUM1 = rsvd_lt4_1bit_num1;
  if (reg->bitfields.RSVD_LT4_1BIT_NUM1 != rsvd_lt4_1bit_num1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::RSVD_LT4_1BIT_NUM1 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt4_1bit_num2(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int rsvd_lt4_1bit_num2)
{
  reg->bitfields.RSVD_LT4_1BIT_NUM2 = rsvd_lt4_1bit_num2;
  if (reg->bitfields.RSVD_LT4_1BIT_NUM2 != rsvd_lt4_1bit_num2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::RSVD_LT4_1BIT_NUM2 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt4_1bit_num3(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int rsvd_lt4_1bit_num3)
{
  reg->bitfields.RSVD_LT4_1BIT_NUM3 = rsvd_lt4_1bit_num3;
  if (reg->bitfields.RSVD_LT4_1BIT_NUM3 != rsvd_lt4_1bit_num3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::RSVD_LT4_1BIT_NUM3 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt4_2bit_num0(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int rsvd_lt4_2bit_num0)
{
  reg->bitfields.RSVD_LT4_2BIT_NUM0 = rsvd_lt4_2bit_num0;
  if (reg->bitfields.RSVD_LT4_2BIT_NUM0 != rsvd_lt4_2bit_num0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::RSVD_LT4_2BIT_NUM0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt4_2bit_num1(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int rsvd_lt4_2bit_num1)
{
  reg->bitfields.RSVD_LT4_2BIT_NUM1 = rsvd_lt4_2bit_num1;
  if (reg->bitfields.RSVD_LT4_2BIT_NUM1 != rsvd_lt4_2bit_num1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::RSVD_LT4_2BIT_NUM1 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_light_ena_5(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int light_ena_5)
{
  reg->bitfields.LIGHT_ENA_5 = light_ena_5;
  if (reg->bitfields.LIGHT_ENA_5 != light_ena_5) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::LIGHT_ENA_5 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_ambient_ena_5(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int ambient_ena_5)
{
  reg->bitfields.AMBIENT_ENA_5 = ambient_ena_5;
  if (reg->bitfields.AMBIENT_ENA_5 != ambient_ena_5) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::AMBIENT_ENA_5 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_specular_ena_5(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int specular_ena_5)
{
  reg->bitfields.SPECULAR_ENA_5 = specular_ena_5;
  if (reg->bitfields.SPECULAR_ENA_5 != specular_ena_5) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::SPECULAR_ENA_5 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_local_light_5(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int local_light_5)
{
  reg->bitfields.LOCAL_LIGHT_5 = local_light_5;
  if (reg->bitfields.LOCAL_LIGHT_5 != local_light_5) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::LOCAL_LIGHT_5 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_spot_ena_5(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int spot_ena_5)
{
  reg->bitfields.SPOT_ENA_5 = spot_ena_5;
  if (reg->bitfields.SPOT_ENA_5 != spot_ena_5) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::SPOT_ENA_5 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_spot_dual_cone_5(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int spot_dual_cone_5)
{
  reg->bitfields.SPOT_DUAL_CONE_5 = spot_dual_cone_5;
  if (reg->bitfields.SPOT_DUAL_CONE_5 != spot_dual_cone_5) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::SPOT_DUAL_CONE_5 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_rng_att_ena_5(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int rng_att_ena_5)
{
  reg->bitfields.RNG_ATT_ENA_5 = rng_att_ena_5;
  if (reg->bitfields.RNG_ATT_ENA_5 != rng_att_ena_5) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::RNG_ATT_ENA_5 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_rng_att_constant_ena_5(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int rng_att_constant_ena_5)
{
  reg->bitfields.RNG_ATT_CONSTANT_ENA_5 = rng_att_constant_ena_5;
  if (reg->bitfields.RNG_ATT_CONSTANT_ENA_5 != rng_att_constant_ena_5) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::RNG_ATT_CONSTANT_ENA_5 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt5_1bit_num0(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int rsvd_lt5_1bit_num0)
{
  reg->bitfields.RSVD_LT5_1BIT_NUM0 = rsvd_lt5_1bit_num0;
  if (reg->bitfields.RSVD_LT5_1BIT_NUM0 != rsvd_lt5_1bit_num0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::RSVD_LT5_1BIT_NUM0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt5_1bit_num1(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int rsvd_lt5_1bit_num1)
{
  reg->bitfields.RSVD_LT5_1BIT_NUM1 = rsvd_lt5_1bit_num1;
  if (reg->bitfields.RSVD_LT5_1BIT_NUM1 != rsvd_lt5_1bit_num1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::RSVD_LT5_1BIT_NUM1 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt5_1bit_num2(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int rsvd_lt5_1bit_num2)
{
  reg->bitfields.RSVD_LT5_1BIT_NUM2 = rsvd_lt5_1bit_num2;
  if (reg->bitfields.RSVD_LT5_1BIT_NUM2 != rsvd_lt5_1bit_num2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::RSVD_LT5_1BIT_NUM2 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt5_1bit_num3(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int rsvd_lt5_1bit_num3)
{
  reg->bitfields.RSVD_LT5_1BIT_NUM3 = rsvd_lt5_1bit_num3;
  if (reg->bitfields.RSVD_LT5_1BIT_NUM3 != rsvd_lt5_1bit_num3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::RSVD_LT5_1BIT_NUM3 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt5_2bit_num0(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int rsvd_lt5_2bit_num0)
{
  reg->bitfields.RSVD_LT5_2BIT_NUM0 = rsvd_lt5_2bit_num0;
  if (reg->bitfields.RSVD_LT5_2BIT_NUM0 != rsvd_lt5_2bit_num0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::RSVD_LT5_2BIT_NUM0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt5_2bit_num1(regSE_TCL_PER_LIGHT_CNTL_2 *reg, unsigned int rsvd_lt5_2bit_num1)
{
  reg->bitfields.RSVD_LT5_2BIT_NUM1 = rsvd_lt5_2bit_num1;
  if (reg->bitfields.RSVD_LT5_2BIT_NUM1 != rsvd_lt5_2bit_num1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_2::RSVD_LT5_2BIT_NUM1 data too large\n");
}
#else
#define set_SE_TCL_PER_LIGHT_CNTL_2_light_ena_4(reg, light_ena_4) (reg)->bitfields.LIGHT_ENA_4 = light_ena_4
#define set_SE_TCL_PER_LIGHT_CNTL_2_ambient_ena_4(reg, ambient_ena_4) (reg)->bitfields.AMBIENT_ENA_4 = ambient_ena_4
#define set_SE_TCL_PER_LIGHT_CNTL_2_specular_ena_4(reg, specular_ena_4) (reg)->bitfields.SPECULAR_ENA_4 = specular_ena_4
#define set_SE_TCL_PER_LIGHT_CNTL_2_local_light_4(reg, local_light_4) (reg)->bitfields.LOCAL_LIGHT_4 = local_light_4
#define set_SE_TCL_PER_LIGHT_CNTL_2_spot_ena_4(reg, spot_ena_4) (reg)->bitfields.SPOT_ENA_4 = spot_ena_4
#define set_SE_TCL_PER_LIGHT_CNTL_2_spot_dual_cone_4(reg, spot_dual_cone_4) (reg)->bitfields.SPOT_DUAL_CONE_4 = spot_dual_cone_4
#define set_SE_TCL_PER_LIGHT_CNTL_2_rng_att_ena_4(reg, rng_att_ena_4) (reg)->bitfields.RNG_ATT_ENA_4 = rng_att_ena_4
#define set_SE_TCL_PER_LIGHT_CNTL_2_rng_att_constant_ena_4(reg, rng_att_constant_ena_4) (reg)->bitfields.RNG_ATT_CONSTANT_ENA_4 = rng_att_constant_ena_4
#define set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt4_1bit_num0(reg, rsvd_lt4_1bit_num0) (reg)->bitfields.RSVD_LT4_1BIT_NUM0 = rsvd_lt4_1bit_num0
#define set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt4_1bit_num1(reg, rsvd_lt4_1bit_num1) (reg)->bitfields.RSVD_LT4_1BIT_NUM1 = rsvd_lt4_1bit_num1
#define set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt4_1bit_num2(reg, rsvd_lt4_1bit_num2) (reg)->bitfields.RSVD_LT4_1BIT_NUM2 = rsvd_lt4_1bit_num2
#define set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt4_1bit_num3(reg, rsvd_lt4_1bit_num3) (reg)->bitfields.RSVD_LT4_1BIT_NUM3 = rsvd_lt4_1bit_num3
#define set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt4_2bit_num0(reg, rsvd_lt4_2bit_num0) (reg)->bitfields.RSVD_LT4_2BIT_NUM0 = rsvd_lt4_2bit_num0
#define set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt4_2bit_num1(reg, rsvd_lt4_2bit_num1) (reg)->bitfields.RSVD_LT4_2BIT_NUM1 = rsvd_lt4_2bit_num1
#define set_SE_TCL_PER_LIGHT_CNTL_2_light_ena_5(reg, light_ena_5) (reg)->bitfields.LIGHT_ENA_5 = light_ena_5
#define set_SE_TCL_PER_LIGHT_CNTL_2_ambient_ena_5(reg, ambient_ena_5) (reg)->bitfields.AMBIENT_ENA_5 = ambient_ena_5
#define set_SE_TCL_PER_LIGHT_CNTL_2_specular_ena_5(reg, specular_ena_5) (reg)->bitfields.SPECULAR_ENA_5 = specular_ena_5
#define set_SE_TCL_PER_LIGHT_CNTL_2_local_light_5(reg, local_light_5) (reg)->bitfields.LOCAL_LIGHT_5 = local_light_5
#define set_SE_TCL_PER_LIGHT_CNTL_2_spot_ena_5(reg, spot_ena_5) (reg)->bitfields.SPOT_ENA_5 = spot_ena_5
#define set_SE_TCL_PER_LIGHT_CNTL_2_spot_dual_cone_5(reg, spot_dual_cone_5) (reg)->bitfields.SPOT_DUAL_CONE_5 = spot_dual_cone_5
#define set_SE_TCL_PER_LIGHT_CNTL_2_rng_att_ena_5(reg, rng_att_ena_5) (reg)->bitfields.RNG_ATT_ENA_5 = rng_att_ena_5
#define set_SE_TCL_PER_LIGHT_CNTL_2_rng_att_constant_ena_5(reg, rng_att_constant_ena_5) (reg)->bitfields.RNG_ATT_CONSTANT_ENA_5 = rng_att_constant_ena_5
#define set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt5_1bit_num0(reg, rsvd_lt5_1bit_num0) (reg)->bitfields.RSVD_LT5_1BIT_NUM0 = rsvd_lt5_1bit_num0
#define set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt5_1bit_num1(reg, rsvd_lt5_1bit_num1) (reg)->bitfields.RSVD_LT5_1BIT_NUM1 = rsvd_lt5_1bit_num1
#define set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt5_1bit_num2(reg, rsvd_lt5_1bit_num2) (reg)->bitfields.RSVD_LT5_1BIT_NUM2 = rsvd_lt5_1bit_num2
#define set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt5_1bit_num3(reg, rsvd_lt5_1bit_num3) (reg)->bitfields.RSVD_LT5_1BIT_NUM3 = rsvd_lt5_1bit_num3
#define set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt5_2bit_num0(reg, rsvd_lt5_2bit_num0) (reg)->bitfields.RSVD_LT5_2BIT_NUM0 = rsvd_lt5_2bit_num0
#define set_SE_TCL_PER_LIGHT_CNTL_2_rsvd_lt5_2bit_num1(reg, rsvd_lt5_2bit_num1) (reg)->bitfields.RSVD_LT5_2BIT_NUM1 = rsvd_lt5_2bit_num1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_PER_LIGHT_CNTL_3 regSE_TCL_PER_LIGHT_CNTL_3;

#ifdef DEBUG
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_light_ena_6(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int light_ena_6)
{
  reg->bitfields.LIGHT_ENA_6 = light_ena_6;
  if (reg->bitfields.LIGHT_ENA_6 != light_ena_6) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::LIGHT_ENA_6 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_ambient_ena_6(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int ambient_ena_6)
{
  reg->bitfields.AMBIENT_ENA_6 = ambient_ena_6;
  if (reg->bitfields.AMBIENT_ENA_6 != ambient_ena_6) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::AMBIENT_ENA_6 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_specular_ena_6(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int specular_ena_6)
{
  reg->bitfields.SPECULAR_ENA_6 = specular_ena_6;
  if (reg->bitfields.SPECULAR_ENA_6 != specular_ena_6) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::SPECULAR_ENA_6 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_local_light_6(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int local_light_6)
{
  reg->bitfields.LOCAL_LIGHT_6 = local_light_6;
  if (reg->bitfields.LOCAL_LIGHT_6 != local_light_6) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::LOCAL_LIGHT_6 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_spot_ena_6(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int spot_ena_6)
{
  reg->bitfields.SPOT_ENA_6 = spot_ena_6;
  if (reg->bitfields.SPOT_ENA_6 != spot_ena_6) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::SPOT_ENA_6 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_spot_dual_cone_6(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int spot_dual_cone_6)
{
  reg->bitfields.SPOT_DUAL_CONE_6 = spot_dual_cone_6;
  if (reg->bitfields.SPOT_DUAL_CONE_6 != spot_dual_cone_6) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::SPOT_DUAL_CONE_6 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_rng_att_ena_6(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int rng_att_ena_6)
{
  reg->bitfields.RNG_ATT_ENA_6 = rng_att_ena_6;
  if (reg->bitfields.RNG_ATT_ENA_6 != rng_att_ena_6) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::RNG_ATT_ENA_6 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_rng_att_constant_ena_6(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int rng_att_constant_ena_6)
{
  reg->bitfields.RNG_ATT_CONSTANT_ENA_6 = rng_att_constant_ena_6;
  if (reg->bitfields.RNG_ATT_CONSTANT_ENA_6 != rng_att_constant_ena_6) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::RNG_ATT_CONSTANT_ENA_6 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt6_1bit_num0(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int rsvd_lt6_1bit_num0)
{
  reg->bitfields.RSVD_LT6_1BIT_NUM0 = rsvd_lt6_1bit_num0;
  if (reg->bitfields.RSVD_LT6_1BIT_NUM0 != rsvd_lt6_1bit_num0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::RSVD_LT6_1BIT_NUM0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt6_1bit_num1(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int rsvd_lt6_1bit_num1)
{
  reg->bitfields.RSVD_LT6_1BIT_NUM1 = rsvd_lt6_1bit_num1;
  if (reg->bitfields.RSVD_LT6_1BIT_NUM1 != rsvd_lt6_1bit_num1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::RSVD_LT6_1BIT_NUM1 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt6_1bit_num2(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int rsvd_lt6_1bit_num2)
{
  reg->bitfields.RSVD_LT6_1BIT_NUM2 = rsvd_lt6_1bit_num2;
  if (reg->bitfields.RSVD_LT6_1BIT_NUM2 != rsvd_lt6_1bit_num2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::RSVD_LT6_1BIT_NUM2 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt6_1bit_num3(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int rsvd_lt6_1bit_num3)
{
  reg->bitfields.RSVD_LT6_1BIT_NUM3 = rsvd_lt6_1bit_num3;
  if (reg->bitfields.RSVD_LT6_1BIT_NUM3 != rsvd_lt6_1bit_num3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::RSVD_LT6_1BIT_NUM3 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt6_2bit_num0(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int rsvd_lt6_2bit_num0)
{
  reg->bitfields.RSVD_LT6_2BIT_NUM0 = rsvd_lt6_2bit_num0;
  if (reg->bitfields.RSVD_LT6_2BIT_NUM0 != rsvd_lt6_2bit_num0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::RSVD_LT6_2BIT_NUM0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt6_2bit_num1(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int rsvd_lt6_2bit_num1)
{
  reg->bitfields.RSVD_LT6_2BIT_NUM1 = rsvd_lt6_2bit_num1;
  if (reg->bitfields.RSVD_LT6_2BIT_NUM1 != rsvd_lt6_2bit_num1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::RSVD_LT6_2BIT_NUM1 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_light_ena_7(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int light_ena_7)
{
  reg->bitfields.LIGHT_ENA_7 = light_ena_7;
  if (reg->bitfields.LIGHT_ENA_7 != light_ena_7) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::LIGHT_ENA_7 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_ambient_ena_7(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int ambient_ena_7)
{
  reg->bitfields.AMBIENT_ENA_7 = ambient_ena_7;
  if (reg->bitfields.AMBIENT_ENA_7 != ambient_ena_7) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::AMBIENT_ENA_7 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_specular_ena_7(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int specular_ena_7)
{
  reg->bitfields.SPECULAR_ENA_7 = specular_ena_7;
  if (reg->bitfields.SPECULAR_ENA_7 != specular_ena_7) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::SPECULAR_ENA_7 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_local_light_7(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int local_light_7)
{
  reg->bitfields.LOCAL_LIGHT_7 = local_light_7;
  if (reg->bitfields.LOCAL_LIGHT_7 != local_light_7) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::LOCAL_LIGHT_7 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_spot_ena_7(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int spot_ena_7)
{
  reg->bitfields.SPOT_ENA_7 = spot_ena_7;
  if (reg->bitfields.SPOT_ENA_7 != spot_ena_7) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::SPOT_ENA_7 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_spot_dual_cone_7(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int spot_dual_cone_7)
{
  reg->bitfields.SPOT_DUAL_CONE_7 = spot_dual_cone_7;
  if (reg->bitfields.SPOT_DUAL_CONE_7 != spot_dual_cone_7) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::SPOT_DUAL_CONE_7 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_rng_att_ena_7(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int rng_att_ena_7)
{
  reg->bitfields.RNG_ATT_ENA_7 = rng_att_ena_7;
  if (reg->bitfields.RNG_ATT_ENA_7 != rng_att_ena_7) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::RNG_ATT_ENA_7 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_rng_att_constant_ena_7(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int rng_att_constant_ena_7)
{
  reg->bitfields.RNG_ATT_CONSTANT_ENA_7 = rng_att_constant_ena_7;
  if (reg->bitfields.RNG_ATT_CONSTANT_ENA_7 != rng_att_constant_ena_7) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::RNG_ATT_CONSTANT_ENA_7 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt7_1bit_num0(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int rsvd_lt7_1bit_num0)
{
  reg->bitfields.RSVD_LT7_1BIT_NUM0 = rsvd_lt7_1bit_num0;
  if (reg->bitfields.RSVD_LT7_1BIT_NUM0 != rsvd_lt7_1bit_num0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::RSVD_LT7_1BIT_NUM0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt7_1bit_num1(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int rsvd_lt7_1bit_num1)
{
  reg->bitfields.RSVD_LT7_1BIT_NUM1 = rsvd_lt7_1bit_num1;
  if (reg->bitfields.RSVD_LT7_1BIT_NUM1 != rsvd_lt7_1bit_num1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::RSVD_LT7_1BIT_NUM1 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt7_1bit_num2(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int rsvd_lt7_1bit_num2)
{
  reg->bitfields.RSVD_LT7_1BIT_NUM2 = rsvd_lt7_1bit_num2;
  if (reg->bitfields.RSVD_LT7_1BIT_NUM2 != rsvd_lt7_1bit_num2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::RSVD_LT7_1BIT_NUM2 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt7_1bit_num3(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int rsvd_lt7_1bit_num3)
{
  reg->bitfields.RSVD_LT7_1BIT_NUM3 = rsvd_lt7_1bit_num3;
  if (reg->bitfields.RSVD_LT7_1BIT_NUM3 != rsvd_lt7_1bit_num3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::RSVD_LT7_1BIT_NUM3 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt7_2bit_num0(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int rsvd_lt7_2bit_num0)
{
  reg->bitfields.RSVD_LT7_2BIT_NUM0 = rsvd_lt7_2bit_num0;
  if (reg->bitfields.RSVD_LT7_2BIT_NUM0 != rsvd_lt7_2bit_num0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::RSVD_LT7_2BIT_NUM0 data too large\n");
}
__inline void set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt7_2bit_num1(regSE_TCL_PER_LIGHT_CNTL_3 *reg, unsigned int rsvd_lt7_2bit_num1)
{
  reg->bitfields.RSVD_LT7_2BIT_NUM1 = rsvd_lt7_2bit_num1;
  if (reg->bitfields.RSVD_LT7_2BIT_NUM1 != rsvd_lt7_2bit_num1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_PER_LIGHT_CNTL_3::RSVD_LT7_2BIT_NUM1 data too large\n");
}
#else
#define set_SE_TCL_PER_LIGHT_CNTL_3_light_ena_6(reg, light_ena_6) (reg)->bitfields.LIGHT_ENA_6 = light_ena_6
#define set_SE_TCL_PER_LIGHT_CNTL_3_ambient_ena_6(reg, ambient_ena_6) (reg)->bitfields.AMBIENT_ENA_6 = ambient_ena_6
#define set_SE_TCL_PER_LIGHT_CNTL_3_specular_ena_6(reg, specular_ena_6) (reg)->bitfields.SPECULAR_ENA_6 = specular_ena_6
#define set_SE_TCL_PER_LIGHT_CNTL_3_local_light_6(reg, local_light_6) (reg)->bitfields.LOCAL_LIGHT_6 = local_light_6
#define set_SE_TCL_PER_LIGHT_CNTL_3_spot_ena_6(reg, spot_ena_6) (reg)->bitfields.SPOT_ENA_6 = spot_ena_6
#define set_SE_TCL_PER_LIGHT_CNTL_3_spot_dual_cone_6(reg, spot_dual_cone_6) (reg)->bitfields.SPOT_DUAL_CONE_6 = spot_dual_cone_6
#define set_SE_TCL_PER_LIGHT_CNTL_3_rng_att_ena_6(reg, rng_att_ena_6) (reg)->bitfields.RNG_ATT_ENA_6 = rng_att_ena_6
#define set_SE_TCL_PER_LIGHT_CNTL_3_rng_att_constant_ena_6(reg, rng_att_constant_ena_6) (reg)->bitfields.RNG_ATT_CONSTANT_ENA_6 = rng_att_constant_ena_6
#define set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt6_1bit_num0(reg, rsvd_lt6_1bit_num0) (reg)->bitfields.RSVD_LT6_1BIT_NUM0 = rsvd_lt6_1bit_num0
#define set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt6_1bit_num1(reg, rsvd_lt6_1bit_num1) (reg)->bitfields.RSVD_LT6_1BIT_NUM1 = rsvd_lt6_1bit_num1
#define set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt6_1bit_num2(reg, rsvd_lt6_1bit_num2) (reg)->bitfields.RSVD_LT6_1BIT_NUM2 = rsvd_lt6_1bit_num2
#define set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt6_1bit_num3(reg, rsvd_lt6_1bit_num3) (reg)->bitfields.RSVD_LT6_1BIT_NUM3 = rsvd_lt6_1bit_num3
#define set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt6_2bit_num0(reg, rsvd_lt6_2bit_num0) (reg)->bitfields.RSVD_LT6_2BIT_NUM0 = rsvd_lt6_2bit_num0
#define set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt6_2bit_num1(reg, rsvd_lt6_2bit_num1) (reg)->bitfields.RSVD_LT6_2BIT_NUM1 = rsvd_lt6_2bit_num1
#define set_SE_TCL_PER_LIGHT_CNTL_3_light_ena_7(reg, light_ena_7) (reg)->bitfields.LIGHT_ENA_7 = light_ena_7
#define set_SE_TCL_PER_LIGHT_CNTL_3_ambient_ena_7(reg, ambient_ena_7) (reg)->bitfields.AMBIENT_ENA_7 = ambient_ena_7
#define set_SE_TCL_PER_LIGHT_CNTL_3_specular_ena_7(reg, specular_ena_7) (reg)->bitfields.SPECULAR_ENA_7 = specular_ena_7
#define set_SE_TCL_PER_LIGHT_CNTL_3_local_light_7(reg, local_light_7) (reg)->bitfields.LOCAL_LIGHT_7 = local_light_7
#define set_SE_TCL_PER_LIGHT_CNTL_3_spot_ena_7(reg, spot_ena_7) (reg)->bitfields.SPOT_ENA_7 = spot_ena_7
#define set_SE_TCL_PER_LIGHT_CNTL_3_spot_dual_cone_7(reg, spot_dual_cone_7) (reg)->bitfields.SPOT_DUAL_CONE_7 = spot_dual_cone_7
#define set_SE_TCL_PER_LIGHT_CNTL_3_rng_att_ena_7(reg, rng_att_ena_7) (reg)->bitfields.RNG_ATT_ENA_7 = rng_att_ena_7
#define set_SE_TCL_PER_LIGHT_CNTL_3_rng_att_constant_ena_7(reg, rng_att_constant_ena_7) (reg)->bitfields.RNG_ATT_CONSTANT_ENA_7 = rng_att_constant_ena_7
#define set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt7_1bit_num0(reg, rsvd_lt7_1bit_num0) (reg)->bitfields.RSVD_LT7_1BIT_NUM0 = rsvd_lt7_1bit_num0
#define set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt7_1bit_num1(reg, rsvd_lt7_1bit_num1) (reg)->bitfields.RSVD_LT7_1BIT_NUM1 = rsvd_lt7_1bit_num1
#define set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt7_1bit_num2(reg, rsvd_lt7_1bit_num2) (reg)->bitfields.RSVD_LT7_1BIT_NUM2 = rsvd_lt7_1bit_num2
#define set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt7_1bit_num3(reg, rsvd_lt7_1bit_num3) (reg)->bitfields.RSVD_LT7_1BIT_NUM3 = rsvd_lt7_1bit_num3
#define set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt7_2bit_num0(reg, rsvd_lt7_2bit_num0) (reg)->bitfields.RSVD_LT7_2BIT_NUM0 = rsvd_lt7_2bit_num0
#define set_SE_TCL_PER_LIGHT_CNTL_3_rsvd_lt7_2bit_num1(reg, rsvd_lt7_2bit_num1) (reg)->bitfields.RSVD_LT7_2BIT_NUM1 = rsvd_lt7_2bit_num1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_DEBUG_0 regSE_TCL_DEBUG_0;

#ifdef DEBUG
__inline void set_SE_TCL_DEBUG_0_debug_rd_sel_ena(regSE_TCL_DEBUG_0 *reg, unsigned int debug_rd_sel_ena)
{
  reg->bitfields.DEBUG_RD_SEL_ENA = debug_rd_sel_ena;
  if (reg->bitfields.DEBUG_RD_SEL_ENA != debug_rd_sel_ena) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_DEBUG_0::DEBUG_RD_SEL_ENA data too large\n");
}
__inline void set_SE_TCL_DEBUG_0_debug_rd_sel(regSE_TCL_DEBUG_0 *reg, unsigned int debug_rd_sel)
{
  reg->bitfields.DEBUG_RD_SEL = debug_rd_sel;
  if (reg->bitfields.DEBUG_RD_SEL != debug_rd_sel) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_DEBUG_0::DEBUG_RD_SEL data too large\n");
}
__inline void set_SE_TCL_DEBUG_0_debug_imm_rd(regSE_TCL_DEBUG_0 *reg, unsigned int debug_imm_rd)
{
  reg->bitfields.DEBUG_IMM_RD = debug_imm_rd;
  if (reg->bitfields.DEBUG_IMM_RD != debug_imm_rd) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_DEBUG_0::DEBUG_IMM_RD data too large\n");
}
__inline void set_SE_TCL_DEBUG_0_st_upd_fifo_sz(regSE_TCL_DEBUG_0 *reg, unsigned int st_upd_fifo_sz)
{
  reg->bitfields.ST_UPD_FIFO_SZ = st_upd_fifo_sz;
  if (reg->bitfields.ST_UPD_FIFO_SZ != st_upd_fifo_sz) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_DEBUG_0::ST_UPD_FIFO_SZ data too large\n");
}
__inline void set_SE_TCL_DEBUG_0_dis_clip_err_detect(regSE_TCL_DEBUG_0 *reg, unsigned int dis_clip_err_detect)
{
  reg->bitfields.DIS_CLIP_ERR_DETECT = dis_clip_err_detect;
  if (reg->bitfields.DIS_CLIP_ERR_DETECT != dis_clip_err_detect) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_DEBUG_0::DIS_CLIP_ERR_DETECT data too large\n");
}
#else
#define set_SE_TCL_DEBUG_0_debug_rd_sel_ena(reg, debug_rd_sel_ena) (reg)->bitfields.DEBUG_RD_SEL_ENA = debug_rd_sel_ena
#define set_SE_TCL_DEBUG_0_debug_rd_sel(reg, debug_rd_sel) (reg)->bitfields.DEBUG_RD_SEL = debug_rd_sel
#define set_SE_TCL_DEBUG_0_debug_imm_rd(reg, debug_imm_rd) (reg)->bitfields.DEBUG_IMM_RD = debug_imm_rd
#define set_SE_TCL_DEBUG_0_st_upd_fifo_sz(reg, st_upd_fifo_sz) (reg)->bitfields.ST_UPD_FIFO_SZ = st_upd_fifo_sz
#define set_SE_TCL_DEBUG_0_dis_clip_err_detect(reg, dis_clip_err_detect) (reg)->bitfields.DIS_CLIP_ERR_DETECT = dis_clip_err_detect

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_STATE_FLUSH_REG regSE_TCL_STATE_FLUSH_REG;

#ifdef DEBUG
__inline void set_SE_TCL_STATE_FLUSH_REG_data_register(regSE_TCL_STATE_FLUSH_REG *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_STATE_FLUSH_REG::DATA_REGISTER data too large\n");
}
#else
#define set_SE_TCL_STATE_FLUSH_REG_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_FPU_LATENCY regSE_TCL_FPU_LATENCY;

#ifdef DEBUG
__inline void set_SE_TCL_FPU_LATENCY_ve_eng_latency(regSE_TCL_FPU_LATENCY *reg, unsigned int ve_eng_latency)
{
  reg->bitfields.VE_ENG_LATENCY = ve_eng_latency;
  if (reg->bitfields.VE_ENG_LATENCY != ve_eng_latency) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_FPU_LATENCY::VE_ENG_LATENCY data too large\n");
}
__inline void set_SE_TCL_FPU_LATENCY_ve_mult_latency(regSE_TCL_FPU_LATENCY *reg, unsigned int ve_mult_latency)
{
  reg->bitfields.VE_MULT_LATENCY = ve_mult_latency;
  if (reg->bitfields.VE_MULT_LATENCY != ve_mult_latency) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_FPU_LATENCY::VE_MULT_LATENCY data too large\n");
}
__inline void set_SE_TCL_FPU_LATENCY_ve_accum_latency(regSE_TCL_FPU_LATENCY *reg, unsigned int ve_accum_latency)
{
  reg->bitfields.VE_ACCUM_LATENCY = ve_accum_latency;
  if (reg->bitfields.VE_ACCUM_LATENCY != ve_accum_latency) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_FPU_LATENCY::VE_ACCUM_LATENCY data too large\n");
}
__inline void set_SE_TCL_FPU_LATENCY_sc_eng_latency(regSE_TCL_FPU_LATENCY *reg, unsigned int sc_eng_latency)
{
  reg->bitfields.SC_ENG_LATENCY = sc_eng_latency;
  if (reg->bitfields.SC_ENG_LATENCY != sc_eng_latency) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_FPU_LATENCY::SC_ENG_LATENCY data too large\n");
}
__inline void set_SE_TCL_FPU_LATENCY_ve_out_latency(regSE_TCL_FPU_LATENCY *reg, unsigned int ve_out_latency)
{
  reg->bitfields.VE_OUT_LATENCY = ve_out_latency;
  if (reg->bitfields.VE_OUT_LATENCY != ve_out_latency) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_FPU_LATENCY::VE_OUT_LATENCY data too large\n");
}
__inline void set_SE_TCL_FPU_LATENCY_sc_math_latency(regSE_TCL_FPU_LATENCY *reg, unsigned int sc_math_latency)
{
  reg->bitfields.SC_MATH_LATENCY = sc_math_latency;
  if (reg->bitfields.SC_MATH_LATENCY != sc_math_latency) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_FPU_LATENCY::SC_MATH_LATENCY data too large\n");
}
__inline void set_SE_TCL_FPU_LATENCY_rsvd_ltncy_2bit(regSE_TCL_FPU_LATENCY *reg, unsigned int rsvd_ltncy_2bit)
{
  reg->bitfields.RSVD_LTNCY_2BIT = rsvd_ltncy_2bit;
  if (reg->bitfields.RSVD_LTNCY_2BIT != rsvd_ltncy_2bit) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_FPU_LATENCY::RSVD_LTNCY_2BIT data too large\n");
}
#else
#define set_SE_TCL_FPU_LATENCY_ve_eng_latency(reg, ve_eng_latency) (reg)->bitfields.VE_ENG_LATENCY = ve_eng_latency
#define set_SE_TCL_FPU_LATENCY_ve_mult_latency(reg, ve_mult_latency) (reg)->bitfields.VE_MULT_LATENCY = ve_mult_latency
#define set_SE_TCL_FPU_LATENCY_ve_accum_latency(reg, ve_accum_latency) (reg)->bitfields.VE_ACCUM_LATENCY = ve_accum_latency
#define set_SE_TCL_FPU_LATENCY_sc_eng_latency(reg, sc_eng_latency) (reg)->bitfields.SC_ENG_LATENCY = sc_eng_latency
#define set_SE_TCL_FPU_LATENCY_ve_out_latency(reg, ve_out_latency) (reg)->bitfields.VE_OUT_LATENCY = ve_out_latency
#define set_SE_TCL_FPU_LATENCY_sc_math_latency(reg, sc_math_latency) (reg)->bitfields.SC_MATH_LATENCY = sc_math_latency
#define set_SE_TCL_FPU_LATENCY_rsvd_ltncy_2bit(reg, rsvd_ltncy_2bit) (reg)->bitfields.RSVD_LTNCY_2BIT = rsvd_ltncy_2bit

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_TEX_PROC_CNTL_2 regSE_TCL_TEX_PROC_CNTL_2;

#ifdef DEBUG
__inline void set_SE_TCL_TEX_PROC_CNTL_2_tcg_comp_mask_0(regSE_TCL_TEX_PROC_CNTL_2 *reg, unsigned int tcg_comp_mask_0)
{
  reg->bitfields.TCG_COMP_MASK_0 = tcg_comp_mask_0;
  if (reg->bitfields.TCG_COMP_MASK_0 != tcg_comp_mask_0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_2::TCG_COMP_MASK_0 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_2_tcg_comp_mask_1(regSE_TCL_TEX_PROC_CNTL_2 *reg, unsigned int tcg_comp_mask_1)
{
  reg->bitfields.TCG_COMP_MASK_1 = tcg_comp_mask_1;
  if (reg->bitfields.TCG_COMP_MASK_1 != tcg_comp_mask_1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_2::TCG_COMP_MASK_1 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_2_tcg_comp_mask_2(regSE_TCL_TEX_PROC_CNTL_2 *reg, unsigned int tcg_comp_mask_2)
{
  reg->bitfields.TCG_COMP_MASK_2 = tcg_comp_mask_2;
  if (reg->bitfields.TCG_COMP_MASK_2 != tcg_comp_mask_2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_2::TCG_COMP_MASK_2 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_2_tcg_comp_mask_3(regSE_TCL_TEX_PROC_CNTL_2 *reg, unsigned int tcg_comp_mask_3)
{
  reg->bitfields.TCG_COMP_MASK_3 = tcg_comp_mask_3;
  if (reg->bitfields.TCG_COMP_MASK_3 != tcg_comp_mask_3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_2::TCG_COMP_MASK_3 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_2_tcg_comp_mask_4(regSE_TCL_TEX_PROC_CNTL_2 *reg, unsigned int tcg_comp_mask_4)
{
  reg->bitfields.TCG_COMP_MASK_4 = tcg_comp_mask_4;
  if (reg->bitfields.TCG_COMP_MASK_4 != tcg_comp_mask_4) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_2::TCG_COMP_MASK_4 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_2_tcg_comp_mask_5(regSE_TCL_TEX_PROC_CNTL_2 *reg, unsigned int tcg_comp_mask_5)
{
  reg->bitfields.TCG_COMP_MASK_5 = tcg_comp_mask_5;
  if (reg->bitfields.TCG_COMP_MASK_5 != tcg_comp_mask_5) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_2::TCG_COMP_MASK_5 data too large\n");
}
#else
#define set_SE_TCL_TEX_PROC_CNTL_2_tcg_comp_mask_0(reg, tcg_comp_mask_0) (reg)->bitfields.TCG_COMP_MASK_0 = tcg_comp_mask_0
#define set_SE_TCL_TEX_PROC_CNTL_2_tcg_comp_mask_1(reg, tcg_comp_mask_1) (reg)->bitfields.TCG_COMP_MASK_1 = tcg_comp_mask_1
#define set_SE_TCL_TEX_PROC_CNTL_2_tcg_comp_mask_2(reg, tcg_comp_mask_2) (reg)->bitfields.TCG_COMP_MASK_2 = tcg_comp_mask_2
#define set_SE_TCL_TEX_PROC_CNTL_2_tcg_comp_mask_3(reg, tcg_comp_mask_3) (reg)->bitfields.TCG_COMP_MASK_3 = tcg_comp_mask_3
#define set_SE_TCL_TEX_PROC_CNTL_2_tcg_comp_mask_4(reg, tcg_comp_mask_4) (reg)->bitfields.TCG_COMP_MASK_4 = tcg_comp_mask_4
#define set_SE_TCL_TEX_PROC_CNTL_2_tcg_comp_mask_5(reg, tcg_comp_mask_5) (reg)->bitfields.TCG_COMP_MASK_5 = tcg_comp_mask_5

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_TEX_PROC_CNTL_3 regSE_TCL_TEX_PROC_CNTL_3;

#ifdef DEBUG
__inline void set_SE_TCL_TEX_PROC_CNTL_3_tcg_input_tex_0(regSE_TCL_TEX_PROC_CNTL_3 *reg, unsigned int tcg_input_tex_0)
{
  reg->bitfields.TCG_INPUT_TEX_0 = tcg_input_tex_0;
  if (reg->bitfields.TCG_INPUT_TEX_0 != tcg_input_tex_0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_3::TCG_INPUT_TEX_0 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_3_tcg_input_tex_1(regSE_TCL_TEX_PROC_CNTL_3 *reg, unsigned int tcg_input_tex_1)
{
  reg->bitfields.TCG_INPUT_TEX_1 = tcg_input_tex_1;
  if (reg->bitfields.TCG_INPUT_TEX_1 != tcg_input_tex_1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_3::TCG_INPUT_TEX_1 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_3_tcg_input_tex_2(regSE_TCL_TEX_PROC_CNTL_3 *reg, unsigned int tcg_input_tex_2)
{
  reg->bitfields.TCG_INPUT_TEX_2 = tcg_input_tex_2;
  if (reg->bitfields.TCG_INPUT_TEX_2 != tcg_input_tex_2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_3::TCG_INPUT_TEX_2 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_3_tcg_input_tex_3(regSE_TCL_TEX_PROC_CNTL_3 *reg, unsigned int tcg_input_tex_3)
{
  reg->bitfields.TCG_INPUT_TEX_3 = tcg_input_tex_3;
  if (reg->bitfields.TCG_INPUT_TEX_3 != tcg_input_tex_3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_3::TCG_INPUT_TEX_3 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_3_tcg_input_tex_4(regSE_TCL_TEX_PROC_CNTL_3 *reg, unsigned int tcg_input_tex_4)
{
  reg->bitfields.TCG_INPUT_TEX_4 = tcg_input_tex_4;
  if (reg->bitfields.TCG_INPUT_TEX_4 != tcg_input_tex_4) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_3::TCG_INPUT_TEX_4 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_3_tcg_input_tex_5(regSE_TCL_TEX_PROC_CNTL_3 *reg, unsigned int tcg_input_tex_5)
{
  reg->bitfields.TCG_INPUT_TEX_5 = tcg_input_tex_5;
  if (reg->bitfields.TCG_INPUT_TEX_5 != tcg_input_tex_5) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_3::TCG_INPUT_TEX_5 data too large\n");
}
#else
#define set_SE_TCL_TEX_PROC_CNTL_3_tcg_input_tex_0(reg, tcg_input_tex_0) (reg)->bitfields.TCG_INPUT_TEX_0 = tcg_input_tex_0
#define set_SE_TCL_TEX_PROC_CNTL_3_tcg_input_tex_1(reg, tcg_input_tex_1) (reg)->bitfields.TCG_INPUT_TEX_1 = tcg_input_tex_1
#define set_SE_TCL_TEX_PROC_CNTL_3_tcg_input_tex_2(reg, tcg_input_tex_2) (reg)->bitfields.TCG_INPUT_TEX_2 = tcg_input_tex_2
#define set_SE_TCL_TEX_PROC_CNTL_3_tcg_input_tex_3(reg, tcg_input_tex_3) (reg)->bitfields.TCG_INPUT_TEX_3 = tcg_input_tex_3
#define set_SE_TCL_TEX_PROC_CNTL_3_tcg_input_tex_4(reg, tcg_input_tex_4) (reg)->bitfields.TCG_INPUT_TEX_4 = tcg_input_tex_4
#define set_SE_TCL_TEX_PROC_CNTL_3_tcg_input_tex_5(reg, tcg_input_tex_5) (reg)->bitfields.TCG_INPUT_TEX_5 = tcg_input_tex_5

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_TEX_PROC_CNTL_0 regSE_TCL_TEX_PROC_CNTL_0;

#ifdef DEBUG
__inline void set_SE_TCL_TEX_PROC_CNTL_0_tex_cs_proc_ena_0(regSE_TCL_TEX_PROC_CNTL_0 *reg, unsigned int tex_cs_proc_ena_0)
{
  reg->bitfields.TEX_CS_PROC_ENA_0 = tex_cs_proc_ena_0;
  if (reg->bitfields.TEX_CS_PROC_ENA_0 != tex_cs_proc_ena_0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_0::TEX_CS_PROC_ENA_0 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_0_tex_cs_proc_ena_1(regSE_TCL_TEX_PROC_CNTL_0 *reg, unsigned int tex_cs_proc_ena_1)
{
  reg->bitfields.TEX_CS_PROC_ENA_1 = tex_cs_proc_ena_1;
  if (reg->bitfields.TEX_CS_PROC_ENA_1 != tex_cs_proc_ena_1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_0::TEX_CS_PROC_ENA_1 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_0_tex_cs_proc_ena_2(regSE_TCL_TEX_PROC_CNTL_0 *reg, unsigned int tex_cs_proc_ena_2)
{
  reg->bitfields.TEX_CS_PROC_ENA_2 = tex_cs_proc_ena_2;
  if (reg->bitfields.TEX_CS_PROC_ENA_2 != tex_cs_proc_ena_2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_0::TEX_CS_PROC_ENA_2 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_0_tex_cs_proc_ena_3(regSE_TCL_TEX_PROC_CNTL_0 *reg, unsigned int tex_cs_proc_ena_3)
{
  reg->bitfields.TEX_CS_PROC_ENA_3 = tex_cs_proc_ena_3;
  if (reg->bitfields.TEX_CS_PROC_ENA_3 != tex_cs_proc_ena_3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_0::TEX_CS_PROC_ENA_3 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_0_tex_cs_proc_ena_4(regSE_TCL_TEX_PROC_CNTL_0 *reg, unsigned int tex_cs_proc_ena_4)
{
  reg->bitfields.TEX_CS_PROC_ENA_4 = tex_cs_proc_ena_4;
  if (reg->bitfields.TEX_CS_PROC_ENA_4 != tex_cs_proc_ena_4) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_0::TEX_CS_PROC_ENA_4 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_0_tex_cs_proc_ena_5(regSE_TCL_TEX_PROC_CNTL_0 *reg, unsigned int tex_cs_proc_ena_5)
{
  reg->bitfields.TEX_CS_PROC_ENA_5 = tex_cs_proc_ena_5;
  if (reg->bitfields.TEX_CS_PROC_ENA_5 != tex_cs_proc_ena_5) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_0::TEX_CS_PROC_ENA_5 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_0_tex_xform_ena_0(regSE_TCL_TEX_PROC_CNTL_0 *reg, unsigned int tex_xform_ena_0)
{
  reg->bitfields.TEX_XFORM_ENA_0 = tex_xform_ena_0;
  if (reg->bitfields.TEX_XFORM_ENA_0 != tex_xform_ena_0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_0::TEX_XFORM_ENA_0 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_0_tex_xform_ena_1(regSE_TCL_TEX_PROC_CNTL_0 *reg, unsigned int tex_xform_ena_1)
{
  reg->bitfields.TEX_XFORM_ENA_1 = tex_xform_ena_1;
  if (reg->bitfields.TEX_XFORM_ENA_1 != tex_xform_ena_1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_0::TEX_XFORM_ENA_1 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_0_tex_xform_ena_2(regSE_TCL_TEX_PROC_CNTL_0 *reg, unsigned int tex_xform_ena_2)
{
  reg->bitfields.TEX_XFORM_ENA_2 = tex_xform_ena_2;
  if (reg->bitfields.TEX_XFORM_ENA_2 != tex_xform_ena_2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_0::TEX_XFORM_ENA_2 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_0_tex_xform_ena_3(regSE_TCL_TEX_PROC_CNTL_0 *reg, unsigned int tex_xform_ena_3)
{
  reg->bitfields.TEX_XFORM_ENA_3 = tex_xform_ena_3;
  if (reg->bitfields.TEX_XFORM_ENA_3 != tex_xform_ena_3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_0::TEX_XFORM_ENA_3 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_0_tex_xform_ena_4(regSE_TCL_TEX_PROC_CNTL_0 *reg, unsigned int tex_xform_ena_4)
{
  reg->bitfields.TEX_XFORM_ENA_4 = tex_xform_ena_4;
  if (reg->bitfields.TEX_XFORM_ENA_4 != tex_xform_ena_4) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_0::TEX_XFORM_ENA_4 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_0_tex_xform_ena_5(regSE_TCL_TEX_PROC_CNTL_0 *reg, unsigned int tex_xform_ena_5)
{
  reg->bitfields.TEX_XFORM_ENA_5 = tex_xform_ena_5;
  if (reg->bitfields.TEX_XFORM_ENA_5 != tex_xform_ena_5) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_0::TEX_XFORM_ENA_5 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_0_tcg_force_w_to_one(regSE_TCL_TEX_PROC_CNTL_0 *reg, unsigned int tcg_force_w_to_one)
{
  reg->bitfields.TCG_FORCE_W_TO_ONE = tcg_force_w_to_one;
  if (reg->bitfields.TCG_FORCE_W_TO_ONE != tcg_force_w_to_one) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_0::TCG_FORCE_W_TO_ONE data too large\n");
}
#else
#define set_SE_TCL_TEX_PROC_CNTL_0_tex_cs_proc_ena_0(reg, tex_cs_proc_ena_0) (reg)->bitfields.TEX_CS_PROC_ENA_0 = tex_cs_proc_ena_0
#define set_SE_TCL_TEX_PROC_CNTL_0_tex_cs_proc_ena_1(reg, tex_cs_proc_ena_1) (reg)->bitfields.TEX_CS_PROC_ENA_1 = tex_cs_proc_ena_1
#define set_SE_TCL_TEX_PROC_CNTL_0_tex_cs_proc_ena_2(reg, tex_cs_proc_ena_2) (reg)->bitfields.TEX_CS_PROC_ENA_2 = tex_cs_proc_ena_2
#define set_SE_TCL_TEX_PROC_CNTL_0_tex_cs_proc_ena_3(reg, tex_cs_proc_ena_3) (reg)->bitfields.TEX_CS_PROC_ENA_3 = tex_cs_proc_ena_3
#define set_SE_TCL_TEX_PROC_CNTL_0_tex_cs_proc_ena_4(reg, tex_cs_proc_ena_4) (reg)->bitfields.TEX_CS_PROC_ENA_4 = tex_cs_proc_ena_4
#define set_SE_TCL_TEX_PROC_CNTL_0_tex_cs_proc_ena_5(reg, tex_cs_proc_ena_5) (reg)->bitfields.TEX_CS_PROC_ENA_5 = tex_cs_proc_ena_5
#define set_SE_TCL_TEX_PROC_CNTL_0_tex_xform_ena_0(reg, tex_xform_ena_0) (reg)->bitfields.TEX_XFORM_ENA_0 = tex_xform_ena_0
#define set_SE_TCL_TEX_PROC_CNTL_0_tex_xform_ena_1(reg, tex_xform_ena_1) (reg)->bitfields.TEX_XFORM_ENA_1 = tex_xform_ena_1
#define set_SE_TCL_TEX_PROC_CNTL_0_tex_xform_ena_2(reg, tex_xform_ena_2) (reg)->bitfields.TEX_XFORM_ENA_2 = tex_xform_ena_2
#define set_SE_TCL_TEX_PROC_CNTL_0_tex_xform_ena_3(reg, tex_xform_ena_3) (reg)->bitfields.TEX_XFORM_ENA_3 = tex_xform_ena_3
#define set_SE_TCL_TEX_PROC_CNTL_0_tex_xform_ena_4(reg, tex_xform_ena_4) (reg)->bitfields.TEX_XFORM_ENA_4 = tex_xform_ena_4
#define set_SE_TCL_TEX_PROC_CNTL_0_tex_xform_ena_5(reg, tex_xform_ena_5) (reg)->bitfields.TEX_XFORM_ENA_5 = tex_xform_ena_5
#define set_SE_TCL_TEX_PROC_CNTL_0_tcg_force_w_to_one(reg, tcg_force_w_to_one) (reg)->bitfields.TCG_FORCE_W_TO_ONE = tcg_force_w_to_one

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_TEX_PROC_CNTL_1 regSE_TCL_TEX_PROC_CNTL_1;

#ifdef DEBUG
__inline void set_SE_TCL_TEX_PROC_CNTL_1_tex_cs_proc_src_0(regSE_TCL_TEX_PROC_CNTL_1 *reg, unsigned int tex_cs_proc_src_0)
{
  reg->bitfields.TEX_CS_PROC_SRC_0 = tex_cs_proc_src_0;
  if (reg->bitfields.TEX_CS_PROC_SRC_0 != tex_cs_proc_src_0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_1::TEX_CS_PROC_SRC_0 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_1_tex_cs_proc_src_1(regSE_TCL_TEX_PROC_CNTL_1 *reg, unsigned int tex_cs_proc_src_1)
{
  reg->bitfields.TEX_CS_PROC_SRC_1 = tex_cs_proc_src_1;
  if (reg->bitfields.TEX_CS_PROC_SRC_1 != tex_cs_proc_src_1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_1::TEX_CS_PROC_SRC_1 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_1_tex_cs_proc_src_2(regSE_TCL_TEX_PROC_CNTL_1 *reg, unsigned int tex_cs_proc_src_2)
{
  reg->bitfields.TEX_CS_PROC_SRC_2 = tex_cs_proc_src_2;
  if (reg->bitfields.TEX_CS_PROC_SRC_2 != tex_cs_proc_src_2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_1::TEX_CS_PROC_SRC_2 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_1_tex_cs_proc_src_3(regSE_TCL_TEX_PROC_CNTL_1 *reg, unsigned int tex_cs_proc_src_3)
{
  reg->bitfields.TEX_CS_PROC_SRC_3 = tex_cs_proc_src_3;
  if (reg->bitfields.TEX_CS_PROC_SRC_3 != tex_cs_proc_src_3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_1::TEX_CS_PROC_SRC_3 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_1_tex_cs_proc_src_4(regSE_TCL_TEX_PROC_CNTL_1 *reg, unsigned int tex_cs_proc_src_4)
{
  reg->bitfields.TEX_CS_PROC_SRC_4 = tex_cs_proc_src_4;
  if (reg->bitfields.TEX_CS_PROC_SRC_4 != tex_cs_proc_src_4) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_1::TEX_CS_PROC_SRC_4 data too large\n");
}
__inline void set_SE_TCL_TEX_PROC_CNTL_1_tex_cs_proc_src_5(regSE_TCL_TEX_PROC_CNTL_1 *reg, unsigned int tex_cs_proc_src_5)
{
  reg->bitfields.TEX_CS_PROC_SRC_5 = tex_cs_proc_src_5;
  if (reg->bitfields.TEX_CS_PROC_SRC_5 != tex_cs_proc_src_5) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_PROC_CNTL_1::TEX_CS_PROC_SRC_5 data too large\n");
}
#else
#define set_SE_TCL_TEX_PROC_CNTL_1_tex_cs_proc_src_0(reg, tex_cs_proc_src_0) (reg)->bitfields.TEX_CS_PROC_SRC_0 = tex_cs_proc_src_0
#define set_SE_TCL_TEX_PROC_CNTL_1_tex_cs_proc_src_1(reg, tex_cs_proc_src_1) (reg)->bitfields.TEX_CS_PROC_SRC_1 = tex_cs_proc_src_1
#define set_SE_TCL_TEX_PROC_CNTL_1_tex_cs_proc_src_2(reg, tex_cs_proc_src_2) (reg)->bitfields.TEX_CS_PROC_SRC_2 = tex_cs_proc_src_2
#define set_SE_TCL_TEX_PROC_CNTL_1_tex_cs_proc_src_3(reg, tex_cs_proc_src_3) (reg)->bitfields.TEX_CS_PROC_SRC_3 = tex_cs_proc_src_3
#define set_SE_TCL_TEX_PROC_CNTL_1_tex_cs_proc_src_4(reg, tex_cs_proc_src_4) (reg)->bitfields.TEX_CS_PROC_SRC_4 = tex_cs_proc_src_4
#define set_SE_TCL_TEX_PROC_CNTL_1_tex_cs_proc_src_5(reg, tex_cs_proc_src_5) (reg)->bitfields.TEX_CS_PROC_SRC_5 = tex_cs_proc_src_5

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_TEX_CYL_WRAP_CNTL regSE_TCL_TEX_CYL_WRAP_CNTL;

#ifdef DEBUG
__inline void set_SE_TCL_TEX_CYL_WRAP_CNTL_tex_cyl_wrap_0(regSE_TCL_TEX_CYL_WRAP_CNTL *reg, unsigned int tex_cyl_wrap_0)
{
  reg->bitfields.TEX_CYL_WRAP_0 = tex_cyl_wrap_0;
  if (reg->bitfields.TEX_CYL_WRAP_0 != tex_cyl_wrap_0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_CYL_WRAP_CNTL::TEX_CYL_WRAP_0 data too large\n");
}
__inline void set_SE_TCL_TEX_CYL_WRAP_CNTL_tex_cyl_wrap_1(regSE_TCL_TEX_CYL_WRAP_CNTL *reg, unsigned int tex_cyl_wrap_1)
{
  reg->bitfields.TEX_CYL_WRAP_1 = tex_cyl_wrap_1;
  if (reg->bitfields.TEX_CYL_WRAP_1 != tex_cyl_wrap_1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_CYL_WRAP_CNTL::TEX_CYL_WRAP_1 data too large\n");
}
__inline void set_SE_TCL_TEX_CYL_WRAP_CNTL_tex_cyl_wrap_2(regSE_TCL_TEX_CYL_WRAP_CNTL *reg, unsigned int tex_cyl_wrap_2)
{
  reg->bitfields.TEX_CYL_WRAP_2 = tex_cyl_wrap_2;
  if (reg->bitfields.TEX_CYL_WRAP_2 != tex_cyl_wrap_2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_CYL_WRAP_CNTL::TEX_CYL_WRAP_2 data too large\n");
}
__inline void set_SE_TCL_TEX_CYL_WRAP_CNTL_tex_cyl_wrap_3(regSE_TCL_TEX_CYL_WRAP_CNTL *reg, unsigned int tex_cyl_wrap_3)
{
  reg->bitfields.TEX_CYL_WRAP_3 = tex_cyl_wrap_3;
  if (reg->bitfields.TEX_CYL_WRAP_3 != tex_cyl_wrap_3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_CYL_WRAP_CNTL::TEX_CYL_WRAP_3 data too large\n");
}
__inline void set_SE_TCL_TEX_CYL_WRAP_CNTL_tex_cyl_wrap_4(regSE_TCL_TEX_CYL_WRAP_CNTL *reg, unsigned int tex_cyl_wrap_4)
{
  reg->bitfields.TEX_CYL_WRAP_4 = tex_cyl_wrap_4;
  if (reg->bitfields.TEX_CYL_WRAP_4 != tex_cyl_wrap_4) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_CYL_WRAP_CNTL::TEX_CYL_WRAP_4 data too large\n");
}
__inline void set_SE_TCL_TEX_CYL_WRAP_CNTL_tex_cyl_wrap_5(regSE_TCL_TEX_CYL_WRAP_CNTL *reg, unsigned int tex_cyl_wrap_5)
{
  reg->bitfields.TEX_CYL_WRAP_5 = tex_cyl_wrap_5;
  if (reg->bitfields.TEX_CYL_WRAP_5 != tex_cyl_wrap_5) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_TEX_CYL_WRAP_CNTL::TEX_CYL_WRAP_5 data too large\n");
}
#else
#define set_SE_TCL_TEX_CYL_WRAP_CNTL_tex_cyl_wrap_0(reg, tex_cyl_wrap_0) (reg)->bitfields.TEX_CYL_WRAP_0 = tex_cyl_wrap_0
#define set_SE_TCL_TEX_CYL_WRAP_CNTL_tex_cyl_wrap_1(reg, tex_cyl_wrap_1) (reg)->bitfields.TEX_CYL_WRAP_1 = tex_cyl_wrap_1
#define set_SE_TCL_TEX_CYL_WRAP_CNTL_tex_cyl_wrap_2(reg, tex_cyl_wrap_2) (reg)->bitfields.TEX_CYL_WRAP_2 = tex_cyl_wrap_2
#define set_SE_TCL_TEX_CYL_WRAP_CNTL_tex_cyl_wrap_3(reg, tex_cyl_wrap_3) (reg)->bitfields.TEX_CYL_WRAP_3 = tex_cyl_wrap_3
#define set_SE_TCL_TEX_CYL_WRAP_CNTL_tex_cyl_wrap_4(reg, tex_cyl_wrap_4) (reg)->bitfields.TEX_CYL_WRAP_4 = tex_cyl_wrap_4
#define set_SE_TCL_TEX_CYL_WRAP_CNTL_tex_cyl_wrap_5(reg, tex_cyl_wrap_5) (reg)->bitfields.TEX_CYL_WRAP_5 = tex_cyl_wrap_5

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_UCP_VTX_BLEND_CNTL regSE_TCL_UCP_VTX_BLEND_CNTL;

#ifdef DEBUG
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_ucp_in_clip_space(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int ucp_in_clip_space)
{
  reg->bitfields.UCP_IN_CLIP_SPACE = ucp_in_clip_space;
  if (reg->bitfields.UCP_IN_CLIP_SPACE != ucp_in_clip_space) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::UCP_IN_CLIP_SPACE data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_ucp_in_model_space(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int ucp_in_model_space)
{
  reg->bitfields.UCP_IN_MODEL_SPACE = ucp_in_model_space;
  if (reg->bitfields.UCP_IN_MODEL_SPACE != ucp_in_model_space) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::UCP_IN_MODEL_SPACE data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_ucp_ena_0(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int ucp_ena_0)
{
  reg->bitfields.UCP_ENA_0 = ucp_ena_0;
  if (reg->bitfields.UCP_ENA_0 != ucp_ena_0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::UCP_ENA_0 data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_ucp_ena_1(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int ucp_ena_1)
{
  reg->bitfields.UCP_ENA_1 = ucp_ena_1;
  if (reg->bitfields.UCP_ENA_1 != ucp_ena_1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::UCP_ENA_1 data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_ucp_ena_2(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int ucp_ena_2)
{
  reg->bitfields.UCP_ENA_2 = ucp_ena_2;
  if (reg->bitfields.UCP_ENA_2 != ucp_ena_2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::UCP_ENA_2 data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_ucp_ena_3(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int ucp_ena_3)
{
  reg->bitfields.UCP_ENA_3 = ucp_ena_3;
  if (reg->bitfields.UCP_ENA_3 != ucp_ena_3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::UCP_ENA_3 data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_ucp_ena_4(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int ucp_ena_4)
{
  reg->bitfields.UCP_ENA_4 = ucp_ena_4;
  if (reg->bitfields.UCP_ENA_4 != ucp_ena_4) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::UCP_ENA_4 data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_ucp_ena_5(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int ucp_ena_5)
{
  reg->bitfields.UCP_ENA_5 = ucp_ena_5;
  if (reg->bitfields.UCP_ENA_5 != ucp_ena_5) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::UCP_ENA_5 data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_fog_mode(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int fog_mode)
{
  reg->bitfields.FOG_MODE = fog_mode;
  if (reg->bitfields.FOG_MODE != fog_mode) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::FOG_MODE data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_rng_based_fog(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int rng_based_fog)
{
  reg->bitfields.RNG_BASED_FOG = rng_based_fog;
  if (reg->bitfields.RNG_BASED_FOG != rng_based_fog) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::RNG_BASED_FOG data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_clip_disable(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int clip_disable)
{
  reg->bitfields.CLIP_DISABLE = clip_disable;
  if (reg->bitfields.CLIP_DISABLE != clip_disable) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::CLIP_DISABLE data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_blend_op_cnt(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int blend_op_cnt)
{
  reg->bitfields.BLEND_OP_CNT = blend_op_cnt;
  if (reg->bitfields.BLEND_OP_CNT != blend_op_cnt) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::BLEND_OP_CNT data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_use_st_blend_op_cnt(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int use_st_blend_op_cnt)
{
  reg->bitfields.USE_ST_BLEND_OP_CNT = use_st_blend_op_cnt;
  if (reg->bitfields.USE_ST_BLEND_OP_CNT != use_st_blend_op_cnt) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::USE_ST_BLEND_OP_CNT data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_position_blend_operation(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int position_blend_operation)
{
  reg->bitfields.POSITION_BLEND_OPERATION = position_blend_operation;
  if (reg->bitfields.POSITION_BLEND_OPERATION != position_blend_operation) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::POSITION_BLEND_OPERATION data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_normal_blend_operation(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int normal_blend_operation)
{
  reg->bitfields.NORMAL_BLEND_OPERATION = normal_blend_operation;
  if (reg->bitfields.NORMAL_BLEND_OPERATION != normal_blend_operation) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::NORMAL_BLEND_OPERATION data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_vtx_blend_src_0(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int vtx_blend_src_0)
{
  reg->bitfields.VTX_BLEND_SRC_0 = vtx_blend_src_0;
  if (reg->bitfields.VTX_BLEND_SRC_0 != vtx_blend_src_0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::VTX_BLEND_SRC_0 data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_vtx_blend_src_1(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int vtx_blend_src_1)
{
  reg->bitfields.VTX_BLEND_SRC_1 = vtx_blend_src_1;
  if (reg->bitfields.VTX_BLEND_SRC_1 != vtx_blend_src_1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::VTX_BLEND_SRC_1 data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_vtx_blend_src_2(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int vtx_blend_src_2)
{
  reg->bitfields.VTX_BLEND_SRC_2 = vtx_blend_src_2;
  if (reg->bitfields.VTX_BLEND_SRC_2 != vtx_blend_src_2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::VTX_BLEND_SRC_2 data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_vtx_blend_src_3(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int vtx_blend_src_3)
{
  reg->bitfields.VTX_BLEND_SRC_3 = vtx_blend_src_3;
  if (reg->bitfields.VTX_BLEND_SRC_3 != vtx_blend_src_3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::VTX_BLEND_SRC_3 data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_blend_weight_minus_one(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int blend_weight_minus_one)
{
  reg->bitfields.BLEND_WEIGHT_MINUS_ONE = blend_weight_minus_one;
  if (reg->bitfields.BLEND_WEIGHT_MINUS_ONE != blend_weight_minus_one) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::BLEND_WEIGHT_MINUS_ONE data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_vtx_blend_use_proj_mtx(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int vtx_blend_use_proj_mtx)
{
  reg->bitfields.VTX_BLEND_USE_PROJ_MTX = vtx_blend_use_proj_mtx;
  if (reg->bitfields.VTX_BLEND_USE_PROJ_MTX != vtx_blend_use_proj_mtx) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::VTX_BLEND_USE_PROJ_MTX data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_vtx_blend_2_optimize(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int vtx_blend_2_optimize)
{
  reg->bitfields.VTX_BLEND_2_OPTIMIZE = vtx_blend_2_optimize;
  if (reg->bitfields.VTX_BLEND_2_OPTIMIZE != vtx_blend_2_optimize) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::VTX_BLEND_2_OPTIMIZE data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_cull_eq_0_ena(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int cull_eq_0_ena)
{
  reg->bitfields.CULL_EQ_0_ENA = cull_eq_0_ena;
  if (reg->bitfields.CULL_EQ_0_ENA != cull_eq_0_ena) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::CULL_EQ_0_ENA data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_cull_method(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int cull_method)
{
  reg->bitfields.CULL_METHOD = cull_method;
  if (reg->bitfields.CULL_METHOD != cull_method) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::CULL_METHOD data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_culling_ff_dir(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int culling_ff_dir)
{
  reg->bitfields.CULLING_FF_DIR = culling_ff_dir;
  if (reg->bitfields.CULLING_FF_DIR != culling_ff_dir) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::CULLING_FF_DIR data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_cull_ff_ena(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int cull_ff_ena)
{
  reg->bitfields.CULL_FF_ENA = cull_ff_ena;
  if (reg->bitfields.CULL_FF_ENA != cull_ff_ena) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::CULL_FF_ENA data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_cull_bf_ena(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int cull_bf_ena)
{
  reg->bitfields.CULL_BF_ENA = cull_bf_ena;
  if (reg->bitfields.CULL_BF_ENA != cull_bf_ena) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::CULL_BF_ENA data too large\n");
}
__inline void set_SE_TCL_UCP_VTX_BLEND_CNTL_ucp_cull_only_ena(regSE_TCL_UCP_VTX_BLEND_CNTL *reg, unsigned int ucp_cull_only_ena)
{
  reg->bitfields.UCP_CULL_ONLY_ENA = ucp_cull_only_ena;
  if (reg->bitfields.UCP_CULL_ONLY_ENA != ucp_cull_only_ena) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_UCP_VTX_BLEND_CNTL::UCP_CULL_ONLY_ENA data too large\n");
}
#else
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_ucp_in_clip_space(reg, ucp_in_clip_space) (reg)->bitfields.UCP_IN_CLIP_SPACE = ucp_in_clip_space
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_ucp_in_model_space(reg, ucp_in_model_space) (reg)->bitfields.UCP_IN_MODEL_SPACE = ucp_in_model_space
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_ucp_ena_0(reg, ucp_ena_0) (reg)->bitfields.UCP_ENA_0 = ucp_ena_0
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_ucp_ena_1(reg, ucp_ena_1) (reg)->bitfields.UCP_ENA_1 = ucp_ena_1
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_ucp_ena_2(reg, ucp_ena_2) (reg)->bitfields.UCP_ENA_2 = ucp_ena_2
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_ucp_ena_3(reg, ucp_ena_3) (reg)->bitfields.UCP_ENA_3 = ucp_ena_3
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_ucp_ena_4(reg, ucp_ena_4) (reg)->bitfields.UCP_ENA_4 = ucp_ena_4
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_ucp_ena_5(reg, ucp_ena_5) (reg)->bitfields.UCP_ENA_5 = ucp_ena_5
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_fog_mode(reg, fog_mode) (reg)->bitfields.FOG_MODE = fog_mode
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_rng_based_fog(reg, rng_based_fog) (reg)->bitfields.RNG_BASED_FOG = rng_based_fog
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_clip_disable(reg, clip_disable) (reg)->bitfields.CLIP_DISABLE = clip_disable
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_blend_op_cnt(reg, blend_op_cnt) (reg)->bitfields.BLEND_OP_CNT = blend_op_cnt
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_use_st_blend_op_cnt(reg, use_st_blend_op_cnt) (reg)->bitfields.USE_ST_BLEND_OP_CNT = use_st_blend_op_cnt
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_position_blend_operation(reg, position_blend_operation) (reg)->bitfields.POSITION_BLEND_OPERATION = position_blend_operation
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_normal_blend_operation(reg, normal_blend_operation) (reg)->bitfields.NORMAL_BLEND_OPERATION = normal_blend_operation
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_vtx_blend_src_0(reg, vtx_blend_src_0) (reg)->bitfields.VTX_BLEND_SRC_0 = vtx_blend_src_0
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_vtx_blend_src_1(reg, vtx_blend_src_1) (reg)->bitfields.VTX_BLEND_SRC_1 = vtx_blend_src_1
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_vtx_blend_src_2(reg, vtx_blend_src_2) (reg)->bitfields.VTX_BLEND_SRC_2 = vtx_blend_src_2
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_vtx_blend_src_3(reg, vtx_blend_src_3) (reg)->bitfields.VTX_BLEND_SRC_3 = vtx_blend_src_3
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_blend_weight_minus_one(reg, blend_weight_minus_one) (reg)->bitfields.BLEND_WEIGHT_MINUS_ONE = blend_weight_minus_one
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_vtx_blend_use_proj_mtx(reg, vtx_blend_use_proj_mtx) (reg)->bitfields.VTX_BLEND_USE_PROJ_MTX = vtx_blend_use_proj_mtx
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_vtx_blend_2_optimize(reg, vtx_blend_2_optimize) (reg)->bitfields.VTX_BLEND_2_OPTIMIZE = vtx_blend_2_optimize
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_cull_eq_0_ena(reg, cull_eq_0_ena) (reg)->bitfields.CULL_EQ_0_ENA = cull_eq_0_ena
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_cull_method(reg, cull_method) (reg)->bitfields.CULL_METHOD = cull_method
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_culling_ff_dir(reg, culling_ff_dir) (reg)->bitfields.CULLING_FF_DIR = culling_ff_dir
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_cull_ff_ena(reg, cull_ff_ena) (reg)->bitfields.CULL_FF_ENA = cull_ff_ena
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_cull_bf_ena(reg, cull_bf_ena) (reg)->bitfields.CULL_BF_ENA = cull_bf_ena
#define set_SE_TCL_UCP_VTX_BLEND_CNTL_ucp_cull_only_ena(reg, ucp_cull_only_ena) (reg)->bitfields.UCP_CULL_ONLY_ENA = ucp_cull_only_ena

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_POINT_SPRITE_CNTL regSE_TCL_POINT_SPRITE_CNTL;

#ifdef DEBUG
__inline void set_SE_TCL_POINT_SPRITE_CNTL_ps_mult(regSE_TCL_POINT_SPRITE_CNTL *reg, unsigned int ps_mult)
{
  reg->bitfields.PS_MULT = ps_mult;
  if (reg->bitfields.PS_MULT != ps_mult) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_POINT_SPRITE_CNTL::PS_MULT data too large\n");
}
__inline void set_SE_TCL_POINT_SPRITE_CNTL_ps_lin_att_zero(regSE_TCL_POINT_SPRITE_CNTL *reg, unsigned int ps_lin_att_zero)
{
  reg->bitfields.PS_LIN_ATT_ZERO = ps_lin_att_zero;
  if (reg->bitfields.PS_LIN_ATT_ZERO != ps_lin_att_zero) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_POINT_SPRITE_CNTL::PS_LIN_ATT_ZERO data too large\n");
}
__inline void set_SE_TCL_POINT_SPRITE_CNTL_ps_use_model_eye_vec(regSE_TCL_POINT_SPRITE_CNTL *reg, unsigned int ps_use_model_eye_vec)
{
  reg->bitfields.PS_USE_MODEL_EYE_VEC = ps_use_model_eye_vec;
  if (reg->bitfields.PS_USE_MODEL_EYE_VEC != ps_use_model_eye_vec) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_POINT_SPRITE_CNTL::PS_USE_MODEL_EYE_VEC data too large\n");
}
__inline void set_SE_TCL_POINT_SPRITE_CNTL_ps_att_alpha(regSE_TCL_POINT_SPRITE_CNTL *reg, unsigned int ps_att_alpha)
{
  reg->bitfields.PS_ATT_ALPHA = ps_att_alpha;
  if (reg->bitfields.PS_ATT_ALPHA != ps_att_alpha) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_POINT_SPRITE_CNTL::PS_ATT_ALPHA data too large\n");
}
__inline void set_SE_TCL_POINT_SPRITE_CNTL_ps_ucp_mode(regSE_TCL_POINT_SPRITE_CNTL *reg, unsigned int ps_ucp_mode)
{
  reg->bitfields.PS_UCP_MODE = ps_ucp_mode;
  if (reg->bitfields.PS_UCP_MODE != ps_ucp_mode) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_POINT_SPRITE_CNTL::PS_UCP_MODE data too large\n");
}
__inline void set_SE_TCL_POINT_SPRITE_CNTL_ps_gen_tex_0(regSE_TCL_POINT_SPRITE_CNTL *reg, unsigned int ps_gen_tex_0)
{
  reg->bitfields.PS_GEN_TEX_0 = ps_gen_tex_0;
  if (reg->bitfields.PS_GEN_TEX_0 != ps_gen_tex_0) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_POINT_SPRITE_CNTL::PS_GEN_TEX_0 data too large\n");
}
__inline void set_SE_TCL_POINT_SPRITE_CNTL_ps_gen_tex_1(regSE_TCL_POINT_SPRITE_CNTL *reg, unsigned int ps_gen_tex_1)
{
  reg->bitfields.PS_GEN_TEX_1 = ps_gen_tex_1;
  if (reg->bitfields.PS_GEN_TEX_1 != ps_gen_tex_1) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_POINT_SPRITE_CNTL::PS_GEN_TEX_1 data too large\n");
}
__inline void set_SE_TCL_POINT_SPRITE_CNTL_ps_gen_tex_2(regSE_TCL_POINT_SPRITE_CNTL *reg, unsigned int ps_gen_tex_2)
{
  reg->bitfields.PS_GEN_TEX_2 = ps_gen_tex_2;
  if (reg->bitfields.PS_GEN_TEX_2 != ps_gen_tex_2) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_POINT_SPRITE_CNTL::PS_GEN_TEX_2 data too large\n");
}
__inline void set_SE_TCL_POINT_SPRITE_CNTL_ps_gen_tex_3(regSE_TCL_POINT_SPRITE_CNTL *reg, unsigned int ps_gen_tex_3)
{
  reg->bitfields.PS_GEN_TEX_3 = ps_gen_tex_3;
  if (reg->bitfields.PS_GEN_TEX_3 != ps_gen_tex_3) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_POINT_SPRITE_CNTL::PS_GEN_TEX_3 data too large\n");
}
__inline void set_SE_TCL_POINT_SPRITE_CNTL_ps_gen_tex_4(regSE_TCL_POINT_SPRITE_CNTL *reg, unsigned int ps_gen_tex_4)
{
  reg->bitfields.PS_GEN_TEX_4 = ps_gen_tex_4;
  if (reg->bitfields.PS_GEN_TEX_4 != ps_gen_tex_4) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_POINT_SPRITE_CNTL::PS_GEN_TEX_4 data too large\n");
}
__inline void set_SE_TCL_POINT_SPRITE_CNTL_ps_gen_tex_5(regSE_TCL_POINT_SPRITE_CNTL *reg, unsigned int ps_gen_tex_5)
{
  reg->bitfields.PS_GEN_TEX_5 = ps_gen_tex_5;
  if (reg->bitfields.PS_GEN_TEX_5 != ps_gen_tex_5) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_POINT_SPRITE_CNTL::PS_GEN_TEX_5 data too large\n");
}
__inline void set_SE_TCL_POINT_SPRITE_CNTL_ps_se_sel_state_size(regSE_TCL_POINT_SPRITE_CNTL *reg, unsigned int ps_se_sel_state_size)
{
  reg->bitfields.PS_SE_SEL_STATE_SIZE = ps_se_sel_state_size;
  if (reg->bitfields.PS_SE_SEL_STATE_SIZE != ps_se_sel_state_size) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_POINT_SPRITE_CNTL::PS_SE_SEL_STATE_SIZE data too large\n");
}
__inline void set_SE_TCL_POINT_SPRITE_CNTL_ps_dis_vv_early_exit(regSE_TCL_POINT_SPRITE_CNTL *reg, unsigned int ps_dis_vv_early_exit)
{
  reg->bitfields.PS_DIS_VV_EARLY_EXIT = ps_dis_vv_early_exit;
  if (reg->bitfields.PS_DIS_VV_EARLY_EXIT != ps_dis_vv_early_exit) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_POINT_SPRITE_CNTL::PS_DIS_VV_EARLY_EXIT data too large\n");
}
#else
#define set_SE_TCL_POINT_SPRITE_CNTL_ps_mult(reg, ps_mult) (reg)->bitfields.PS_MULT = ps_mult
#define set_SE_TCL_POINT_SPRITE_CNTL_ps_lin_att_zero(reg, ps_lin_att_zero) (reg)->bitfields.PS_LIN_ATT_ZERO = ps_lin_att_zero
#define set_SE_TCL_POINT_SPRITE_CNTL_ps_use_model_eye_vec(reg, ps_use_model_eye_vec) (reg)->bitfields.PS_USE_MODEL_EYE_VEC = ps_use_model_eye_vec
#define set_SE_TCL_POINT_SPRITE_CNTL_ps_att_alpha(reg, ps_att_alpha) (reg)->bitfields.PS_ATT_ALPHA = ps_att_alpha
#define set_SE_TCL_POINT_SPRITE_CNTL_ps_ucp_mode(reg, ps_ucp_mode) (reg)->bitfields.PS_UCP_MODE = ps_ucp_mode
#define set_SE_TCL_POINT_SPRITE_CNTL_ps_gen_tex_0(reg, ps_gen_tex_0) (reg)->bitfields.PS_GEN_TEX_0 = ps_gen_tex_0
#define set_SE_TCL_POINT_SPRITE_CNTL_ps_gen_tex_1(reg, ps_gen_tex_1) (reg)->bitfields.PS_GEN_TEX_1 = ps_gen_tex_1
#define set_SE_TCL_POINT_SPRITE_CNTL_ps_gen_tex_2(reg, ps_gen_tex_2) (reg)->bitfields.PS_GEN_TEX_2 = ps_gen_tex_2
#define set_SE_TCL_POINT_SPRITE_CNTL_ps_gen_tex_3(reg, ps_gen_tex_3) (reg)->bitfields.PS_GEN_TEX_3 = ps_gen_tex_3
#define set_SE_TCL_POINT_SPRITE_CNTL_ps_gen_tex_4(reg, ps_gen_tex_4) (reg)->bitfields.PS_GEN_TEX_4 = ps_gen_tex_4
#define set_SE_TCL_POINT_SPRITE_CNTL_ps_gen_tex_5(reg, ps_gen_tex_5) (reg)->bitfields.PS_GEN_TEX_5 = ps_gen_tex_5
#define set_SE_TCL_POINT_SPRITE_CNTL_ps_se_sel_state_size(reg, ps_se_sel_state_size) (reg)->bitfields.PS_SE_SEL_STATE_SIZE = ps_se_sel_state_size
#define set_SE_TCL_POINT_SPRITE_CNTL_ps_dis_vv_early_exit(reg, ps_dis_vv_early_exit) (reg)->bitfields.PS_DIS_VV_EARLY_EXIT = ps_dis_vv_early_exit

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PVS_CNTL regSE_PVS_CNTL;

#ifdef DEBUG
__inline void set_SE_PVS_CNTL_pvs_first_inst(regSE_PVS_CNTL *reg, unsigned int pvs_first_inst)
{
  reg->bitfields.PVS_FIRST_INST = pvs_first_inst;
  if (reg->bitfields.PVS_FIRST_INST != pvs_first_inst) HSLDPF(E_ERROR_MESSAGE,"SE_PVS_CNTL::PVS_FIRST_INST data too large\n");
}
__inline void set_SE_PVS_CNTL_pvs_xyzw_valid_inst(regSE_PVS_CNTL *reg, unsigned int pvs_xyzw_valid_inst)
{
  reg->bitfields.PVS_XYZW_VALID_INST = pvs_xyzw_valid_inst;
  if (reg->bitfields.PVS_XYZW_VALID_INST != pvs_xyzw_valid_inst) HSLDPF(E_ERROR_MESSAGE,"SE_PVS_CNTL::PVS_XYZW_VALID_INST data too large\n");
}
__inline void set_SE_PVS_CNTL_pvs_last_inst(regSE_PVS_CNTL *reg, unsigned int pvs_last_inst)
{
  reg->bitfields.PVS_LAST_INST = pvs_last_inst;
  if (reg->bitfields.PVS_LAST_INST != pvs_last_inst) HSLDPF(E_ERROR_MESSAGE,"SE_PVS_CNTL::PVS_LAST_INST data too large\n");
}
#else
#define set_SE_PVS_CNTL_pvs_first_inst(reg, pvs_first_inst) (reg)->bitfields.PVS_FIRST_INST = pvs_first_inst
#define set_SE_PVS_CNTL_pvs_xyzw_valid_inst(reg, pvs_xyzw_valid_inst) (reg)->bitfields.PVS_XYZW_VALID_INST = pvs_xyzw_valid_inst
#define set_SE_PVS_CNTL_pvs_last_inst(reg, pvs_last_inst) (reg)->bitfields.PVS_LAST_INST = pvs_last_inst

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_PVS_CONST_CNTL regSE_PVS_CONST_CNTL;

#ifdef DEBUG
__inline void set_SE_PVS_CONST_CNTL_pvs_const_base_offset(regSE_PVS_CONST_CNTL *reg, unsigned int pvs_const_base_offset)
{
  reg->bitfields.PVS_CONST_BASE_OFFSET = pvs_const_base_offset;
  if (reg->bitfields.PVS_CONST_BASE_OFFSET != pvs_const_base_offset) HSLDPF(E_ERROR_MESSAGE,"SE_PVS_CONST_CNTL::PVS_CONST_BASE_OFFSET data too large\n");
}
__inline void set_SE_PVS_CONST_CNTL_pvs_max_const_addr(regSE_PVS_CONST_CNTL *reg, unsigned int pvs_max_const_addr)
{
  reg->bitfields.PVS_MAX_CONST_ADDR = pvs_max_const_addr;
  if (reg->bitfields.PVS_MAX_CONST_ADDR != pvs_max_const_addr) HSLDPF(E_ERROR_MESSAGE,"SE_PVS_CONST_CNTL::PVS_MAX_CONST_ADDR data too large\n");
}
#else
#define set_SE_PVS_CONST_CNTL_pvs_const_base_offset(reg, pvs_const_base_offset) (reg)->bitfields.PVS_CONST_BASE_OFFSET = pvs_const_base_offset
#define set_SE_PVS_CONST_CNTL_pvs_max_const_addr(reg, pvs_max_const_addr) (reg)->bitfields.PVS_MAX_CONST_ADDR = pvs_max_const_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_POS_0_X_4 regSE_VTX_ST_POS_0_X_4;

#ifdef DEBUG
__inline void set_SE_VTX_ST_POS_0_X_4_data_register(regSE_VTX_ST_POS_0_X_4 *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_POS_0_X_4::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_POS_0_X_4_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_POS_0_Y_4 regSE_VTX_ST_POS_0_Y_4;

#ifdef DEBUG
__inline void set_SE_VTX_ST_POS_0_Y_4_data_register(regSE_VTX_ST_POS_0_Y_4 *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_POS_0_Y_4::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_POS_0_Y_4_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_POS_0_Z_4 regSE_VTX_ST_POS_0_Z_4;

#ifdef DEBUG
__inline void set_SE_VTX_ST_POS_0_Z_4_data_register(regSE_VTX_ST_POS_0_Z_4 *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_POS_0_Z_4::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_POS_0_Z_4_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_POS_0_W_4 regSE_VTX_ST_POS_0_W_4;

#ifdef DEBUG
__inline void set_SE_VTX_ST_POS_0_W_4_data_register(regSE_VTX_ST_POS_0_W_4 *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_POS_0_W_4::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_POS_0_W_4_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_NORM_0_X regSE_VTX_ST_NORM_0_X;

#ifdef DEBUG
__inline void set_SE_VTX_ST_NORM_0_X_data_register(regSE_VTX_ST_NORM_0_X *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_NORM_0_X::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_NORM_0_X_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_NORM_0_Y regSE_VTX_ST_NORM_0_Y;

#ifdef DEBUG
__inline void set_SE_VTX_ST_NORM_0_Y_data_register(regSE_VTX_ST_NORM_0_Y *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_NORM_0_Y::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_NORM_0_Y_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_NORM_0_Z regSE_VTX_ST_NORM_0_Z;

#ifdef DEBUG
__inline void set_SE_VTX_ST_NORM_0_Z_data_register(regSE_VTX_ST_NORM_0_Z *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_NORM_0_Z::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_NORM_0_Z_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_PVMS regSE_VTX_ST_PVMS;

#ifdef DEBUG
__inline void set_SE_VTX_ST_PVMS_data_register(regSE_VTX_ST_PVMS *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_PVMS::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_PVMS_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_0_R regSE_VTX_ST_CLR_0_R;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_0_R_data_register(regSE_VTX_ST_CLR_0_R *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_0_R::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_0_R_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_0_G regSE_VTX_ST_CLR_0_G;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_0_G_data_register(regSE_VTX_ST_CLR_0_G *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_0_G::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_0_G_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_0_B regSE_VTX_ST_CLR_0_B;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_0_B_data_register(regSE_VTX_ST_CLR_0_B *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_0_B::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_0_B_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_0_A regSE_VTX_ST_CLR_0_A;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_0_A_data_register(regSE_VTX_ST_CLR_0_A *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_0_A::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_0_A_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_1_R regSE_VTX_ST_CLR_1_R;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_1_R_data_register(regSE_VTX_ST_CLR_1_R *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_1_R::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_1_R_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_1_G regSE_VTX_ST_CLR_1_G;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_1_G_data_register(regSE_VTX_ST_CLR_1_G *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_1_G::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_1_G_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_1_B regSE_VTX_ST_CLR_1_B;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_1_B_data_register(regSE_VTX_ST_CLR_1_B *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_1_B::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_1_B_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_1_A regSE_VTX_ST_CLR_1_A;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_1_A_data_register(regSE_VTX_ST_CLR_1_A *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_1_A::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_1_A_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_2_R regSE_VTX_ST_CLR_2_R;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_2_R_data_register(regSE_VTX_ST_CLR_2_R *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_2_R::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_2_R_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_2_G regSE_VTX_ST_CLR_2_G;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_2_G_data_register(regSE_VTX_ST_CLR_2_G *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_2_G::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_2_G_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_2_B regSE_VTX_ST_CLR_2_B;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_2_B_data_register(regSE_VTX_ST_CLR_2_B *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_2_B::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_2_B_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_2_A regSE_VTX_ST_CLR_2_A;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_2_A_data_register(regSE_VTX_ST_CLR_2_A *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_2_A::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_2_A_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_3_R regSE_VTX_ST_CLR_3_R;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_3_R_data_register(regSE_VTX_ST_CLR_3_R *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_3_R::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_3_R_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_3_G regSE_VTX_ST_CLR_3_G;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_3_G_data_register(regSE_VTX_ST_CLR_3_G *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_3_G::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_3_G_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_3_B regSE_VTX_ST_CLR_3_B;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_3_B_data_register(regSE_VTX_ST_CLR_3_B *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_3_B::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_3_B_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_3_A regSE_VTX_ST_CLR_3_A;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_3_A_data_register(regSE_VTX_ST_CLR_3_A *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_3_A::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_3_A_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_4_R regSE_VTX_ST_CLR_4_R;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_4_R_data_register(regSE_VTX_ST_CLR_4_R *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_4_R::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_4_R_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_4_G regSE_VTX_ST_CLR_4_G;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_4_G_data_register(regSE_VTX_ST_CLR_4_G *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_4_G::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_4_G_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_4_B regSE_VTX_ST_CLR_4_B;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_4_B_data_register(regSE_VTX_ST_CLR_4_B *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_4_B::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_4_B_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_4_A regSE_VTX_ST_CLR_4_A;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_4_A_data_register(regSE_VTX_ST_CLR_4_A *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_4_A::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_4_A_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_5_R regSE_VTX_ST_CLR_5_R;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_5_R_data_register(regSE_VTX_ST_CLR_5_R *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_5_R::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_5_R_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_5_G regSE_VTX_ST_CLR_5_G;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_5_G_data_register(regSE_VTX_ST_CLR_5_G *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_5_G::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_5_G_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_5_B regSE_VTX_ST_CLR_5_B;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_5_B_data_register(regSE_VTX_ST_CLR_5_B *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_5_B::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_5_B_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_5_A regSE_VTX_ST_CLR_5_A;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_5_A_data_register(regSE_VTX_ST_CLR_5_A *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_5_A::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_5_A_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_6_R regSE_VTX_ST_CLR_6_R;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_6_R_data_register(regSE_VTX_ST_CLR_6_R *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_6_R::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_6_R_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_6_G regSE_VTX_ST_CLR_6_G;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_6_G_data_register(regSE_VTX_ST_CLR_6_G *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_6_G::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_6_G_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_6_B regSE_VTX_ST_CLR_6_B;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_6_B_data_register(regSE_VTX_ST_CLR_6_B *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_6_B::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_6_B_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_6_A regSE_VTX_ST_CLR_6_A;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_6_A_data_register(regSE_VTX_ST_CLR_6_A *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_6_A::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_6_A_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_7_R regSE_VTX_ST_CLR_7_R;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_7_R_data_register(regSE_VTX_ST_CLR_7_R *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_7_R::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_7_R_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_7_G regSE_VTX_ST_CLR_7_G;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_7_G_data_register(regSE_VTX_ST_CLR_7_G *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_7_G::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_7_G_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_7_B regSE_VTX_ST_CLR_7_B;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_7_B_data_register(regSE_VTX_ST_CLR_7_B *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_7_B::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_7_B_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_7_A regSE_VTX_ST_CLR_7_A;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_7_A_data_register(regSE_VTX_ST_CLR_7_A *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_7_A::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_7_A_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_0_S regSE_VTX_ST_TEX_0_S;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_0_S_data_register(regSE_VTX_ST_TEX_0_S *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_0_S::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_0_S_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_0_T regSE_VTX_ST_TEX_0_T;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_0_T_data_register(regSE_VTX_ST_TEX_0_T *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_0_T::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_0_T_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_0_R regSE_VTX_ST_TEX_0_R;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_0_R_data_register(regSE_VTX_ST_TEX_0_R *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_0_R::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_0_R_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_0_Q regSE_VTX_ST_TEX_0_Q;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_0_Q_data_register(regSE_VTX_ST_TEX_0_Q *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_0_Q::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_0_Q_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_1_S regSE_VTX_ST_TEX_1_S;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_1_S_data_register(regSE_VTX_ST_TEX_1_S *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_1_S::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_1_S_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_1_T regSE_VTX_ST_TEX_1_T;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_1_T_data_register(regSE_VTX_ST_TEX_1_T *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_1_T::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_1_T_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_1_R regSE_VTX_ST_TEX_1_R;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_1_R_data_register(regSE_VTX_ST_TEX_1_R *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_1_R::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_1_R_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_1_Q regSE_VTX_ST_TEX_1_Q;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_1_Q_data_register(regSE_VTX_ST_TEX_1_Q *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_1_Q::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_1_Q_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_2_S regSE_VTX_ST_TEX_2_S;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_2_S_data_register(regSE_VTX_ST_TEX_2_S *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_2_S::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_2_S_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_2_T regSE_VTX_ST_TEX_2_T;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_2_T_data_register(regSE_VTX_ST_TEX_2_T *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_2_T::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_2_T_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_2_R regSE_VTX_ST_TEX_2_R;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_2_R_data_register(regSE_VTX_ST_TEX_2_R *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_2_R::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_2_R_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_2_Q regSE_VTX_ST_TEX_2_Q;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_2_Q_data_register(regSE_VTX_ST_TEX_2_Q *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_2_Q::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_2_Q_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_3_S regSE_VTX_ST_TEX_3_S;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_3_S_data_register(regSE_VTX_ST_TEX_3_S *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_3_S::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_3_S_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_3_T regSE_VTX_ST_TEX_3_T;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_3_T_data_register(regSE_VTX_ST_TEX_3_T *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_3_T::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_3_T_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_3_R regSE_VTX_ST_TEX_3_R;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_3_R_data_register(regSE_VTX_ST_TEX_3_R *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_3_R::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_3_R_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_3_Q regSE_VTX_ST_TEX_3_Q;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_3_Q_data_register(regSE_VTX_ST_TEX_3_Q *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_3_Q::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_3_Q_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_4_S regSE_VTX_ST_TEX_4_S;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_4_S_data_register(regSE_VTX_ST_TEX_4_S *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_4_S::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_4_S_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_4_T regSE_VTX_ST_TEX_4_T;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_4_T_data_register(regSE_VTX_ST_TEX_4_T *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_4_T::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_4_T_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_4_R regSE_VTX_ST_TEX_4_R;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_4_R_data_register(regSE_VTX_ST_TEX_4_R *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_4_R::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_4_R_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_4_Q regSE_VTX_ST_TEX_4_Q;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_4_Q_data_register(regSE_VTX_ST_TEX_4_Q *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_4_Q::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_4_Q_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_5_S regSE_VTX_ST_TEX_5_S;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_5_S_data_register(regSE_VTX_ST_TEX_5_S *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_5_S::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_5_S_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_5_T regSE_VTX_ST_TEX_5_T;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_5_T_data_register(regSE_VTX_ST_TEX_5_T *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_5_T::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_5_T_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_5_R regSE_VTX_ST_TEX_5_R;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_5_R_data_register(regSE_VTX_ST_TEX_5_R *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_5_R::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_5_R_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_TEX_5_Q regSE_VTX_ST_TEX_5_Q;

#ifdef DEBUG
__inline void set_SE_VTX_ST_TEX_5_Q_data_register(regSE_VTX_ST_TEX_5_Q *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_TEX_5_Q::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_TEX_5_Q_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_PNT_SPRT_SZ regSE_VTX_ST_PNT_SPRT_SZ;

#ifdef DEBUG
__inline void set_SE_VTX_ST_PNT_SPRT_SZ_data_register(regSE_VTX_ST_PNT_SPRT_SZ *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_PNT_SPRT_SZ::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_PNT_SPRT_SZ_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_DISC_FOG regSE_VTX_ST_DISC_FOG;

#ifdef DEBUG
__inline void set_SE_VTX_ST_DISC_FOG_data_register(regSE_VTX_ST_DISC_FOG *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_DISC_FOG::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_DISC_FOG_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_SHININESS_0 regSE_VTX_ST_SHININESS_0;

#ifdef DEBUG
__inline void set_SE_VTX_ST_SHININESS_0_data_register(regSE_VTX_ST_SHININESS_0 *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_SHININESS_0::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_SHININESS_0_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_SHININESS_1 regSE_VTX_ST_SHININESS_1;

#ifdef DEBUG
__inline void set_SE_VTX_ST_SHININESS_1_data_register(regSE_VTX_ST_SHININESS_1 *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_SHININESS_1::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_SHININESS_1_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_BLND_WT_0 regSE_VTX_ST_BLND_WT_0;

#ifdef DEBUG
__inline void set_SE_VTX_ST_BLND_WT_0_data_register(regSE_VTX_ST_BLND_WT_0 *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_BLND_WT_0::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_BLND_WT_0_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_BLND_WT_1 regSE_VTX_ST_BLND_WT_1;

#ifdef DEBUG
__inline void set_SE_VTX_ST_BLND_WT_1_data_register(regSE_VTX_ST_BLND_WT_1 *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_BLND_WT_1::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_BLND_WT_1_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_BLND_WT_2 regSE_VTX_ST_BLND_WT_2;

#ifdef DEBUG
__inline void set_SE_VTX_ST_BLND_WT_2_data_register(regSE_VTX_ST_BLND_WT_2 *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_BLND_WT_2::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_BLND_WT_2_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_BLND_WT_3 regSE_VTX_ST_BLND_WT_3;

#ifdef DEBUG
__inline void set_SE_VTX_ST_BLND_WT_3_data_register(regSE_VTX_ST_BLND_WT_3 *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_BLND_WT_3::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_BLND_WT_3_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_POS_1_X regSE_VTX_ST_POS_1_X;

#ifdef DEBUG
__inline void set_SE_VTX_ST_POS_1_X_data_register(regSE_VTX_ST_POS_1_X *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_POS_1_X::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_POS_1_X_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_POS_1_Y regSE_VTX_ST_POS_1_Y;

#ifdef DEBUG
__inline void set_SE_VTX_ST_POS_1_Y_data_register(regSE_VTX_ST_POS_1_Y *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_POS_1_Y::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_POS_1_Y_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_POS_1_Z regSE_VTX_ST_POS_1_Z;

#ifdef DEBUG
__inline void set_SE_VTX_ST_POS_1_Z_data_register(regSE_VTX_ST_POS_1_Z *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_POS_1_Z::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_POS_1_Z_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_POS_1_W regSE_VTX_ST_POS_1_W;

#ifdef DEBUG
__inline void set_SE_VTX_ST_POS_1_W_data_register(regSE_VTX_ST_POS_1_W *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_POS_1_W::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_POS_1_W_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_NORM_1_X regSE_VTX_ST_NORM_1_X;

#ifdef DEBUG
__inline void set_SE_VTX_ST_NORM_1_X_data_register(regSE_VTX_ST_NORM_1_X *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_NORM_1_X::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_NORM_1_X_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_NORM_1_Y regSE_VTX_ST_NORM_1_Y;

#ifdef DEBUG
__inline void set_SE_VTX_ST_NORM_1_Y_data_register(regSE_VTX_ST_NORM_1_Y *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_NORM_1_Y::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_NORM_1_Y_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_NORM_1_Z regSE_VTX_ST_NORM_1_Z;

#ifdef DEBUG
__inline void set_SE_VTX_ST_NORM_1_Z_data_register(regSE_VTX_ST_NORM_1_Z *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_NORM_1_Z::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_NORM_1_Z_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_SPARE_43C regSE_VTX_ST_SPARE_43C;

#ifdef DEBUG
__inline void set_SE_VTX_ST_SPARE_43C_data_register(regSE_VTX_ST_SPARE_43C *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_SPARE_43C::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_SPARE_43C_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_USR_CLR_0_R regSE_VTX_ST_USR_CLR_0_R;

#ifdef DEBUG
__inline void set_SE_VTX_ST_USR_CLR_0_R_data_register(regSE_VTX_ST_USR_CLR_0_R *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_USR_CLR_0_R::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_USR_CLR_0_R_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_USR_CLR_0_G regSE_VTX_ST_USR_CLR_0_G;

#ifdef DEBUG
__inline void set_SE_VTX_ST_USR_CLR_0_G_data_register(regSE_VTX_ST_USR_CLR_0_G *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_USR_CLR_0_G::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_USR_CLR_0_G_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_USR_CLR_0_B regSE_VTX_ST_USR_CLR_0_B;

#ifdef DEBUG
__inline void set_SE_VTX_ST_USR_CLR_0_B_data_register(regSE_VTX_ST_USR_CLR_0_B *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_USR_CLR_0_B::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_USR_CLR_0_B_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_USR_CLR_0_A regSE_VTX_ST_USR_CLR_0_A;

#ifdef DEBUG
__inline void set_SE_VTX_ST_USR_CLR_0_A_data_register(regSE_VTX_ST_USR_CLR_0_A *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_USR_CLR_0_A::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_USR_CLR_0_A_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_USR_CLR_1_R regSE_VTX_ST_USR_CLR_1_R;

#ifdef DEBUG
__inline void set_SE_VTX_ST_USR_CLR_1_R_data_register(regSE_VTX_ST_USR_CLR_1_R *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_USR_CLR_1_R::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_USR_CLR_1_R_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_USR_CLR_1_G regSE_VTX_ST_USR_CLR_1_G;

#ifdef DEBUG
__inline void set_SE_VTX_ST_USR_CLR_1_G_data_register(regSE_VTX_ST_USR_CLR_1_G *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_USR_CLR_1_G::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_USR_CLR_1_G_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_USR_CLR_1_B regSE_VTX_ST_USR_CLR_1_B;

#ifdef DEBUG
__inline void set_SE_VTX_ST_USR_CLR_1_B_data_register(regSE_VTX_ST_USR_CLR_1_B *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_USR_CLR_1_B::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_USR_CLR_1_B_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_USR_CLR_1_A regSE_VTX_ST_USR_CLR_1_A;

#ifdef DEBUG
__inline void set_SE_VTX_ST_USR_CLR_1_A_data_register(regSE_VTX_ST_USR_CLR_1_A *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_USR_CLR_1_A::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_USR_CLR_1_A_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_0_PKD regSE_VTX_ST_CLR_0_PKD;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_0_PKD_data_register(regSE_VTX_ST_CLR_0_PKD *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_0_PKD::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_0_PKD_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_1_PKD regSE_VTX_ST_CLR_1_PKD;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_1_PKD_data_register(regSE_VTX_ST_CLR_1_PKD *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_1_PKD::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_1_PKD_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_2_PKD regSE_VTX_ST_CLR_2_PKD;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_2_PKD_data_register(regSE_VTX_ST_CLR_2_PKD *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_2_PKD::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_2_PKD_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_3_PKD regSE_VTX_ST_CLR_3_PKD;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_3_PKD_data_register(regSE_VTX_ST_CLR_3_PKD *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_3_PKD::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_3_PKD_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_4_PKD regSE_VTX_ST_CLR_4_PKD;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_4_PKD_data_register(regSE_VTX_ST_CLR_4_PKD *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_4_PKD::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_4_PKD_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_5_PKD regSE_VTX_ST_CLR_5_PKD;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_5_PKD_data_register(regSE_VTX_ST_CLR_5_PKD *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_5_PKD::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_5_PKD_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_6_PKD regSE_VTX_ST_CLR_6_PKD;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_6_PKD_data_register(regSE_VTX_ST_CLR_6_PKD *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_6_PKD::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_6_PKD_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_CLR_7_PKD regSE_VTX_ST_CLR_7_PKD;

#ifdef DEBUG
__inline void set_SE_VTX_ST_CLR_7_PKD_data_register(regSE_VTX_ST_CLR_7_PKD *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_CLR_7_PKD::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_CLR_7_PKD_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_POS_0_X_2 regSE_VTX_ST_POS_0_X_2;

#ifdef DEBUG
__inline void set_SE_VTX_ST_POS_0_X_2_data_register(regSE_VTX_ST_POS_0_X_2 *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_POS_0_X_2::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_POS_0_X_2_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_POS_0_Y_2 regSE_VTX_ST_POS_0_Y_2;

#ifdef DEBUG
__inline void set_SE_VTX_ST_POS_0_Y_2_data_register(regSE_VTX_ST_POS_0_Y_2 *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_POS_0_Y_2::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_POS_0_Y_2_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_PAR_CLR_LD regSE_VTX_ST_PAR_CLR_LD;

#ifdef DEBUG
__inline void set_SE_VTX_ST_PAR_CLR_LD_data_register(regSE_VTX_ST_PAR_CLR_LD *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_PAR_CLR_LD::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_PAR_CLR_LD_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_USR_CLR_PKD regSE_VTX_ST_USR_CLR_PKD;

#ifdef DEBUG
__inline void set_SE_VTX_ST_USR_CLR_PKD_data_register(regSE_VTX_ST_USR_CLR_PKD *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_USR_CLR_PKD::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_USR_CLR_PKD_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_POS_0_X_3 regSE_VTX_ST_POS_0_X_3;

#ifdef DEBUG
__inline void set_SE_VTX_ST_POS_0_X_3_data_register(regSE_VTX_ST_POS_0_X_3 *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_POS_0_X_3::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_POS_0_X_3_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_POS_0_Y_3 regSE_VTX_ST_POS_0_Y_3;

#ifdef DEBUG
__inline void set_SE_VTX_ST_POS_0_Y_3_data_register(regSE_VTX_ST_POS_0_Y_3 *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_POS_0_Y_3::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_POS_0_Y_3_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_POS_0_Z_3 regSE_VTX_ST_POS_0_Z_3;

#ifdef DEBUG
__inline void set_SE_VTX_ST_POS_0_Z_3_data_register(regSE_VTX_ST_POS_0_Z_3 *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_POS_0_Z_3::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_POS_0_Z_3_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_ST_END_OF_PKT regSE_VTX_ST_END_OF_PKT;

#ifdef DEBUG
__inline void set_SE_VTX_ST_END_OF_PKT_data_register(regSE_VTX_ST_END_OF_PKT *reg, unsigned int data_register)
{
  reg->bitfields.DATA_REGISTER = data_register;
  if (reg->bitfields.DATA_REGISTER != data_register) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_ST_END_OF_PKT::DATA_REGISTER data too large\n");
}
#else
#define set_SE_VTX_ST_END_OF_PKT_data_register(reg, data_register) (reg)->bitfields.DATA_REGISTER = data_register

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_SOLID_COLOR regRE_SOLID_COLOR;

#ifdef DEBUG
__inline void set_RE_SOLID_COLOR_solid_color(regRE_SOLID_COLOR *reg, unsigned int solid_color)
{
  reg->bitfields.SOLID_COLOR = solid_color;
  if (reg->bitfields.SOLID_COLOR != solid_color) HSLDPF(E_ERROR_MESSAGE,"RE_SOLID_COLOR::SOLID_COLOR data too large\n");
}
#else
#define set_RE_SOLID_COLOR_solid_color(reg, solid_color) (reg)->bitfields.SOLID_COLOR = solid_color

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_WIDTH_HEIGHT regRE_WIDTH_HEIGHT;

#ifdef DEBUG
__inline void set_RE_WIDTH_HEIGHT_width(regRE_WIDTH_HEIGHT *reg, unsigned int width)
{
  reg->bitfields.WIDTH = width;
  if (reg->bitfields.WIDTH != width) HSLDPF(E_ERROR_MESSAGE,"RE_WIDTH_HEIGHT::WIDTH data too large\n");
}
__inline void set_RE_WIDTH_HEIGHT_height(regRE_WIDTH_HEIGHT *reg, unsigned int height)
{
  reg->bitfields.HEIGHT = height;
  if (reg->bitfields.HEIGHT != height) HSLDPF(E_ERROR_MESSAGE,"RE_WIDTH_HEIGHT::HEIGHT data too large\n");
}
#else
#define set_RE_WIDTH_HEIGHT_width(reg, width) (reg)->bitfields.WIDTH = width
#define set_RE_WIDTH_HEIGHT_height(reg, height) (reg)->bitfields.HEIGHT = height

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_POINTSIZE regRE_POINTSIZE;

#ifdef DEBUG
__inline void set_RE_POINTSIZE_pointsize(regRE_POINTSIZE *reg, unsigned int pointsize)
{
  reg->bitfields.POINTSIZE = pointsize;
  if (reg->bitfields.POINTSIZE != pointsize) HSLDPF(E_ERROR_MESSAGE,"RE_POINTSIZE::POINTSIZE data too large\n");
}
__inline void set_RE_POINTSIZE_maxpointsize(regRE_POINTSIZE *reg, unsigned int maxpointsize)
{
  reg->bitfields.MAXPOINTSIZE = maxpointsize;
  if (reg->bitfields.MAXPOINTSIZE != maxpointsize) HSLDPF(E_ERROR_MESSAGE,"RE_POINTSIZE::MAXPOINTSIZE data too large\n");
}
#else
#define set_RE_POINTSIZE_pointsize(reg, pointsize) (reg)->bitfields.POINTSIZE = pointsize
#define set_RE_POINTSIZE_maxpointsize(reg, maxpointsize) (reg)->bitfields.MAXPOINTSIZE = maxpointsize

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_CNTL regSE_CNTL;

#ifdef DEBUG
__inline void set_SE_CNTL_fface_cull_dir(regSE_CNTL *reg, unsigned int fface_cull_dir)
{
  reg->bitfields.FFACE_CULL_DIR = fface_cull_dir;
  if (reg->bitfields.FFACE_CULL_DIR != fface_cull_dir) HSLDPF(E_ERROR_MESSAGE,"SE_CNTL::FFACE_CULL_DIR data too large\n");
}
__inline void set_SE_CNTL_bface_cull_fcn(regSE_CNTL *reg, unsigned int bface_cull_fcn)
{
  reg->bitfields.BFACE_CULL_FCN = bface_cull_fcn;
  if (reg->bitfields.BFACE_CULL_FCN != bface_cull_fcn) HSLDPF(E_ERROR_MESSAGE,"SE_CNTL::BFACE_CULL_FCN data too large\n");
}
__inline void set_SE_CNTL_fface_cull_fcn(regSE_CNTL *reg, unsigned int fface_cull_fcn)
{
  reg->bitfields.FFACE_CULL_FCN = fface_cull_fcn;
  if (reg->bitfields.FFACE_CULL_FCN != fface_cull_fcn) HSLDPF(E_ERROR_MESSAGE,"SE_CNTL::FFACE_CULL_FCN data too large\n");
}
__inline void set_SE_CNTL_flat_shade_vtx(regSE_CNTL *reg, unsigned int flat_shade_vtx)
{
  reg->bitfields.FLAT_SHADE_VTX = flat_shade_vtx;
  if (reg->bitfields.FLAT_SHADE_VTX != flat_shade_vtx) HSLDPF(E_ERROR_MESSAGE,"SE_CNTL::FLAT_SHADE_VTX data too large\n");
}
__inline void set_SE_CNTL_diffuse_shade_fcn(regSE_CNTL *reg, unsigned int diffuse_shade_fcn)
{
  reg->bitfields.DIFFUSE_SHADE_FCN = diffuse_shade_fcn;
  if (reg->bitfields.DIFFUSE_SHADE_FCN != diffuse_shade_fcn) HSLDPF(E_ERROR_MESSAGE,"SE_CNTL::DIFFUSE_SHADE_FCN data too large\n");
}
__inline void set_SE_CNTL_alpha_shade_fcn(regSE_CNTL *reg, unsigned int alpha_shade_fcn)
{
  reg->bitfields.ALPHA_SHADE_FCN = alpha_shade_fcn;
  if (reg->bitfields.ALPHA_SHADE_FCN != alpha_shade_fcn) HSLDPF(E_ERROR_MESSAGE,"SE_CNTL::ALPHA_SHADE_FCN data too large\n");
}
__inline void set_SE_CNTL_specular_shade_fcn(regSE_CNTL *reg, unsigned int specular_shade_fcn)
{
  reg->bitfields.SPECULAR_SHADE_FCN = specular_shade_fcn;
  if (reg->bitfields.SPECULAR_SHADE_FCN != specular_shade_fcn) HSLDPF(E_ERROR_MESSAGE,"SE_CNTL::SPECULAR_SHADE_FCN data too large\n");
}
__inline void set_SE_CNTL_fog_shade_fcn(regSE_CNTL *reg, unsigned int fog_shade_fcn)
{
  reg->bitfields.FOG_SHADE_FCN = fog_shade_fcn;
  if (reg->bitfields.FOG_SHADE_FCN != fog_shade_fcn) HSLDPF(E_ERROR_MESSAGE,"SE_CNTL::FOG_SHADE_FCN data too large\n");
}
__inline void set_SE_CNTL_zbias_en_point(regSE_CNTL *reg, unsigned int zbias_en_point)
{
  reg->bitfields.ZBIAS_EN_POINT = zbias_en_point;
  if (reg->bitfields.ZBIAS_EN_POINT != zbias_en_point) HSLDPF(E_ERROR_MESSAGE,"SE_CNTL::ZBIAS_EN_POINT data too large\n");
}
__inline void set_SE_CNTL_zbias_en_line(regSE_CNTL *reg, unsigned int zbias_en_line)
{
  reg->bitfields.ZBIAS_EN_LINE = zbias_en_line;
  if (reg->bitfields.ZBIAS_EN_LINE != zbias_en_line) HSLDPF(E_ERROR_MESSAGE,"SE_CNTL::ZBIAS_EN_LINE data too large\n");
}
__inline void set_SE_CNTL_zbias_en_tri(regSE_CNTL *reg, unsigned int zbias_en_tri)
{
  reg->bitfields.ZBIAS_EN_TRI = zbias_en_tri;
  if (reg->bitfields.ZBIAS_EN_TRI != zbias_en_tri) HSLDPF(E_ERROR_MESSAGE,"SE_CNTL::ZBIAS_EN_TRI data too large\n");
}
__inline void set_SE_CNTL_wideline_en(regSE_CNTL *reg, unsigned int wideline_en)
{
  reg->bitfields.WIDELINE_EN = wideline_en;
  if (reg->bitfields.WIDELINE_EN != wideline_en) HSLDPF(E_ERROR_MESSAGE,"SE_CNTL::WIDELINE_EN data too large\n");
}
__inline void set_SE_CNTL_discrete_fog_shade_fcn(regSE_CNTL *reg, unsigned int discrete_fog_shade_fcn)
{
  reg->bitfields.DISCRETE_FOG_SHADE_FCN = discrete_fog_shade_fcn;
  if (reg->bitfields.DISCRETE_FOG_SHADE_FCN != discrete_fog_shade_fcn) HSLDPF(E_ERROR_MESSAGE,"SE_CNTL::DISCRETE_FOG_SHADE_FCN data too large\n");
}
__inline void set_SE_CNTL_vtx_pixcenter(regSE_CNTL *reg, unsigned int vtx_pixcenter)
{
  reg->bitfields.VTX_PIXCENTER = vtx_pixcenter;
  if (reg->bitfields.VTX_PIXCENTER != vtx_pixcenter) HSLDPF(E_ERROR_MESSAGE,"SE_CNTL::VTX_PIXCENTER data too large\n");
}
__inline void set_SE_CNTL_round_mode(regSE_CNTL *reg, unsigned int round_mode)
{
  reg->bitfields.ROUND_MODE = round_mode;
  if (reg->bitfields.ROUND_MODE != round_mode) HSLDPF(E_ERROR_MESSAGE,"SE_CNTL::ROUND_MODE data too large\n");
}
__inline void set_SE_CNTL_round_precision(regSE_CNTL *reg, unsigned int round_precision)
{
  reg->bitfields.ROUND_PRECISION = round_precision;
  if (reg->bitfields.ROUND_PRECISION != round_precision) HSLDPF(E_ERROR_MESSAGE,"SE_CNTL::ROUND_PRECISION data too large\n");
}
#else
#define set_SE_CNTL_fface_cull_dir(reg, fface_cull_dir) (reg)->bitfields.FFACE_CULL_DIR = fface_cull_dir
#define set_SE_CNTL_bface_cull_fcn(reg, bface_cull_fcn) (reg)->bitfields.BFACE_CULL_FCN = bface_cull_fcn
#define set_SE_CNTL_fface_cull_fcn(reg, fface_cull_fcn) (reg)->bitfields.FFACE_CULL_FCN = fface_cull_fcn
#define set_SE_CNTL_flat_shade_vtx(reg, flat_shade_vtx) (reg)->bitfields.FLAT_SHADE_VTX = flat_shade_vtx
#define set_SE_CNTL_diffuse_shade_fcn(reg, diffuse_shade_fcn) (reg)->bitfields.DIFFUSE_SHADE_FCN = diffuse_shade_fcn
#define set_SE_CNTL_alpha_shade_fcn(reg, alpha_shade_fcn) (reg)->bitfields.ALPHA_SHADE_FCN = alpha_shade_fcn
#define set_SE_CNTL_specular_shade_fcn(reg, specular_shade_fcn) (reg)->bitfields.SPECULAR_SHADE_FCN = specular_shade_fcn
#define set_SE_CNTL_fog_shade_fcn(reg, fog_shade_fcn) (reg)->bitfields.FOG_SHADE_FCN = fog_shade_fcn
#define set_SE_CNTL_zbias_en_point(reg, zbias_en_point) (reg)->bitfields.ZBIAS_EN_POINT = zbias_en_point
#define set_SE_CNTL_zbias_en_line(reg, zbias_en_line) (reg)->bitfields.ZBIAS_EN_LINE = zbias_en_line
#define set_SE_CNTL_zbias_en_tri(reg, zbias_en_tri) (reg)->bitfields.ZBIAS_EN_TRI = zbias_en_tri
#define set_SE_CNTL_wideline_en(reg, wideline_en) (reg)->bitfields.WIDELINE_EN = wideline_en
#define set_SE_CNTL_discrete_fog_shade_fcn(reg, discrete_fog_shade_fcn) (reg)->bitfields.DISCRETE_FOG_SHADE_FCN = discrete_fog_shade_fcn
#define set_SE_CNTL_vtx_pixcenter(reg, vtx_pixcenter) (reg)->bitfields.VTX_PIXCENTER = vtx_pixcenter
#define set_SE_CNTL_round_mode(reg, round_mode) (reg)->bitfields.ROUND_MODE = round_mode
#define set_SE_CNTL_round_precision(reg, round_precision) (reg)->bitfields.ROUND_PRECISION = round_precision

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_CNTL regRE_CNTL;

#ifdef DEBUG
__inline void set_RE_CNTL_stipple_enable(regRE_CNTL *reg, unsigned int stipple_enable)
{
  reg->bitfields.STIPPLE_ENABLE = stipple_enable;
  if (reg->bitfields.STIPPLE_ENABLE != stipple_enable) HSLDPF(E_ERROR_MESSAGE,"RE_CNTL::STIPPLE_ENABLE data too large\n");
}
__inline void set_RE_CNTL_scissor_enable(regRE_CNTL *reg, unsigned int scissor_enable)
{
  reg->bitfields.SCISSOR_ENABLE = scissor_enable;
  if (reg->bitfields.SCISSOR_ENABLE != scissor_enable) HSLDPF(E_ERROR_MESSAGE,"RE_CNTL::SCISSOR_ENABLE data too large\n");
}
__inline void set_RE_CNTL_pattern_enable(regRE_CNTL *reg, unsigned int pattern_enable)
{
  reg->bitfields.PATTERN_ENABLE = pattern_enable;
  if (reg->bitfields.PATTERN_ENABLE != pattern_enable) HSLDPF(E_ERROR_MESSAGE,"RE_CNTL::PATTERN_ENABLE data too large\n");
}
__inline void set_RE_CNTL_perspective_enable(regRE_CNTL *reg, unsigned int perspective_enable)
{
  reg->bitfields.PERSPECTIVE_ENABLE = perspective_enable;
  if (reg->bitfields.PERSPECTIVE_ENABLE != perspective_enable) HSLDPF(E_ERROR_MESSAGE,"RE_CNTL::PERSPECTIVE_ENABLE data too large\n");
}
__inline void set_RE_CNTL_jitter_enable(regRE_CNTL *reg, unsigned int jitter_enable)
{
  reg->bitfields.JITTER_ENABLE = jitter_enable;
  if (reg->bitfields.JITTER_ENABLE != jitter_enable) HSLDPF(E_ERROR_MESSAGE,"RE_CNTL::JITTER_ENABLE data too large\n");
}
__inline void set_RE_CNTL_point_smooth(regRE_CNTL *reg, unsigned int point_smooth)
{
  reg->bitfields.POINT_SMOOTH = point_smooth;
  if (reg->bitfields.POINT_SMOOTH != point_smooth) HSLDPF(E_ERROR_MESSAGE,"RE_CNTL::POINT_SMOOTH data too large\n");
}
__inline void set_RE_CNTL_vtx_save_t0_n3(regRE_CNTL *reg, unsigned int vtx_save_t0_n3)
{
  reg->bitfields.VTX_SAVE_T0_N3 = vtx_save_t0_n3;
  if (reg->bitfields.VTX_SAVE_T0_N3 != vtx_save_t0_n3) HSLDPF(E_ERROR_MESSAGE,"RE_CNTL::VTX_SAVE_T0_N3 data too large\n");
}
__inline void set_RE_CNTL_vtx_save_t1_n3(regRE_CNTL *reg, unsigned int vtx_save_t1_n3)
{
  reg->bitfields.VTX_SAVE_T1_N3 = vtx_save_t1_n3;
  if (reg->bitfields.VTX_SAVE_T1_N3 != vtx_save_t1_n3) HSLDPF(E_ERROR_MESSAGE,"RE_CNTL::VTX_SAVE_T1_N3 data too large\n");
}
__inline void set_RE_CNTL_vtx_save_t2_n3(regRE_CNTL *reg, unsigned int vtx_save_t2_n3)
{
  reg->bitfields.VTX_SAVE_T2_N3 = vtx_save_t2_n3;
  if (reg->bitfields.VTX_SAVE_T2_N3 != vtx_save_t2_n3) HSLDPF(E_ERROR_MESSAGE,"RE_CNTL::VTX_SAVE_T2_N3 data too large\n");
}
__inline void set_RE_CNTL_vtx_save_t3_n3(regRE_CNTL *reg, unsigned int vtx_save_t3_n3)
{
  reg->bitfields.VTX_SAVE_T3_N3 = vtx_save_t3_n3;
  if (reg->bitfields.VTX_SAVE_T3_N3 != vtx_save_t3_n3) HSLDPF(E_ERROR_MESSAGE,"RE_CNTL::VTX_SAVE_T3_N3 data too large\n");
}
__inline void set_RE_CNTL_vtx_save_t4_n3(regRE_CNTL *reg, unsigned int vtx_save_t4_n3)
{
  reg->bitfields.VTX_SAVE_T4_N3 = vtx_save_t4_n3;
  if (reg->bitfields.VTX_SAVE_T4_N3 != vtx_save_t4_n3) HSLDPF(E_ERROR_MESSAGE,"RE_CNTL::VTX_SAVE_T4_N3 data too large\n");
}
__inline void set_RE_CNTL_vtx_stq0_route(regRE_CNTL *reg, unsigned int vtx_stq0_route)
{
  reg->bitfields.VTX_STQ0_ROUTE = vtx_stq0_route;
  if (reg->bitfields.VTX_STQ0_ROUTE != vtx_stq0_route) HSLDPF(E_ERROR_MESSAGE,"RE_CNTL::VTX_STQ0_ROUTE data too large\n");
}
__inline void set_RE_CNTL_vtx_stq1_route(regRE_CNTL *reg, unsigned int vtx_stq1_route)
{
  reg->bitfields.VTX_STQ1_ROUTE = vtx_stq1_route;
  if (reg->bitfields.VTX_STQ1_ROUTE != vtx_stq1_route) HSLDPF(E_ERROR_MESSAGE,"RE_CNTL::VTX_STQ1_ROUTE data too large\n");
}
__inline void set_RE_CNTL_vtx_stq2_route(regRE_CNTL *reg, unsigned int vtx_stq2_route)
{
  reg->bitfields.VTX_STQ2_ROUTE = vtx_stq2_route;
  if (reg->bitfields.VTX_STQ2_ROUTE != vtx_stq2_route) HSLDPF(E_ERROR_MESSAGE,"RE_CNTL::VTX_STQ2_ROUTE data too large\n");
}
__inline void set_RE_CNTL_vtx_stq3_route(regRE_CNTL *reg, unsigned int vtx_stq3_route)
{
  reg->bitfields.VTX_STQ3_ROUTE = vtx_stq3_route;
  if (reg->bitfields.VTX_STQ3_ROUTE != vtx_stq3_route) HSLDPF(E_ERROR_MESSAGE,"RE_CNTL::VTX_STQ3_ROUTE data too large\n");
}
__inline void set_RE_CNTL_vtx_stq4_route(regRE_CNTL *reg, unsigned int vtx_stq4_route)
{
  reg->bitfields.VTX_STQ4_ROUTE = vtx_stq4_route;
  if (reg->bitfields.VTX_STQ4_ROUTE != vtx_stq4_route) HSLDPF(E_ERROR_MESSAGE,"RE_CNTL::VTX_STQ4_ROUTE data too large\n");
}
__inline void set_RE_CNTL_vtx_stq5_route(regRE_CNTL *reg, unsigned int vtx_stq5_route)
{
  reg->bitfields.VTX_STQ5_ROUTE = vtx_stq5_route;
  if (reg->bitfields.VTX_STQ5_ROUTE != vtx_stq5_route) HSLDPF(E_ERROR_MESSAGE,"RE_CNTL::VTX_STQ5_ROUTE data too large\n");
}
#else
#define set_RE_CNTL_stipple_enable(reg, stipple_enable) (reg)->bitfields.STIPPLE_ENABLE = stipple_enable
#define set_RE_CNTL_scissor_enable(reg, scissor_enable) (reg)->bitfields.SCISSOR_ENABLE = scissor_enable
#define set_RE_CNTL_pattern_enable(reg, pattern_enable) (reg)->bitfields.PATTERN_ENABLE = pattern_enable
#define set_RE_CNTL_perspective_enable(reg, perspective_enable) (reg)->bitfields.PERSPECTIVE_ENABLE = perspective_enable
#define set_RE_CNTL_jitter_enable(reg, jitter_enable) (reg)->bitfields.JITTER_ENABLE = jitter_enable
#define set_RE_CNTL_point_smooth(reg, point_smooth) (reg)->bitfields.POINT_SMOOTH = point_smooth
#define set_RE_CNTL_vtx_save_t0_n3(reg, vtx_save_t0_n3) (reg)->bitfields.VTX_SAVE_T0_N3 = vtx_save_t0_n3
#define set_RE_CNTL_vtx_save_t1_n3(reg, vtx_save_t1_n3) (reg)->bitfields.VTX_SAVE_T1_N3 = vtx_save_t1_n3
#define set_RE_CNTL_vtx_save_t2_n3(reg, vtx_save_t2_n3) (reg)->bitfields.VTX_SAVE_T2_N3 = vtx_save_t2_n3
#define set_RE_CNTL_vtx_save_t3_n3(reg, vtx_save_t3_n3) (reg)->bitfields.VTX_SAVE_T3_N3 = vtx_save_t3_n3
#define set_RE_CNTL_vtx_save_t4_n3(reg, vtx_save_t4_n3) (reg)->bitfields.VTX_SAVE_T4_N3 = vtx_save_t4_n3
#define set_RE_CNTL_vtx_stq0_route(reg, vtx_stq0_route) (reg)->bitfields.VTX_STQ0_ROUTE = vtx_stq0_route
#define set_RE_CNTL_vtx_stq1_route(reg, vtx_stq1_route) (reg)->bitfields.VTX_STQ1_ROUTE = vtx_stq1_route
#define set_RE_CNTL_vtx_stq2_route(reg, vtx_stq2_route) (reg)->bitfields.VTX_STQ2_ROUTE = vtx_stq2_route
#define set_RE_CNTL_vtx_stq3_route(reg, vtx_stq3_route) (reg)->bitfields.VTX_STQ3_ROUTE = vtx_stq3_route
#define set_RE_CNTL_vtx_stq4_route(reg, vtx_stq4_route) (reg)->bitfields.VTX_STQ4_ROUTE = vtx_stq4_route
#define set_RE_CNTL_vtx_stq5_route(reg, vtx_stq5_route) (reg)->bitfields.VTX_STQ5_ROUTE = vtx_stq5_route

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_PERF_CNTL regRE_PERF_CNTL;

#ifdef DEBUG
__inline void set_RE_PERF_CNTL_cull_presetup(regRE_PERF_CNTL *reg, unsigned int cull_presetup)
{
  reg->bitfields.CULL_PRESETUP = cull_presetup;
  if (reg->bitfields.CULL_PRESETUP != cull_presetup) HSLDPF(E_ERROR_MESSAGE,"RE_PERF_CNTL::CULL_PRESETUP data too large\n");
}
__inline void set_RE_PERF_CNTL_cull_postsetup(regRE_PERF_CNTL *reg, unsigned int cull_postsetup)
{
  reg->bitfields.CULL_POSTSETUP = cull_postsetup;
  if (reg->bitfields.CULL_POSTSETUP != cull_postsetup) HSLDPF(E_ERROR_MESSAGE,"RE_PERF_CNTL::CULL_POSTSETUP data too large\n");
}
__inline void set_RE_PERF_CNTL_block_disable(regRE_PERF_CNTL *reg, unsigned int block_disable)
{
  reg->bitfields.BLOCK_DISABLE = block_disable;
  if (reg->bitfields.BLOCK_DISABLE != block_disable) HSLDPF(E_ERROR_MESSAGE,"RE_PERF_CNTL::BLOCK_DISABLE data too large\n");
}
__inline void set_RE_PERF_CNTL_hz_override(regRE_PERF_CNTL *reg, unsigned int hz_override)
{
  reg->bitfields.HZ_OVERRIDE = hz_override;
  if (reg->bitfields.HZ_OVERRIDE != hz_override) HSLDPF(E_ERROR_MESSAGE,"RE_PERF_CNTL::HZ_OVERRIDE data too large\n");
}
__inline void set_RE_PERF_CNTL_perfsel0(regRE_PERF_CNTL *reg, unsigned int perfsel0)
{
  reg->bitfields.PERFSEL0 = perfsel0;
  if (reg->bitfields.PERFSEL0 != perfsel0) HSLDPF(E_ERROR_MESSAGE,"RE_PERF_CNTL::PERFSEL0 data too large\n");
}
__inline void set_RE_PERF_CNTL_clr_perf0(regRE_PERF_CNTL *reg, unsigned int clr_perf0)
{
  reg->bitfields.CLR_PERF0 = clr_perf0;
  if (reg->bitfields.CLR_PERF0 != clr_perf0) HSLDPF(E_ERROR_MESSAGE,"RE_PERF_CNTL::CLR_PERF0 data too large\n");
}
__inline void set_RE_PERF_CNTL_en_perf0(regRE_PERF_CNTL *reg, unsigned int en_perf0)
{
  reg->bitfields.EN_PERF0 = en_perf0;
  if (reg->bitfields.EN_PERF0 != en_perf0) HSLDPF(E_ERROR_MESSAGE,"RE_PERF_CNTL::EN_PERF0 data too large\n");
}
__inline void set_RE_PERF_CNTL_perfsel1(regRE_PERF_CNTL *reg, unsigned int perfsel1)
{
  reg->bitfields.PERFSEL1 = perfsel1;
  if (reg->bitfields.PERFSEL1 != perfsel1) HSLDPF(E_ERROR_MESSAGE,"RE_PERF_CNTL::PERFSEL1 data too large\n");
}
__inline void set_RE_PERF_CNTL_clr_perf1(regRE_PERF_CNTL *reg, unsigned int clr_perf1)
{
  reg->bitfields.CLR_PERF1 = clr_perf1;
  if (reg->bitfields.CLR_PERF1 != clr_perf1) HSLDPF(E_ERROR_MESSAGE,"RE_PERF_CNTL::CLR_PERF1 data too large\n");
}
__inline void set_RE_PERF_CNTL_en_perf1(regRE_PERF_CNTL *reg, unsigned int en_perf1)
{
  reg->bitfields.EN_PERF1 = en_perf1;
  if (reg->bitfields.EN_PERF1 != en_perf1) HSLDPF(E_ERROR_MESSAGE,"RE_PERF_CNTL::EN_PERF1 data too large\n");
}
__inline void set_RE_PERF_CNTL_perfsel2(regRE_PERF_CNTL *reg, unsigned int perfsel2)
{
  reg->bitfields.PERFSEL2 = perfsel2;
  if (reg->bitfields.PERFSEL2 != perfsel2) HSLDPF(E_ERROR_MESSAGE,"RE_PERF_CNTL::PERFSEL2 data too large\n");
}
__inline void set_RE_PERF_CNTL_clr_perf2(regRE_PERF_CNTL *reg, unsigned int clr_perf2)
{
  reg->bitfields.CLR_PERF2 = clr_perf2;
  if (reg->bitfields.CLR_PERF2 != clr_perf2) HSLDPF(E_ERROR_MESSAGE,"RE_PERF_CNTL::CLR_PERF2 data too large\n");
}
__inline void set_RE_PERF_CNTL_en_perf2(regRE_PERF_CNTL *reg, unsigned int en_perf2)
{
  reg->bitfields.EN_PERF2 = en_perf2;
  if (reg->bitfields.EN_PERF2 != en_perf2) HSLDPF(E_ERROR_MESSAGE,"RE_PERF_CNTL::EN_PERF2 data too large\n");
}
#else
#define set_RE_PERF_CNTL_cull_presetup(reg, cull_presetup) (reg)->bitfields.CULL_PRESETUP = cull_presetup
#define set_RE_PERF_CNTL_cull_postsetup(reg, cull_postsetup) (reg)->bitfields.CULL_POSTSETUP = cull_postsetup
#define set_RE_PERF_CNTL_block_disable(reg, block_disable) (reg)->bitfields.BLOCK_DISABLE = block_disable
#define set_RE_PERF_CNTL_hz_override(reg, hz_override) (reg)->bitfields.HZ_OVERRIDE = hz_override
#define set_RE_PERF_CNTL_perfsel0(reg, perfsel0) (reg)->bitfields.PERFSEL0 = perfsel0
#define set_RE_PERF_CNTL_clr_perf0(reg, clr_perf0) (reg)->bitfields.CLR_PERF0 = clr_perf0
#define set_RE_PERF_CNTL_en_perf0(reg, en_perf0) (reg)->bitfields.EN_PERF0 = en_perf0
#define set_RE_PERF_CNTL_perfsel1(reg, perfsel1) (reg)->bitfields.PERFSEL1 = perfsel1
#define set_RE_PERF_CNTL_clr_perf1(reg, clr_perf1) (reg)->bitfields.CLR_PERF1 = clr_perf1
#define set_RE_PERF_CNTL_en_perf1(reg, en_perf1) (reg)->bitfields.EN_PERF1 = en_perf1
#define set_RE_PERF_CNTL_perfsel2(reg, perfsel2) (reg)->bitfields.PERFSEL2 = perfsel2
#define set_RE_PERF_CNTL_clr_perf2(reg, clr_perf2) (reg)->bitfields.CLR_PERF2 = clr_perf2
#define set_RE_PERF_CNTL_en_perf2(reg, en_perf2) (reg)->bitfields.EN_PERF2 = en_perf2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_PERF_COUNT_0 regRE_PERF_COUNT_0;

#ifdef DEBUG
__inline void set_RE_PERF_COUNT_0_perf_count(regRE_PERF_COUNT_0 *reg, unsigned int perf_count)
{
  reg->bitfields.PERF_COUNT = perf_count;
  if (reg->bitfields.PERF_COUNT != perf_count) HSLDPF(E_ERROR_MESSAGE,"RE_PERF_COUNT_0::PERF_COUNT data too large\n");
}
#else
#define set_RE_PERF_COUNT_0_perf_count(reg, perf_count) (reg)->bitfields.PERF_COUNT = perf_count

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_PERF_COUNT_1 regRE_PERF_COUNT_1;

#ifdef DEBUG
__inline void set_RE_PERF_COUNT_1_perf_count(regRE_PERF_COUNT_1 *reg, unsigned int perf_count)
{
  reg->bitfields.PERF_COUNT = perf_count;
  if (reg->bitfields.PERF_COUNT != perf_count) HSLDPF(E_ERROR_MESSAGE,"RE_PERF_COUNT_1::PERF_COUNT data too large\n");
}
#else
#define set_RE_PERF_COUNT_1_perf_count(reg, perf_count) (reg)->bitfields.PERF_COUNT = perf_count

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_PERF_COUNT_2 regRE_PERF_COUNT_2;

#ifdef DEBUG
__inline void set_RE_PERF_COUNT_2_perf_count(regRE_PERF_COUNT_2 *reg, unsigned int perf_count)
{
  reg->bitfields.PERF_COUNT = perf_count;
  if (reg->bitfields.PERF_COUNT != perf_count) HSLDPF(E_ERROR_MESSAGE,"RE_PERF_COUNT_2::PERF_COUNT data too large\n");
}
#else
#define set_RE_PERF_COUNT_2_perf_count(reg, perf_count) (reg)->bitfields.PERF_COUNT = perf_count

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_DEBUG0 regRE_DEBUG0;

#ifdef DEBUG
__inline void set_RE_DEBUG0_re_dword(regRE_DEBUG0 *reg, unsigned int re_dword)
{
  reg->bitfields.RE_DWORD = re_dword;
  if (reg->bitfields.RE_DWORD != re_dword) HSLDPF(E_ERROR_MESSAGE,"RE_DEBUG0::RE_DWORD data too large\n");
}
#else
#define set_RE_DEBUG0_re_dword(reg, re_dword) (reg)->bitfields.RE_DWORD = re_dword

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_DEBUG1 regRE_DEBUG1;

#ifdef DEBUG
__inline void set_RE_DEBUG1_re_dword(regRE_DEBUG1 *reg, unsigned int re_dword)
{
  reg->bitfields.RE_DWORD = re_dword;
  if (reg->bitfields.RE_DWORD != re_dword) HSLDPF(E_ERROR_MESSAGE,"RE_DEBUG1::RE_DWORD data too large\n");
}
#else
#define set_RE_DEBUG1_re_dword(reg, re_dword) (reg)->bitfields.RE_DWORD = re_dword

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_DEBUG2 regRE_DEBUG2;

#ifdef DEBUG
__inline void set_RE_DEBUG2_re_dword(regRE_DEBUG2 *reg, unsigned int re_dword)
{
  reg->bitfields.RE_DWORD = re_dword;
  if (reg->bitfields.RE_DWORD != re_dword) HSLDPF(E_ERROR_MESSAGE,"RE_DEBUG2::RE_DWORD data too large\n");
}
#else
#define set_RE_DEBUG2_re_dword(reg, re_dword) (reg)->bitfields.RE_DWORD = re_dword

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_DEBUG3 regRE_DEBUG3;

#ifdef DEBUG
__inline void set_RE_DEBUG3_re_dword(regRE_DEBUG3 *reg, unsigned int re_dword)
{
  reg->bitfields.RE_DWORD = re_dword;
  if (reg->bitfields.RE_DWORD != re_dword) HSLDPF(E_ERROR_MESSAGE,"RE_DEBUG3::RE_DWORD data too large\n");
}
#else
#define set_RE_DEBUG3_re_dword(reg, re_dword) (reg)->bitfields.RE_DWORD = re_dword

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_DEBUG4 regRE_DEBUG4;

#ifdef DEBUG
__inline void set_RE_DEBUG4_re_dword(regRE_DEBUG4 *reg, unsigned int re_dword)
{
  reg->bitfields.RE_DWORD = re_dword;
  if (reg->bitfields.RE_DWORD != re_dword) HSLDPF(E_ERROR_MESSAGE,"RE_DEBUG4::RE_DWORD data too large\n");
}
#else
#define set_RE_DEBUG4_re_dword(reg, re_dword) (reg)->bitfields.RE_DWORD = re_dword

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_DEBUG5 regRE_DEBUG5;

#ifdef DEBUG
__inline void set_RE_DEBUG5_re_dword(regRE_DEBUG5 *reg, unsigned int re_dword)
{
  reg->bitfields.RE_DWORD = re_dword;
  if (reg->bitfields.RE_DWORD != re_dword) HSLDPF(E_ERROR_MESSAGE,"RE_DEBUG5::RE_DWORD data too large\n");
}
#else
#define set_RE_DEBUG5_re_dword(reg, re_dword) (reg)->bitfields.RE_DWORD = re_dword

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_DEBUG6 regRE_DEBUG6;

#ifdef DEBUG
__inline void set_RE_DEBUG6_re_dword(regRE_DEBUG6 *reg, unsigned int re_dword)
{
  reg->bitfields.RE_DWORD = re_dword;
  if (reg->bitfields.RE_DWORD != re_dword) HSLDPF(E_ERROR_MESSAGE,"RE_DEBUG6::RE_DWORD data too large\n");
}
#else
#define set_RE_DEBUG6_re_dword(reg, re_dword) (reg)->bitfields.RE_DWORD = re_dword

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_DEBUG7 regRE_DEBUG7;

#ifdef DEBUG
__inline void set_RE_DEBUG7_hiz_ram_rm(regRE_DEBUG7 *reg, unsigned int hiz_ram_rm)
{
  reg->bitfields.HIZ_RAM_RM = hiz_ram_rm;
  if (reg->bitfields.HIZ_RAM_RM != hiz_ram_rm) HSLDPF(E_ERROR_MESSAGE,"RE_DEBUG7::HIZ_RAM_RM data too large\n");
}
__inline void set_RE_DEBUG7_one_prim_per_pass(regRE_DEBUG7 *reg, unsigned int one_prim_per_pass)
{
  reg->bitfields.ONE_PRIM_PER_PASS = one_prim_per_pass;
  if (reg->bitfields.ONE_PRIM_PER_PASS != one_prim_per_pass) HSLDPF(E_ERROR_MESSAGE,"RE_DEBUG7::ONE_PRIM_PER_PASS data too large\n");
}
__inline void set_RE_DEBUG7_re_dbg_data(regRE_DEBUG7 *reg, unsigned int re_dbg_data)
{
  reg->bitfields.RE_DBG_DATA = re_dbg_data;
  if (reg->bitfields.RE_DBG_DATA != re_dbg_data) HSLDPF(E_ERROR_MESSAGE,"RE_DEBUG7::RE_DBG_DATA data too large\n");
}
#else
#define set_RE_DEBUG7_hiz_ram_rm(reg, hiz_ram_rm) (reg)->bitfields.HIZ_RAM_RM = hiz_ram_rm
#define set_RE_DEBUG7_one_prim_per_pass(reg, one_prim_per_pass) (reg)->bitfields.ONE_PRIM_PER_PASS = one_prim_per_pass
#define set_RE_DEBUG7_re_dbg_data(reg, re_dbg_data) (reg)->bitfields.RE_DBG_DATA = re_dbg_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_TOP_LEFT regRE_TOP_LEFT;

#ifdef DEBUG
__inline void set_RE_TOP_LEFT_x_left(regRE_TOP_LEFT *reg, unsigned int x_left)
{
  reg->bitfields.X_LEFT = x_left;
  if (reg->bitfields.X_LEFT != x_left) HSLDPF(E_ERROR_MESSAGE,"RE_TOP_LEFT::X_LEFT data too large\n");
}
__inline void set_RE_TOP_LEFT_y_top(regRE_TOP_LEFT *reg, unsigned int y_top)
{
  reg->bitfields.Y_TOP = y_top;
  if (reg->bitfields.Y_TOP != y_top) HSLDPF(E_ERROR_MESSAGE,"RE_TOP_LEFT::Y_TOP data too large\n");
}
#else
#define set_RE_TOP_LEFT_x_left(reg, x_left) (reg)->bitfields.X_LEFT = x_left
#define set_RE_TOP_LEFT_y_top(reg, y_top) (reg)->bitfields.Y_TOP = y_top

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_MISC regRE_MISC;

#ifdef DEBUG
__inline void set_RE_MISC_stipple_x_offset(regRE_MISC *reg, unsigned int stipple_x_offset)
{
  reg->bitfields.STIPPLE_X_OFFSET = stipple_x_offset;
  if (reg->bitfields.STIPPLE_X_OFFSET != stipple_x_offset) HSLDPF(E_ERROR_MESSAGE,"RE_MISC::STIPPLE_X_OFFSET data too large\n");
}
__inline void set_RE_MISC_stipple_y_offset(regRE_MISC *reg, unsigned int stipple_y_offset)
{
  reg->bitfields.STIPPLE_Y_OFFSET = stipple_y_offset;
  if (reg->bitfields.STIPPLE_Y_OFFSET != stipple_y_offset) HSLDPF(E_ERROR_MESSAGE,"RE_MISC::STIPPLE_Y_OFFSET data too large\n");
}
__inline void set_RE_MISC_stipple_bit_order(regRE_MISC *reg, unsigned int stipple_bit_order)
{
  reg->bitfields.STIPPLE_BIT_ORDER = stipple_bit_order;
  if (reg->bitfields.STIPPLE_BIT_ORDER != stipple_bit_order) HSLDPF(E_ERROR_MESSAGE,"RE_MISC::STIPPLE_BIT_ORDER data too large\n");
}
#else
#define set_RE_MISC_stipple_x_offset(reg, stipple_x_offset) (reg)->bitfields.STIPPLE_X_OFFSET = stipple_x_offset
#define set_RE_MISC_stipple_y_offset(reg, stipple_y_offset) (reg)->bitfields.STIPPLE_Y_OFFSET = stipple_y_offset
#define set_RE_MISC_stipple_bit_order(reg, stipple_bit_order) (reg)->bitfields.STIPPLE_BIT_ORDER = stipple_bit_order

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_STIPPLE_ADDR regRE_STIPPLE_ADDR;

#ifdef DEBUG
__inline void set_RE_STIPPLE_ADDR_stipple_addr(regRE_STIPPLE_ADDR *reg, unsigned int stipple_addr)
{
  reg->bitfields.STIPPLE_ADDR = stipple_addr;
  if (reg->bitfields.STIPPLE_ADDR != stipple_addr) HSLDPF(E_ERROR_MESSAGE,"RE_STIPPLE_ADDR::STIPPLE_ADDR data too large\n");
}
#else
#define set_RE_STIPPLE_ADDR_stipple_addr(reg, stipple_addr) (reg)->bitfields.STIPPLE_ADDR = stipple_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_STIPPLE_DATA regRE_STIPPLE_DATA;

#ifdef DEBUG
__inline void set_RE_STIPPLE_DATA_stipple_data(regRE_STIPPLE_DATA *reg, unsigned int stipple_data)
{
  reg->bitfields.STIPPLE_DATA = stipple_data;
  if (reg->bitfields.STIPPLE_DATA != stipple_data) HSLDPF(E_ERROR_MESSAGE,"RE_STIPPLE_DATA::STIPPLE_DATA data too large\n");
}
#else
#define set_RE_STIPPLE_DATA_stipple_data(reg, stipple_data) (reg)->bitfields.STIPPLE_DATA = stipple_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_LINE_PATTERN regRE_LINE_PATTERN;

#ifdef DEBUG
__inline void set_RE_LINE_PATTERN_line_pattern(regRE_LINE_PATTERN *reg, unsigned int line_pattern)
{
  reg->bitfields.LINE_PATTERN = line_pattern;
  if (reg->bitfields.LINE_PATTERN != line_pattern) HSLDPF(E_ERROR_MESSAGE,"RE_LINE_PATTERN::LINE_PATTERN data too large\n");
}
__inline void set_RE_LINE_PATTERN_repeat_count(regRE_LINE_PATTERN *reg, unsigned int repeat_count)
{
  reg->bitfields.REPEAT_COUNT = repeat_count;
  if (reg->bitfields.REPEAT_COUNT != repeat_count) HSLDPF(E_ERROR_MESSAGE,"RE_LINE_PATTERN::REPEAT_COUNT data too large\n");
}
__inline void set_RE_LINE_PATTERN_pattern_start(regRE_LINE_PATTERN *reg, unsigned int pattern_start)
{
  reg->bitfields.PATTERN_START = pattern_start;
  if (reg->bitfields.PATTERN_START != pattern_start) HSLDPF(E_ERROR_MESSAGE,"RE_LINE_PATTERN::PATTERN_START data too large\n");
}
__inline void set_RE_LINE_PATTERN_pattern_bit_order(regRE_LINE_PATTERN *reg, unsigned int pattern_bit_order)
{
  reg->bitfields.PATTERN_BIT_ORDER = pattern_bit_order;
  if (reg->bitfields.PATTERN_BIT_ORDER != pattern_bit_order) HSLDPF(E_ERROR_MESSAGE,"RE_LINE_PATTERN::PATTERN_BIT_ORDER data too large\n");
}
__inline void set_RE_LINE_PATTERN_auto_reset_enable(regRE_LINE_PATTERN *reg, unsigned int auto_reset_enable)
{
  reg->bitfields.AUTO_RESET_ENABLE = auto_reset_enable;
  if (reg->bitfields.AUTO_RESET_ENABLE != auto_reset_enable) HSLDPF(E_ERROR_MESSAGE,"RE_LINE_PATTERN::AUTO_RESET_ENABLE data too large\n");
}
#else
#define set_RE_LINE_PATTERN_line_pattern(reg, line_pattern) (reg)->bitfields.LINE_PATTERN = line_pattern
#define set_RE_LINE_PATTERN_repeat_count(reg, repeat_count) (reg)->bitfields.REPEAT_COUNT = repeat_count
#define set_RE_LINE_PATTERN_pattern_start(reg, pattern_start) (reg)->bitfields.PATTERN_START = pattern_start
#define set_RE_LINE_PATTERN_pattern_bit_order(reg, pattern_bit_order) (reg)->bitfields.PATTERN_BIT_ORDER = pattern_bit_order
#define set_RE_LINE_PATTERN_auto_reset_enable(reg, auto_reset_enable) (reg)->bitfields.AUTO_RESET_ENABLE = auto_reset_enable

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_LINE_STATE regRE_LINE_STATE;

#ifdef DEBUG
__inline void set_RE_LINE_STATE_current_ptr(regRE_LINE_STATE *reg, unsigned int current_ptr)
{
  reg->bitfields.CURRENT_PTR = current_ptr;
  if (reg->bitfields.CURRENT_PTR != current_ptr) HSLDPF(E_ERROR_MESSAGE,"RE_LINE_STATE::CURRENT_PTR data too large\n");
}
__inline void set_RE_LINE_STATE_current_count(regRE_LINE_STATE *reg, unsigned int current_count)
{
  reg->bitfields.CURRENT_COUNT = current_count;
  if (reg->bitfields.CURRENT_COUNT != current_count) HSLDPF(E_ERROR_MESSAGE,"RE_LINE_STATE::CURRENT_COUNT data too large\n");
}
#else
#define set_RE_LINE_STATE_current_ptr(reg, current_ptr) (reg)->bitfields.CURRENT_PTR = current_ptr
#define set_RE_LINE_STATE_current_count(reg, current_count) (reg)->bitfields.CURRENT_COUNT = current_count

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_SCISSOR_TL_0 regRE_SCISSOR_TL_0;

#ifdef DEBUG
__inline void set_RE_SCISSOR_TL_0_x_left(regRE_SCISSOR_TL_0 *reg, unsigned int x_left)
{
  reg->bitfields.X_LEFT = x_left;
  if (reg->bitfields.X_LEFT != x_left) HSLDPF(E_ERROR_MESSAGE,"RE_SCISSOR_TL_0::X_LEFT data too large\n");
}
__inline void set_RE_SCISSOR_TL_0_y_top(regRE_SCISSOR_TL_0 *reg, unsigned int y_top)
{
  reg->bitfields.Y_TOP = y_top;
  if (reg->bitfields.Y_TOP != y_top) HSLDPF(E_ERROR_MESSAGE,"RE_SCISSOR_TL_0::Y_TOP data too large\n");
}
#else
#define set_RE_SCISSOR_TL_0_x_left(reg, x_left) (reg)->bitfields.X_LEFT = x_left
#define set_RE_SCISSOR_TL_0_y_top(reg, y_top) (reg)->bitfields.Y_TOP = y_top

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_SCISSOR_BR_0 regRE_SCISSOR_BR_0;

#ifdef DEBUG
__inline void set_RE_SCISSOR_BR_0_x_right(regRE_SCISSOR_BR_0 *reg, unsigned int x_right)
{
  reg->bitfields.X_RIGHT = x_right;
  if (reg->bitfields.X_RIGHT != x_right) HSLDPF(E_ERROR_MESSAGE,"RE_SCISSOR_BR_0::X_RIGHT data too large\n");
}
__inline void set_RE_SCISSOR_BR_0_y_bottom(regRE_SCISSOR_BR_0 *reg, unsigned int y_bottom)
{
  reg->bitfields.Y_BOTTOM = y_bottom;
  if (reg->bitfields.Y_BOTTOM != y_bottom) HSLDPF(E_ERROR_MESSAGE,"RE_SCISSOR_BR_0::Y_BOTTOM data too large\n");
}
#else
#define set_RE_SCISSOR_BR_0_x_right(reg, x_right) (reg)->bitfields.X_RIGHT = x_right
#define set_RE_SCISSOR_BR_0_y_bottom(reg, y_bottom) (reg)->bitfields.Y_BOTTOM = y_bottom

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_SCISSOR_TL_1 regRE_SCISSOR_TL_1;

#ifdef DEBUG
__inline void set_RE_SCISSOR_TL_1_x_left(regRE_SCISSOR_TL_1 *reg, unsigned int x_left)
{
  reg->bitfields.X_LEFT = x_left;
  if (reg->bitfields.X_LEFT != x_left) HSLDPF(E_ERROR_MESSAGE,"RE_SCISSOR_TL_1::X_LEFT data too large\n");
}
__inline void set_RE_SCISSOR_TL_1_y_top(regRE_SCISSOR_TL_1 *reg, unsigned int y_top)
{
  reg->bitfields.Y_TOP = y_top;
  if (reg->bitfields.Y_TOP != y_top) HSLDPF(E_ERROR_MESSAGE,"RE_SCISSOR_TL_1::Y_TOP data too large\n");
}
#else
#define set_RE_SCISSOR_TL_1_x_left(reg, x_left) (reg)->bitfields.X_LEFT = x_left
#define set_RE_SCISSOR_TL_1_y_top(reg, y_top) (reg)->bitfields.Y_TOP = y_top

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_SCISSOR_BR_1 regRE_SCISSOR_BR_1;

#ifdef DEBUG
__inline void set_RE_SCISSOR_BR_1_x_right(regRE_SCISSOR_BR_1 *reg, unsigned int x_right)
{
  reg->bitfields.X_RIGHT = x_right;
  if (reg->bitfields.X_RIGHT != x_right) HSLDPF(E_ERROR_MESSAGE,"RE_SCISSOR_BR_1::X_RIGHT data too large\n");
}
__inline void set_RE_SCISSOR_BR_1_y_bottom(regRE_SCISSOR_BR_1 *reg, unsigned int y_bottom)
{
  reg->bitfields.Y_BOTTOM = y_bottom;
  if (reg->bitfields.Y_BOTTOM != y_bottom) HSLDPF(E_ERROR_MESSAGE,"RE_SCISSOR_BR_1::Y_BOTTOM data too large\n");
}
#else
#define set_RE_SCISSOR_BR_1_x_right(reg, x_right) (reg)->bitfields.X_RIGHT = x_right
#define set_RE_SCISSOR_BR_1_y_bottom(reg, y_bottom) (reg)->bitfields.Y_BOTTOM = y_bottom

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_SCISSOR_TL_2 regRE_SCISSOR_TL_2;

#ifdef DEBUG
__inline void set_RE_SCISSOR_TL_2_x_left(regRE_SCISSOR_TL_2 *reg, unsigned int x_left)
{
  reg->bitfields.X_LEFT = x_left;
  if (reg->bitfields.X_LEFT != x_left) HSLDPF(E_ERROR_MESSAGE,"RE_SCISSOR_TL_2::X_LEFT data too large\n");
}
__inline void set_RE_SCISSOR_TL_2_y_top(regRE_SCISSOR_TL_2 *reg, unsigned int y_top)
{
  reg->bitfields.Y_TOP = y_top;
  if (reg->bitfields.Y_TOP != y_top) HSLDPF(E_ERROR_MESSAGE,"RE_SCISSOR_TL_2::Y_TOP data too large\n");
}
#else
#define set_RE_SCISSOR_TL_2_x_left(reg, x_left) (reg)->bitfields.X_LEFT = x_left
#define set_RE_SCISSOR_TL_2_y_top(reg, y_top) (reg)->bitfields.Y_TOP = y_top

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_SCISSOR_BR_2 regRE_SCISSOR_BR_2;

#ifdef DEBUG
__inline void set_RE_SCISSOR_BR_2_x_right(regRE_SCISSOR_BR_2 *reg, unsigned int x_right)
{
  reg->bitfields.X_RIGHT = x_right;
  if (reg->bitfields.X_RIGHT != x_right) HSLDPF(E_ERROR_MESSAGE,"RE_SCISSOR_BR_2::X_RIGHT data too large\n");
}
__inline void set_RE_SCISSOR_BR_2_y_bottom(regRE_SCISSOR_BR_2 *reg, unsigned int y_bottom)
{
  reg->bitfields.Y_BOTTOM = y_bottom;
  if (reg->bitfields.Y_BOTTOM != y_bottom) HSLDPF(E_ERROR_MESSAGE,"RE_SCISSOR_BR_2::Y_BOTTOM data too large\n");
}
#else
#define set_RE_SCISSOR_BR_2_x_right(reg, x_right) (reg)->bitfields.X_RIGHT = x_right
#define set_RE_SCISSOR_BR_2_y_bottom(reg, y_bottom) (reg)->bitfields.Y_BOTTOM = y_bottom

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_AUX_SCISSOR_CNTL regRE_AUX_SCISSOR_CNTL;

#ifdef DEBUG
__inline void set_RE_AUX_SCISSOR_CNTL_exclusive_scissor_0(regRE_AUX_SCISSOR_CNTL *reg, unsigned int exclusive_scissor_0)
{
  reg->bitfields.EXCLUSIVE_SCISSOR_0 = exclusive_scissor_0;
  if (reg->bitfields.EXCLUSIVE_SCISSOR_0 != exclusive_scissor_0) HSLDPF(E_ERROR_MESSAGE,"RE_AUX_SCISSOR_CNTL::EXCLUSIVE_SCISSOR_0 data too large\n");
}
__inline void set_RE_AUX_SCISSOR_CNTL_exclusive_scissor_1(regRE_AUX_SCISSOR_CNTL *reg, unsigned int exclusive_scissor_1)
{
  reg->bitfields.EXCLUSIVE_SCISSOR_1 = exclusive_scissor_1;
  if (reg->bitfields.EXCLUSIVE_SCISSOR_1 != exclusive_scissor_1) HSLDPF(E_ERROR_MESSAGE,"RE_AUX_SCISSOR_CNTL::EXCLUSIVE_SCISSOR_1 data too large\n");
}
__inline void set_RE_AUX_SCISSOR_CNTL_exclusive_scissor_2(regRE_AUX_SCISSOR_CNTL *reg, unsigned int exclusive_scissor_2)
{
  reg->bitfields.EXCLUSIVE_SCISSOR_2 = exclusive_scissor_2;
  if (reg->bitfields.EXCLUSIVE_SCISSOR_2 != exclusive_scissor_2) HSLDPF(E_ERROR_MESSAGE,"RE_AUX_SCISSOR_CNTL::EXCLUSIVE_SCISSOR_2 data too large\n");
}
__inline void set_RE_AUX_SCISSOR_CNTL_scissor_enable_0(regRE_AUX_SCISSOR_CNTL *reg, unsigned int scissor_enable_0)
{
  reg->bitfields.SCISSOR_ENABLE_0 = scissor_enable_0;
  if (reg->bitfields.SCISSOR_ENABLE_0 != scissor_enable_0) HSLDPF(E_ERROR_MESSAGE,"RE_AUX_SCISSOR_CNTL::SCISSOR_ENABLE_0 data too large\n");
}
__inline void set_RE_AUX_SCISSOR_CNTL_scissor_enable_1(regRE_AUX_SCISSOR_CNTL *reg, unsigned int scissor_enable_1)
{
  reg->bitfields.SCISSOR_ENABLE_1 = scissor_enable_1;
  if (reg->bitfields.SCISSOR_ENABLE_1 != scissor_enable_1) HSLDPF(E_ERROR_MESSAGE,"RE_AUX_SCISSOR_CNTL::SCISSOR_ENABLE_1 data too large\n");
}
__inline void set_RE_AUX_SCISSOR_CNTL_scissor_enable_2(regRE_AUX_SCISSOR_CNTL *reg, unsigned int scissor_enable_2)
{
  reg->bitfields.SCISSOR_ENABLE_2 = scissor_enable_2;
  if (reg->bitfields.SCISSOR_ENABLE_2 != scissor_enable_2) HSLDPF(E_ERROR_MESSAGE,"RE_AUX_SCISSOR_CNTL::SCISSOR_ENABLE_2 data too large\n");
}
#else
#define set_RE_AUX_SCISSOR_CNTL_exclusive_scissor_0(reg, exclusive_scissor_0) (reg)->bitfields.EXCLUSIVE_SCISSOR_0 = exclusive_scissor_0
#define set_RE_AUX_SCISSOR_CNTL_exclusive_scissor_1(reg, exclusive_scissor_1) (reg)->bitfields.EXCLUSIVE_SCISSOR_1 = exclusive_scissor_1
#define set_RE_AUX_SCISSOR_CNTL_exclusive_scissor_2(reg, exclusive_scissor_2) (reg)->bitfields.EXCLUSIVE_SCISSOR_2 = exclusive_scissor_2
#define set_RE_AUX_SCISSOR_CNTL_scissor_enable_0(reg, scissor_enable_0) (reg)->bitfields.SCISSOR_ENABLE_0 = scissor_enable_0
#define set_RE_AUX_SCISSOR_CNTL_scissor_enable_1(reg, scissor_enable_1) (reg)->bitfields.SCISSOR_ENABLE_1 = scissor_enable_1
#define set_RE_AUX_SCISSOR_CNTL_scissor_enable_2(reg, scissor_enable_2) (reg)->bitfields.SCISSOR_ENABLE_2 = scissor_enable_2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_JITTER_TABLE0 regRE_JITTER_TABLE0;

#ifdef DEBUG
__inline void set_RE_JITTER_TABLE0_sample_sel_00(regRE_JITTER_TABLE0 *reg, unsigned int sample_sel_00)
{
  reg->bitfields.SAMPLE_SEL_00 = sample_sel_00;
  if (reg->bitfields.SAMPLE_SEL_00 != sample_sel_00) HSLDPF(E_ERROR_MESSAGE,"RE_JITTER_TABLE0::SAMPLE_SEL_00 data too large\n");
}
__inline void set_RE_JITTER_TABLE0_sample_sel_10(regRE_JITTER_TABLE0 *reg, unsigned int sample_sel_10)
{
  reg->bitfields.SAMPLE_SEL_10 = sample_sel_10;
  if (reg->bitfields.SAMPLE_SEL_10 != sample_sel_10) HSLDPF(E_ERROR_MESSAGE,"RE_JITTER_TABLE0::SAMPLE_SEL_10 data too large\n");
}
__inline void set_RE_JITTER_TABLE0_sample_sel_20(regRE_JITTER_TABLE0 *reg, unsigned int sample_sel_20)
{
  reg->bitfields.SAMPLE_SEL_20 = sample_sel_20;
  if (reg->bitfields.SAMPLE_SEL_20 != sample_sel_20) HSLDPF(E_ERROR_MESSAGE,"RE_JITTER_TABLE0::SAMPLE_SEL_20 data too large\n");
}
__inline void set_RE_JITTER_TABLE0_sample_sel_30(regRE_JITTER_TABLE0 *reg, unsigned int sample_sel_30)
{
  reg->bitfields.SAMPLE_SEL_30 = sample_sel_30;
  if (reg->bitfields.SAMPLE_SEL_30 != sample_sel_30) HSLDPF(E_ERROR_MESSAGE,"RE_JITTER_TABLE0::SAMPLE_SEL_30 data too large\n");
}
__inline void set_RE_JITTER_TABLE0_sample_sel_01(regRE_JITTER_TABLE0 *reg, unsigned int sample_sel_01)
{
  reg->bitfields.SAMPLE_SEL_01 = sample_sel_01;
  if (reg->bitfields.SAMPLE_SEL_01 != sample_sel_01) HSLDPF(E_ERROR_MESSAGE,"RE_JITTER_TABLE0::SAMPLE_SEL_01 data too large\n");
}
__inline void set_RE_JITTER_TABLE0_sample_sel_11(regRE_JITTER_TABLE0 *reg, unsigned int sample_sel_11)
{
  reg->bitfields.SAMPLE_SEL_11 = sample_sel_11;
  if (reg->bitfields.SAMPLE_SEL_11 != sample_sel_11) HSLDPF(E_ERROR_MESSAGE,"RE_JITTER_TABLE0::SAMPLE_SEL_11 data too large\n");
}
__inline void set_RE_JITTER_TABLE0_sample_sel_21(regRE_JITTER_TABLE0 *reg, unsigned int sample_sel_21)
{
  reg->bitfields.SAMPLE_SEL_21 = sample_sel_21;
  if (reg->bitfields.SAMPLE_SEL_21 != sample_sel_21) HSLDPF(E_ERROR_MESSAGE,"RE_JITTER_TABLE0::SAMPLE_SEL_21 data too large\n");
}
__inline void set_RE_JITTER_TABLE0_sample_sel_31(regRE_JITTER_TABLE0 *reg, unsigned int sample_sel_31)
{
  reg->bitfields.SAMPLE_SEL_31 = sample_sel_31;
  if (reg->bitfields.SAMPLE_SEL_31 != sample_sel_31) HSLDPF(E_ERROR_MESSAGE,"RE_JITTER_TABLE0::SAMPLE_SEL_31 data too large\n");
}
#else
#define set_RE_JITTER_TABLE0_sample_sel_00(reg, sample_sel_00) (reg)->bitfields.SAMPLE_SEL_00 = sample_sel_00
#define set_RE_JITTER_TABLE0_sample_sel_10(reg, sample_sel_10) (reg)->bitfields.SAMPLE_SEL_10 = sample_sel_10
#define set_RE_JITTER_TABLE0_sample_sel_20(reg, sample_sel_20) (reg)->bitfields.SAMPLE_SEL_20 = sample_sel_20
#define set_RE_JITTER_TABLE0_sample_sel_30(reg, sample_sel_30) (reg)->bitfields.SAMPLE_SEL_30 = sample_sel_30
#define set_RE_JITTER_TABLE0_sample_sel_01(reg, sample_sel_01) (reg)->bitfields.SAMPLE_SEL_01 = sample_sel_01
#define set_RE_JITTER_TABLE0_sample_sel_11(reg, sample_sel_11) (reg)->bitfields.SAMPLE_SEL_11 = sample_sel_11
#define set_RE_JITTER_TABLE0_sample_sel_21(reg, sample_sel_21) (reg)->bitfields.SAMPLE_SEL_21 = sample_sel_21
#define set_RE_JITTER_TABLE0_sample_sel_31(reg, sample_sel_31) (reg)->bitfields.SAMPLE_SEL_31 = sample_sel_31

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_JITTER_TABLE1 regRE_JITTER_TABLE1;

#ifdef DEBUG
__inline void set_RE_JITTER_TABLE1_sample_sel_02(regRE_JITTER_TABLE1 *reg, unsigned int sample_sel_02)
{
  reg->bitfields.SAMPLE_SEL_02 = sample_sel_02;
  if (reg->bitfields.SAMPLE_SEL_02 != sample_sel_02) HSLDPF(E_ERROR_MESSAGE,"RE_JITTER_TABLE1::SAMPLE_SEL_02 data too large\n");
}
__inline void set_RE_JITTER_TABLE1_sample_sel_12(regRE_JITTER_TABLE1 *reg, unsigned int sample_sel_12)
{
  reg->bitfields.SAMPLE_SEL_12 = sample_sel_12;
  if (reg->bitfields.SAMPLE_SEL_12 != sample_sel_12) HSLDPF(E_ERROR_MESSAGE,"RE_JITTER_TABLE1::SAMPLE_SEL_12 data too large\n");
}
__inline void set_RE_JITTER_TABLE1_sample_sel_22(regRE_JITTER_TABLE1 *reg, unsigned int sample_sel_22)
{
  reg->bitfields.SAMPLE_SEL_22 = sample_sel_22;
  if (reg->bitfields.SAMPLE_SEL_22 != sample_sel_22) HSLDPF(E_ERROR_MESSAGE,"RE_JITTER_TABLE1::SAMPLE_SEL_22 data too large\n");
}
__inline void set_RE_JITTER_TABLE1_sample_sel_32(regRE_JITTER_TABLE1 *reg, unsigned int sample_sel_32)
{
  reg->bitfields.SAMPLE_SEL_32 = sample_sel_32;
  if (reg->bitfields.SAMPLE_SEL_32 != sample_sel_32) HSLDPF(E_ERROR_MESSAGE,"RE_JITTER_TABLE1::SAMPLE_SEL_32 data too large\n");
}
__inline void set_RE_JITTER_TABLE1_sample_sel_03(regRE_JITTER_TABLE1 *reg, unsigned int sample_sel_03)
{
  reg->bitfields.SAMPLE_SEL_03 = sample_sel_03;
  if (reg->bitfields.SAMPLE_SEL_03 != sample_sel_03) HSLDPF(E_ERROR_MESSAGE,"RE_JITTER_TABLE1::SAMPLE_SEL_03 data too large\n");
}
__inline void set_RE_JITTER_TABLE1_sample_sel_13(regRE_JITTER_TABLE1 *reg, unsigned int sample_sel_13)
{
  reg->bitfields.SAMPLE_SEL_13 = sample_sel_13;
  if (reg->bitfields.SAMPLE_SEL_13 != sample_sel_13) HSLDPF(E_ERROR_MESSAGE,"RE_JITTER_TABLE1::SAMPLE_SEL_13 data too large\n");
}
__inline void set_RE_JITTER_TABLE1_sample_sel_23(regRE_JITTER_TABLE1 *reg, unsigned int sample_sel_23)
{
  reg->bitfields.SAMPLE_SEL_23 = sample_sel_23;
  if (reg->bitfields.SAMPLE_SEL_23 != sample_sel_23) HSLDPF(E_ERROR_MESSAGE,"RE_JITTER_TABLE1::SAMPLE_SEL_23 data too large\n");
}
__inline void set_RE_JITTER_TABLE1_sample_sel_33(regRE_JITTER_TABLE1 *reg, unsigned int sample_sel_33)
{
  reg->bitfields.SAMPLE_SEL_33 = sample_sel_33;
  if (reg->bitfields.SAMPLE_SEL_33 != sample_sel_33) HSLDPF(E_ERROR_MESSAGE,"RE_JITTER_TABLE1::SAMPLE_SEL_33 data too large\n");
}
#else
#define set_RE_JITTER_TABLE1_sample_sel_02(reg, sample_sel_02) (reg)->bitfields.SAMPLE_SEL_02 = sample_sel_02
#define set_RE_JITTER_TABLE1_sample_sel_12(reg, sample_sel_12) (reg)->bitfields.SAMPLE_SEL_12 = sample_sel_12
#define set_RE_JITTER_TABLE1_sample_sel_22(reg, sample_sel_22) (reg)->bitfields.SAMPLE_SEL_22 = sample_sel_22
#define set_RE_JITTER_TABLE1_sample_sel_32(reg, sample_sel_32) (reg)->bitfields.SAMPLE_SEL_32 = sample_sel_32
#define set_RE_JITTER_TABLE1_sample_sel_03(reg, sample_sel_03) (reg)->bitfields.SAMPLE_SEL_03 = sample_sel_03
#define set_RE_JITTER_TABLE1_sample_sel_13(reg, sample_sel_13) (reg)->bitfields.SAMPLE_SEL_13 = sample_sel_13
#define set_RE_JITTER_TABLE1_sample_sel_23(reg, sample_sel_23) (reg)->bitfields.SAMPLE_SEL_23 = sample_sel_23
#define set_RE_JITTER_TABLE1_sample_sel_33(reg, sample_sel_33) (reg)->bitfields.SAMPLE_SEL_33 = sample_sel_33

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_FOG_TABLE_INDEX regPP_FOG_TABLE_INDEX;

#ifdef DEBUG
__inline void set_PP_FOG_TABLE_INDEX_fog_index(regPP_FOG_TABLE_INDEX *reg, unsigned int fog_index)
{
  reg->bitfields.FOG_INDEX = fog_index;
  if (reg->bitfields.FOG_INDEX != fog_index) HSLDPF(E_ERROR_MESSAGE,"PP_FOG_TABLE_INDEX::FOG_INDEX data too large\n");
}
#else
#define set_PP_FOG_TABLE_INDEX_fog_index(reg, fog_index) (reg)->bitfields.FOG_INDEX = fog_index

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_FOG_TABLE_DATA regPP_FOG_TABLE_DATA;

#ifdef DEBUG
__inline void set_PP_FOG_TABLE_DATA_fog_data(regPP_FOG_TABLE_DATA *reg, unsigned int fog_data)
{
  reg->bitfields.FOG_DATA = fog_data;
  if (reg->bitfields.FOG_DATA != fog_data) HSLDPF(E_ERROR_MESSAGE,"PP_FOG_TABLE_DATA::FOG_DATA data too large\n");
}
#else
#define set_PP_FOG_TABLE_DATA_fog_data(reg, fog_data) (reg)->bitfields.FOG_DATA = fog_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_ZBIAS_FACTOR regSE_ZBIAS_FACTOR;

#ifdef DEBUG
__inline void set_SE_ZBIAS_FACTOR_zbias_factor(regSE_ZBIAS_FACTOR *reg, unsigned int zbias_factor)
{
  reg->bitfields.ZBIAS_FACTOR = zbias_factor;
  if (reg->bitfields.ZBIAS_FACTOR != zbias_factor) HSLDPF(E_ERROR_MESSAGE,"SE_ZBIAS_FACTOR::ZBIAS_FACTOR data too large\n");
}
#else
#define set_SE_ZBIAS_FACTOR_zbias_factor(reg, zbias_factor) (reg)->bitfields.ZBIAS_FACTOR = zbias_factor

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_ZBIAS_CONSTANT regSE_ZBIAS_CONSTANT;

#ifdef DEBUG
__inline void set_SE_ZBIAS_CONSTANT_zbias_constant(regSE_ZBIAS_CONSTANT *reg, unsigned int zbias_constant)
{
  reg->bitfields.ZBIAS_CONSTANT = zbias_constant;
  if (reg->bitfields.ZBIAS_CONSTANT != zbias_constant) HSLDPF(E_ERROR_MESSAGE,"SE_ZBIAS_CONSTANT::ZBIAS_CONSTANT data too large\n");
}
#else
#define set_SE_ZBIAS_CONSTANT_zbias_constant(reg, zbias_constant) (reg)->bitfields.ZBIAS_CONSTANT = zbias_constant

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_LINE_WIDTH regSE_LINE_WIDTH;

#ifdef DEBUG
__inline void set_SE_LINE_WIDTH_line_width(regSE_LINE_WIDTH *reg, unsigned int line_width)
{
  reg->bitfields.LINE_WIDTH = line_width;
  if (reg->bitfields.LINE_WIDTH != line_width) HSLDPF(E_ERROR_MESSAGE,"SE_LINE_WIDTH::LINE_WIDTH data too large\n");
}
__inline void set_SE_LINE_WIDTH_minpointsize(regSE_LINE_WIDTH *reg, unsigned int minpointsize)
{
  reg->bitfields.MINPOINTSIZE = minpointsize;
  if (reg->bitfields.MINPOINTSIZE != minpointsize) HSLDPF(E_ERROR_MESSAGE,"SE_LINE_WIDTH::MINPOINTSIZE data too large\n");
}
#else
#define set_SE_LINE_WIDTH_line_width(reg, line_width) (reg)->bitfields.LINE_WIDTH = line_width
#define set_SE_LINE_WIDTH_minpointsize(reg, minpointsize) (reg)->bitfields.MINPOINTSIZE = minpointsize

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_W_BIAS regRE_W_BIAS;

#ifdef DEBUG
__inline void set_RE_W_BIAS_w_bias(regRE_W_BIAS *reg, unsigned int w_bias)
{
  reg->bitfields.W_BIAS = w_bias;
  if (reg->bitfields.W_BIAS != w_bias) HSLDPF(E_ERROR_MESSAGE,"RE_W_BIAS::W_BIAS data too large\n");
}
#else
#define set_RE_W_BIAS_w_bias(reg, w_bias) (reg)->bitfields.W_BIAS = w_bias

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_MC_SRC2_CNTL regSE_MC_SRC2_CNTL;

#ifdef DEBUG
__inline void set_SE_MC_SRC2_CNTL_mc_x2(regSE_MC_SRC2_CNTL *reg, unsigned int mc_x2)
{
  reg->bitfields.MC_X2 = mc_x2;
  if (reg->bitfields.MC_X2 != mc_x2) HSLDPF(E_ERROR_MESSAGE,"SE_MC_SRC2_CNTL::MC_X2 data too large\n");
}
__inline void set_SE_MC_SRC2_CNTL_mc_y2(regSE_MC_SRC2_CNTL *reg, unsigned int mc_y2)
{
  reg->bitfields.MC_Y2 = mc_y2;
  if (reg->bitfields.MC_Y2 != mc_y2) HSLDPF(E_ERROR_MESSAGE,"SE_MC_SRC2_CNTL::MC_Y2 data too large\n");
}
__inline void set_SE_MC_SRC2_CNTL_mc_sec_src_pitch_mul(regSE_MC_SRC2_CNTL *reg, unsigned int mc_sec_src_pitch_mul)
{
  reg->bitfields.MC_SEC_SRC_PITCH_MUL = mc_sec_src_pitch_mul;
  if (reg->bitfields.MC_SEC_SRC_PITCH_MUL != mc_sec_src_pitch_mul) HSLDPF(E_ERROR_MESSAGE,"SE_MC_SRC2_CNTL::MC_SEC_SRC_PITCH_MUL data too large\n");
}
#else
#define set_SE_MC_SRC2_CNTL_mc_x2(reg, mc_x2) (reg)->bitfields.MC_X2 = mc_x2
#define set_SE_MC_SRC2_CNTL_mc_y2(reg, mc_y2) (reg)->bitfields.MC_Y2 = mc_y2
#define set_SE_MC_SRC2_CNTL_mc_sec_src_pitch_mul(reg, mc_sec_src_pitch_mul) (reg)->bitfields.MC_SEC_SRC_PITCH_MUL = mc_sec_src_pitch_mul

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_MC_SRC1_CNTL regSE_MC_SRC1_CNTL;

#ifdef DEBUG
__inline void set_SE_MC_SRC1_CNTL_mc_x1(regSE_MC_SRC1_CNTL *reg, unsigned int mc_x1)
{
  reg->bitfields.MC_X1 = mc_x1;
  if (reg->bitfields.MC_X1 != mc_x1) HSLDPF(E_ERROR_MESSAGE,"SE_MC_SRC1_CNTL::MC_X1 data too large\n");
}
__inline void set_SE_MC_SRC1_CNTL_mc_y1(regSE_MC_SRC1_CNTL *reg, unsigned int mc_y1)
{
  reg->bitfields.MC_Y1 = mc_y1;
  if (reg->bitfields.MC_Y1 != mc_y1) HSLDPF(E_ERROR_MESSAGE,"SE_MC_SRC1_CNTL::MC_Y1 data too large\n");
}
__inline void set_SE_MC_SRC1_CNTL_mc_idct_enb(regSE_MC_SRC1_CNTL *reg, unsigned int mc_idct_enb)
{
  reg->bitfields.MC_IDCT_ENB = mc_idct_enb;
  if (reg->bitfields.MC_IDCT_ENB != mc_idct_enb) HSLDPF(E_ERROR_MESSAGE,"SE_MC_SRC1_CNTL::MC_IDCT_ENB data too large\n");
}
__inline void set_SE_MC_SRC1_CNTL_mc_sec_tex_enb(regSE_MC_SRC1_CNTL *reg, unsigned int mc_sec_tex_enb)
{
  reg->bitfields.MC_SEC_TEX_ENB = mc_sec_tex_enb;
  if (reg->bitfields.MC_SEC_TEX_ENB != mc_sec_tex_enb) HSLDPF(E_ERROR_MESSAGE,"SE_MC_SRC1_CNTL::MC_SEC_TEX_ENB data too large\n");
}
__inline void set_SE_MC_SRC1_CNTL_mc_src_pitch_mul(regSE_MC_SRC1_CNTL *reg, unsigned int mc_src_pitch_mul)
{
  reg->bitfields.MC_SRC_PITCH_MUL = mc_src_pitch_mul;
  if (reg->bitfields.MC_SRC_PITCH_MUL != mc_src_pitch_mul) HSLDPF(E_ERROR_MESSAGE,"SE_MC_SRC1_CNTL::MC_SRC_PITCH_MUL data too large\n");
}
#else
#define set_SE_MC_SRC1_CNTL_mc_x1(reg, mc_x1) (reg)->bitfields.MC_X1 = mc_x1
#define set_SE_MC_SRC1_CNTL_mc_y1(reg, mc_y1) (reg)->bitfields.MC_Y1 = mc_y1
#define set_SE_MC_SRC1_CNTL_mc_idct_enb(reg, mc_idct_enb) (reg)->bitfields.MC_IDCT_ENB = mc_idct_enb
#define set_SE_MC_SRC1_CNTL_mc_sec_tex_enb(reg, mc_sec_tex_enb) (reg)->bitfields.MC_SEC_TEX_ENB = mc_sec_tex_enb
#define set_SE_MC_SRC1_CNTL_mc_src_pitch_mul(reg, mc_src_pitch_mul) (reg)->bitfields.MC_SRC_PITCH_MUL = mc_src_pitch_mul

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_MC_DST_CNTL regSE_MC_DST_CNTL;

#ifdef DEBUG
__inline void set_SE_MC_DST_CNTL_mc_dst_y(regSE_MC_DST_CNTL *reg, unsigned int mc_dst_y)
{
  reg->bitfields.MC_DST_Y = mc_dst_y;
  if (reg->bitfields.MC_DST_Y != mc_dst_y) HSLDPF(E_ERROR_MESSAGE,"SE_MC_DST_CNTL::MC_DST_Y data too large\n");
}
__inline void set_SE_MC_DST_CNTL_mc_dst_x(regSE_MC_DST_CNTL *reg, unsigned int mc_dst_x)
{
  reg->bitfields.MC_DST_X = mc_dst_x;
  if (reg->bitfields.MC_DST_X != mc_dst_x) HSLDPF(E_ERROR_MESSAGE,"SE_MC_DST_CNTL::MC_DST_X data too large\n");
}
__inline void set_SE_MC_DST_CNTL_mc_dst_pitch_mul(regSE_MC_DST_CNTL *reg, unsigned int mc_dst_pitch_mul)
{
  reg->bitfields.MC_DST_PITCH_MUL = mc_dst_pitch_mul;
  if (reg->bitfields.MC_DST_PITCH_MUL != mc_dst_pitch_mul) HSLDPF(E_ERROR_MESSAGE,"SE_MC_DST_CNTL::MC_DST_PITCH_MUL data too large\n");
}
#else
#define set_SE_MC_DST_CNTL_mc_dst_y(reg, mc_dst_y) (reg)->bitfields.MC_DST_Y = mc_dst_y
#define set_SE_MC_DST_CNTL_mc_dst_x(reg, mc_dst_x) (reg)->bitfields.MC_DST_X = mc_dst_x
#define set_SE_MC_DST_CNTL_mc_dst_pitch_mul(reg, mc_dst_pitch_mul) (reg)->bitfields.MC_DST_PITCH_MUL = mc_dst_pitch_mul

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_MC_CNTL_START regSE_MC_CNTL_START;

#ifdef DEBUG
__inline void set_SE_MC_CNTL_START_mc_cntl_src_1_index(regSE_MC_CNTL_START *reg, unsigned int mc_cntl_src_1_index)
{
  reg->bitfields.MC_CNTL_SRC_1_INDEX = mc_cntl_src_1_index;
  if (reg->bitfields.MC_CNTL_SRC_1_INDEX != mc_cntl_src_1_index) HSLDPF(E_ERROR_MESSAGE,"SE_MC_CNTL_START::MC_CNTL_SRC_1_INDEX data too large\n");
}
__inline void set_SE_MC_CNTL_START_mc_cntl_dst_offset(regSE_MC_CNTL_START *reg, unsigned int mc_cntl_dst_offset)
{
  reg->bitfields.MC_CNTL_DST_OFFSET = mc_cntl_dst_offset;
  if (reg->bitfields.MC_CNTL_DST_OFFSET != mc_cntl_dst_offset) HSLDPF(E_ERROR_MESSAGE,"SE_MC_CNTL_START::MC_CNTL_DST_OFFSET data too large\n");
}
__inline void set_SE_MC_CNTL_START_mc_alpha_enb(regSE_MC_CNTL_START *reg, unsigned int mc_alpha_enb)
{
  reg->bitfields.MC_ALPHA_ENB = mc_alpha_enb;
  if (reg->bitfields.MC_ALPHA_ENB != mc_alpha_enb) HSLDPF(E_ERROR_MESSAGE,"SE_MC_CNTL_START::MC_ALPHA_ENB data too large\n");
}
__inline void set_SE_MC_CNTL_START_mc_cntl_src_2_index(regSE_MC_CNTL_START *reg, unsigned int mc_cntl_src_2_index)
{
  reg->bitfields.MC_CNTL_SRC_2_INDEX = mc_cntl_src_2_index;
  if (reg->bitfields.MC_CNTL_SRC_2_INDEX != mc_cntl_src_2_index) HSLDPF(E_ERROR_MESSAGE,"SE_MC_CNTL_START::MC_CNTL_SRC_2_INDEX data too large\n");
}
__inline void set_SE_MC_CNTL_START_mc_cntl_width_height_sel(regSE_MC_CNTL_START *reg, unsigned int mc_cntl_width_height_sel)
{
  reg->bitfields.MC_CNTL_WIDTH_HEIGHT_SEL = mc_cntl_width_height_sel;
  if (reg->bitfields.MC_CNTL_WIDTH_HEIGHT_SEL != mc_cntl_width_height_sel) HSLDPF(E_ERROR_MESSAGE,"SE_MC_CNTL_START::MC_CNTL_WIDTH_HEIGHT_SEL data too large\n");
}
#else
#define set_SE_MC_CNTL_START_mc_cntl_src_1_index(reg, mc_cntl_src_1_index) (reg)->bitfields.MC_CNTL_SRC_1_INDEX = mc_cntl_src_1_index
#define set_SE_MC_CNTL_START_mc_cntl_dst_offset(reg, mc_cntl_dst_offset) (reg)->bitfields.MC_CNTL_DST_OFFSET = mc_cntl_dst_offset
#define set_SE_MC_CNTL_START_mc_alpha_enb(reg, mc_alpha_enb) (reg)->bitfields.MC_ALPHA_ENB = mc_alpha_enb
#define set_SE_MC_CNTL_START_mc_cntl_src_2_index(reg, mc_cntl_src_2_index) (reg)->bitfields.MC_CNTL_SRC_2_INDEX = mc_cntl_src_2_index
#define set_SE_MC_CNTL_START_mc_cntl_width_height_sel(reg, mc_cntl_width_height_sel) (reg)->bitfields.MC_CNTL_WIDTH_HEIGHT_SEL = mc_cntl_width_height_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_MC_BUF_BASE regSE_MC_BUF_BASE;

#ifdef DEBUG
__inline void set_SE_MC_BUF_BASE_mc_buf_base(regSE_MC_BUF_BASE *reg, unsigned int mc_buf_base)
{
  reg->bitfields.MC_BUF_BASE = mc_buf_base;
  if (reg->bitfields.MC_BUF_BASE != mc_buf_base) HSLDPF(E_ERROR_MESSAGE,"SE_MC_BUF_BASE::MC_BUF_BASE data too large\n");
}
#else
#define set_SE_MC_BUF_BASE_mc_buf_base(reg, mc_buf_base) (reg)->bitfields.MC_BUF_BASE = mc_buf_base

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXFILTER_0 regPP_TXFILTER_0;

#ifdef DEBUG
__inline void set_PP_TXFILTER_0_mag_filter(regPP_TXFILTER_0 *reg, unsigned int mag_filter)
{
  reg->bitfields.MAG_FILTER = mag_filter;
  if (reg->bitfields.MAG_FILTER != mag_filter) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_0::MAG_FILTER data too large\n");
}
__inline void set_PP_TXFILTER_0_min_filter(regPP_TXFILTER_0 *reg, unsigned int min_filter)
{
  reg->bitfields.MIN_FILTER = min_filter;
  if (reg->bitfields.MIN_FILTER != min_filter) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_0::MIN_FILTER data too large\n");
}
__inline void set_PP_TXFILTER_0_max_anis(regPP_TXFILTER_0 *reg, unsigned int max_anis)
{
  reg->bitfields.MAX_ANIS = max_anis;
  if (reg->bitfields.MAX_ANIS != max_anis) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_0::MAX_ANIS data too large\n");
}
__inline void set_PP_TXFILTER_0_max_mip_level(regPP_TXFILTER_0 *reg, unsigned int max_mip_level)
{
  reg->bitfields.MAX_MIP_LEVEL = max_mip_level;
  if (reg->bitfields.MAX_MIP_LEVEL != max_mip_level) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_0::MAX_MIP_LEVEL data too large\n");
}
__inline void set_PP_TXFILTER_0_yuv_to_rgb(regPP_TXFILTER_0 *reg, unsigned int yuv_to_rgb)
{
  reg->bitfields.YUV_TO_RGB = yuv_to_rgb;
  if (reg->bitfields.YUV_TO_RGB != yuv_to_rgb) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_0::YUV_TO_RGB data too large\n");
}
__inline void set_PP_TXFILTER_0_yuv_temperature(regPP_TXFILTER_0 *reg, unsigned int yuv_temperature)
{
  reg->bitfields.YUV_TEMPERATURE = yuv_temperature;
  if (reg->bitfields.YUV_TEMPERATURE != yuv_temperature) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_0::YUV_TEMPERATURE data too large\n");
}
__inline void set_PP_TXFILTER_0_wrapen_s(regPP_TXFILTER_0 *reg, unsigned int wrapen_s)
{
  reg->bitfields.WRAPEN_S = wrapen_s;
  if (reg->bitfields.WRAPEN_S != wrapen_s) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_0::WRAPEN_S data too large\n");
}
__inline void set_PP_TXFILTER_0_clamp_s(regPP_TXFILTER_0 *reg, unsigned int clamp_s)
{
  reg->bitfields.CLAMP_S = clamp_s;
  if (reg->bitfields.CLAMP_S != clamp_s) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_0::CLAMP_S data too large\n");
}
__inline void set_PP_TXFILTER_0_wrapen_t(regPP_TXFILTER_0 *reg, unsigned int wrapen_t)
{
  reg->bitfields.WRAPEN_T = wrapen_t;
  if (reg->bitfields.WRAPEN_T != wrapen_t) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_0::WRAPEN_T data too large\n");
}
__inline void set_PP_TXFILTER_0_clamp_t(regPP_TXFILTER_0 *reg, unsigned int clamp_t)
{
  reg->bitfields.CLAMP_T = clamp_t;
  if (reg->bitfields.CLAMP_T != clamp_t) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_0::CLAMP_T data too large\n");
}
__inline void set_PP_TXFILTER_0_kill_lt_0(regPP_TXFILTER_0 *reg, unsigned int kill_lt_0)
{
  reg->bitfields.KILL_LT_0 = kill_lt_0;
  if (reg->bitfields.KILL_LT_0 != kill_lt_0) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_0::KILL_LT_0 data too large\n");
}
__inline void set_PP_TXFILTER_0_border_mode(regPP_TXFILTER_0 *reg, unsigned int border_mode)
{
  reg->bitfields.BORDER_MODE = border_mode;
  if (reg->bitfields.BORDER_MODE != border_mode) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_0::BORDER_MODE data too large\n");
}
#else
#define set_PP_TXFILTER_0_mag_filter(reg, mag_filter) (reg)->bitfields.MAG_FILTER = mag_filter
#define set_PP_TXFILTER_0_min_filter(reg, min_filter) (reg)->bitfields.MIN_FILTER = min_filter
#define set_PP_TXFILTER_0_max_anis(reg, max_anis) (reg)->bitfields.MAX_ANIS = max_anis
#define set_PP_TXFILTER_0_max_mip_level(reg, max_mip_level) (reg)->bitfields.MAX_MIP_LEVEL = max_mip_level
#define set_PP_TXFILTER_0_yuv_to_rgb(reg, yuv_to_rgb) (reg)->bitfields.YUV_TO_RGB = yuv_to_rgb
#define set_PP_TXFILTER_0_yuv_temperature(reg, yuv_temperature) (reg)->bitfields.YUV_TEMPERATURE = yuv_temperature
#define set_PP_TXFILTER_0_wrapen_s(reg, wrapen_s) (reg)->bitfields.WRAPEN_S = wrapen_s
#define set_PP_TXFILTER_0_clamp_s(reg, clamp_s) (reg)->bitfields.CLAMP_S = clamp_s
#define set_PP_TXFILTER_0_wrapen_t(reg, wrapen_t) (reg)->bitfields.WRAPEN_T = wrapen_t
#define set_PP_TXFILTER_0_clamp_t(reg, clamp_t) (reg)->bitfields.CLAMP_T = clamp_t
#define set_PP_TXFILTER_0_kill_lt_0(reg, kill_lt_0) (reg)->bitfields.KILL_LT_0 = kill_lt_0
#define set_PP_TXFILTER_0_border_mode(reg, border_mode) (reg)->bitfields.BORDER_MODE = border_mode

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXFILTER_1 regPP_TXFILTER_1;

#ifdef DEBUG
__inline void set_PP_TXFILTER_1_mag_filter(regPP_TXFILTER_1 *reg, unsigned int mag_filter)
{
  reg->bitfields.MAG_FILTER = mag_filter;
  if (reg->bitfields.MAG_FILTER != mag_filter) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_1::MAG_FILTER data too large\n");
}
__inline void set_PP_TXFILTER_1_min_filter(regPP_TXFILTER_1 *reg, unsigned int min_filter)
{
  reg->bitfields.MIN_FILTER = min_filter;
  if (reg->bitfields.MIN_FILTER != min_filter) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_1::MIN_FILTER data too large\n");
}
__inline void set_PP_TXFILTER_1_max_anis(regPP_TXFILTER_1 *reg, unsigned int max_anis)
{
  reg->bitfields.MAX_ANIS = max_anis;
  if (reg->bitfields.MAX_ANIS != max_anis) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_1::MAX_ANIS data too large\n");
}
__inline void set_PP_TXFILTER_1_max_mip_level(regPP_TXFILTER_1 *reg, unsigned int max_mip_level)
{
  reg->bitfields.MAX_MIP_LEVEL = max_mip_level;
  if (reg->bitfields.MAX_MIP_LEVEL != max_mip_level) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_1::MAX_MIP_LEVEL data too large\n");
}
__inline void set_PP_TXFILTER_1_yuv_to_rgb(regPP_TXFILTER_1 *reg, unsigned int yuv_to_rgb)
{
  reg->bitfields.YUV_TO_RGB = yuv_to_rgb;
  if (reg->bitfields.YUV_TO_RGB != yuv_to_rgb) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_1::YUV_TO_RGB data too large\n");
}
__inline void set_PP_TXFILTER_1_yuv_temperature(regPP_TXFILTER_1 *reg, unsigned int yuv_temperature)
{
  reg->bitfields.YUV_TEMPERATURE = yuv_temperature;
  if (reg->bitfields.YUV_TEMPERATURE != yuv_temperature) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_1::YUV_TEMPERATURE data too large\n");
}
__inline void set_PP_TXFILTER_1_wrapen_s(regPP_TXFILTER_1 *reg, unsigned int wrapen_s)
{
  reg->bitfields.WRAPEN_S = wrapen_s;
  if (reg->bitfields.WRAPEN_S != wrapen_s) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_1::WRAPEN_S data too large\n");
}
__inline void set_PP_TXFILTER_1_clamp_s(regPP_TXFILTER_1 *reg, unsigned int clamp_s)
{
  reg->bitfields.CLAMP_S = clamp_s;
  if (reg->bitfields.CLAMP_S != clamp_s) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_1::CLAMP_S data too large\n");
}
__inline void set_PP_TXFILTER_1_wrapen_t(regPP_TXFILTER_1 *reg, unsigned int wrapen_t)
{
  reg->bitfields.WRAPEN_T = wrapen_t;
  if (reg->bitfields.WRAPEN_T != wrapen_t) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_1::WRAPEN_T data too large\n");
}
__inline void set_PP_TXFILTER_1_clamp_t(regPP_TXFILTER_1 *reg, unsigned int clamp_t)
{
  reg->bitfields.CLAMP_T = clamp_t;
  if (reg->bitfields.CLAMP_T != clamp_t) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_1::CLAMP_T data too large\n");
}
__inline void set_PP_TXFILTER_1_kill_lt_0(regPP_TXFILTER_1 *reg, unsigned int kill_lt_0)
{
  reg->bitfields.KILL_LT_0 = kill_lt_0;
  if (reg->bitfields.KILL_LT_0 != kill_lt_0) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_1::KILL_LT_0 data too large\n");
}
__inline void set_PP_TXFILTER_1_border_mode(regPP_TXFILTER_1 *reg, unsigned int border_mode)
{
  reg->bitfields.BORDER_MODE = border_mode;
  if (reg->bitfields.BORDER_MODE != border_mode) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_1::BORDER_MODE data too large\n");
}
#else
#define set_PP_TXFILTER_1_mag_filter(reg, mag_filter) (reg)->bitfields.MAG_FILTER = mag_filter
#define set_PP_TXFILTER_1_min_filter(reg, min_filter) (reg)->bitfields.MIN_FILTER = min_filter
#define set_PP_TXFILTER_1_max_anis(reg, max_anis) (reg)->bitfields.MAX_ANIS = max_anis
#define set_PP_TXFILTER_1_max_mip_level(reg, max_mip_level) (reg)->bitfields.MAX_MIP_LEVEL = max_mip_level
#define set_PP_TXFILTER_1_yuv_to_rgb(reg, yuv_to_rgb) (reg)->bitfields.YUV_TO_RGB = yuv_to_rgb
#define set_PP_TXFILTER_1_yuv_temperature(reg, yuv_temperature) (reg)->bitfields.YUV_TEMPERATURE = yuv_temperature
#define set_PP_TXFILTER_1_wrapen_s(reg, wrapen_s) (reg)->bitfields.WRAPEN_S = wrapen_s
#define set_PP_TXFILTER_1_clamp_s(reg, clamp_s) (reg)->bitfields.CLAMP_S = clamp_s
#define set_PP_TXFILTER_1_wrapen_t(reg, wrapen_t) (reg)->bitfields.WRAPEN_T = wrapen_t
#define set_PP_TXFILTER_1_clamp_t(reg, clamp_t) (reg)->bitfields.CLAMP_T = clamp_t
#define set_PP_TXFILTER_1_kill_lt_0(reg, kill_lt_0) (reg)->bitfields.KILL_LT_0 = kill_lt_0
#define set_PP_TXFILTER_1_border_mode(reg, border_mode) (reg)->bitfields.BORDER_MODE = border_mode

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXFILTER_2 regPP_TXFILTER_2;

#ifdef DEBUG
__inline void set_PP_TXFILTER_2_mag_filter(regPP_TXFILTER_2 *reg, unsigned int mag_filter)
{
  reg->bitfields.MAG_FILTER = mag_filter;
  if (reg->bitfields.MAG_FILTER != mag_filter) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_2::MAG_FILTER data too large\n");
}
__inline void set_PP_TXFILTER_2_min_filter(regPP_TXFILTER_2 *reg, unsigned int min_filter)
{
  reg->bitfields.MIN_FILTER = min_filter;
  if (reg->bitfields.MIN_FILTER != min_filter) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_2::MIN_FILTER data too large\n");
}
__inline void set_PP_TXFILTER_2_max_anis(regPP_TXFILTER_2 *reg, unsigned int max_anis)
{
  reg->bitfields.MAX_ANIS = max_anis;
  if (reg->bitfields.MAX_ANIS != max_anis) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_2::MAX_ANIS data too large\n");
}
__inline void set_PP_TXFILTER_2_max_mip_level(regPP_TXFILTER_2 *reg, unsigned int max_mip_level)
{
  reg->bitfields.MAX_MIP_LEVEL = max_mip_level;
  if (reg->bitfields.MAX_MIP_LEVEL != max_mip_level) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_2::MAX_MIP_LEVEL data too large\n");
}
__inline void set_PP_TXFILTER_2_yuv_to_rgb(regPP_TXFILTER_2 *reg, unsigned int yuv_to_rgb)
{
  reg->bitfields.YUV_TO_RGB = yuv_to_rgb;
  if (reg->bitfields.YUV_TO_RGB != yuv_to_rgb) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_2::YUV_TO_RGB data too large\n");
}
__inline void set_PP_TXFILTER_2_yuv_temperature(regPP_TXFILTER_2 *reg, unsigned int yuv_temperature)
{
  reg->bitfields.YUV_TEMPERATURE = yuv_temperature;
  if (reg->bitfields.YUV_TEMPERATURE != yuv_temperature) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_2::YUV_TEMPERATURE data too large\n");
}
__inline void set_PP_TXFILTER_2_wrapen_s(regPP_TXFILTER_2 *reg, unsigned int wrapen_s)
{
  reg->bitfields.WRAPEN_S = wrapen_s;
  if (reg->bitfields.WRAPEN_S != wrapen_s) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_2::WRAPEN_S data too large\n");
}
__inline void set_PP_TXFILTER_2_clamp_s(regPP_TXFILTER_2 *reg, unsigned int clamp_s)
{
  reg->bitfields.CLAMP_S = clamp_s;
  if (reg->bitfields.CLAMP_S != clamp_s) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_2::CLAMP_S data too large\n");
}
__inline void set_PP_TXFILTER_2_wrapen_t(regPP_TXFILTER_2 *reg, unsigned int wrapen_t)
{
  reg->bitfields.WRAPEN_T = wrapen_t;
  if (reg->bitfields.WRAPEN_T != wrapen_t) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_2::WRAPEN_T data too large\n");
}
__inline void set_PP_TXFILTER_2_clamp_t(regPP_TXFILTER_2 *reg, unsigned int clamp_t)
{
  reg->bitfields.CLAMP_T = clamp_t;
  if (reg->bitfields.CLAMP_T != clamp_t) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_2::CLAMP_T data too large\n");
}
__inline void set_PP_TXFILTER_2_kill_lt_0(regPP_TXFILTER_2 *reg, unsigned int kill_lt_0)
{
  reg->bitfields.KILL_LT_0 = kill_lt_0;
  if (reg->bitfields.KILL_LT_0 != kill_lt_0) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_2::KILL_LT_0 data too large\n");
}
__inline void set_PP_TXFILTER_2_border_mode(regPP_TXFILTER_2 *reg, unsigned int border_mode)
{
  reg->bitfields.BORDER_MODE = border_mode;
  if (reg->bitfields.BORDER_MODE != border_mode) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_2::BORDER_MODE data too large\n");
}
#else
#define set_PP_TXFILTER_2_mag_filter(reg, mag_filter) (reg)->bitfields.MAG_FILTER = mag_filter
#define set_PP_TXFILTER_2_min_filter(reg, min_filter) (reg)->bitfields.MIN_FILTER = min_filter
#define set_PP_TXFILTER_2_max_anis(reg, max_anis) (reg)->bitfields.MAX_ANIS = max_anis
#define set_PP_TXFILTER_2_max_mip_level(reg, max_mip_level) (reg)->bitfields.MAX_MIP_LEVEL = max_mip_level
#define set_PP_TXFILTER_2_yuv_to_rgb(reg, yuv_to_rgb) (reg)->bitfields.YUV_TO_RGB = yuv_to_rgb
#define set_PP_TXFILTER_2_yuv_temperature(reg, yuv_temperature) (reg)->bitfields.YUV_TEMPERATURE = yuv_temperature
#define set_PP_TXFILTER_2_wrapen_s(reg, wrapen_s) (reg)->bitfields.WRAPEN_S = wrapen_s
#define set_PP_TXFILTER_2_clamp_s(reg, clamp_s) (reg)->bitfields.CLAMP_S = clamp_s
#define set_PP_TXFILTER_2_wrapen_t(reg, wrapen_t) (reg)->bitfields.WRAPEN_T = wrapen_t
#define set_PP_TXFILTER_2_clamp_t(reg, clamp_t) (reg)->bitfields.CLAMP_T = clamp_t
#define set_PP_TXFILTER_2_kill_lt_0(reg, kill_lt_0) (reg)->bitfields.KILL_LT_0 = kill_lt_0
#define set_PP_TXFILTER_2_border_mode(reg, border_mode) (reg)->bitfields.BORDER_MODE = border_mode

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXFILTER_3 regPP_TXFILTER_3;

#ifdef DEBUG
__inline void set_PP_TXFILTER_3_mag_filter(regPP_TXFILTER_3 *reg, unsigned int mag_filter)
{
  reg->bitfields.MAG_FILTER = mag_filter;
  if (reg->bitfields.MAG_FILTER != mag_filter) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_3::MAG_FILTER data too large\n");
}
__inline void set_PP_TXFILTER_3_min_filter(regPP_TXFILTER_3 *reg, unsigned int min_filter)
{
  reg->bitfields.MIN_FILTER = min_filter;
  if (reg->bitfields.MIN_FILTER != min_filter) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_3::MIN_FILTER data too large\n");
}
__inline void set_PP_TXFILTER_3_max_anis(regPP_TXFILTER_3 *reg, unsigned int max_anis)
{
  reg->bitfields.MAX_ANIS = max_anis;
  if (reg->bitfields.MAX_ANIS != max_anis) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_3::MAX_ANIS data too large\n");
}
__inline void set_PP_TXFILTER_3_max_mip_level(regPP_TXFILTER_3 *reg, unsigned int max_mip_level)
{
  reg->bitfields.MAX_MIP_LEVEL = max_mip_level;
  if (reg->bitfields.MAX_MIP_LEVEL != max_mip_level) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_3::MAX_MIP_LEVEL data too large\n");
}
__inline void set_PP_TXFILTER_3_yuv_to_rgb(regPP_TXFILTER_3 *reg, unsigned int yuv_to_rgb)
{
  reg->bitfields.YUV_TO_RGB = yuv_to_rgb;
  if (reg->bitfields.YUV_TO_RGB != yuv_to_rgb) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_3::YUV_TO_RGB data too large\n");
}
__inline void set_PP_TXFILTER_3_yuv_temperature(regPP_TXFILTER_3 *reg, unsigned int yuv_temperature)
{
  reg->bitfields.YUV_TEMPERATURE = yuv_temperature;
  if (reg->bitfields.YUV_TEMPERATURE != yuv_temperature) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_3::YUV_TEMPERATURE data too large\n");
}
__inline void set_PP_TXFILTER_3_wrapen_s(regPP_TXFILTER_3 *reg, unsigned int wrapen_s)
{
  reg->bitfields.WRAPEN_S = wrapen_s;
  if (reg->bitfields.WRAPEN_S != wrapen_s) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_3::WRAPEN_S data too large\n");
}
__inline void set_PP_TXFILTER_3_clamp_s(regPP_TXFILTER_3 *reg, unsigned int clamp_s)
{
  reg->bitfields.CLAMP_S = clamp_s;
  if (reg->bitfields.CLAMP_S != clamp_s) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_3::CLAMP_S data too large\n");
}
__inline void set_PP_TXFILTER_3_wrapen_t(regPP_TXFILTER_3 *reg, unsigned int wrapen_t)
{
  reg->bitfields.WRAPEN_T = wrapen_t;
  if (reg->bitfields.WRAPEN_T != wrapen_t) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_3::WRAPEN_T data too large\n");
}
__inline void set_PP_TXFILTER_3_clamp_t(regPP_TXFILTER_3 *reg, unsigned int clamp_t)
{
  reg->bitfields.CLAMP_T = clamp_t;
  if (reg->bitfields.CLAMP_T != clamp_t) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_3::CLAMP_T data too large\n");
}
__inline void set_PP_TXFILTER_3_kill_lt_0(regPP_TXFILTER_3 *reg, unsigned int kill_lt_0)
{
  reg->bitfields.KILL_LT_0 = kill_lt_0;
  if (reg->bitfields.KILL_LT_0 != kill_lt_0) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_3::KILL_LT_0 data too large\n");
}
__inline void set_PP_TXFILTER_3_border_mode(regPP_TXFILTER_3 *reg, unsigned int border_mode)
{
  reg->bitfields.BORDER_MODE = border_mode;
  if (reg->bitfields.BORDER_MODE != border_mode) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_3::BORDER_MODE data too large\n");
}
#else
#define set_PP_TXFILTER_3_mag_filter(reg, mag_filter) (reg)->bitfields.MAG_FILTER = mag_filter
#define set_PP_TXFILTER_3_min_filter(reg, min_filter) (reg)->bitfields.MIN_FILTER = min_filter
#define set_PP_TXFILTER_3_max_anis(reg, max_anis) (reg)->bitfields.MAX_ANIS = max_anis
#define set_PP_TXFILTER_3_max_mip_level(reg, max_mip_level) (reg)->bitfields.MAX_MIP_LEVEL = max_mip_level
#define set_PP_TXFILTER_3_yuv_to_rgb(reg, yuv_to_rgb) (reg)->bitfields.YUV_TO_RGB = yuv_to_rgb
#define set_PP_TXFILTER_3_yuv_temperature(reg, yuv_temperature) (reg)->bitfields.YUV_TEMPERATURE = yuv_temperature
#define set_PP_TXFILTER_3_wrapen_s(reg, wrapen_s) (reg)->bitfields.WRAPEN_S = wrapen_s
#define set_PP_TXFILTER_3_clamp_s(reg, clamp_s) (reg)->bitfields.CLAMP_S = clamp_s
#define set_PP_TXFILTER_3_wrapen_t(reg, wrapen_t) (reg)->bitfields.WRAPEN_T = wrapen_t
#define set_PP_TXFILTER_3_clamp_t(reg, clamp_t) (reg)->bitfields.CLAMP_T = clamp_t
#define set_PP_TXFILTER_3_kill_lt_0(reg, kill_lt_0) (reg)->bitfields.KILL_LT_0 = kill_lt_0
#define set_PP_TXFILTER_3_border_mode(reg, border_mode) (reg)->bitfields.BORDER_MODE = border_mode

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXFILTER_4 regPP_TXFILTER_4;

#ifdef DEBUG
__inline void set_PP_TXFILTER_4_mag_filter(regPP_TXFILTER_4 *reg, unsigned int mag_filter)
{
  reg->bitfields.MAG_FILTER = mag_filter;
  if (reg->bitfields.MAG_FILTER != mag_filter) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_4::MAG_FILTER data too large\n");
}
__inline void set_PP_TXFILTER_4_min_filter(regPP_TXFILTER_4 *reg, unsigned int min_filter)
{
  reg->bitfields.MIN_FILTER = min_filter;
  if (reg->bitfields.MIN_FILTER != min_filter) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_4::MIN_FILTER data too large\n");
}
__inline void set_PP_TXFILTER_4_max_anis(regPP_TXFILTER_4 *reg, unsigned int max_anis)
{
  reg->bitfields.MAX_ANIS = max_anis;
  if (reg->bitfields.MAX_ANIS != max_anis) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_4::MAX_ANIS data too large\n");
}
__inline void set_PP_TXFILTER_4_max_mip_level(regPP_TXFILTER_4 *reg, unsigned int max_mip_level)
{
  reg->bitfields.MAX_MIP_LEVEL = max_mip_level;
  if (reg->bitfields.MAX_MIP_LEVEL != max_mip_level) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_4::MAX_MIP_LEVEL data too large\n");
}
__inline void set_PP_TXFILTER_4_yuv_to_rgb(regPP_TXFILTER_4 *reg, unsigned int yuv_to_rgb)
{
  reg->bitfields.YUV_TO_RGB = yuv_to_rgb;
  if (reg->bitfields.YUV_TO_RGB != yuv_to_rgb) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_4::YUV_TO_RGB data too large\n");
}
__inline void set_PP_TXFILTER_4_yuv_temperature(regPP_TXFILTER_4 *reg, unsigned int yuv_temperature)
{
  reg->bitfields.YUV_TEMPERATURE = yuv_temperature;
  if (reg->bitfields.YUV_TEMPERATURE != yuv_temperature) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_4::YUV_TEMPERATURE data too large\n");
}
__inline void set_PP_TXFILTER_4_wrapen_s(regPP_TXFILTER_4 *reg, unsigned int wrapen_s)
{
  reg->bitfields.WRAPEN_S = wrapen_s;
  if (reg->bitfields.WRAPEN_S != wrapen_s) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_4::WRAPEN_S data too large\n");
}
__inline void set_PP_TXFILTER_4_clamp_s(regPP_TXFILTER_4 *reg, unsigned int clamp_s)
{
  reg->bitfields.CLAMP_S = clamp_s;
  if (reg->bitfields.CLAMP_S != clamp_s) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_4::CLAMP_S data too large\n");
}
__inline void set_PP_TXFILTER_4_wrapen_t(regPP_TXFILTER_4 *reg, unsigned int wrapen_t)
{
  reg->bitfields.WRAPEN_T = wrapen_t;
  if (reg->bitfields.WRAPEN_T != wrapen_t) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_4::WRAPEN_T data too large\n");
}
__inline void set_PP_TXFILTER_4_clamp_t(regPP_TXFILTER_4 *reg, unsigned int clamp_t)
{
  reg->bitfields.CLAMP_T = clamp_t;
  if (reg->bitfields.CLAMP_T != clamp_t) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_4::CLAMP_T data too large\n");
}
__inline void set_PP_TXFILTER_4_kill_lt_0(regPP_TXFILTER_4 *reg, unsigned int kill_lt_0)
{
  reg->bitfields.KILL_LT_0 = kill_lt_0;
  if (reg->bitfields.KILL_LT_0 != kill_lt_0) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_4::KILL_LT_0 data too large\n");
}
__inline void set_PP_TXFILTER_4_border_mode(regPP_TXFILTER_4 *reg, unsigned int border_mode)
{
  reg->bitfields.BORDER_MODE = border_mode;
  if (reg->bitfields.BORDER_MODE != border_mode) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_4::BORDER_MODE data too large\n");
}
#else
#define set_PP_TXFILTER_4_mag_filter(reg, mag_filter) (reg)->bitfields.MAG_FILTER = mag_filter
#define set_PP_TXFILTER_4_min_filter(reg, min_filter) (reg)->bitfields.MIN_FILTER = min_filter
#define set_PP_TXFILTER_4_max_anis(reg, max_anis) (reg)->bitfields.MAX_ANIS = max_anis
#define set_PP_TXFILTER_4_max_mip_level(reg, max_mip_level) (reg)->bitfields.MAX_MIP_LEVEL = max_mip_level
#define set_PP_TXFILTER_4_yuv_to_rgb(reg, yuv_to_rgb) (reg)->bitfields.YUV_TO_RGB = yuv_to_rgb
#define set_PP_TXFILTER_4_yuv_temperature(reg, yuv_temperature) (reg)->bitfields.YUV_TEMPERATURE = yuv_temperature
#define set_PP_TXFILTER_4_wrapen_s(reg, wrapen_s) (reg)->bitfields.WRAPEN_S = wrapen_s
#define set_PP_TXFILTER_4_clamp_s(reg, clamp_s) (reg)->bitfields.CLAMP_S = clamp_s
#define set_PP_TXFILTER_4_wrapen_t(reg, wrapen_t) (reg)->bitfields.WRAPEN_T = wrapen_t
#define set_PP_TXFILTER_4_clamp_t(reg, clamp_t) (reg)->bitfields.CLAMP_T = clamp_t
#define set_PP_TXFILTER_4_kill_lt_0(reg, kill_lt_0) (reg)->bitfields.KILL_LT_0 = kill_lt_0
#define set_PP_TXFILTER_4_border_mode(reg, border_mode) (reg)->bitfields.BORDER_MODE = border_mode

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXFILTER_5 regPP_TXFILTER_5;

#ifdef DEBUG
__inline void set_PP_TXFILTER_5_mag_filter(regPP_TXFILTER_5 *reg, unsigned int mag_filter)
{
  reg->bitfields.MAG_FILTER = mag_filter;
  if (reg->bitfields.MAG_FILTER != mag_filter) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_5::MAG_FILTER data too large\n");
}
__inline void set_PP_TXFILTER_5_min_filter(regPP_TXFILTER_5 *reg, unsigned int min_filter)
{
  reg->bitfields.MIN_FILTER = min_filter;
  if (reg->bitfields.MIN_FILTER != min_filter) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_5::MIN_FILTER data too large\n");
}
__inline void set_PP_TXFILTER_5_max_anis(regPP_TXFILTER_5 *reg, unsigned int max_anis)
{
  reg->bitfields.MAX_ANIS = max_anis;
  if (reg->bitfields.MAX_ANIS != max_anis) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_5::MAX_ANIS data too large\n");
}
__inline void set_PP_TXFILTER_5_max_mip_level(regPP_TXFILTER_5 *reg, unsigned int max_mip_level)
{
  reg->bitfields.MAX_MIP_LEVEL = max_mip_level;
  if (reg->bitfields.MAX_MIP_LEVEL != max_mip_level) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_5::MAX_MIP_LEVEL data too large\n");
}
__inline void set_PP_TXFILTER_5_yuv_to_rgb(regPP_TXFILTER_5 *reg, unsigned int yuv_to_rgb)
{
  reg->bitfields.YUV_TO_RGB = yuv_to_rgb;
  if (reg->bitfields.YUV_TO_RGB != yuv_to_rgb) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_5::YUV_TO_RGB data too large\n");
}
__inline void set_PP_TXFILTER_5_yuv_temperature(regPP_TXFILTER_5 *reg, unsigned int yuv_temperature)
{
  reg->bitfields.YUV_TEMPERATURE = yuv_temperature;
  if (reg->bitfields.YUV_TEMPERATURE != yuv_temperature) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_5::YUV_TEMPERATURE data too large\n");
}
__inline void set_PP_TXFILTER_5_wrapen_s(regPP_TXFILTER_5 *reg, unsigned int wrapen_s)
{
  reg->bitfields.WRAPEN_S = wrapen_s;
  if (reg->bitfields.WRAPEN_S != wrapen_s) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_5::WRAPEN_S data too large\n");
}
__inline void set_PP_TXFILTER_5_clamp_s(regPP_TXFILTER_5 *reg, unsigned int clamp_s)
{
  reg->bitfields.CLAMP_S = clamp_s;
  if (reg->bitfields.CLAMP_S != clamp_s) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_5::CLAMP_S data too large\n");
}
__inline void set_PP_TXFILTER_5_wrapen_t(regPP_TXFILTER_5 *reg, unsigned int wrapen_t)
{
  reg->bitfields.WRAPEN_T = wrapen_t;
  if (reg->bitfields.WRAPEN_T != wrapen_t) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_5::WRAPEN_T data too large\n");
}
__inline void set_PP_TXFILTER_5_clamp_t(regPP_TXFILTER_5 *reg, unsigned int clamp_t)
{
  reg->bitfields.CLAMP_T = clamp_t;
  if (reg->bitfields.CLAMP_T != clamp_t) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_5::CLAMP_T data too large\n");
}
__inline void set_PP_TXFILTER_5_kill_lt_0(regPP_TXFILTER_5 *reg, unsigned int kill_lt_0)
{
  reg->bitfields.KILL_LT_0 = kill_lt_0;
  if (reg->bitfields.KILL_LT_0 != kill_lt_0) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_5::KILL_LT_0 data too large\n");
}
__inline void set_PP_TXFILTER_5_border_mode(regPP_TXFILTER_5 *reg, unsigned int border_mode)
{
  reg->bitfields.BORDER_MODE = border_mode;
  if (reg->bitfields.BORDER_MODE != border_mode) HSLDPF(E_ERROR_MESSAGE,"PP_TXFILTER_5::BORDER_MODE data too large\n");
}
#else
#define set_PP_TXFILTER_5_mag_filter(reg, mag_filter) (reg)->bitfields.MAG_FILTER = mag_filter
#define set_PP_TXFILTER_5_min_filter(reg, min_filter) (reg)->bitfields.MIN_FILTER = min_filter
#define set_PP_TXFILTER_5_max_anis(reg, max_anis) (reg)->bitfields.MAX_ANIS = max_anis
#define set_PP_TXFILTER_5_max_mip_level(reg, max_mip_level) (reg)->bitfields.MAX_MIP_LEVEL = max_mip_level
#define set_PP_TXFILTER_5_yuv_to_rgb(reg, yuv_to_rgb) (reg)->bitfields.YUV_TO_RGB = yuv_to_rgb
#define set_PP_TXFILTER_5_yuv_temperature(reg, yuv_temperature) (reg)->bitfields.YUV_TEMPERATURE = yuv_temperature
#define set_PP_TXFILTER_5_wrapen_s(reg, wrapen_s) (reg)->bitfields.WRAPEN_S = wrapen_s
#define set_PP_TXFILTER_5_clamp_s(reg, clamp_s) (reg)->bitfields.CLAMP_S = clamp_s
#define set_PP_TXFILTER_5_wrapen_t(reg, wrapen_t) (reg)->bitfields.WRAPEN_T = wrapen_t
#define set_PP_TXFILTER_5_clamp_t(reg, clamp_t) (reg)->bitfields.CLAMP_T = clamp_t
#define set_PP_TXFILTER_5_kill_lt_0(reg, kill_lt_0) (reg)->bitfields.KILL_LT_0 = kill_lt_0
#define set_PP_TXFILTER_5_border_mode(reg, border_mode) (reg)->bitfields.BORDER_MODE = border_mode

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXFORMAT_0 regPP_TXFORMAT_0;

#ifdef DEBUG
__inline void set_PP_TXFORMAT_0_txformat(regPP_TXFORMAT_0 *reg, unsigned int txformat)
{
  reg->bitfields.TXFORMAT = txformat;
  if (reg->bitfields.TXFORMAT != txformat) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_0::TXFORMAT data too large\n");
}
__inline void set_PP_TXFORMAT_0_apple_yuv(regPP_TXFORMAT_0 *reg, unsigned int apple_yuv)
{
  reg->bitfields.APPLE_YUV = apple_yuv;
  if (reg->bitfields.APPLE_YUV != apple_yuv) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_0::APPLE_YUV data too large\n");
}
__inline void set_PP_TXFORMAT_0_alpha_enable(regPP_TXFORMAT_0 *reg, unsigned int alpha_enable)
{
  reg->bitfields.ALPHA_ENABLE = alpha_enable;
  if (reg->bitfields.ALPHA_ENABLE != alpha_enable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_0::ALPHA_ENABLE data too large\n");
}
__inline void set_PP_TXFORMAT_0_non_power2(regPP_TXFORMAT_0 *reg, unsigned int non_power2)
{
  reg->bitfields.NON_POWER2 = non_power2;
  if (reg->bitfields.NON_POWER2 != non_power2) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_0::NON_POWER2 data too large\n");
}
__inline void set_PP_TXFORMAT_0_txwidth(regPP_TXFORMAT_0 *reg, unsigned int txwidth)
{
  reg->bitfields.TXWIDTH = txwidth;
  if (reg->bitfields.TXWIDTH != txwidth) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_0::TXWIDTH data too large\n");
}
__inline void set_PP_TXFORMAT_0_txheight(regPP_TXFORMAT_0 *reg, unsigned int txheight)
{
  reg->bitfields.TXHEIGHT = txheight;
  if (reg->bitfields.TXHEIGHT != txheight) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_0::TXHEIGHT data too large\n");
}
__inline void set_PP_TXFORMAT_0_face_width_5(regPP_TXFORMAT_0 *reg, unsigned int face_width_5)
{
  reg->bitfields.FACE_WIDTH_5 = face_width_5;
  if (reg->bitfields.FACE_WIDTH_5 != face_width_5) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_0::FACE_WIDTH_5 data too large\n");
}
__inline void set_PP_TXFORMAT_0_face_height_5(regPP_TXFORMAT_0 *reg, unsigned int face_height_5)
{
  reg->bitfields.FACE_HEIGHT_5 = face_height_5;
  if (reg->bitfields.FACE_HEIGHT_5 != face_height_5) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_0::FACE_HEIGHT_5 data too large\n");
}
__inline void set_PP_TXFORMAT_0_st_route_r2(regPP_TXFORMAT_0 *reg, unsigned int st_route_r2)
{
  reg->bitfields.ST_ROUTE_R2 = st_route_r2;
  if (reg->bitfields.ST_ROUTE_R2 != st_route_r2) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_0::ST_ROUTE_R2 data too large\n");
}
__inline void set_PP_TXFORMAT_0_lookup_disable(regPP_TXFORMAT_0 *reg, unsigned int lookup_disable)
{
  reg->bitfields.LOOKUP_DISABLE = lookup_disable;
  if (reg->bitfields.LOOKUP_DISABLE != lookup_disable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_0::LOOKUP_DISABLE data too large\n");
}
__inline void set_PP_TXFORMAT_0_alpha_mask_enable(regPP_TXFORMAT_0 *reg, unsigned int alpha_mask_enable)
{
  reg->bitfields.ALPHA_MASK_ENABLE = alpha_mask_enable;
  if (reg->bitfields.ALPHA_MASK_ENABLE != alpha_mask_enable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_0::ALPHA_MASK_ENABLE data too large\n");
}
__inline void set_PP_TXFORMAT_0_chroma_key_enable(regPP_TXFORMAT_0 *reg, unsigned int chroma_key_enable)
{
  reg->bitfields.CHROMA_KEY_ENABLE = chroma_key_enable;
  if (reg->bitfields.CHROMA_KEY_ENABLE != chroma_key_enable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_0::CHROMA_KEY_ENABLE data too large\n");
}
#else
#define set_PP_TXFORMAT_0_txformat(reg, txformat) (reg)->bitfields.TXFORMAT = txformat
#define set_PP_TXFORMAT_0_apple_yuv(reg, apple_yuv) (reg)->bitfields.APPLE_YUV = apple_yuv
#define set_PP_TXFORMAT_0_alpha_enable(reg, alpha_enable) (reg)->bitfields.ALPHA_ENABLE = alpha_enable
#define set_PP_TXFORMAT_0_non_power2(reg, non_power2) (reg)->bitfields.NON_POWER2 = non_power2
#define set_PP_TXFORMAT_0_txwidth(reg, txwidth) (reg)->bitfields.TXWIDTH = txwidth
#define set_PP_TXFORMAT_0_txheight(reg, txheight) (reg)->bitfields.TXHEIGHT = txheight
#define set_PP_TXFORMAT_0_face_width_5(reg, face_width_5) (reg)->bitfields.FACE_WIDTH_5 = face_width_5
#define set_PP_TXFORMAT_0_face_height_5(reg, face_height_5) (reg)->bitfields.FACE_HEIGHT_5 = face_height_5
#define set_PP_TXFORMAT_0_st_route_r2(reg, st_route_r2) (reg)->bitfields.ST_ROUTE_R2 = st_route_r2
#define set_PP_TXFORMAT_0_lookup_disable(reg, lookup_disable) (reg)->bitfields.LOOKUP_DISABLE = lookup_disable
#define set_PP_TXFORMAT_0_alpha_mask_enable(reg, alpha_mask_enable) (reg)->bitfields.ALPHA_MASK_ENABLE = alpha_mask_enable
#define set_PP_TXFORMAT_0_chroma_key_enable(reg, chroma_key_enable) (reg)->bitfields.CHROMA_KEY_ENABLE = chroma_key_enable

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXFORMAT_1 regPP_TXFORMAT_1;

#ifdef DEBUG
__inline void set_PP_TXFORMAT_1_txformat(regPP_TXFORMAT_1 *reg, unsigned int txformat)
{
  reg->bitfields.TXFORMAT = txformat;
  if (reg->bitfields.TXFORMAT != txformat) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_1::TXFORMAT data too large\n");
}
__inline void set_PP_TXFORMAT_1_apple_yuv(regPP_TXFORMAT_1 *reg, unsigned int apple_yuv)
{
  reg->bitfields.APPLE_YUV = apple_yuv;
  if (reg->bitfields.APPLE_YUV != apple_yuv) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_1::APPLE_YUV data too large\n");
}
__inline void set_PP_TXFORMAT_1_alpha_enable(regPP_TXFORMAT_1 *reg, unsigned int alpha_enable)
{
  reg->bitfields.ALPHA_ENABLE = alpha_enable;
  if (reg->bitfields.ALPHA_ENABLE != alpha_enable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_1::ALPHA_ENABLE data too large\n");
}
__inline void set_PP_TXFORMAT_1_non_power2(regPP_TXFORMAT_1 *reg, unsigned int non_power2)
{
  reg->bitfields.NON_POWER2 = non_power2;
  if (reg->bitfields.NON_POWER2 != non_power2) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_1::NON_POWER2 data too large\n");
}
__inline void set_PP_TXFORMAT_1_txwidth(regPP_TXFORMAT_1 *reg, unsigned int txwidth)
{
  reg->bitfields.TXWIDTH = txwidth;
  if (reg->bitfields.TXWIDTH != txwidth) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_1::TXWIDTH data too large\n");
}
__inline void set_PP_TXFORMAT_1_txheight(regPP_TXFORMAT_1 *reg, unsigned int txheight)
{
  reg->bitfields.TXHEIGHT = txheight;
  if (reg->bitfields.TXHEIGHT != txheight) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_1::TXHEIGHT data too large\n");
}
__inline void set_PP_TXFORMAT_1_face_width_5(regPP_TXFORMAT_1 *reg, unsigned int face_width_5)
{
  reg->bitfields.FACE_WIDTH_5 = face_width_5;
  if (reg->bitfields.FACE_WIDTH_5 != face_width_5) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_1::FACE_WIDTH_5 data too large\n");
}
__inline void set_PP_TXFORMAT_1_face_height_5(regPP_TXFORMAT_1 *reg, unsigned int face_height_5)
{
  reg->bitfields.FACE_HEIGHT_5 = face_height_5;
  if (reg->bitfields.FACE_HEIGHT_5 != face_height_5) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_1::FACE_HEIGHT_5 data too large\n");
}
__inline void set_PP_TXFORMAT_1_st_route_r2(regPP_TXFORMAT_1 *reg, unsigned int st_route_r2)
{
  reg->bitfields.ST_ROUTE_R2 = st_route_r2;
  if (reg->bitfields.ST_ROUTE_R2 != st_route_r2) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_1::ST_ROUTE_R2 data too large\n");
}
__inline void set_PP_TXFORMAT_1_lookup_disable(regPP_TXFORMAT_1 *reg, unsigned int lookup_disable)
{
  reg->bitfields.LOOKUP_DISABLE = lookup_disable;
  if (reg->bitfields.LOOKUP_DISABLE != lookup_disable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_1::LOOKUP_DISABLE data too large\n");
}
__inline void set_PP_TXFORMAT_1_alpha_mask_enable(regPP_TXFORMAT_1 *reg, unsigned int alpha_mask_enable)
{
  reg->bitfields.ALPHA_MASK_ENABLE = alpha_mask_enable;
  if (reg->bitfields.ALPHA_MASK_ENABLE != alpha_mask_enable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_1::ALPHA_MASK_ENABLE data too large\n");
}
__inline void set_PP_TXFORMAT_1_chroma_key_enable(regPP_TXFORMAT_1 *reg, unsigned int chroma_key_enable)
{
  reg->bitfields.CHROMA_KEY_ENABLE = chroma_key_enable;
  if (reg->bitfields.CHROMA_KEY_ENABLE != chroma_key_enable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_1::CHROMA_KEY_ENABLE data too large\n");
}
#else
#define set_PP_TXFORMAT_1_txformat(reg, txformat) (reg)->bitfields.TXFORMAT = txformat
#define set_PP_TXFORMAT_1_apple_yuv(reg, apple_yuv) (reg)->bitfields.APPLE_YUV = apple_yuv
#define set_PP_TXFORMAT_1_alpha_enable(reg, alpha_enable) (reg)->bitfields.ALPHA_ENABLE = alpha_enable
#define set_PP_TXFORMAT_1_non_power2(reg, non_power2) (reg)->bitfields.NON_POWER2 = non_power2
#define set_PP_TXFORMAT_1_txwidth(reg, txwidth) (reg)->bitfields.TXWIDTH = txwidth
#define set_PP_TXFORMAT_1_txheight(reg, txheight) (reg)->bitfields.TXHEIGHT = txheight
#define set_PP_TXFORMAT_1_face_width_5(reg, face_width_5) (reg)->bitfields.FACE_WIDTH_5 = face_width_5
#define set_PP_TXFORMAT_1_face_height_5(reg, face_height_5) (reg)->bitfields.FACE_HEIGHT_5 = face_height_5
#define set_PP_TXFORMAT_1_st_route_r2(reg, st_route_r2) (reg)->bitfields.ST_ROUTE_R2 = st_route_r2
#define set_PP_TXFORMAT_1_lookup_disable(reg, lookup_disable) (reg)->bitfields.LOOKUP_DISABLE = lookup_disable
#define set_PP_TXFORMAT_1_alpha_mask_enable(reg, alpha_mask_enable) (reg)->bitfields.ALPHA_MASK_ENABLE = alpha_mask_enable
#define set_PP_TXFORMAT_1_chroma_key_enable(reg, chroma_key_enable) (reg)->bitfields.CHROMA_KEY_ENABLE = chroma_key_enable

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXFORMAT_2 regPP_TXFORMAT_2;

#ifdef DEBUG
__inline void set_PP_TXFORMAT_2_txformat(regPP_TXFORMAT_2 *reg, unsigned int txformat)
{
  reg->bitfields.TXFORMAT = txformat;
  if (reg->bitfields.TXFORMAT != txformat) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_2::TXFORMAT data too large\n");
}
__inline void set_PP_TXFORMAT_2_apple_yuv(regPP_TXFORMAT_2 *reg, unsigned int apple_yuv)
{
  reg->bitfields.APPLE_YUV = apple_yuv;
  if (reg->bitfields.APPLE_YUV != apple_yuv) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_2::APPLE_YUV data too large\n");
}
__inline void set_PP_TXFORMAT_2_alpha_enable(regPP_TXFORMAT_2 *reg, unsigned int alpha_enable)
{
  reg->bitfields.ALPHA_ENABLE = alpha_enable;
  if (reg->bitfields.ALPHA_ENABLE != alpha_enable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_2::ALPHA_ENABLE data too large\n");
}
__inline void set_PP_TXFORMAT_2_non_power2(regPP_TXFORMAT_2 *reg, unsigned int non_power2)
{
  reg->bitfields.NON_POWER2 = non_power2;
  if (reg->bitfields.NON_POWER2 != non_power2) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_2::NON_POWER2 data too large\n");
}
__inline void set_PP_TXFORMAT_2_txwidth(regPP_TXFORMAT_2 *reg, unsigned int txwidth)
{
  reg->bitfields.TXWIDTH = txwidth;
  if (reg->bitfields.TXWIDTH != txwidth) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_2::TXWIDTH data too large\n");
}
__inline void set_PP_TXFORMAT_2_txheight(regPP_TXFORMAT_2 *reg, unsigned int txheight)
{
  reg->bitfields.TXHEIGHT = txheight;
  if (reg->bitfields.TXHEIGHT != txheight) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_2::TXHEIGHT data too large\n");
}
__inline void set_PP_TXFORMAT_2_face_width_5(regPP_TXFORMAT_2 *reg, unsigned int face_width_5)
{
  reg->bitfields.FACE_WIDTH_5 = face_width_5;
  if (reg->bitfields.FACE_WIDTH_5 != face_width_5) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_2::FACE_WIDTH_5 data too large\n");
}
__inline void set_PP_TXFORMAT_2_face_height_5(regPP_TXFORMAT_2 *reg, unsigned int face_height_5)
{
  reg->bitfields.FACE_HEIGHT_5 = face_height_5;
  if (reg->bitfields.FACE_HEIGHT_5 != face_height_5) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_2::FACE_HEIGHT_5 data too large\n");
}
__inline void set_PP_TXFORMAT_2_st_route_r2(regPP_TXFORMAT_2 *reg, unsigned int st_route_r2)
{
  reg->bitfields.ST_ROUTE_R2 = st_route_r2;
  if (reg->bitfields.ST_ROUTE_R2 != st_route_r2) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_2::ST_ROUTE_R2 data too large\n");
}
__inline void set_PP_TXFORMAT_2_lookup_disable(regPP_TXFORMAT_2 *reg, unsigned int lookup_disable)
{
  reg->bitfields.LOOKUP_DISABLE = lookup_disable;
  if (reg->bitfields.LOOKUP_DISABLE != lookup_disable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_2::LOOKUP_DISABLE data too large\n");
}
__inline void set_PP_TXFORMAT_2_alpha_mask_enable(regPP_TXFORMAT_2 *reg, unsigned int alpha_mask_enable)
{
  reg->bitfields.ALPHA_MASK_ENABLE = alpha_mask_enable;
  if (reg->bitfields.ALPHA_MASK_ENABLE != alpha_mask_enable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_2::ALPHA_MASK_ENABLE data too large\n");
}
__inline void set_PP_TXFORMAT_2_chroma_key_enable(regPP_TXFORMAT_2 *reg, unsigned int chroma_key_enable)
{
  reg->bitfields.CHROMA_KEY_ENABLE = chroma_key_enable;
  if (reg->bitfields.CHROMA_KEY_ENABLE != chroma_key_enable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_2::CHROMA_KEY_ENABLE data too large\n");
}
#else
#define set_PP_TXFORMAT_2_txformat(reg, txformat) (reg)->bitfields.TXFORMAT = txformat
#define set_PP_TXFORMAT_2_apple_yuv(reg, apple_yuv) (reg)->bitfields.APPLE_YUV = apple_yuv
#define set_PP_TXFORMAT_2_alpha_enable(reg, alpha_enable) (reg)->bitfields.ALPHA_ENABLE = alpha_enable
#define set_PP_TXFORMAT_2_non_power2(reg, non_power2) (reg)->bitfields.NON_POWER2 = non_power2
#define set_PP_TXFORMAT_2_txwidth(reg, txwidth) (reg)->bitfields.TXWIDTH = txwidth
#define set_PP_TXFORMAT_2_txheight(reg, txheight) (reg)->bitfields.TXHEIGHT = txheight
#define set_PP_TXFORMAT_2_face_width_5(reg, face_width_5) (reg)->bitfields.FACE_WIDTH_5 = face_width_5
#define set_PP_TXFORMAT_2_face_height_5(reg, face_height_5) (reg)->bitfields.FACE_HEIGHT_5 = face_height_5
#define set_PP_TXFORMAT_2_st_route_r2(reg, st_route_r2) (reg)->bitfields.ST_ROUTE_R2 = st_route_r2
#define set_PP_TXFORMAT_2_lookup_disable(reg, lookup_disable) (reg)->bitfields.LOOKUP_DISABLE = lookup_disable
#define set_PP_TXFORMAT_2_alpha_mask_enable(reg, alpha_mask_enable) (reg)->bitfields.ALPHA_MASK_ENABLE = alpha_mask_enable
#define set_PP_TXFORMAT_2_chroma_key_enable(reg, chroma_key_enable) (reg)->bitfields.CHROMA_KEY_ENABLE = chroma_key_enable

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXFORMAT_3 regPP_TXFORMAT_3;

#ifdef DEBUG
__inline void set_PP_TXFORMAT_3_txformat(regPP_TXFORMAT_3 *reg, unsigned int txformat)
{
  reg->bitfields.TXFORMAT = txformat;
  if (reg->bitfields.TXFORMAT != txformat) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_3::TXFORMAT data too large\n");
}
__inline void set_PP_TXFORMAT_3_apple_yuv(regPP_TXFORMAT_3 *reg, unsigned int apple_yuv)
{
  reg->bitfields.APPLE_YUV = apple_yuv;
  if (reg->bitfields.APPLE_YUV != apple_yuv) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_3::APPLE_YUV data too large\n");
}
__inline void set_PP_TXFORMAT_3_alpha_enable(regPP_TXFORMAT_3 *reg, unsigned int alpha_enable)
{
  reg->bitfields.ALPHA_ENABLE = alpha_enable;
  if (reg->bitfields.ALPHA_ENABLE != alpha_enable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_3::ALPHA_ENABLE data too large\n");
}
__inline void set_PP_TXFORMAT_3_non_power2(regPP_TXFORMAT_3 *reg, unsigned int non_power2)
{
  reg->bitfields.NON_POWER2 = non_power2;
  if (reg->bitfields.NON_POWER2 != non_power2) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_3::NON_POWER2 data too large\n");
}
__inline void set_PP_TXFORMAT_3_txwidth(regPP_TXFORMAT_3 *reg, unsigned int txwidth)
{
  reg->bitfields.TXWIDTH = txwidth;
  if (reg->bitfields.TXWIDTH != txwidth) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_3::TXWIDTH data too large\n");
}
__inline void set_PP_TXFORMAT_3_txheight(regPP_TXFORMAT_3 *reg, unsigned int txheight)
{
  reg->bitfields.TXHEIGHT = txheight;
  if (reg->bitfields.TXHEIGHT != txheight) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_3::TXHEIGHT data too large\n");
}
__inline void set_PP_TXFORMAT_3_face_width_5(regPP_TXFORMAT_3 *reg, unsigned int face_width_5)
{
  reg->bitfields.FACE_WIDTH_5 = face_width_5;
  if (reg->bitfields.FACE_WIDTH_5 != face_width_5) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_3::FACE_WIDTH_5 data too large\n");
}
__inline void set_PP_TXFORMAT_3_face_height_5(regPP_TXFORMAT_3 *reg, unsigned int face_height_5)
{
  reg->bitfields.FACE_HEIGHT_5 = face_height_5;
  if (reg->bitfields.FACE_HEIGHT_5 != face_height_5) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_3::FACE_HEIGHT_5 data too large\n");
}
__inline void set_PP_TXFORMAT_3_st_route(regPP_TXFORMAT_3 *reg, unsigned int st_route)
{
  reg->bitfields.ST_ROUTE = st_route;
  if (reg->bitfields.ST_ROUTE != st_route) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_3::ST_ROUTE data too large\n");
}
__inline void set_PP_TXFORMAT_3_lookup_disable(regPP_TXFORMAT_3 *reg, unsigned int lookup_disable)
{
  reg->bitfields.LOOKUP_DISABLE = lookup_disable;
  if (reg->bitfields.LOOKUP_DISABLE != lookup_disable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_3::LOOKUP_DISABLE data too large\n");
}
__inline void set_PP_TXFORMAT_3_alpha_mask_enable(regPP_TXFORMAT_3 *reg, unsigned int alpha_mask_enable)
{
  reg->bitfields.ALPHA_MASK_ENABLE = alpha_mask_enable;
  if (reg->bitfields.ALPHA_MASK_ENABLE != alpha_mask_enable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_3::ALPHA_MASK_ENABLE data too large\n");
}
__inline void set_PP_TXFORMAT_3_chroma_key_enable(regPP_TXFORMAT_3 *reg, unsigned int chroma_key_enable)
{
  reg->bitfields.CHROMA_KEY_ENABLE = chroma_key_enable;
  if (reg->bitfields.CHROMA_KEY_ENABLE != chroma_key_enable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_3::CHROMA_KEY_ENABLE data too large\n");
}
#else
#define set_PP_TXFORMAT_3_txformat(reg, txformat) (reg)->bitfields.TXFORMAT = txformat
#define set_PP_TXFORMAT_3_apple_yuv(reg, apple_yuv) (reg)->bitfields.APPLE_YUV = apple_yuv
#define set_PP_TXFORMAT_3_alpha_enable(reg, alpha_enable) (reg)->bitfields.ALPHA_ENABLE = alpha_enable
#define set_PP_TXFORMAT_3_non_power2(reg, non_power2) (reg)->bitfields.NON_POWER2 = non_power2
#define set_PP_TXFORMAT_3_txwidth(reg, txwidth) (reg)->bitfields.TXWIDTH = txwidth
#define set_PP_TXFORMAT_3_txheight(reg, txheight) (reg)->bitfields.TXHEIGHT = txheight
#define set_PP_TXFORMAT_3_face_width_5(reg, face_width_5) (reg)->bitfields.FACE_WIDTH_5 = face_width_5
#define set_PP_TXFORMAT_3_face_height_5(reg, face_height_5) (reg)->bitfields.FACE_HEIGHT_5 = face_height_5
#define set_PP_TXFORMAT_3_st_route(reg, st_route) (reg)->bitfields.ST_ROUTE = st_route
#define set_PP_TXFORMAT_3_lookup_disable(reg, lookup_disable) (reg)->bitfields.LOOKUP_DISABLE = lookup_disable
#define set_PP_TXFORMAT_3_alpha_mask_enable(reg, alpha_mask_enable) (reg)->bitfields.ALPHA_MASK_ENABLE = alpha_mask_enable
#define set_PP_TXFORMAT_3_chroma_key_enable(reg, chroma_key_enable) (reg)->bitfields.CHROMA_KEY_ENABLE = chroma_key_enable

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXFORMAT_4 regPP_TXFORMAT_4;

#ifdef DEBUG
__inline void set_PP_TXFORMAT_4_txformat(regPP_TXFORMAT_4 *reg, unsigned int txformat)
{
  reg->bitfields.TXFORMAT = txformat;
  if (reg->bitfields.TXFORMAT != txformat) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_4::TXFORMAT data too large\n");
}
__inline void set_PP_TXFORMAT_4_apple_yuv(regPP_TXFORMAT_4 *reg, unsigned int apple_yuv)
{
  reg->bitfields.APPLE_YUV = apple_yuv;
  if (reg->bitfields.APPLE_YUV != apple_yuv) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_4::APPLE_YUV data too large\n");
}
__inline void set_PP_TXFORMAT_4_alpha_enable(regPP_TXFORMAT_4 *reg, unsigned int alpha_enable)
{
  reg->bitfields.ALPHA_ENABLE = alpha_enable;
  if (reg->bitfields.ALPHA_ENABLE != alpha_enable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_4::ALPHA_ENABLE data too large\n");
}
__inline void set_PP_TXFORMAT_4_non_power2(regPP_TXFORMAT_4 *reg, unsigned int non_power2)
{
  reg->bitfields.NON_POWER2 = non_power2;
  if (reg->bitfields.NON_POWER2 != non_power2) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_4::NON_POWER2 data too large\n");
}
__inline void set_PP_TXFORMAT_4_txwidth(regPP_TXFORMAT_4 *reg, unsigned int txwidth)
{
  reg->bitfields.TXWIDTH = txwidth;
  if (reg->bitfields.TXWIDTH != txwidth) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_4::TXWIDTH data too large\n");
}
__inline void set_PP_TXFORMAT_4_txheight(regPP_TXFORMAT_4 *reg, unsigned int txheight)
{
  reg->bitfields.TXHEIGHT = txheight;
  if (reg->bitfields.TXHEIGHT != txheight) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_4::TXHEIGHT data too large\n");
}
__inline void set_PP_TXFORMAT_4_face_width_5(regPP_TXFORMAT_4 *reg, unsigned int face_width_5)
{
  reg->bitfields.FACE_WIDTH_5 = face_width_5;
  if (reg->bitfields.FACE_WIDTH_5 != face_width_5) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_4::FACE_WIDTH_5 data too large\n");
}
__inline void set_PP_TXFORMAT_4_face_height_5(regPP_TXFORMAT_4 *reg, unsigned int face_height_5)
{
  reg->bitfields.FACE_HEIGHT_5 = face_height_5;
  if (reg->bitfields.FACE_HEIGHT_5 != face_height_5) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_4::FACE_HEIGHT_5 data too large\n");
}
__inline void set_PP_TXFORMAT_4_st_route(regPP_TXFORMAT_4 *reg, unsigned int st_route)
{
  reg->bitfields.ST_ROUTE = st_route;
  if (reg->bitfields.ST_ROUTE != st_route) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_4::ST_ROUTE data too large\n");
}
__inline void set_PP_TXFORMAT_4_lookup_disable(regPP_TXFORMAT_4 *reg, unsigned int lookup_disable)
{
  reg->bitfields.LOOKUP_DISABLE = lookup_disable;
  if (reg->bitfields.LOOKUP_DISABLE != lookup_disable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_4::LOOKUP_DISABLE data too large\n");
}
__inline void set_PP_TXFORMAT_4_alpha_mask_enable(regPP_TXFORMAT_4 *reg, unsigned int alpha_mask_enable)
{
  reg->bitfields.ALPHA_MASK_ENABLE = alpha_mask_enable;
  if (reg->bitfields.ALPHA_MASK_ENABLE != alpha_mask_enable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_4::ALPHA_MASK_ENABLE data too large\n");
}
__inline void set_PP_TXFORMAT_4_chroma_key_enable(regPP_TXFORMAT_4 *reg, unsigned int chroma_key_enable)
{
  reg->bitfields.CHROMA_KEY_ENABLE = chroma_key_enable;
  if (reg->bitfields.CHROMA_KEY_ENABLE != chroma_key_enable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_4::CHROMA_KEY_ENABLE data too large\n");
}
#else
#define set_PP_TXFORMAT_4_txformat(reg, txformat) (reg)->bitfields.TXFORMAT = txformat
#define set_PP_TXFORMAT_4_apple_yuv(reg, apple_yuv) (reg)->bitfields.APPLE_YUV = apple_yuv
#define set_PP_TXFORMAT_4_alpha_enable(reg, alpha_enable) (reg)->bitfields.ALPHA_ENABLE = alpha_enable
#define set_PP_TXFORMAT_4_non_power2(reg, non_power2) (reg)->bitfields.NON_POWER2 = non_power2
#define set_PP_TXFORMAT_4_txwidth(reg, txwidth) (reg)->bitfields.TXWIDTH = txwidth
#define set_PP_TXFORMAT_4_txheight(reg, txheight) (reg)->bitfields.TXHEIGHT = txheight
#define set_PP_TXFORMAT_4_face_width_5(reg, face_width_5) (reg)->bitfields.FACE_WIDTH_5 = face_width_5
#define set_PP_TXFORMAT_4_face_height_5(reg, face_height_5) (reg)->bitfields.FACE_HEIGHT_5 = face_height_5
#define set_PP_TXFORMAT_4_st_route(reg, st_route) (reg)->bitfields.ST_ROUTE = st_route
#define set_PP_TXFORMAT_4_lookup_disable(reg, lookup_disable) (reg)->bitfields.LOOKUP_DISABLE = lookup_disable
#define set_PP_TXFORMAT_4_alpha_mask_enable(reg, alpha_mask_enable) (reg)->bitfields.ALPHA_MASK_ENABLE = alpha_mask_enable
#define set_PP_TXFORMAT_4_chroma_key_enable(reg, chroma_key_enable) (reg)->bitfields.CHROMA_KEY_ENABLE = chroma_key_enable

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXFORMAT_5 regPP_TXFORMAT_5;

#ifdef DEBUG
__inline void set_PP_TXFORMAT_5_txformat(regPP_TXFORMAT_5 *reg, unsigned int txformat)
{
  reg->bitfields.TXFORMAT = txformat;
  if (reg->bitfields.TXFORMAT != txformat) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_5::TXFORMAT data too large\n");
}
__inline void set_PP_TXFORMAT_5_apple_yuv(regPP_TXFORMAT_5 *reg, unsigned int apple_yuv)
{
  reg->bitfields.APPLE_YUV = apple_yuv;
  if (reg->bitfields.APPLE_YUV != apple_yuv) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_5::APPLE_YUV data too large\n");
}
__inline void set_PP_TXFORMAT_5_alpha_enable(regPP_TXFORMAT_5 *reg, unsigned int alpha_enable)
{
  reg->bitfields.ALPHA_ENABLE = alpha_enable;
  if (reg->bitfields.ALPHA_ENABLE != alpha_enable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_5::ALPHA_ENABLE data too large\n");
}
__inline void set_PP_TXFORMAT_5_non_power2(regPP_TXFORMAT_5 *reg, unsigned int non_power2)
{
  reg->bitfields.NON_POWER2 = non_power2;
  if (reg->bitfields.NON_POWER2 != non_power2) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_5::NON_POWER2 data too large\n");
}
__inline void set_PP_TXFORMAT_5_txwidth(regPP_TXFORMAT_5 *reg, unsigned int txwidth)
{
  reg->bitfields.TXWIDTH = txwidth;
  if (reg->bitfields.TXWIDTH != txwidth) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_5::TXWIDTH data too large\n");
}
__inline void set_PP_TXFORMAT_5_txheight(regPP_TXFORMAT_5 *reg, unsigned int txheight)
{
  reg->bitfields.TXHEIGHT = txheight;
  if (reg->bitfields.TXHEIGHT != txheight) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_5::TXHEIGHT data too large\n");
}
__inline void set_PP_TXFORMAT_5_face_width_5(regPP_TXFORMAT_5 *reg, unsigned int face_width_5)
{
  reg->bitfields.FACE_WIDTH_5 = face_width_5;
  if (reg->bitfields.FACE_WIDTH_5 != face_width_5) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_5::FACE_WIDTH_5 data too large\n");
}
__inline void set_PP_TXFORMAT_5_face_height_5(regPP_TXFORMAT_5 *reg, unsigned int face_height_5)
{
  reg->bitfields.FACE_HEIGHT_5 = face_height_5;
  if (reg->bitfields.FACE_HEIGHT_5 != face_height_5) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_5::FACE_HEIGHT_5 data too large\n");
}
__inline void set_PP_TXFORMAT_5_st_route(regPP_TXFORMAT_5 *reg, unsigned int st_route)
{
  reg->bitfields.ST_ROUTE = st_route;
  if (reg->bitfields.ST_ROUTE != st_route) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_5::ST_ROUTE data too large\n");
}
__inline void set_PP_TXFORMAT_5_lookup_disable(regPP_TXFORMAT_5 *reg, unsigned int lookup_disable)
{
  reg->bitfields.LOOKUP_DISABLE = lookup_disable;
  if (reg->bitfields.LOOKUP_DISABLE != lookup_disable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_5::LOOKUP_DISABLE data too large\n");
}
__inline void set_PP_TXFORMAT_5_alpha_mask_enable(regPP_TXFORMAT_5 *reg, unsigned int alpha_mask_enable)
{
  reg->bitfields.ALPHA_MASK_ENABLE = alpha_mask_enable;
  if (reg->bitfields.ALPHA_MASK_ENABLE != alpha_mask_enable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_5::ALPHA_MASK_ENABLE data too large\n");
}
__inline void set_PP_TXFORMAT_5_chroma_key_enable(regPP_TXFORMAT_5 *reg, unsigned int chroma_key_enable)
{
  reg->bitfields.CHROMA_KEY_ENABLE = chroma_key_enable;
  if (reg->bitfields.CHROMA_KEY_ENABLE != chroma_key_enable) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_5::CHROMA_KEY_ENABLE data too large\n");
}
#else
#define set_PP_TXFORMAT_5_txformat(reg, txformat) (reg)->bitfields.TXFORMAT = txformat
#define set_PP_TXFORMAT_5_apple_yuv(reg, apple_yuv) (reg)->bitfields.APPLE_YUV = apple_yuv
#define set_PP_TXFORMAT_5_alpha_enable(reg, alpha_enable) (reg)->bitfields.ALPHA_ENABLE = alpha_enable
#define set_PP_TXFORMAT_5_non_power2(reg, non_power2) (reg)->bitfields.NON_POWER2 = non_power2
#define set_PP_TXFORMAT_5_txwidth(reg, txwidth) (reg)->bitfields.TXWIDTH = txwidth
#define set_PP_TXFORMAT_5_txheight(reg, txheight) (reg)->bitfields.TXHEIGHT = txheight
#define set_PP_TXFORMAT_5_face_width_5(reg, face_width_5) (reg)->bitfields.FACE_WIDTH_5 = face_width_5
#define set_PP_TXFORMAT_5_face_height_5(reg, face_height_5) (reg)->bitfields.FACE_HEIGHT_5 = face_height_5
#define set_PP_TXFORMAT_5_st_route(reg, st_route) (reg)->bitfields.ST_ROUTE = st_route
#define set_PP_TXFORMAT_5_lookup_disable(reg, lookup_disable) (reg)->bitfields.LOOKUP_DISABLE = lookup_disable
#define set_PP_TXFORMAT_5_alpha_mask_enable(reg, alpha_mask_enable) (reg)->bitfields.ALPHA_MASK_ENABLE = alpha_mask_enable
#define set_PP_TXFORMAT_5_chroma_key_enable(reg, chroma_key_enable) (reg)->bitfields.CHROMA_KEY_ENABLE = chroma_key_enable

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXFORMAT_X_0 regPP_TXFORMAT_X_0;

#ifdef DEBUG
__inline void set_PP_TXFORMAT_X_0_txdepth(regPP_TXFORMAT_X_0 *reg, unsigned int txdepth)
{
  reg->bitfields.TXDEPTH = txdepth;
  if (reg->bitfields.TXDEPTH != txdepth) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_0::TXDEPTH data too large\n");
}
__inline void set_PP_TXFORMAT_X_0_volume_filter(regPP_TXFORMAT_X_0 *reg, unsigned int volume_filter)
{
  reg->bitfields.VOLUME_FILTER = volume_filter;
  if (reg->bitfields.VOLUME_FILTER != volume_filter) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_0::VOLUME_FILTER data too large\n");
}
__inline void set_PP_TXFORMAT_X_0_clamp_mode(regPP_TXFORMAT_X_0 *reg, unsigned int clamp_mode)
{
  reg->bitfields.CLAMP_MODE = clamp_mode;
  if (reg->bitfields.CLAMP_MODE != clamp_mode) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_0::CLAMP_MODE data too large\n");
}
__inline void set_PP_TXFORMAT_X_0_wrapen_q(regPP_TXFORMAT_X_0 *reg, unsigned int wrapen_q)
{
  reg->bitfields.WRAPEN_Q = wrapen_q;
  if (reg->bitfields.WRAPEN_Q != wrapen_q) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_0::WRAPEN_Q data too large\n");
}
__inline void set_PP_TXFORMAT_X_0_clamp_q(regPP_TXFORMAT_X_0 *reg, unsigned int clamp_q)
{
  reg->bitfields.CLAMP_Q = clamp_q;
  if (reg->bitfields.CLAMP_Q != clamp_q) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_0::CLAMP_Q data too large\n");
}
__inline void set_PP_TXFORMAT_X_0_min_mip_level(regPP_TXFORMAT_X_0 *reg, unsigned int min_mip_level)
{
  reg->bitfields.MIN_MIP_LEVEL = min_mip_level;
  if (reg->bitfields.MIN_MIP_LEVEL != min_mip_level) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_0::MIN_MIP_LEVEL data too large\n");
}
__inline void set_PP_TXFORMAT_X_0_tex_coord_type(regPP_TXFORMAT_X_0 *reg, unsigned int tex_coord_type)
{
  reg->bitfields.TEX_COORD_TYPE = tex_coord_type;
  if (reg->bitfields.TEX_COORD_TYPE != tex_coord_type) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_0::TEX_COORD_TYPE data too large\n");
}
__inline void set_PP_TXFORMAT_X_0_lod_bias(regPP_TXFORMAT_X_0 *reg, unsigned int lod_bias)
{
  reg->bitfields.LOD_BIAS = lod_bias;
  if (reg->bitfields.LOD_BIAS != lod_bias) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_0::LOD_BIAS data too large\n");
}
#else
#define set_PP_TXFORMAT_X_0_txdepth(reg, txdepth) (reg)->bitfields.TXDEPTH = txdepth
#define set_PP_TXFORMAT_X_0_volume_filter(reg, volume_filter) (reg)->bitfields.VOLUME_FILTER = volume_filter
#define set_PP_TXFORMAT_X_0_clamp_mode(reg, clamp_mode) (reg)->bitfields.CLAMP_MODE = clamp_mode
#define set_PP_TXFORMAT_X_0_wrapen_q(reg, wrapen_q) (reg)->bitfields.WRAPEN_Q = wrapen_q
#define set_PP_TXFORMAT_X_0_clamp_q(reg, clamp_q) (reg)->bitfields.CLAMP_Q = clamp_q
#define set_PP_TXFORMAT_X_0_min_mip_level(reg, min_mip_level) (reg)->bitfields.MIN_MIP_LEVEL = min_mip_level
#define set_PP_TXFORMAT_X_0_tex_coord_type(reg, tex_coord_type) (reg)->bitfields.TEX_COORD_TYPE = tex_coord_type
#define set_PP_TXFORMAT_X_0_lod_bias(reg, lod_bias) (reg)->bitfields.LOD_BIAS = lod_bias

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXFORMAT_X_1 regPP_TXFORMAT_X_1;

#ifdef DEBUG
__inline void set_PP_TXFORMAT_X_1_txdepth(regPP_TXFORMAT_X_1 *reg, unsigned int txdepth)
{
  reg->bitfields.TXDEPTH = txdepth;
  if (reg->bitfields.TXDEPTH != txdepth) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_1::TXDEPTH data too large\n");
}
__inline void set_PP_TXFORMAT_X_1_volume_filter(regPP_TXFORMAT_X_1 *reg, unsigned int volume_filter)
{
  reg->bitfields.VOLUME_FILTER = volume_filter;
  if (reg->bitfields.VOLUME_FILTER != volume_filter) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_1::VOLUME_FILTER data too large\n");
}
__inline void set_PP_TXFORMAT_X_1_clamp_mode(regPP_TXFORMAT_X_1 *reg, unsigned int clamp_mode)
{
  reg->bitfields.CLAMP_MODE = clamp_mode;
  if (reg->bitfields.CLAMP_MODE != clamp_mode) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_1::CLAMP_MODE data too large\n");
}
__inline void set_PP_TXFORMAT_X_1_wrapen_q(regPP_TXFORMAT_X_1 *reg, unsigned int wrapen_q)
{
  reg->bitfields.WRAPEN_Q = wrapen_q;
  if (reg->bitfields.WRAPEN_Q != wrapen_q) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_1::WRAPEN_Q data too large\n");
}
__inline void set_PP_TXFORMAT_X_1_clamp_q(regPP_TXFORMAT_X_1 *reg, unsigned int clamp_q)
{
  reg->bitfields.CLAMP_Q = clamp_q;
  if (reg->bitfields.CLAMP_Q != clamp_q) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_1::CLAMP_Q data too large\n");
}
__inline void set_PP_TXFORMAT_X_1_min_mip_level(regPP_TXFORMAT_X_1 *reg, unsigned int min_mip_level)
{
  reg->bitfields.MIN_MIP_LEVEL = min_mip_level;
  if (reg->bitfields.MIN_MIP_LEVEL != min_mip_level) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_1::MIN_MIP_LEVEL data too large\n");
}
__inline void set_PP_TXFORMAT_X_1_tex_coord_type(regPP_TXFORMAT_X_1 *reg, unsigned int tex_coord_type)
{
  reg->bitfields.TEX_COORD_TYPE = tex_coord_type;
  if (reg->bitfields.TEX_COORD_TYPE != tex_coord_type) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_1::TEX_COORD_TYPE data too large\n");
}
__inline void set_PP_TXFORMAT_X_1_lod_bias(regPP_TXFORMAT_X_1 *reg, unsigned int lod_bias)
{
  reg->bitfields.LOD_BIAS = lod_bias;
  if (reg->bitfields.LOD_BIAS != lod_bias) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_1::LOD_BIAS data too large\n");
}
#else
#define set_PP_TXFORMAT_X_1_txdepth(reg, txdepth) (reg)->bitfields.TXDEPTH = txdepth
#define set_PP_TXFORMAT_X_1_volume_filter(reg, volume_filter) (reg)->bitfields.VOLUME_FILTER = volume_filter
#define set_PP_TXFORMAT_X_1_clamp_mode(reg, clamp_mode) (reg)->bitfields.CLAMP_MODE = clamp_mode
#define set_PP_TXFORMAT_X_1_wrapen_q(reg, wrapen_q) (reg)->bitfields.WRAPEN_Q = wrapen_q
#define set_PP_TXFORMAT_X_1_clamp_q(reg, clamp_q) (reg)->bitfields.CLAMP_Q = clamp_q
#define set_PP_TXFORMAT_X_1_min_mip_level(reg, min_mip_level) (reg)->bitfields.MIN_MIP_LEVEL = min_mip_level
#define set_PP_TXFORMAT_X_1_tex_coord_type(reg, tex_coord_type) (reg)->bitfields.TEX_COORD_TYPE = tex_coord_type
#define set_PP_TXFORMAT_X_1_lod_bias(reg, lod_bias) (reg)->bitfields.LOD_BIAS = lod_bias

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXFORMAT_X_2 regPP_TXFORMAT_X_2;

#ifdef DEBUG
__inline void set_PP_TXFORMAT_X_2_txdepth(regPP_TXFORMAT_X_2 *reg, unsigned int txdepth)
{
  reg->bitfields.TXDEPTH = txdepth;
  if (reg->bitfields.TXDEPTH != txdepth) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_2::TXDEPTH data too large\n");
}
__inline void set_PP_TXFORMAT_X_2_volume_filter(regPP_TXFORMAT_X_2 *reg, unsigned int volume_filter)
{
  reg->bitfields.VOLUME_FILTER = volume_filter;
  if (reg->bitfields.VOLUME_FILTER != volume_filter) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_2::VOLUME_FILTER data too large\n");
}
__inline void set_PP_TXFORMAT_X_2_clamp_mode(regPP_TXFORMAT_X_2 *reg, unsigned int clamp_mode)
{
  reg->bitfields.CLAMP_MODE = clamp_mode;
  if (reg->bitfields.CLAMP_MODE != clamp_mode) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_2::CLAMP_MODE data too large\n");
}
__inline void set_PP_TXFORMAT_X_2_wrapen_q(regPP_TXFORMAT_X_2 *reg, unsigned int wrapen_q)
{
  reg->bitfields.WRAPEN_Q = wrapen_q;
  if (reg->bitfields.WRAPEN_Q != wrapen_q) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_2::WRAPEN_Q data too large\n");
}
__inline void set_PP_TXFORMAT_X_2_clamp_q(regPP_TXFORMAT_X_2 *reg, unsigned int clamp_q)
{
  reg->bitfields.CLAMP_Q = clamp_q;
  if (reg->bitfields.CLAMP_Q != clamp_q) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_2::CLAMP_Q data too large\n");
}
__inline void set_PP_TXFORMAT_X_2_min_mip_level(regPP_TXFORMAT_X_2 *reg, unsigned int min_mip_level)
{
  reg->bitfields.MIN_MIP_LEVEL = min_mip_level;
  if (reg->bitfields.MIN_MIP_LEVEL != min_mip_level) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_2::MIN_MIP_LEVEL data too large\n");
}
__inline void set_PP_TXFORMAT_X_2_tex_coord_type(regPP_TXFORMAT_X_2 *reg, unsigned int tex_coord_type)
{
  reg->bitfields.TEX_COORD_TYPE = tex_coord_type;
  if (reg->bitfields.TEX_COORD_TYPE != tex_coord_type) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_2::TEX_COORD_TYPE data too large\n");
}
__inline void set_PP_TXFORMAT_X_2_lod_bias(regPP_TXFORMAT_X_2 *reg, unsigned int lod_bias)
{
  reg->bitfields.LOD_BIAS = lod_bias;
  if (reg->bitfields.LOD_BIAS != lod_bias) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_2::LOD_BIAS data too large\n");
}
#else
#define set_PP_TXFORMAT_X_2_txdepth(reg, txdepth) (reg)->bitfields.TXDEPTH = txdepth
#define set_PP_TXFORMAT_X_2_volume_filter(reg, volume_filter) (reg)->bitfields.VOLUME_FILTER = volume_filter
#define set_PP_TXFORMAT_X_2_clamp_mode(reg, clamp_mode) (reg)->bitfields.CLAMP_MODE = clamp_mode
#define set_PP_TXFORMAT_X_2_wrapen_q(reg, wrapen_q) (reg)->bitfields.WRAPEN_Q = wrapen_q
#define set_PP_TXFORMAT_X_2_clamp_q(reg, clamp_q) (reg)->bitfields.CLAMP_Q = clamp_q
#define set_PP_TXFORMAT_X_2_min_mip_level(reg, min_mip_level) (reg)->bitfields.MIN_MIP_LEVEL = min_mip_level
#define set_PP_TXFORMAT_X_2_tex_coord_type(reg, tex_coord_type) (reg)->bitfields.TEX_COORD_TYPE = tex_coord_type
#define set_PP_TXFORMAT_X_2_lod_bias(reg, lod_bias) (reg)->bitfields.LOD_BIAS = lod_bias

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXFORMAT_X_3 regPP_TXFORMAT_X_3;

#ifdef DEBUG
__inline void set_PP_TXFORMAT_X_3_txdepth(regPP_TXFORMAT_X_3 *reg, unsigned int txdepth)
{
  reg->bitfields.TXDEPTH = txdepth;
  if (reg->bitfields.TXDEPTH != txdepth) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_3::TXDEPTH data too large\n");
}
__inline void set_PP_TXFORMAT_X_3_volume_filter(regPP_TXFORMAT_X_3 *reg, unsigned int volume_filter)
{
  reg->bitfields.VOLUME_FILTER = volume_filter;
  if (reg->bitfields.VOLUME_FILTER != volume_filter) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_3::VOLUME_FILTER data too large\n");
}
__inline void set_PP_TXFORMAT_X_3_clamp_mode(regPP_TXFORMAT_X_3 *reg, unsigned int clamp_mode)
{
  reg->bitfields.CLAMP_MODE = clamp_mode;
  if (reg->bitfields.CLAMP_MODE != clamp_mode) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_3::CLAMP_MODE data too large\n");
}
__inline void set_PP_TXFORMAT_X_3_wrapen_q(regPP_TXFORMAT_X_3 *reg, unsigned int wrapen_q)
{
  reg->bitfields.WRAPEN_Q = wrapen_q;
  if (reg->bitfields.WRAPEN_Q != wrapen_q) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_3::WRAPEN_Q data too large\n");
}
__inline void set_PP_TXFORMAT_X_3_clamp_q(regPP_TXFORMAT_X_3 *reg, unsigned int clamp_q)
{
  reg->bitfields.CLAMP_Q = clamp_q;
  if (reg->bitfields.CLAMP_Q != clamp_q) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_3::CLAMP_Q data too large\n");
}
__inline void set_PP_TXFORMAT_X_3_min_mip_level(regPP_TXFORMAT_X_3 *reg, unsigned int min_mip_level)
{
  reg->bitfields.MIN_MIP_LEVEL = min_mip_level;
  if (reg->bitfields.MIN_MIP_LEVEL != min_mip_level) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_3::MIN_MIP_LEVEL data too large\n");
}
__inline void set_PP_TXFORMAT_X_3_tex_coord_type(regPP_TXFORMAT_X_3 *reg, unsigned int tex_coord_type)
{
  reg->bitfields.TEX_COORD_TYPE = tex_coord_type;
  if (reg->bitfields.TEX_COORD_TYPE != tex_coord_type) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_3::TEX_COORD_TYPE data too large\n");
}
__inline void set_PP_TXFORMAT_X_3_lod_bias(regPP_TXFORMAT_X_3 *reg, unsigned int lod_bias)
{
  reg->bitfields.LOD_BIAS = lod_bias;
  if (reg->bitfields.LOD_BIAS != lod_bias) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_3::LOD_BIAS data too large\n");
}
#else
#define set_PP_TXFORMAT_X_3_txdepth(reg, txdepth) (reg)->bitfields.TXDEPTH = txdepth
#define set_PP_TXFORMAT_X_3_volume_filter(reg, volume_filter) (reg)->bitfields.VOLUME_FILTER = volume_filter
#define set_PP_TXFORMAT_X_3_clamp_mode(reg, clamp_mode) (reg)->bitfields.CLAMP_MODE = clamp_mode
#define set_PP_TXFORMAT_X_3_wrapen_q(reg, wrapen_q) (reg)->bitfields.WRAPEN_Q = wrapen_q
#define set_PP_TXFORMAT_X_3_clamp_q(reg, clamp_q) (reg)->bitfields.CLAMP_Q = clamp_q
#define set_PP_TXFORMAT_X_3_min_mip_level(reg, min_mip_level) (reg)->bitfields.MIN_MIP_LEVEL = min_mip_level
#define set_PP_TXFORMAT_X_3_tex_coord_type(reg, tex_coord_type) (reg)->bitfields.TEX_COORD_TYPE = tex_coord_type
#define set_PP_TXFORMAT_X_3_lod_bias(reg, lod_bias) (reg)->bitfields.LOD_BIAS = lod_bias

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXFORMAT_X_4 regPP_TXFORMAT_X_4;

#ifdef DEBUG
__inline void set_PP_TXFORMAT_X_4_txdepth(regPP_TXFORMAT_X_4 *reg, unsigned int txdepth)
{
  reg->bitfields.TXDEPTH = txdepth;
  if (reg->bitfields.TXDEPTH != txdepth) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_4::TXDEPTH data too large\n");
}
__inline void set_PP_TXFORMAT_X_4_volume_filter(regPP_TXFORMAT_X_4 *reg, unsigned int volume_filter)
{
  reg->bitfields.VOLUME_FILTER = volume_filter;
  if (reg->bitfields.VOLUME_FILTER != volume_filter) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_4::VOLUME_FILTER data too large\n");
}
__inline void set_PP_TXFORMAT_X_4_clamp_mode(regPP_TXFORMAT_X_4 *reg, unsigned int clamp_mode)
{
  reg->bitfields.CLAMP_MODE = clamp_mode;
  if (reg->bitfields.CLAMP_MODE != clamp_mode) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_4::CLAMP_MODE data too large\n");
}
__inline void set_PP_TXFORMAT_X_4_wrapen_q(regPP_TXFORMAT_X_4 *reg, unsigned int wrapen_q)
{
  reg->bitfields.WRAPEN_Q = wrapen_q;
  if (reg->bitfields.WRAPEN_Q != wrapen_q) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_4::WRAPEN_Q data too large\n");
}
__inline void set_PP_TXFORMAT_X_4_clamp_q(regPP_TXFORMAT_X_4 *reg, unsigned int clamp_q)
{
  reg->bitfields.CLAMP_Q = clamp_q;
  if (reg->bitfields.CLAMP_Q != clamp_q) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_4::CLAMP_Q data too large\n");
}
__inline void set_PP_TXFORMAT_X_4_min_mip_level(regPP_TXFORMAT_X_4 *reg, unsigned int min_mip_level)
{
  reg->bitfields.MIN_MIP_LEVEL = min_mip_level;
  if (reg->bitfields.MIN_MIP_LEVEL != min_mip_level) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_4::MIN_MIP_LEVEL data too large\n");
}
__inline void set_PP_TXFORMAT_X_4_tex_coord_type(regPP_TXFORMAT_X_4 *reg, unsigned int tex_coord_type)
{
  reg->bitfields.TEX_COORD_TYPE = tex_coord_type;
  if (reg->bitfields.TEX_COORD_TYPE != tex_coord_type) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_4::TEX_COORD_TYPE data too large\n");
}
__inline void set_PP_TXFORMAT_X_4_lod_bias(regPP_TXFORMAT_X_4 *reg, unsigned int lod_bias)
{
  reg->bitfields.LOD_BIAS = lod_bias;
  if (reg->bitfields.LOD_BIAS != lod_bias) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_4::LOD_BIAS data too large\n");
}
#else
#define set_PP_TXFORMAT_X_4_txdepth(reg, txdepth) (reg)->bitfields.TXDEPTH = txdepth
#define set_PP_TXFORMAT_X_4_volume_filter(reg, volume_filter) (reg)->bitfields.VOLUME_FILTER = volume_filter
#define set_PP_TXFORMAT_X_4_clamp_mode(reg, clamp_mode) (reg)->bitfields.CLAMP_MODE = clamp_mode
#define set_PP_TXFORMAT_X_4_wrapen_q(reg, wrapen_q) (reg)->bitfields.WRAPEN_Q = wrapen_q
#define set_PP_TXFORMAT_X_4_clamp_q(reg, clamp_q) (reg)->bitfields.CLAMP_Q = clamp_q
#define set_PP_TXFORMAT_X_4_min_mip_level(reg, min_mip_level) (reg)->bitfields.MIN_MIP_LEVEL = min_mip_level
#define set_PP_TXFORMAT_X_4_tex_coord_type(reg, tex_coord_type) (reg)->bitfields.TEX_COORD_TYPE = tex_coord_type
#define set_PP_TXFORMAT_X_4_lod_bias(reg, lod_bias) (reg)->bitfields.LOD_BIAS = lod_bias

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXFORMAT_X_5 regPP_TXFORMAT_X_5;

#ifdef DEBUG
__inline void set_PP_TXFORMAT_X_5_txdepth(regPP_TXFORMAT_X_5 *reg, unsigned int txdepth)
{
  reg->bitfields.TXDEPTH = txdepth;
  if (reg->bitfields.TXDEPTH != txdepth) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_5::TXDEPTH data too large\n");
}
__inline void set_PP_TXFORMAT_X_5_volume_filter(regPP_TXFORMAT_X_5 *reg, unsigned int volume_filter)
{
  reg->bitfields.VOLUME_FILTER = volume_filter;
  if (reg->bitfields.VOLUME_FILTER != volume_filter) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_5::VOLUME_FILTER data too large\n");
}
__inline void set_PP_TXFORMAT_X_5_clamp_mode(regPP_TXFORMAT_X_5 *reg, unsigned int clamp_mode)
{
  reg->bitfields.CLAMP_MODE = clamp_mode;
  if (reg->bitfields.CLAMP_MODE != clamp_mode) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_5::CLAMP_MODE data too large\n");
}
__inline void set_PP_TXFORMAT_X_5_wrapen_q(regPP_TXFORMAT_X_5 *reg, unsigned int wrapen_q)
{
  reg->bitfields.WRAPEN_Q = wrapen_q;
  if (reg->bitfields.WRAPEN_Q != wrapen_q) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_5::WRAPEN_Q data too large\n");
}
__inline void set_PP_TXFORMAT_X_5_clamp_q(regPP_TXFORMAT_X_5 *reg, unsigned int clamp_q)
{
  reg->bitfields.CLAMP_Q = clamp_q;
  if (reg->bitfields.CLAMP_Q != clamp_q) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_5::CLAMP_Q data too large\n");
}
__inline void set_PP_TXFORMAT_X_5_min_mip_level(regPP_TXFORMAT_X_5 *reg, unsigned int min_mip_level)
{
  reg->bitfields.MIN_MIP_LEVEL = min_mip_level;
  if (reg->bitfields.MIN_MIP_LEVEL != min_mip_level) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_5::MIN_MIP_LEVEL data too large\n");
}
__inline void set_PP_TXFORMAT_X_5_tex_coord_type(regPP_TXFORMAT_X_5 *reg, unsigned int tex_coord_type)
{
  reg->bitfields.TEX_COORD_TYPE = tex_coord_type;
  if (reg->bitfields.TEX_COORD_TYPE != tex_coord_type) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_5::TEX_COORD_TYPE data too large\n");
}
__inline void set_PP_TXFORMAT_X_5_lod_bias(regPP_TXFORMAT_X_5 *reg, unsigned int lod_bias)
{
  reg->bitfields.LOD_BIAS = lod_bias;
  if (reg->bitfields.LOD_BIAS != lod_bias) HSLDPF(E_ERROR_MESSAGE,"PP_TXFORMAT_X_5::LOD_BIAS data too large\n");
}
#else
#define set_PP_TXFORMAT_X_5_txdepth(reg, txdepth) (reg)->bitfields.TXDEPTH = txdepth
#define set_PP_TXFORMAT_X_5_volume_filter(reg, volume_filter) (reg)->bitfields.VOLUME_FILTER = volume_filter
#define set_PP_TXFORMAT_X_5_clamp_mode(reg, clamp_mode) (reg)->bitfields.CLAMP_MODE = clamp_mode
#define set_PP_TXFORMAT_X_5_wrapen_q(reg, wrapen_q) (reg)->bitfields.WRAPEN_Q = wrapen_q
#define set_PP_TXFORMAT_X_5_clamp_q(reg, clamp_q) (reg)->bitfields.CLAMP_Q = clamp_q
#define set_PP_TXFORMAT_X_5_min_mip_level(reg, min_mip_level) (reg)->bitfields.MIN_MIP_LEVEL = min_mip_level
#define set_PP_TXFORMAT_X_5_tex_coord_type(reg, tex_coord_type) (reg)->bitfields.TEX_COORD_TYPE = tex_coord_type
#define set_PP_TXFORMAT_X_5_lod_bias(reg, lod_bias) (reg)->bitfields.LOD_BIAS = lod_bias

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TEX_SIZE_0 regPP_TEX_SIZE_0;

#ifdef DEBUG
__inline void set_PP_TEX_SIZE_0_tex_usize(regPP_TEX_SIZE_0 *reg, unsigned int tex_usize)
{
  reg->bitfields.TEX_USIZE = tex_usize;
  if (reg->bitfields.TEX_USIZE != tex_usize) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_0::TEX_USIZE data too large\n");
}
__inline void set_PP_TEX_SIZE_0_tex_vsize(regPP_TEX_SIZE_0 *reg, unsigned int tex_vsize)
{
  reg->bitfields.TEX_VSIZE = tex_vsize;
  if (reg->bitfields.TEX_VSIZE != tex_vsize) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_0::TEX_VSIZE data too large\n");
}
__inline void set_PP_TEX_SIZE_0_signed_rgb(regPP_TEX_SIZE_0 *reg, unsigned int signed_rgb)
{
  reg->bitfields.SIGNED_RGB = signed_rgb;
  if (reg->bitfields.SIGNED_RGB != signed_rgb) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_0::SIGNED_RGB data too large\n");
}
__inline void set_PP_TEX_SIZE_0_signed_alpha(regPP_TEX_SIZE_0 *reg, unsigned int signed_alpha)
{
  reg->bitfields.SIGNED_ALPHA = signed_alpha;
  if (reg->bitfields.SIGNED_ALPHA != signed_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_0::SIGNED_ALPHA data too large\n");
}
#else
#define set_PP_TEX_SIZE_0_tex_usize(reg, tex_usize) (reg)->bitfields.TEX_USIZE = tex_usize
#define set_PP_TEX_SIZE_0_tex_vsize(reg, tex_vsize) (reg)->bitfields.TEX_VSIZE = tex_vsize
#define set_PP_TEX_SIZE_0_signed_rgb(reg, signed_rgb) (reg)->bitfields.SIGNED_RGB = signed_rgb
#define set_PP_TEX_SIZE_0_signed_alpha(reg, signed_alpha) (reg)->bitfields.SIGNED_ALPHA = signed_alpha

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TEX_SIZE_1 regPP_TEX_SIZE_1;

#ifdef DEBUG
__inline void set_PP_TEX_SIZE_1_tex_usize(regPP_TEX_SIZE_1 *reg, unsigned int tex_usize)
{
  reg->bitfields.TEX_USIZE = tex_usize;
  if (reg->bitfields.TEX_USIZE != tex_usize) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_1::TEX_USIZE data too large\n");
}
__inline void set_PP_TEX_SIZE_1_tex_vsize(regPP_TEX_SIZE_1 *reg, unsigned int tex_vsize)
{
  reg->bitfields.TEX_VSIZE = tex_vsize;
  if (reg->bitfields.TEX_VSIZE != tex_vsize) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_1::TEX_VSIZE data too large\n");
}
__inline void set_PP_TEX_SIZE_1_signed_rgb(regPP_TEX_SIZE_1 *reg, unsigned int signed_rgb)
{
  reg->bitfields.SIGNED_RGB = signed_rgb;
  if (reg->bitfields.SIGNED_RGB != signed_rgb) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_1::SIGNED_RGB data too large\n");
}
__inline void set_PP_TEX_SIZE_1_signed_alpha(regPP_TEX_SIZE_1 *reg, unsigned int signed_alpha)
{
  reg->bitfields.SIGNED_ALPHA = signed_alpha;
  if (reg->bitfields.SIGNED_ALPHA != signed_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_1::SIGNED_ALPHA data too large\n");
}
#else
#define set_PP_TEX_SIZE_1_tex_usize(reg, tex_usize) (reg)->bitfields.TEX_USIZE = tex_usize
#define set_PP_TEX_SIZE_1_tex_vsize(reg, tex_vsize) (reg)->bitfields.TEX_VSIZE = tex_vsize
#define set_PP_TEX_SIZE_1_signed_rgb(reg, signed_rgb) (reg)->bitfields.SIGNED_RGB = signed_rgb
#define set_PP_TEX_SIZE_1_signed_alpha(reg, signed_alpha) (reg)->bitfields.SIGNED_ALPHA = signed_alpha

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TEX_SIZE_2 regPP_TEX_SIZE_2;

#ifdef DEBUG
__inline void set_PP_TEX_SIZE_2_tex_usize(regPP_TEX_SIZE_2 *reg, unsigned int tex_usize)
{
  reg->bitfields.TEX_USIZE = tex_usize;
  if (reg->bitfields.TEX_USIZE != tex_usize) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_2::TEX_USIZE data too large\n");
}
__inline void set_PP_TEX_SIZE_2_tex_vsize(regPP_TEX_SIZE_2 *reg, unsigned int tex_vsize)
{
  reg->bitfields.TEX_VSIZE = tex_vsize;
  if (reg->bitfields.TEX_VSIZE != tex_vsize) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_2::TEX_VSIZE data too large\n");
}
__inline void set_PP_TEX_SIZE_2_signed_rgb(regPP_TEX_SIZE_2 *reg, unsigned int signed_rgb)
{
  reg->bitfields.SIGNED_RGB = signed_rgb;
  if (reg->bitfields.SIGNED_RGB != signed_rgb) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_2::SIGNED_RGB data too large\n");
}
__inline void set_PP_TEX_SIZE_2_signed_alpha(regPP_TEX_SIZE_2 *reg, unsigned int signed_alpha)
{
  reg->bitfields.SIGNED_ALPHA = signed_alpha;
  if (reg->bitfields.SIGNED_ALPHA != signed_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_2::SIGNED_ALPHA data too large\n");
}
#else
#define set_PP_TEX_SIZE_2_tex_usize(reg, tex_usize) (reg)->bitfields.TEX_USIZE = tex_usize
#define set_PP_TEX_SIZE_2_tex_vsize(reg, tex_vsize) (reg)->bitfields.TEX_VSIZE = tex_vsize
#define set_PP_TEX_SIZE_2_signed_rgb(reg, signed_rgb) (reg)->bitfields.SIGNED_RGB = signed_rgb
#define set_PP_TEX_SIZE_2_signed_alpha(reg, signed_alpha) (reg)->bitfields.SIGNED_ALPHA = signed_alpha

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TEX_SIZE_3 regPP_TEX_SIZE_3;

#ifdef DEBUG
__inline void set_PP_TEX_SIZE_3_tex_usize(regPP_TEX_SIZE_3 *reg, unsigned int tex_usize)
{
  reg->bitfields.TEX_USIZE = tex_usize;
  if (reg->bitfields.TEX_USIZE != tex_usize) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_3::TEX_USIZE data too large\n");
}
__inline void set_PP_TEX_SIZE_3_tex_vsize(regPP_TEX_SIZE_3 *reg, unsigned int tex_vsize)
{
  reg->bitfields.TEX_VSIZE = tex_vsize;
  if (reg->bitfields.TEX_VSIZE != tex_vsize) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_3::TEX_VSIZE data too large\n");
}
__inline void set_PP_TEX_SIZE_3_signed_rgb(regPP_TEX_SIZE_3 *reg, unsigned int signed_rgb)
{
  reg->bitfields.SIGNED_RGB = signed_rgb;
  if (reg->bitfields.SIGNED_RGB != signed_rgb) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_3::SIGNED_RGB data too large\n");
}
__inline void set_PP_TEX_SIZE_3_signed_alpha(regPP_TEX_SIZE_3 *reg, unsigned int signed_alpha)
{
  reg->bitfields.SIGNED_ALPHA = signed_alpha;
  if (reg->bitfields.SIGNED_ALPHA != signed_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_3::SIGNED_ALPHA data too large\n");
}
#else
#define set_PP_TEX_SIZE_3_tex_usize(reg, tex_usize) (reg)->bitfields.TEX_USIZE = tex_usize
#define set_PP_TEX_SIZE_3_tex_vsize(reg, tex_vsize) (reg)->bitfields.TEX_VSIZE = tex_vsize
#define set_PP_TEX_SIZE_3_signed_rgb(reg, signed_rgb) (reg)->bitfields.SIGNED_RGB = signed_rgb
#define set_PP_TEX_SIZE_3_signed_alpha(reg, signed_alpha) (reg)->bitfields.SIGNED_ALPHA = signed_alpha

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TEX_SIZE_4 regPP_TEX_SIZE_4;

#ifdef DEBUG
__inline void set_PP_TEX_SIZE_4_tex_usize(regPP_TEX_SIZE_4 *reg, unsigned int tex_usize)
{
  reg->bitfields.TEX_USIZE = tex_usize;
  if (reg->bitfields.TEX_USIZE != tex_usize) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_4::TEX_USIZE data too large\n");
}
__inline void set_PP_TEX_SIZE_4_tex_vsize(regPP_TEX_SIZE_4 *reg, unsigned int tex_vsize)
{
  reg->bitfields.TEX_VSIZE = tex_vsize;
  if (reg->bitfields.TEX_VSIZE != tex_vsize) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_4::TEX_VSIZE data too large\n");
}
__inline void set_PP_TEX_SIZE_4_signed_rgb(regPP_TEX_SIZE_4 *reg, unsigned int signed_rgb)
{
  reg->bitfields.SIGNED_RGB = signed_rgb;
  if (reg->bitfields.SIGNED_RGB != signed_rgb) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_4::SIGNED_RGB data too large\n");
}
__inline void set_PP_TEX_SIZE_4_signed_alpha(regPP_TEX_SIZE_4 *reg, unsigned int signed_alpha)
{
  reg->bitfields.SIGNED_ALPHA = signed_alpha;
  if (reg->bitfields.SIGNED_ALPHA != signed_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_4::SIGNED_ALPHA data too large\n");
}
#else
#define set_PP_TEX_SIZE_4_tex_usize(reg, tex_usize) (reg)->bitfields.TEX_USIZE = tex_usize
#define set_PP_TEX_SIZE_4_tex_vsize(reg, tex_vsize) (reg)->bitfields.TEX_VSIZE = tex_vsize
#define set_PP_TEX_SIZE_4_signed_rgb(reg, signed_rgb) (reg)->bitfields.SIGNED_RGB = signed_rgb
#define set_PP_TEX_SIZE_4_signed_alpha(reg, signed_alpha) (reg)->bitfields.SIGNED_ALPHA = signed_alpha

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TEX_SIZE_5 regPP_TEX_SIZE_5;

#ifdef DEBUG
__inline void set_PP_TEX_SIZE_5_tex_usize(regPP_TEX_SIZE_5 *reg, unsigned int tex_usize)
{
  reg->bitfields.TEX_USIZE = tex_usize;
  if (reg->bitfields.TEX_USIZE != tex_usize) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_5::TEX_USIZE data too large\n");
}
__inline void set_PP_TEX_SIZE_5_tex_vsize(regPP_TEX_SIZE_5 *reg, unsigned int tex_vsize)
{
  reg->bitfields.TEX_VSIZE = tex_vsize;
  if (reg->bitfields.TEX_VSIZE != tex_vsize) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_5::TEX_VSIZE data too large\n");
}
__inline void set_PP_TEX_SIZE_5_signed_rgb(regPP_TEX_SIZE_5 *reg, unsigned int signed_rgb)
{
  reg->bitfields.SIGNED_RGB = signed_rgb;
  if (reg->bitfields.SIGNED_RGB != signed_rgb) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_5::SIGNED_RGB data too large\n");
}
__inline void set_PP_TEX_SIZE_5_signed_alpha(regPP_TEX_SIZE_5 *reg, unsigned int signed_alpha)
{
  reg->bitfields.SIGNED_ALPHA = signed_alpha;
  if (reg->bitfields.SIGNED_ALPHA != signed_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_TEX_SIZE_5::SIGNED_ALPHA data too large\n");
}
#else
#define set_PP_TEX_SIZE_5_tex_usize(reg, tex_usize) (reg)->bitfields.TEX_USIZE = tex_usize
#define set_PP_TEX_SIZE_5_tex_vsize(reg, tex_vsize) (reg)->bitfields.TEX_VSIZE = tex_vsize
#define set_PP_TEX_SIZE_5_signed_rgb(reg, signed_rgb) (reg)->bitfields.SIGNED_RGB = signed_rgb
#define set_PP_TEX_SIZE_5_signed_alpha(reg, signed_alpha) (reg)->bitfields.SIGNED_ALPHA = signed_alpha

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXPITCH_0 regPP_TXPITCH_0;

#ifdef DEBUG
__inline void set_PP_TXPITCH_0_txpitch(regPP_TXPITCH_0 *reg, unsigned int txpitch)
{
  reg->bitfields.TXPITCH = txpitch;
  if (reg->bitfields.TXPITCH != txpitch) HSLDPF(E_ERROR_MESSAGE,"PP_TXPITCH_0::TXPITCH data too large\n");
}
__inline void set_PP_TXPITCH_0_tex_tag_cntl(regPP_TXPITCH_0 *reg, unsigned int tex_tag_cntl)
{
  reg->bitfields.TEX_TAG_CNTL = tex_tag_cntl;
  if (reg->bitfields.TEX_TAG_CNTL != tex_tag_cntl) HSLDPF(E_ERROR_MESSAGE,"PP_TXPITCH_0::TEX_TAG_CNTL data too large\n");
}
#else
#define set_PP_TXPITCH_0_txpitch(reg, txpitch) (reg)->bitfields.TXPITCH = txpitch
#define set_PP_TXPITCH_0_tex_tag_cntl(reg, tex_tag_cntl) (reg)->bitfields.TEX_TAG_CNTL = tex_tag_cntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXPITCH_1 regPP_TXPITCH_1;

#ifdef DEBUG
__inline void set_PP_TXPITCH_1_txpitch(regPP_TXPITCH_1 *reg, unsigned int txpitch)
{
  reg->bitfields.TXPITCH = txpitch;
  if (reg->bitfields.TXPITCH != txpitch) HSLDPF(E_ERROR_MESSAGE,"PP_TXPITCH_1::TXPITCH data too large\n");
}
__inline void set_PP_TXPITCH_1_tex_tag_cntl(regPP_TXPITCH_1 *reg, unsigned int tex_tag_cntl)
{
  reg->bitfields.TEX_TAG_CNTL = tex_tag_cntl;
  if (reg->bitfields.TEX_TAG_CNTL != tex_tag_cntl) HSLDPF(E_ERROR_MESSAGE,"PP_TXPITCH_1::TEX_TAG_CNTL data too large\n");
}
#else
#define set_PP_TXPITCH_1_txpitch(reg, txpitch) (reg)->bitfields.TXPITCH = txpitch
#define set_PP_TXPITCH_1_tex_tag_cntl(reg, tex_tag_cntl) (reg)->bitfields.TEX_TAG_CNTL = tex_tag_cntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXPITCH_2 regPP_TXPITCH_2;

#ifdef DEBUG
__inline void set_PP_TXPITCH_2_txpitch(regPP_TXPITCH_2 *reg, unsigned int txpitch)
{
  reg->bitfields.TXPITCH = txpitch;
  if (reg->bitfields.TXPITCH != txpitch) HSLDPF(E_ERROR_MESSAGE,"PP_TXPITCH_2::TXPITCH data too large\n");
}
__inline void set_PP_TXPITCH_2_tex_tag_cntl(regPP_TXPITCH_2 *reg, unsigned int tex_tag_cntl)
{
  reg->bitfields.TEX_TAG_CNTL = tex_tag_cntl;
  if (reg->bitfields.TEX_TAG_CNTL != tex_tag_cntl) HSLDPF(E_ERROR_MESSAGE,"PP_TXPITCH_2::TEX_TAG_CNTL data too large\n");
}
#else
#define set_PP_TXPITCH_2_txpitch(reg, txpitch) (reg)->bitfields.TXPITCH = txpitch
#define set_PP_TXPITCH_2_tex_tag_cntl(reg, tex_tag_cntl) (reg)->bitfields.TEX_TAG_CNTL = tex_tag_cntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXPITCH_3 regPP_TXPITCH_3;

#ifdef DEBUG
__inline void set_PP_TXPITCH_3_txpitch(regPP_TXPITCH_3 *reg, unsigned int txpitch)
{
  reg->bitfields.TXPITCH = txpitch;
  if (reg->bitfields.TXPITCH != txpitch) HSLDPF(E_ERROR_MESSAGE,"PP_TXPITCH_3::TXPITCH data too large\n");
}
__inline void set_PP_TXPITCH_3_tex_tag_cntl(regPP_TXPITCH_3 *reg, unsigned int tex_tag_cntl)
{
  reg->bitfields.TEX_TAG_CNTL = tex_tag_cntl;
  if (reg->bitfields.TEX_TAG_CNTL != tex_tag_cntl) HSLDPF(E_ERROR_MESSAGE,"PP_TXPITCH_3::TEX_TAG_CNTL data too large\n");
}
#else
#define set_PP_TXPITCH_3_txpitch(reg, txpitch) (reg)->bitfields.TXPITCH = txpitch
#define set_PP_TXPITCH_3_tex_tag_cntl(reg, tex_tag_cntl) (reg)->bitfields.TEX_TAG_CNTL = tex_tag_cntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXPITCH_4 regPP_TXPITCH_4;

#ifdef DEBUG
__inline void set_PP_TXPITCH_4_txpitch(regPP_TXPITCH_4 *reg, unsigned int txpitch)
{
  reg->bitfields.TXPITCH = txpitch;
  if (reg->bitfields.TXPITCH != txpitch) HSLDPF(E_ERROR_MESSAGE,"PP_TXPITCH_4::TXPITCH data too large\n");
}
__inline void set_PP_TXPITCH_4_tex_tag_cntl(regPP_TXPITCH_4 *reg, unsigned int tex_tag_cntl)
{
  reg->bitfields.TEX_TAG_CNTL = tex_tag_cntl;
  if (reg->bitfields.TEX_TAG_CNTL != tex_tag_cntl) HSLDPF(E_ERROR_MESSAGE,"PP_TXPITCH_4::TEX_TAG_CNTL data too large\n");
}
#else
#define set_PP_TXPITCH_4_txpitch(reg, txpitch) (reg)->bitfields.TXPITCH = txpitch
#define set_PP_TXPITCH_4_tex_tag_cntl(reg, tex_tag_cntl) (reg)->bitfields.TEX_TAG_CNTL = tex_tag_cntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXPITCH_5 regPP_TXPITCH_5;

#ifdef DEBUG
__inline void set_PP_TXPITCH_5_txpitch(regPP_TXPITCH_5 *reg, unsigned int txpitch)
{
  reg->bitfields.TXPITCH = txpitch;
  if (reg->bitfields.TXPITCH != txpitch) HSLDPF(E_ERROR_MESSAGE,"PP_TXPITCH_5::TXPITCH data too large\n");
}
__inline void set_PP_TXPITCH_5_tex_tag_cntl(regPP_TXPITCH_5 *reg, unsigned int tex_tag_cntl)
{
  reg->bitfields.TEX_TAG_CNTL = tex_tag_cntl;
  if (reg->bitfields.TEX_TAG_CNTL != tex_tag_cntl) HSLDPF(E_ERROR_MESSAGE,"PP_TXPITCH_5::TEX_TAG_CNTL data too large\n");
}
#else
#define set_PP_TXPITCH_5_txpitch(reg, txpitch) (reg)->bitfields.TXPITCH = txpitch
#define set_PP_TXPITCH_5_tex_tag_cntl(reg, tex_tag_cntl) (reg)->bitfields.TEX_TAG_CNTL = tex_tag_cntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_BORDER_COLOR_0 regPP_BORDER_COLOR_0;

#ifdef DEBUG
__inline void set_PP_BORDER_COLOR_0_bord_color(regPP_BORDER_COLOR_0 *reg, unsigned int bord_color)
{
  reg->bitfields.BORD_COLOR = bord_color;
  if (reg->bitfields.BORD_COLOR != bord_color) HSLDPF(E_ERROR_MESSAGE,"PP_BORDER_COLOR_0::BORD_COLOR data too large\n");
}
#else
#define set_PP_BORDER_COLOR_0_bord_color(reg, bord_color) (reg)->bitfields.BORD_COLOR = bord_color

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_BORDER_COLOR_1 regPP_BORDER_COLOR_1;

#ifdef DEBUG
__inline void set_PP_BORDER_COLOR_1_bord_color(regPP_BORDER_COLOR_1 *reg, unsigned int bord_color)
{
  reg->bitfields.BORD_COLOR = bord_color;
  if (reg->bitfields.BORD_COLOR != bord_color) HSLDPF(E_ERROR_MESSAGE,"PP_BORDER_COLOR_1::BORD_COLOR data too large\n");
}
#else
#define set_PP_BORDER_COLOR_1_bord_color(reg, bord_color) (reg)->bitfields.BORD_COLOR = bord_color

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_BORDER_COLOR_2 regPP_BORDER_COLOR_2;

#ifdef DEBUG
__inline void set_PP_BORDER_COLOR_2_bord_color(regPP_BORDER_COLOR_2 *reg, unsigned int bord_color)
{
  reg->bitfields.BORD_COLOR = bord_color;
  if (reg->bitfields.BORD_COLOR != bord_color) HSLDPF(E_ERROR_MESSAGE,"PP_BORDER_COLOR_2::BORD_COLOR data too large\n");
}
#else
#define set_PP_BORDER_COLOR_2_bord_color(reg, bord_color) (reg)->bitfields.BORD_COLOR = bord_color

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_BORDER_COLOR_3 regPP_BORDER_COLOR_3;

#ifdef DEBUG
__inline void set_PP_BORDER_COLOR_3_bord_color(regPP_BORDER_COLOR_3 *reg, unsigned int bord_color)
{
  reg->bitfields.BORD_COLOR = bord_color;
  if (reg->bitfields.BORD_COLOR != bord_color) HSLDPF(E_ERROR_MESSAGE,"PP_BORDER_COLOR_3::BORD_COLOR data too large\n");
}
#else
#define set_PP_BORDER_COLOR_3_bord_color(reg, bord_color) (reg)->bitfields.BORD_COLOR = bord_color

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_BORDER_COLOR_4 regPP_BORDER_COLOR_4;

#ifdef DEBUG
__inline void set_PP_BORDER_COLOR_4_bord_color(regPP_BORDER_COLOR_4 *reg, unsigned int bord_color)
{
  reg->bitfields.BORD_COLOR = bord_color;
  if (reg->bitfields.BORD_COLOR != bord_color) HSLDPF(E_ERROR_MESSAGE,"PP_BORDER_COLOR_4::BORD_COLOR data too large\n");
}
#else
#define set_PP_BORDER_COLOR_4_bord_color(reg, bord_color) (reg)->bitfields.BORD_COLOR = bord_color

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_BORDER_COLOR_5 regPP_BORDER_COLOR_5;

#ifdef DEBUG
__inline void set_PP_BORDER_COLOR_5_bord_color(regPP_BORDER_COLOR_5 *reg, unsigned int bord_color)
{
  reg->bitfields.BORD_COLOR = bord_color;
  if (reg->bitfields.BORD_COLOR != bord_color) HSLDPF(E_ERROR_MESSAGE,"PP_BORDER_COLOR_5::BORD_COLOR data too large\n");
}
#else
#define set_PP_BORDER_COLOR_5_bord_color(reg, bord_color) (reg)->bitfields.BORD_COLOR = bord_color

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_FACES_0 regPP_CUBIC_FACES_0;

#ifdef DEBUG
__inline void set_PP_CUBIC_FACES_0_face_width_1(regPP_CUBIC_FACES_0 *reg, unsigned int face_width_1)
{
  reg->bitfields.FACE_WIDTH_1 = face_width_1;
  if (reg->bitfields.FACE_WIDTH_1 != face_width_1) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_0::FACE_WIDTH_1 data too large\n");
}
__inline void set_PP_CUBIC_FACES_0_face_height_1(regPP_CUBIC_FACES_0 *reg, unsigned int face_height_1)
{
  reg->bitfields.FACE_HEIGHT_1 = face_height_1;
  if (reg->bitfields.FACE_HEIGHT_1 != face_height_1) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_0::FACE_HEIGHT_1 data too large\n");
}
__inline void set_PP_CUBIC_FACES_0_face_width_2(regPP_CUBIC_FACES_0 *reg, unsigned int face_width_2)
{
  reg->bitfields.FACE_WIDTH_2 = face_width_2;
  if (reg->bitfields.FACE_WIDTH_2 != face_width_2) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_0::FACE_WIDTH_2 data too large\n");
}
__inline void set_PP_CUBIC_FACES_0_face_height_2(regPP_CUBIC_FACES_0 *reg, unsigned int face_height_2)
{
  reg->bitfields.FACE_HEIGHT_2 = face_height_2;
  if (reg->bitfields.FACE_HEIGHT_2 != face_height_2) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_0::FACE_HEIGHT_2 data too large\n");
}
__inline void set_PP_CUBIC_FACES_0_face_width_3(regPP_CUBIC_FACES_0 *reg, unsigned int face_width_3)
{
  reg->bitfields.FACE_WIDTH_3 = face_width_3;
  if (reg->bitfields.FACE_WIDTH_3 != face_width_3) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_0::FACE_WIDTH_3 data too large\n");
}
__inline void set_PP_CUBIC_FACES_0_face_height_3(regPP_CUBIC_FACES_0 *reg, unsigned int face_height_3)
{
  reg->bitfields.FACE_HEIGHT_3 = face_height_3;
  if (reg->bitfields.FACE_HEIGHT_3 != face_height_3) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_0::FACE_HEIGHT_3 data too large\n");
}
__inline void set_PP_CUBIC_FACES_0_face_width_4(regPP_CUBIC_FACES_0 *reg, unsigned int face_width_4)
{
  reg->bitfields.FACE_WIDTH_4 = face_width_4;
  if (reg->bitfields.FACE_WIDTH_4 != face_width_4) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_0::FACE_WIDTH_4 data too large\n");
}
__inline void set_PP_CUBIC_FACES_0_face_height_4(regPP_CUBIC_FACES_0 *reg, unsigned int face_height_4)
{
  reg->bitfields.FACE_HEIGHT_4 = face_height_4;
  if (reg->bitfields.FACE_HEIGHT_4 != face_height_4) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_0::FACE_HEIGHT_4 data too large\n");
}
#else
#define set_PP_CUBIC_FACES_0_face_width_1(reg, face_width_1) (reg)->bitfields.FACE_WIDTH_1 = face_width_1
#define set_PP_CUBIC_FACES_0_face_height_1(reg, face_height_1) (reg)->bitfields.FACE_HEIGHT_1 = face_height_1
#define set_PP_CUBIC_FACES_0_face_width_2(reg, face_width_2) (reg)->bitfields.FACE_WIDTH_2 = face_width_2
#define set_PP_CUBIC_FACES_0_face_height_2(reg, face_height_2) (reg)->bitfields.FACE_HEIGHT_2 = face_height_2
#define set_PP_CUBIC_FACES_0_face_width_3(reg, face_width_3) (reg)->bitfields.FACE_WIDTH_3 = face_width_3
#define set_PP_CUBIC_FACES_0_face_height_3(reg, face_height_3) (reg)->bitfields.FACE_HEIGHT_3 = face_height_3
#define set_PP_CUBIC_FACES_0_face_width_4(reg, face_width_4) (reg)->bitfields.FACE_WIDTH_4 = face_width_4
#define set_PP_CUBIC_FACES_0_face_height_4(reg, face_height_4) (reg)->bitfields.FACE_HEIGHT_4 = face_height_4

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_FACES_1 regPP_CUBIC_FACES_1;

#ifdef DEBUG
__inline void set_PP_CUBIC_FACES_1_face_width_1(regPP_CUBIC_FACES_1 *reg, unsigned int face_width_1)
{
  reg->bitfields.FACE_WIDTH_1 = face_width_1;
  if (reg->bitfields.FACE_WIDTH_1 != face_width_1) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_1::FACE_WIDTH_1 data too large\n");
}
__inline void set_PP_CUBIC_FACES_1_face_height_1(regPP_CUBIC_FACES_1 *reg, unsigned int face_height_1)
{
  reg->bitfields.FACE_HEIGHT_1 = face_height_1;
  if (reg->bitfields.FACE_HEIGHT_1 != face_height_1) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_1::FACE_HEIGHT_1 data too large\n");
}
__inline void set_PP_CUBIC_FACES_1_face_width_2(regPP_CUBIC_FACES_1 *reg, unsigned int face_width_2)
{
  reg->bitfields.FACE_WIDTH_2 = face_width_2;
  if (reg->bitfields.FACE_WIDTH_2 != face_width_2) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_1::FACE_WIDTH_2 data too large\n");
}
__inline void set_PP_CUBIC_FACES_1_face_height_2(regPP_CUBIC_FACES_1 *reg, unsigned int face_height_2)
{
  reg->bitfields.FACE_HEIGHT_2 = face_height_2;
  if (reg->bitfields.FACE_HEIGHT_2 != face_height_2) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_1::FACE_HEIGHT_2 data too large\n");
}
__inline void set_PP_CUBIC_FACES_1_face_width_3(regPP_CUBIC_FACES_1 *reg, unsigned int face_width_3)
{
  reg->bitfields.FACE_WIDTH_3 = face_width_3;
  if (reg->bitfields.FACE_WIDTH_3 != face_width_3) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_1::FACE_WIDTH_3 data too large\n");
}
__inline void set_PP_CUBIC_FACES_1_face_height_3(regPP_CUBIC_FACES_1 *reg, unsigned int face_height_3)
{
  reg->bitfields.FACE_HEIGHT_3 = face_height_3;
  if (reg->bitfields.FACE_HEIGHT_3 != face_height_3) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_1::FACE_HEIGHT_3 data too large\n");
}
__inline void set_PP_CUBIC_FACES_1_face_width_4(regPP_CUBIC_FACES_1 *reg, unsigned int face_width_4)
{
  reg->bitfields.FACE_WIDTH_4 = face_width_4;
  if (reg->bitfields.FACE_WIDTH_4 != face_width_4) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_1::FACE_WIDTH_4 data too large\n");
}
__inline void set_PP_CUBIC_FACES_1_face_height_4(regPP_CUBIC_FACES_1 *reg, unsigned int face_height_4)
{
  reg->bitfields.FACE_HEIGHT_4 = face_height_4;
  if (reg->bitfields.FACE_HEIGHT_4 != face_height_4) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_1::FACE_HEIGHT_4 data too large\n");
}
#else
#define set_PP_CUBIC_FACES_1_face_width_1(reg, face_width_1) (reg)->bitfields.FACE_WIDTH_1 = face_width_1
#define set_PP_CUBIC_FACES_1_face_height_1(reg, face_height_1) (reg)->bitfields.FACE_HEIGHT_1 = face_height_1
#define set_PP_CUBIC_FACES_1_face_width_2(reg, face_width_2) (reg)->bitfields.FACE_WIDTH_2 = face_width_2
#define set_PP_CUBIC_FACES_1_face_height_2(reg, face_height_2) (reg)->bitfields.FACE_HEIGHT_2 = face_height_2
#define set_PP_CUBIC_FACES_1_face_width_3(reg, face_width_3) (reg)->bitfields.FACE_WIDTH_3 = face_width_3
#define set_PP_CUBIC_FACES_1_face_height_3(reg, face_height_3) (reg)->bitfields.FACE_HEIGHT_3 = face_height_3
#define set_PP_CUBIC_FACES_1_face_width_4(reg, face_width_4) (reg)->bitfields.FACE_WIDTH_4 = face_width_4
#define set_PP_CUBIC_FACES_1_face_height_4(reg, face_height_4) (reg)->bitfields.FACE_HEIGHT_4 = face_height_4

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_FACES_2 regPP_CUBIC_FACES_2;

#ifdef DEBUG
__inline void set_PP_CUBIC_FACES_2_face_width_1(regPP_CUBIC_FACES_2 *reg, unsigned int face_width_1)
{
  reg->bitfields.FACE_WIDTH_1 = face_width_1;
  if (reg->bitfields.FACE_WIDTH_1 != face_width_1) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_2::FACE_WIDTH_1 data too large\n");
}
__inline void set_PP_CUBIC_FACES_2_face_height_1(regPP_CUBIC_FACES_2 *reg, unsigned int face_height_1)
{
  reg->bitfields.FACE_HEIGHT_1 = face_height_1;
  if (reg->bitfields.FACE_HEIGHT_1 != face_height_1) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_2::FACE_HEIGHT_1 data too large\n");
}
__inline void set_PP_CUBIC_FACES_2_face_width_2(regPP_CUBIC_FACES_2 *reg, unsigned int face_width_2)
{
  reg->bitfields.FACE_WIDTH_2 = face_width_2;
  if (reg->bitfields.FACE_WIDTH_2 != face_width_2) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_2::FACE_WIDTH_2 data too large\n");
}
__inline void set_PP_CUBIC_FACES_2_face_height_2(regPP_CUBIC_FACES_2 *reg, unsigned int face_height_2)
{
  reg->bitfields.FACE_HEIGHT_2 = face_height_2;
  if (reg->bitfields.FACE_HEIGHT_2 != face_height_2) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_2::FACE_HEIGHT_2 data too large\n");
}
__inline void set_PP_CUBIC_FACES_2_face_width_3(regPP_CUBIC_FACES_2 *reg, unsigned int face_width_3)
{
  reg->bitfields.FACE_WIDTH_3 = face_width_3;
  if (reg->bitfields.FACE_WIDTH_3 != face_width_3) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_2::FACE_WIDTH_3 data too large\n");
}
__inline void set_PP_CUBIC_FACES_2_face_height_3(regPP_CUBIC_FACES_2 *reg, unsigned int face_height_3)
{
  reg->bitfields.FACE_HEIGHT_3 = face_height_3;
  if (reg->bitfields.FACE_HEIGHT_3 != face_height_3) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_2::FACE_HEIGHT_3 data too large\n");
}
__inline void set_PP_CUBIC_FACES_2_face_width_4(regPP_CUBIC_FACES_2 *reg, unsigned int face_width_4)
{
  reg->bitfields.FACE_WIDTH_4 = face_width_4;
  if (reg->bitfields.FACE_WIDTH_4 != face_width_4) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_2::FACE_WIDTH_4 data too large\n");
}
__inline void set_PP_CUBIC_FACES_2_face_height_4(regPP_CUBIC_FACES_2 *reg, unsigned int face_height_4)
{
  reg->bitfields.FACE_HEIGHT_4 = face_height_4;
  if (reg->bitfields.FACE_HEIGHT_4 != face_height_4) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_2::FACE_HEIGHT_4 data too large\n");
}
#else
#define set_PP_CUBIC_FACES_2_face_width_1(reg, face_width_1) (reg)->bitfields.FACE_WIDTH_1 = face_width_1
#define set_PP_CUBIC_FACES_2_face_height_1(reg, face_height_1) (reg)->bitfields.FACE_HEIGHT_1 = face_height_1
#define set_PP_CUBIC_FACES_2_face_width_2(reg, face_width_2) (reg)->bitfields.FACE_WIDTH_2 = face_width_2
#define set_PP_CUBIC_FACES_2_face_height_2(reg, face_height_2) (reg)->bitfields.FACE_HEIGHT_2 = face_height_2
#define set_PP_CUBIC_FACES_2_face_width_3(reg, face_width_3) (reg)->bitfields.FACE_WIDTH_3 = face_width_3
#define set_PP_CUBIC_FACES_2_face_height_3(reg, face_height_3) (reg)->bitfields.FACE_HEIGHT_3 = face_height_3
#define set_PP_CUBIC_FACES_2_face_width_4(reg, face_width_4) (reg)->bitfields.FACE_WIDTH_4 = face_width_4
#define set_PP_CUBIC_FACES_2_face_height_4(reg, face_height_4) (reg)->bitfields.FACE_HEIGHT_4 = face_height_4

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_FACES_3 regPP_CUBIC_FACES_3;

#ifdef DEBUG
__inline void set_PP_CUBIC_FACES_3_face_width_1(regPP_CUBIC_FACES_3 *reg, unsigned int face_width_1)
{
  reg->bitfields.FACE_WIDTH_1 = face_width_1;
  if (reg->bitfields.FACE_WIDTH_1 != face_width_1) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_3::FACE_WIDTH_1 data too large\n");
}
__inline void set_PP_CUBIC_FACES_3_face_height_1(regPP_CUBIC_FACES_3 *reg, unsigned int face_height_1)
{
  reg->bitfields.FACE_HEIGHT_1 = face_height_1;
  if (reg->bitfields.FACE_HEIGHT_1 != face_height_1) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_3::FACE_HEIGHT_1 data too large\n");
}
__inline void set_PP_CUBIC_FACES_3_face_width_2(regPP_CUBIC_FACES_3 *reg, unsigned int face_width_2)
{
  reg->bitfields.FACE_WIDTH_2 = face_width_2;
  if (reg->bitfields.FACE_WIDTH_2 != face_width_2) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_3::FACE_WIDTH_2 data too large\n");
}
__inline void set_PP_CUBIC_FACES_3_face_height_2(regPP_CUBIC_FACES_3 *reg, unsigned int face_height_2)
{
  reg->bitfields.FACE_HEIGHT_2 = face_height_2;
  if (reg->bitfields.FACE_HEIGHT_2 != face_height_2) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_3::FACE_HEIGHT_2 data too large\n");
}
__inline void set_PP_CUBIC_FACES_3_face_width_3(regPP_CUBIC_FACES_3 *reg, unsigned int face_width_3)
{
  reg->bitfields.FACE_WIDTH_3 = face_width_3;
  if (reg->bitfields.FACE_WIDTH_3 != face_width_3) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_3::FACE_WIDTH_3 data too large\n");
}
__inline void set_PP_CUBIC_FACES_3_face_height_3(regPP_CUBIC_FACES_3 *reg, unsigned int face_height_3)
{
  reg->bitfields.FACE_HEIGHT_3 = face_height_3;
  if (reg->bitfields.FACE_HEIGHT_3 != face_height_3) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_3::FACE_HEIGHT_3 data too large\n");
}
__inline void set_PP_CUBIC_FACES_3_face_width_4(regPP_CUBIC_FACES_3 *reg, unsigned int face_width_4)
{
  reg->bitfields.FACE_WIDTH_4 = face_width_4;
  if (reg->bitfields.FACE_WIDTH_4 != face_width_4) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_3::FACE_WIDTH_4 data too large\n");
}
__inline void set_PP_CUBIC_FACES_3_face_height_4(regPP_CUBIC_FACES_3 *reg, unsigned int face_height_4)
{
  reg->bitfields.FACE_HEIGHT_4 = face_height_4;
  if (reg->bitfields.FACE_HEIGHT_4 != face_height_4) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_3::FACE_HEIGHT_4 data too large\n");
}
#else
#define set_PP_CUBIC_FACES_3_face_width_1(reg, face_width_1) (reg)->bitfields.FACE_WIDTH_1 = face_width_1
#define set_PP_CUBIC_FACES_3_face_height_1(reg, face_height_1) (reg)->bitfields.FACE_HEIGHT_1 = face_height_1
#define set_PP_CUBIC_FACES_3_face_width_2(reg, face_width_2) (reg)->bitfields.FACE_WIDTH_2 = face_width_2
#define set_PP_CUBIC_FACES_3_face_height_2(reg, face_height_2) (reg)->bitfields.FACE_HEIGHT_2 = face_height_2
#define set_PP_CUBIC_FACES_3_face_width_3(reg, face_width_3) (reg)->bitfields.FACE_WIDTH_3 = face_width_3
#define set_PP_CUBIC_FACES_3_face_height_3(reg, face_height_3) (reg)->bitfields.FACE_HEIGHT_3 = face_height_3
#define set_PP_CUBIC_FACES_3_face_width_4(reg, face_width_4) (reg)->bitfields.FACE_WIDTH_4 = face_width_4
#define set_PP_CUBIC_FACES_3_face_height_4(reg, face_height_4) (reg)->bitfields.FACE_HEIGHT_4 = face_height_4

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_FACES_4 regPP_CUBIC_FACES_4;

#ifdef DEBUG
__inline void set_PP_CUBIC_FACES_4_face_width_1(regPP_CUBIC_FACES_4 *reg, unsigned int face_width_1)
{
  reg->bitfields.FACE_WIDTH_1 = face_width_1;
  if (reg->bitfields.FACE_WIDTH_1 != face_width_1) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_4::FACE_WIDTH_1 data too large\n");
}
__inline void set_PP_CUBIC_FACES_4_face_height_1(regPP_CUBIC_FACES_4 *reg, unsigned int face_height_1)
{
  reg->bitfields.FACE_HEIGHT_1 = face_height_1;
  if (reg->bitfields.FACE_HEIGHT_1 != face_height_1) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_4::FACE_HEIGHT_1 data too large\n");
}
__inline void set_PP_CUBIC_FACES_4_face_width_2(regPP_CUBIC_FACES_4 *reg, unsigned int face_width_2)
{
  reg->bitfields.FACE_WIDTH_2 = face_width_2;
  if (reg->bitfields.FACE_WIDTH_2 != face_width_2) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_4::FACE_WIDTH_2 data too large\n");
}
__inline void set_PP_CUBIC_FACES_4_face_height_2(regPP_CUBIC_FACES_4 *reg, unsigned int face_height_2)
{
  reg->bitfields.FACE_HEIGHT_2 = face_height_2;
  if (reg->bitfields.FACE_HEIGHT_2 != face_height_2) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_4::FACE_HEIGHT_2 data too large\n");
}
__inline void set_PP_CUBIC_FACES_4_face_width_3(regPP_CUBIC_FACES_4 *reg, unsigned int face_width_3)
{
  reg->bitfields.FACE_WIDTH_3 = face_width_3;
  if (reg->bitfields.FACE_WIDTH_3 != face_width_3) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_4::FACE_WIDTH_3 data too large\n");
}
__inline void set_PP_CUBIC_FACES_4_face_height_3(regPP_CUBIC_FACES_4 *reg, unsigned int face_height_3)
{
  reg->bitfields.FACE_HEIGHT_3 = face_height_3;
  if (reg->bitfields.FACE_HEIGHT_3 != face_height_3) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_4::FACE_HEIGHT_3 data too large\n");
}
__inline void set_PP_CUBIC_FACES_4_face_width_4(regPP_CUBIC_FACES_4 *reg, unsigned int face_width_4)
{
  reg->bitfields.FACE_WIDTH_4 = face_width_4;
  if (reg->bitfields.FACE_WIDTH_4 != face_width_4) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_4::FACE_WIDTH_4 data too large\n");
}
__inline void set_PP_CUBIC_FACES_4_face_height_4(regPP_CUBIC_FACES_4 *reg, unsigned int face_height_4)
{
  reg->bitfields.FACE_HEIGHT_4 = face_height_4;
  if (reg->bitfields.FACE_HEIGHT_4 != face_height_4) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_4::FACE_HEIGHT_4 data too large\n");
}
#else
#define set_PP_CUBIC_FACES_4_face_width_1(reg, face_width_1) (reg)->bitfields.FACE_WIDTH_1 = face_width_1
#define set_PP_CUBIC_FACES_4_face_height_1(reg, face_height_1) (reg)->bitfields.FACE_HEIGHT_1 = face_height_1
#define set_PP_CUBIC_FACES_4_face_width_2(reg, face_width_2) (reg)->bitfields.FACE_WIDTH_2 = face_width_2
#define set_PP_CUBIC_FACES_4_face_height_2(reg, face_height_2) (reg)->bitfields.FACE_HEIGHT_2 = face_height_2
#define set_PP_CUBIC_FACES_4_face_width_3(reg, face_width_3) (reg)->bitfields.FACE_WIDTH_3 = face_width_3
#define set_PP_CUBIC_FACES_4_face_height_3(reg, face_height_3) (reg)->bitfields.FACE_HEIGHT_3 = face_height_3
#define set_PP_CUBIC_FACES_4_face_width_4(reg, face_width_4) (reg)->bitfields.FACE_WIDTH_4 = face_width_4
#define set_PP_CUBIC_FACES_4_face_height_4(reg, face_height_4) (reg)->bitfields.FACE_HEIGHT_4 = face_height_4

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_FACES_5 regPP_CUBIC_FACES_5;

#ifdef DEBUG
__inline void set_PP_CUBIC_FACES_5_face_width_1(regPP_CUBIC_FACES_5 *reg, unsigned int face_width_1)
{
  reg->bitfields.FACE_WIDTH_1 = face_width_1;
  if (reg->bitfields.FACE_WIDTH_1 != face_width_1) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_5::FACE_WIDTH_1 data too large\n");
}
__inline void set_PP_CUBIC_FACES_5_face_height_1(regPP_CUBIC_FACES_5 *reg, unsigned int face_height_1)
{
  reg->bitfields.FACE_HEIGHT_1 = face_height_1;
  if (reg->bitfields.FACE_HEIGHT_1 != face_height_1) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_5::FACE_HEIGHT_1 data too large\n");
}
__inline void set_PP_CUBIC_FACES_5_face_width_2(regPP_CUBIC_FACES_5 *reg, unsigned int face_width_2)
{
  reg->bitfields.FACE_WIDTH_2 = face_width_2;
  if (reg->bitfields.FACE_WIDTH_2 != face_width_2) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_5::FACE_WIDTH_2 data too large\n");
}
__inline void set_PP_CUBIC_FACES_5_face_height_2(regPP_CUBIC_FACES_5 *reg, unsigned int face_height_2)
{
  reg->bitfields.FACE_HEIGHT_2 = face_height_2;
  if (reg->bitfields.FACE_HEIGHT_2 != face_height_2) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_5::FACE_HEIGHT_2 data too large\n");
}
__inline void set_PP_CUBIC_FACES_5_face_width_3(regPP_CUBIC_FACES_5 *reg, unsigned int face_width_3)
{
  reg->bitfields.FACE_WIDTH_3 = face_width_3;
  if (reg->bitfields.FACE_WIDTH_3 != face_width_3) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_5::FACE_WIDTH_3 data too large\n");
}
__inline void set_PP_CUBIC_FACES_5_face_height_3(regPP_CUBIC_FACES_5 *reg, unsigned int face_height_3)
{
  reg->bitfields.FACE_HEIGHT_3 = face_height_3;
  if (reg->bitfields.FACE_HEIGHT_3 != face_height_3) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_5::FACE_HEIGHT_3 data too large\n");
}
__inline void set_PP_CUBIC_FACES_5_face_width_4(regPP_CUBIC_FACES_5 *reg, unsigned int face_width_4)
{
  reg->bitfields.FACE_WIDTH_4 = face_width_4;
  if (reg->bitfields.FACE_WIDTH_4 != face_width_4) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_5::FACE_WIDTH_4 data too large\n");
}
__inline void set_PP_CUBIC_FACES_5_face_height_4(regPP_CUBIC_FACES_5 *reg, unsigned int face_height_4)
{
  reg->bitfields.FACE_HEIGHT_4 = face_height_4;
  if (reg->bitfields.FACE_HEIGHT_4 != face_height_4) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_FACES_5::FACE_HEIGHT_4 data too large\n");
}
#else
#define set_PP_CUBIC_FACES_5_face_width_1(reg, face_width_1) (reg)->bitfields.FACE_WIDTH_1 = face_width_1
#define set_PP_CUBIC_FACES_5_face_height_1(reg, face_height_1) (reg)->bitfields.FACE_HEIGHT_1 = face_height_1
#define set_PP_CUBIC_FACES_5_face_width_2(reg, face_width_2) (reg)->bitfields.FACE_WIDTH_2 = face_width_2
#define set_PP_CUBIC_FACES_5_face_height_2(reg, face_height_2) (reg)->bitfields.FACE_HEIGHT_2 = face_height_2
#define set_PP_CUBIC_FACES_5_face_width_3(reg, face_width_3) (reg)->bitfields.FACE_WIDTH_3 = face_width_3
#define set_PP_CUBIC_FACES_5_face_height_3(reg, face_height_3) (reg)->bitfields.FACE_HEIGHT_3 = face_height_3
#define set_PP_CUBIC_FACES_5_face_width_4(reg, face_width_4) (reg)->bitfields.FACE_WIDTH_4 = face_width_4
#define set_PP_CUBIC_FACES_5_face_height_4(reg, face_height_4) (reg)->bitfields.FACE_HEIGHT_4 = face_height_4

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXMULTI_CTL_0 regPP_TXMULTI_CTL_0;

#ifdef DEBUG
__inline void set_PP_TXMULTI_CTL_0_lookup_disable_1(regPP_TXMULTI_CTL_0 *reg, unsigned int lookup_disable_1)
{
  reg->bitfields.LOOKUP_DISABLE_1 = lookup_disable_1;
  if (reg->bitfields.LOOKUP_DISABLE_1 != lookup_disable_1) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_0::LOOKUP_DISABLE_1 data too large\n");
}
__inline void set_PP_TXMULTI_CTL_0_tex_coord_type_1(regPP_TXMULTI_CTL_0 *reg, unsigned int tex_coord_type_1)
{
  reg->bitfields.TEX_COORD_TYPE_1 = tex_coord_type_1;
  if (reg->bitfields.TEX_COORD_TYPE_1 != tex_coord_type_1) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_0::TEX_COORD_TYPE_1 data too large\n");
}
__inline void set_PP_TXMULTI_CTL_0_st_route_1(regPP_TXMULTI_CTL_0 *reg, unsigned int st_route_1)
{
  reg->bitfields.ST_ROUTE_1 = st_route_1;
  if (reg->bitfields.ST_ROUTE_1 != st_route_1) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_0::ST_ROUTE_1 data too large\n");
}
__inline void set_PP_TXMULTI_CTL_0_clamp_mode(regPP_TXMULTI_CTL_0 *reg, unsigned int clamp_mode)
{
  reg->bitfields.CLAMP_MODE = clamp_mode;
  if (reg->bitfields.CLAMP_MODE != clamp_mode) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_0::CLAMP_MODE data too large\n");
}
__inline void set_PP_TXMULTI_CTL_0_st_route_2(regPP_TXMULTI_CTL_0 *reg, unsigned int st_route_2)
{
  reg->bitfields.ST_ROUTE_2 = st_route_2;
  if (reg->bitfields.ST_ROUTE_2 != st_route_2) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_0::ST_ROUTE_2 data too large\n");
}
#else
#define set_PP_TXMULTI_CTL_0_lookup_disable_1(reg, lookup_disable_1) (reg)->bitfields.LOOKUP_DISABLE_1 = lookup_disable_1
#define set_PP_TXMULTI_CTL_0_tex_coord_type_1(reg, tex_coord_type_1) (reg)->bitfields.TEX_COORD_TYPE_1 = tex_coord_type_1
#define set_PP_TXMULTI_CTL_0_st_route_1(reg, st_route_1) (reg)->bitfields.ST_ROUTE_1 = st_route_1
#define set_PP_TXMULTI_CTL_0_clamp_mode(reg, clamp_mode) (reg)->bitfields.CLAMP_MODE = clamp_mode
#define set_PP_TXMULTI_CTL_0_st_route_2(reg, st_route_2) (reg)->bitfields.ST_ROUTE_2 = st_route_2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXMULTI_CTL_1 regPP_TXMULTI_CTL_1;

#ifdef DEBUG
__inline void set_PP_TXMULTI_CTL_1_lookup_disable_1(regPP_TXMULTI_CTL_1 *reg, unsigned int lookup_disable_1)
{
  reg->bitfields.LOOKUP_DISABLE_1 = lookup_disable_1;
  if (reg->bitfields.LOOKUP_DISABLE_1 != lookup_disable_1) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_1::LOOKUP_DISABLE_1 data too large\n");
}
__inline void set_PP_TXMULTI_CTL_1_tex_coord_type_1(regPP_TXMULTI_CTL_1 *reg, unsigned int tex_coord_type_1)
{
  reg->bitfields.TEX_COORD_TYPE_1 = tex_coord_type_1;
  if (reg->bitfields.TEX_COORD_TYPE_1 != tex_coord_type_1) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_1::TEX_COORD_TYPE_1 data too large\n");
}
__inline void set_PP_TXMULTI_CTL_1_st_route_1(regPP_TXMULTI_CTL_1 *reg, unsigned int st_route_1)
{
  reg->bitfields.ST_ROUTE_1 = st_route_1;
  if (reg->bitfields.ST_ROUTE_1 != st_route_1) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_1::ST_ROUTE_1 data too large\n");
}
__inline void set_PP_TXMULTI_CTL_1_clamp_mode(regPP_TXMULTI_CTL_1 *reg, unsigned int clamp_mode)
{
  reg->bitfields.CLAMP_MODE = clamp_mode;
  if (reg->bitfields.CLAMP_MODE != clamp_mode) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_1::CLAMP_MODE data too large\n");
}
__inline void set_PP_TXMULTI_CTL_1_st_route_2(regPP_TXMULTI_CTL_1 *reg, unsigned int st_route_2)
{
  reg->bitfields.ST_ROUTE_2 = st_route_2;
  if (reg->bitfields.ST_ROUTE_2 != st_route_2) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_1::ST_ROUTE_2 data too large\n");
}
#else
#define set_PP_TXMULTI_CTL_1_lookup_disable_1(reg, lookup_disable_1) (reg)->bitfields.LOOKUP_DISABLE_1 = lookup_disable_1
#define set_PP_TXMULTI_CTL_1_tex_coord_type_1(reg, tex_coord_type_1) (reg)->bitfields.TEX_COORD_TYPE_1 = tex_coord_type_1
#define set_PP_TXMULTI_CTL_1_st_route_1(reg, st_route_1) (reg)->bitfields.ST_ROUTE_1 = st_route_1
#define set_PP_TXMULTI_CTL_1_clamp_mode(reg, clamp_mode) (reg)->bitfields.CLAMP_MODE = clamp_mode
#define set_PP_TXMULTI_CTL_1_st_route_2(reg, st_route_2) (reg)->bitfields.ST_ROUTE_2 = st_route_2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXMULTI_CTL_2 regPP_TXMULTI_CTL_2;

#ifdef DEBUG
__inline void set_PP_TXMULTI_CTL_2_lookup_disable_1(regPP_TXMULTI_CTL_2 *reg, unsigned int lookup_disable_1)
{
  reg->bitfields.LOOKUP_DISABLE_1 = lookup_disable_1;
  if (reg->bitfields.LOOKUP_DISABLE_1 != lookup_disable_1) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_2::LOOKUP_DISABLE_1 data too large\n");
}
__inline void set_PP_TXMULTI_CTL_2_tex_coord_type_1(regPP_TXMULTI_CTL_2 *reg, unsigned int tex_coord_type_1)
{
  reg->bitfields.TEX_COORD_TYPE_1 = tex_coord_type_1;
  if (reg->bitfields.TEX_COORD_TYPE_1 != tex_coord_type_1) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_2::TEX_COORD_TYPE_1 data too large\n");
}
__inline void set_PP_TXMULTI_CTL_2_st_route_1(regPP_TXMULTI_CTL_2 *reg, unsigned int st_route_1)
{
  reg->bitfields.ST_ROUTE_1 = st_route_1;
  if (reg->bitfields.ST_ROUTE_1 != st_route_1) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_2::ST_ROUTE_1 data too large\n");
}
__inline void set_PP_TXMULTI_CTL_2_clamp_mode(regPP_TXMULTI_CTL_2 *reg, unsigned int clamp_mode)
{
  reg->bitfields.CLAMP_MODE = clamp_mode;
  if (reg->bitfields.CLAMP_MODE != clamp_mode) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_2::CLAMP_MODE data too large\n");
}
__inline void set_PP_TXMULTI_CTL_2_st_route_2(regPP_TXMULTI_CTL_2 *reg, unsigned int st_route_2)
{
  reg->bitfields.ST_ROUTE_2 = st_route_2;
  if (reg->bitfields.ST_ROUTE_2 != st_route_2) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_2::ST_ROUTE_2 data too large\n");
}
#else
#define set_PP_TXMULTI_CTL_2_lookup_disable_1(reg, lookup_disable_1) (reg)->bitfields.LOOKUP_DISABLE_1 = lookup_disable_1
#define set_PP_TXMULTI_CTL_2_tex_coord_type_1(reg, tex_coord_type_1) (reg)->bitfields.TEX_COORD_TYPE_1 = tex_coord_type_1
#define set_PP_TXMULTI_CTL_2_st_route_1(reg, st_route_1) (reg)->bitfields.ST_ROUTE_1 = st_route_1
#define set_PP_TXMULTI_CTL_2_clamp_mode(reg, clamp_mode) (reg)->bitfields.CLAMP_MODE = clamp_mode
#define set_PP_TXMULTI_CTL_2_st_route_2(reg, st_route_2) (reg)->bitfields.ST_ROUTE_2 = st_route_2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXMULTI_CTL_3 regPP_TXMULTI_CTL_3;

#ifdef DEBUG
__inline void set_PP_TXMULTI_CTL_3_lookup_disable_1(regPP_TXMULTI_CTL_3 *reg, unsigned int lookup_disable_1)
{
  reg->bitfields.LOOKUP_DISABLE_1 = lookup_disable_1;
  if (reg->bitfields.LOOKUP_DISABLE_1 != lookup_disable_1) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_3::LOOKUP_DISABLE_1 data too large\n");
}
__inline void set_PP_TXMULTI_CTL_3_tex_coord_type_1(regPP_TXMULTI_CTL_3 *reg, unsigned int tex_coord_type_1)
{
  reg->bitfields.TEX_COORD_TYPE_1 = tex_coord_type_1;
  if (reg->bitfields.TEX_COORD_TYPE_1 != tex_coord_type_1) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_3::TEX_COORD_TYPE_1 data too large\n");
}
__inline void set_PP_TXMULTI_CTL_3_st_route_1(regPP_TXMULTI_CTL_3 *reg, unsigned int st_route_1)
{
  reg->bitfields.ST_ROUTE_1 = st_route_1;
  if (reg->bitfields.ST_ROUTE_1 != st_route_1) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_3::ST_ROUTE_1 data too large\n");
}
__inline void set_PP_TXMULTI_CTL_3_clamp_mode(regPP_TXMULTI_CTL_3 *reg, unsigned int clamp_mode)
{
  reg->bitfields.CLAMP_MODE = clamp_mode;
  if (reg->bitfields.CLAMP_MODE != clamp_mode) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_3::CLAMP_MODE data too large\n");
}
__inline void set_PP_TXMULTI_CTL_3_st_route_2(regPP_TXMULTI_CTL_3 *reg, unsigned int st_route_2)
{
  reg->bitfields.ST_ROUTE_2 = st_route_2;
  if (reg->bitfields.ST_ROUTE_2 != st_route_2) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_3::ST_ROUTE_2 data too large\n");
}
#else
#define set_PP_TXMULTI_CTL_3_lookup_disable_1(reg, lookup_disable_1) (reg)->bitfields.LOOKUP_DISABLE_1 = lookup_disable_1
#define set_PP_TXMULTI_CTL_3_tex_coord_type_1(reg, tex_coord_type_1) (reg)->bitfields.TEX_COORD_TYPE_1 = tex_coord_type_1
#define set_PP_TXMULTI_CTL_3_st_route_1(reg, st_route_1) (reg)->bitfields.ST_ROUTE_1 = st_route_1
#define set_PP_TXMULTI_CTL_3_clamp_mode(reg, clamp_mode) (reg)->bitfields.CLAMP_MODE = clamp_mode
#define set_PP_TXMULTI_CTL_3_st_route_2(reg, st_route_2) (reg)->bitfields.ST_ROUTE_2 = st_route_2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXMULTI_CTL_4 regPP_TXMULTI_CTL_4;

#ifdef DEBUG
__inline void set_PP_TXMULTI_CTL_4_lookup_disable_1(regPP_TXMULTI_CTL_4 *reg, unsigned int lookup_disable_1)
{
  reg->bitfields.LOOKUP_DISABLE_1 = lookup_disable_1;
  if (reg->bitfields.LOOKUP_DISABLE_1 != lookup_disable_1) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_4::LOOKUP_DISABLE_1 data too large\n");
}
__inline void set_PP_TXMULTI_CTL_4_tex_coord_type_1(regPP_TXMULTI_CTL_4 *reg, unsigned int tex_coord_type_1)
{
  reg->bitfields.TEX_COORD_TYPE_1 = tex_coord_type_1;
  if (reg->bitfields.TEX_COORD_TYPE_1 != tex_coord_type_1) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_4::TEX_COORD_TYPE_1 data too large\n");
}
__inline void set_PP_TXMULTI_CTL_4_st_route_1(regPP_TXMULTI_CTL_4 *reg, unsigned int st_route_1)
{
  reg->bitfields.ST_ROUTE_1 = st_route_1;
  if (reg->bitfields.ST_ROUTE_1 != st_route_1) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_4::ST_ROUTE_1 data too large\n");
}
__inline void set_PP_TXMULTI_CTL_4_clamp_mode(regPP_TXMULTI_CTL_4 *reg, unsigned int clamp_mode)
{
  reg->bitfields.CLAMP_MODE = clamp_mode;
  if (reg->bitfields.CLAMP_MODE != clamp_mode) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_4::CLAMP_MODE data too large\n");
}
__inline void set_PP_TXMULTI_CTL_4_st_route_2(regPP_TXMULTI_CTL_4 *reg, unsigned int st_route_2)
{
  reg->bitfields.ST_ROUTE_2 = st_route_2;
  if (reg->bitfields.ST_ROUTE_2 != st_route_2) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_4::ST_ROUTE_2 data too large\n");
}
#else
#define set_PP_TXMULTI_CTL_4_lookup_disable_1(reg, lookup_disable_1) (reg)->bitfields.LOOKUP_DISABLE_1 = lookup_disable_1
#define set_PP_TXMULTI_CTL_4_tex_coord_type_1(reg, tex_coord_type_1) (reg)->bitfields.TEX_COORD_TYPE_1 = tex_coord_type_1
#define set_PP_TXMULTI_CTL_4_st_route_1(reg, st_route_1) (reg)->bitfields.ST_ROUTE_1 = st_route_1
#define set_PP_TXMULTI_CTL_4_clamp_mode(reg, clamp_mode) (reg)->bitfields.CLAMP_MODE = clamp_mode
#define set_PP_TXMULTI_CTL_4_st_route_2(reg, st_route_2) (reg)->bitfields.ST_ROUTE_2 = st_route_2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXMULTI_CTL_5 regPP_TXMULTI_CTL_5;

#ifdef DEBUG
__inline void set_PP_TXMULTI_CTL_5_lookup_disable_1(regPP_TXMULTI_CTL_5 *reg, unsigned int lookup_disable_1)
{
  reg->bitfields.LOOKUP_DISABLE_1 = lookup_disable_1;
  if (reg->bitfields.LOOKUP_DISABLE_1 != lookup_disable_1) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_5::LOOKUP_DISABLE_1 data too large\n");
}
__inline void set_PP_TXMULTI_CTL_5_tex_coord_type_1(regPP_TXMULTI_CTL_5 *reg, unsigned int tex_coord_type_1)
{
  reg->bitfields.TEX_COORD_TYPE_1 = tex_coord_type_1;
  if (reg->bitfields.TEX_COORD_TYPE_1 != tex_coord_type_1) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_5::TEX_COORD_TYPE_1 data too large\n");
}
__inline void set_PP_TXMULTI_CTL_5_st_route_1(regPP_TXMULTI_CTL_5 *reg, unsigned int st_route_1)
{
  reg->bitfields.ST_ROUTE_1 = st_route_1;
  if (reg->bitfields.ST_ROUTE_1 != st_route_1) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_5::ST_ROUTE_1 data too large\n");
}
__inline void set_PP_TXMULTI_CTL_5_clamp_mode(regPP_TXMULTI_CTL_5 *reg, unsigned int clamp_mode)
{
  reg->bitfields.CLAMP_MODE = clamp_mode;
  if (reg->bitfields.CLAMP_MODE != clamp_mode) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_5::CLAMP_MODE data too large\n");
}
__inline void set_PP_TXMULTI_CTL_5_st_route_2(regPP_TXMULTI_CTL_5 *reg, unsigned int st_route_2)
{
  reg->bitfields.ST_ROUTE_2 = st_route_2;
  if (reg->bitfields.ST_ROUTE_2 != st_route_2) HSLDPF(E_ERROR_MESSAGE,"PP_TXMULTI_CTL_5::ST_ROUTE_2 data too large\n");
}
#else
#define set_PP_TXMULTI_CTL_5_lookup_disable_1(reg, lookup_disable_1) (reg)->bitfields.LOOKUP_DISABLE_1 = lookup_disable_1
#define set_PP_TXMULTI_CTL_5_tex_coord_type_1(reg, tex_coord_type_1) (reg)->bitfields.TEX_COORD_TYPE_1 = tex_coord_type_1
#define set_PP_TXMULTI_CTL_5_st_route_1(reg, st_route_1) (reg)->bitfields.ST_ROUTE_1 = st_route_1
#define set_PP_TXMULTI_CTL_5_clamp_mode(reg, clamp_mode) (reg)->bitfields.CLAMP_MODE = clamp_mode
#define set_PP_TXMULTI_CTL_5_st_route_2(reg, st_route_2) (reg)->bitfields.ST_ROUTE_2 = st_route_2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CNTL regPP_CNTL;

#ifdef DEBUG
__inline void set_PP_CNTL_tex_0_enable(regPP_CNTL *reg, unsigned int tex_0_enable)
{
  reg->bitfields.TEX_0_ENABLE = tex_0_enable;
  if (reg->bitfields.TEX_0_ENABLE != tex_0_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL::TEX_0_ENABLE data too large\n");
}
__inline void set_PP_CNTL_tex_1_enable(regPP_CNTL *reg, unsigned int tex_1_enable)
{
  reg->bitfields.TEX_1_ENABLE = tex_1_enable;
  if (reg->bitfields.TEX_1_ENABLE != tex_1_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL::TEX_1_ENABLE data too large\n");
}
__inline void set_PP_CNTL_tex_2_enable(regPP_CNTL *reg, unsigned int tex_2_enable)
{
  reg->bitfields.TEX_2_ENABLE = tex_2_enable;
  if (reg->bitfields.TEX_2_ENABLE != tex_2_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL::TEX_2_ENABLE data too large\n");
}
__inline void set_PP_CNTL_tex_3_enable(regPP_CNTL *reg, unsigned int tex_3_enable)
{
  reg->bitfields.TEX_3_ENABLE = tex_3_enable;
  if (reg->bitfields.TEX_3_ENABLE != tex_3_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL::TEX_3_ENABLE data too large\n");
}
__inline void set_PP_CNTL_tex_4_enable(regPP_CNTL *reg, unsigned int tex_4_enable)
{
  reg->bitfields.TEX_4_ENABLE = tex_4_enable;
  if (reg->bitfields.TEX_4_ENABLE != tex_4_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL::TEX_4_ENABLE data too large\n");
}
__inline void set_PP_CNTL_tex_5_enable(regPP_CNTL *reg, unsigned int tex_5_enable)
{
  reg->bitfields.TEX_5_ENABLE = tex_5_enable;
  if (reg->bitfields.TEX_5_ENABLE != tex_5_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL::TEX_5_ENABLE data too large\n");
}
__inline void set_PP_CNTL_filter_round_mode(regPP_CNTL *reg, unsigned int filter_round_mode)
{
  reg->bitfields.FILTER_ROUND_MODE = filter_round_mode;
  if (reg->bitfields.FILTER_ROUND_MODE != filter_round_mode) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL::FILTER_ROUND_MODE data too large\n");
}
__inline void set_PP_CNTL_tex_blend_7_enable(regPP_CNTL *reg, unsigned int tex_blend_7_enable)
{
  reg->bitfields.TEX_BLEND_7_ENABLE = tex_blend_7_enable;
  if (reg->bitfields.TEX_BLEND_7_ENABLE != tex_blend_7_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL::TEX_BLEND_7_ENABLE data too large\n");
}
__inline void set_PP_CNTL_tex_blend_0_enable(regPP_CNTL *reg, unsigned int tex_blend_0_enable)
{
  reg->bitfields.TEX_BLEND_0_ENABLE = tex_blend_0_enable;
  if (reg->bitfields.TEX_BLEND_0_ENABLE != tex_blend_0_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL::TEX_BLEND_0_ENABLE data too large\n");
}
__inline void set_PP_CNTL_tex_blend_1_enable(regPP_CNTL *reg, unsigned int tex_blend_1_enable)
{
  reg->bitfields.TEX_BLEND_1_ENABLE = tex_blend_1_enable;
  if (reg->bitfields.TEX_BLEND_1_ENABLE != tex_blend_1_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL::TEX_BLEND_1_ENABLE data too large\n");
}
__inline void set_PP_CNTL_tex_blend_2_enable(regPP_CNTL *reg, unsigned int tex_blend_2_enable)
{
  reg->bitfields.TEX_BLEND_2_ENABLE = tex_blend_2_enable;
  if (reg->bitfields.TEX_BLEND_2_ENABLE != tex_blend_2_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL::TEX_BLEND_2_ENABLE data too large\n");
}
__inline void set_PP_CNTL_tex_blend_3_enable(regPP_CNTL *reg, unsigned int tex_blend_3_enable)
{
  reg->bitfields.TEX_BLEND_3_ENABLE = tex_blend_3_enable;
  if (reg->bitfields.TEX_BLEND_3_ENABLE != tex_blend_3_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL::TEX_BLEND_3_ENABLE data too large\n");
}
__inline void set_PP_CNTL_tex_blend_4_enable(regPP_CNTL *reg, unsigned int tex_blend_4_enable)
{
  reg->bitfields.TEX_BLEND_4_ENABLE = tex_blend_4_enable;
  if (reg->bitfields.TEX_BLEND_4_ENABLE != tex_blend_4_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL::TEX_BLEND_4_ENABLE data too large\n");
}
__inline void set_PP_CNTL_tex_blend_5_enable(regPP_CNTL *reg, unsigned int tex_blend_5_enable)
{
  reg->bitfields.TEX_BLEND_5_ENABLE = tex_blend_5_enable;
  if (reg->bitfields.TEX_BLEND_5_ENABLE != tex_blend_5_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL::TEX_BLEND_5_ENABLE data too large\n");
}
__inline void set_PP_CNTL_tex_blend_6_enable(regPP_CNTL *reg, unsigned int tex_blend_6_enable)
{
  reg->bitfields.TEX_BLEND_6_ENABLE = tex_blend_6_enable;
  if (reg->bitfields.TEX_BLEND_6_ENABLE != tex_blend_6_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL::TEX_BLEND_6_ENABLE data too large\n");
}
__inline void set_PP_CNTL_multi_pass_enable(regPP_CNTL *reg, unsigned int multi_pass_enable)
{
  reg->bitfields.MULTI_PASS_ENABLE = multi_pass_enable;
  if (reg->bitfields.MULTI_PASS_ENABLE != multi_pass_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL::MULTI_PASS_ENABLE data too large\n");
}
__inline void set_PP_CNTL_specular_enable(regPP_CNTL *reg, unsigned int specular_enable)
{
  reg->bitfields.SPECULAR_ENABLE = specular_enable;
  if (reg->bitfields.SPECULAR_ENABLE != specular_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL::SPECULAR_ENABLE data too large\n");
}
__inline void set_PP_CNTL_fog_enable(regPP_CNTL *reg, unsigned int fog_enable)
{
  reg->bitfields.FOG_ENABLE = fog_enable;
  if (reg->bitfields.FOG_ENABLE != fog_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL::FOG_ENABLE data too large\n");
}
__inline void set_PP_CNTL_alpha_test_enable(regPP_CNTL *reg, unsigned int alpha_test_enable)
{
  reg->bitfields.ALPHA_TEST_ENABLE = alpha_test_enable;
  if (reg->bitfields.ALPHA_TEST_ENABLE != alpha_test_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL::ALPHA_TEST_ENABLE data too large\n");
}
__inline void set_PP_CNTL_anti_alias_ctl(regPP_CNTL *reg, unsigned int anti_alias_ctl)
{
  reg->bitfields.ANTI_ALIAS_CTL = anti_alias_ctl;
  if (reg->bitfields.ANTI_ALIAS_CTL != anti_alias_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL::ANTI_ALIAS_CTL data too large\n");
}
__inline void set_PP_CNTL_mc_enable(regPP_CNTL *reg, unsigned int mc_enable)
{
  reg->bitfields.MC_ENABLE = mc_enable;
  if (reg->bitfields.MC_ENABLE != mc_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL::MC_ENABLE data too large\n");
}
#else
#define set_PP_CNTL_tex_0_enable(reg, tex_0_enable) (reg)->bitfields.TEX_0_ENABLE = tex_0_enable
#define set_PP_CNTL_tex_1_enable(reg, tex_1_enable) (reg)->bitfields.TEX_1_ENABLE = tex_1_enable
#define set_PP_CNTL_tex_2_enable(reg, tex_2_enable) (reg)->bitfields.TEX_2_ENABLE = tex_2_enable
#define set_PP_CNTL_tex_3_enable(reg, tex_3_enable) (reg)->bitfields.TEX_3_ENABLE = tex_3_enable
#define set_PP_CNTL_tex_4_enable(reg, tex_4_enable) (reg)->bitfields.TEX_4_ENABLE = tex_4_enable
#define set_PP_CNTL_tex_5_enable(reg, tex_5_enable) (reg)->bitfields.TEX_5_ENABLE = tex_5_enable
#define set_PP_CNTL_filter_round_mode(reg, filter_round_mode) (reg)->bitfields.FILTER_ROUND_MODE = filter_round_mode
#define set_PP_CNTL_tex_blend_7_enable(reg, tex_blend_7_enable) (reg)->bitfields.TEX_BLEND_7_ENABLE = tex_blend_7_enable
#define set_PP_CNTL_tex_blend_0_enable(reg, tex_blend_0_enable) (reg)->bitfields.TEX_BLEND_0_ENABLE = tex_blend_0_enable
#define set_PP_CNTL_tex_blend_1_enable(reg, tex_blend_1_enable) (reg)->bitfields.TEX_BLEND_1_ENABLE = tex_blend_1_enable
#define set_PP_CNTL_tex_blend_2_enable(reg, tex_blend_2_enable) (reg)->bitfields.TEX_BLEND_2_ENABLE = tex_blend_2_enable
#define set_PP_CNTL_tex_blend_3_enable(reg, tex_blend_3_enable) (reg)->bitfields.TEX_BLEND_3_ENABLE = tex_blend_3_enable
#define set_PP_CNTL_tex_blend_4_enable(reg, tex_blend_4_enable) (reg)->bitfields.TEX_BLEND_4_ENABLE = tex_blend_4_enable
#define set_PP_CNTL_tex_blend_5_enable(reg, tex_blend_5_enable) (reg)->bitfields.TEX_BLEND_5_ENABLE = tex_blend_5_enable
#define set_PP_CNTL_tex_blend_6_enable(reg, tex_blend_6_enable) (reg)->bitfields.TEX_BLEND_6_ENABLE = tex_blend_6_enable
#define set_PP_CNTL_multi_pass_enable(reg, multi_pass_enable) (reg)->bitfields.MULTI_PASS_ENABLE = multi_pass_enable
#define set_PP_CNTL_specular_enable(reg, specular_enable) (reg)->bitfields.SPECULAR_ENABLE = specular_enable
#define set_PP_CNTL_fog_enable(reg, fog_enable) (reg)->bitfields.FOG_ENABLE = fog_enable
#define set_PP_CNTL_alpha_test_enable(reg, alpha_test_enable) (reg)->bitfields.ALPHA_TEST_ENABLE = alpha_test_enable
#define set_PP_CNTL_anti_alias_ctl(reg, anti_alias_ctl) (reg)->bitfields.ANTI_ALIAS_CTL = anti_alias_ctl
#define set_PP_CNTL_mc_enable(reg, mc_enable) (reg)->bitfields.MC_ENABLE = mc_enable

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CNTL_X regPP_CNTL_X;

#ifdef DEBUG
__inline void set_PP_CNTL_X_tex_0_enable_pass_1(regPP_CNTL_X *reg, unsigned int tex_0_enable_pass_1)
{
  reg->bitfields.TEX_0_ENABLE_PASS_1 = tex_0_enable_pass_1;
  if (reg->bitfields.TEX_0_ENABLE_PASS_1 != tex_0_enable_pass_1) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL_X::TEX_0_ENABLE_PASS_1 data too large\n");
}
__inline void set_PP_CNTL_X_tex_1_enable_pass_1(regPP_CNTL_X *reg, unsigned int tex_1_enable_pass_1)
{
  reg->bitfields.TEX_1_ENABLE_PASS_1 = tex_1_enable_pass_1;
  if (reg->bitfields.TEX_1_ENABLE_PASS_1 != tex_1_enable_pass_1) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL_X::TEX_1_ENABLE_PASS_1 data too large\n");
}
__inline void set_PP_CNTL_X_tex_2_enable_pass_1(regPP_CNTL_X *reg, unsigned int tex_2_enable_pass_1)
{
  reg->bitfields.TEX_2_ENABLE_PASS_1 = tex_2_enable_pass_1;
  if (reg->bitfields.TEX_2_ENABLE_PASS_1 != tex_2_enable_pass_1) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL_X::TEX_2_ENABLE_PASS_1 data too large\n");
}
__inline void set_PP_CNTL_X_tex_3_enable_pass_1(regPP_CNTL_X *reg, unsigned int tex_3_enable_pass_1)
{
  reg->bitfields.TEX_3_ENABLE_PASS_1 = tex_3_enable_pass_1;
  if (reg->bitfields.TEX_3_ENABLE_PASS_1 != tex_3_enable_pass_1) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL_X::TEX_3_ENABLE_PASS_1 data too large\n");
}
__inline void set_PP_CNTL_X_tex_4_enable_pass_1(regPP_CNTL_X *reg, unsigned int tex_4_enable_pass_1)
{
  reg->bitfields.TEX_4_ENABLE_PASS_1 = tex_4_enable_pass_1;
  if (reg->bitfields.TEX_4_ENABLE_PASS_1 != tex_4_enable_pass_1) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL_X::TEX_4_ENABLE_PASS_1 data too large\n");
}
__inline void set_PP_CNTL_X_tex_5_enable_pass_1(regPP_CNTL_X *reg, unsigned int tex_5_enable_pass_1)
{
  reg->bitfields.TEX_5_ENABLE_PASS_1 = tex_5_enable_pass_1;
  if (reg->bitfields.TEX_5_ENABLE_PASS_1 != tex_5_enable_pass_1) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL_X::TEX_5_ENABLE_PASS_1 data too large\n");
}
__inline void set_PP_CNTL_X_indirect_regs(regPP_CNTL_X *reg, unsigned int indirect_regs)
{
  reg->bitfields.INDIRECT_REGS = indirect_regs;
  if (reg->bitfields.INDIRECT_REGS != indirect_regs) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL_X::INDIRECT_REGS data too large\n");
}
__inline void set_PP_CNTL_X_tex_blend_a0_enable(regPP_CNTL_X *reg, unsigned int tex_blend_a0_enable)
{
  reg->bitfields.TEX_BLEND_A0_ENABLE = tex_blend_a0_enable;
  if (reg->bitfields.TEX_BLEND_A0_ENABLE != tex_blend_a0_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL_X::TEX_BLEND_A0_ENABLE data too large\n");
}
__inline void set_PP_CNTL_X_tex_blend_a1_enable(regPP_CNTL_X *reg, unsigned int tex_blend_a1_enable)
{
  reg->bitfields.TEX_BLEND_A1_ENABLE = tex_blend_a1_enable;
  if (reg->bitfields.TEX_BLEND_A1_ENABLE != tex_blend_a1_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL_X::TEX_BLEND_A1_ENABLE data too large\n");
}
__inline void set_PP_CNTL_X_tex_blend_a2_enable(regPP_CNTL_X *reg, unsigned int tex_blend_a2_enable)
{
  reg->bitfields.TEX_BLEND_A2_ENABLE = tex_blend_a2_enable;
  if (reg->bitfields.TEX_BLEND_A2_ENABLE != tex_blend_a2_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL_X::TEX_BLEND_A2_ENABLE data too large\n");
}
__inline void set_PP_CNTL_X_tex_blend_a3_enable(regPP_CNTL_X *reg, unsigned int tex_blend_a3_enable)
{
  reg->bitfields.TEX_BLEND_A3_ENABLE = tex_blend_a3_enable;
  if (reg->bitfields.TEX_BLEND_A3_ENABLE != tex_blend_a3_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL_X::TEX_BLEND_A3_ENABLE data too large\n");
}
__inline void set_PP_CNTL_X_tex_blend_a4_enable(regPP_CNTL_X *reg, unsigned int tex_blend_a4_enable)
{
  reg->bitfields.TEX_BLEND_A4_ENABLE = tex_blend_a4_enable;
  if (reg->bitfields.TEX_BLEND_A4_ENABLE != tex_blend_a4_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL_X::TEX_BLEND_A4_ENABLE data too large\n");
}
__inline void set_PP_CNTL_X_tex_blend_a5_enable(regPP_CNTL_X *reg, unsigned int tex_blend_a5_enable)
{
  reg->bitfields.TEX_BLEND_A5_ENABLE = tex_blend_a5_enable;
  if (reg->bitfields.TEX_BLEND_A5_ENABLE != tex_blend_a5_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL_X::TEX_BLEND_A5_ENABLE data too large\n");
}
__inline void set_PP_CNTL_X_tex_blend_a6_enable(regPP_CNTL_X *reg, unsigned int tex_blend_a6_enable)
{
  reg->bitfields.TEX_BLEND_A6_ENABLE = tex_blend_a6_enable;
  if (reg->bitfields.TEX_BLEND_A6_ENABLE != tex_blend_a6_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL_X::TEX_BLEND_A6_ENABLE data too large\n");
}
__inline void set_PP_CNTL_X_tex_blend_a7_enable(regPP_CNTL_X *reg, unsigned int tex_blend_a7_enable)
{
  reg->bitfields.TEX_BLEND_A7_ENABLE = tex_blend_a7_enable;
  if (reg->bitfields.TEX_BLEND_A7_ENABLE != tex_blend_a7_enable) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL_X::TEX_BLEND_A7_ENABLE data too large\n");
}
__inline void set_PP_CNTL_X_shader_output_cntl(regPP_CNTL_X *reg, unsigned int shader_output_cntl)
{
  reg->bitfields.SHADER_OUTPUT_CNTL = shader_output_cntl;
  if (reg->bitfields.SHADER_OUTPUT_CNTL != shader_output_cntl) HSLDPF(E_ERROR_MESSAGE,"PP_CNTL_X::SHADER_OUTPUT_CNTL data too large\n");
}
#else
#define set_PP_CNTL_X_tex_0_enable_pass_1(reg, tex_0_enable_pass_1) (reg)->bitfields.TEX_0_ENABLE_PASS_1 = tex_0_enable_pass_1
#define set_PP_CNTL_X_tex_1_enable_pass_1(reg, tex_1_enable_pass_1) (reg)->bitfields.TEX_1_ENABLE_PASS_1 = tex_1_enable_pass_1
#define set_PP_CNTL_X_tex_2_enable_pass_1(reg, tex_2_enable_pass_1) (reg)->bitfields.TEX_2_ENABLE_PASS_1 = tex_2_enable_pass_1
#define set_PP_CNTL_X_tex_3_enable_pass_1(reg, tex_3_enable_pass_1) (reg)->bitfields.TEX_3_ENABLE_PASS_1 = tex_3_enable_pass_1
#define set_PP_CNTL_X_tex_4_enable_pass_1(reg, tex_4_enable_pass_1) (reg)->bitfields.TEX_4_ENABLE_PASS_1 = tex_4_enable_pass_1
#define set_PP_CNTL_X_tex_5_enable_pass_1(reg, tex_5_enable_pass_1) (reg)->bitfields.TEX_5_ENABLE_PASS_1 = tex_5_enable_pass_1
#define set_PP_CNTL_X_indirect_regs(reg, indirect_regs) (reg)->bitfields.INDIRECT_REGS = indirect_regs
#define set_PP_CNTL_X_tex_blend_a0_enable(reg, tex_blend_a0_enable) (reg)->bitfields.TEX_BLEND_A0_ENABLE = tex_blend_a0_enable
#define set_PP_CNTL_X_tex_blend_a1_enable(reg, tex_blend_a1_enable) (reg)->bitfields.TEX_BLEND_A1_ENABLE = tex_blend_a1_enable
#define set_PP_CNTL_X_tex_blend_a2_enable(reg, tex_blend_a2_enable) (reg)->bitfields.TEX_BLEND_A2_ENABLE = tex_blend_a2_enable
#define set_PP_CNTL_X_tex_blend_a3_enable(reg, tex_blend_a3_enable) (reg)->bitfields.TEX_BLEND_A3_ENABLE = tex_blend_a3_enable
#define set_PP_CNTL_X_tex_blend_a4_enable(reg, tex_blend_a4_enable) (reg)->bitfields.TEX_BLEND_A4_ENABLE = tex_blend_a4_enable
#define set_PP_CNTL_X_tex_blend_a5_enable(reg, tex_blend_a5_enable) (reg)->bitfields.TEX_BLEND_A5_ENABLE = tex_blend_a5_enable
#define set_PP_CNTL_X_tex_blend_a6_enable(reg, tex_blend_a6_enable) (reg)->bitfields.TEX_BLEND_A6_ENABLE = tex_blend_a6_enable
#define set_PP_CNTL_X_tex_blend_a7_enable(reg, tex_blend_a7_enable) (reg)->bitfields.TEX_BLEND_A7_ENABLE = tex_blend_a7_enable
#define set_PP_CNTL_X_shader_output_cntl(reg, shader_output_cntl) (reg)->bitfields.SHADER_OUTPUT_CNTL = shader_output_cntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_MISC regPP_MISC;

#ifdef DEBUG
__inline void set_PP_MISC_ref_alpha(regPP_MISC *reg, unsigned int ref_alpha)
{
  reg->bitfields.REF_ALPHA = ref_alpha;
  if (reg->bitfields.REF_ALPHA != ref_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_MISC::REF_ALPHA data too large\n");
}
__inline void set_PP_MISC_alpha_test_op(regPP_MISC *reg, unsigned int alpha_test_op)
{
  reg->bitfields.ALPHA_TEST_OP = alpha_test_op;
  if (reg->bitfields.ALPHA_TEST_OP != alpha_test_op) HSLDPF(E_ERROR_MESSAGE,"PP_MISC::ALPHA_TEST_OP data too large\n");
}
__inline void set_PP_MISC_chroma_func(regPP_MISC *reg, unsigned int chroma_func)
{
  reg->bitfields.CHROMA_FUNC = chroma_func;
  if (reg->bitfields.CHROMA_FUNC != chroma_func) HSLDPF(E_ERROR_MESSAGE,"PP_MISC::CHROMA_FUNC data too large\n");
}
__inline void set_PP_MISC_chroma_key_mode(regPP_MISC *reg, unsigned int chroma_key_mode)
{
  reg->bitfields.CHROMA_KEY_MODE = chroma_key_mode;
  if (reg->bitfields.CHROMA_KEY_MODE != chroma_key_mode) HSLDPF(E_ERROR_MESSAGE,"PP_MISC::CHROMA_KEY_MODE data too large\n");
}
__inline void set_PP_MISC_right_hand_cube(regPP_MISC *reg, unsigned int right_hand_cube)
{
  reg->bitfields.RIGHT_HAND_CUBE = right_hand_cube;
  if (reg->bitfields.RIGHT_HAND_CUBE != right_hand_cube) HSLDPF(E_ERROR_MESSAGE,"PP_MISC::RIGHT_HAND_CUBE data too large\n");
}
#else
#define set_PP_MISC_ref_alpha(reg, ref_alpha) (reg)->bitfields.REF_ALPHA = ref_alpha
#define set_PP_MISC_alpha_test_op(reg, alpha_test_op) (reg)->bitfields.ALPHA_TEST_OP = alpha_test_op
#define set_PP_MISC_chroma_func(reg, chroma_func) (reg)->bitfields.CHROMA_FUNC = chroma_func
#define set_PP_MISC_chroma_key_mode(reg, chroma_key_mode) (reg)->bitfields.CHROMA_KEY_MODE = chroma_key_mode
#define set_PP_MISC_right_hand_cube(reg, right_hand_cube) (reg)->bitfields.RIGHT_HAND_CUBE = right_hand_cube

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CHROMA_COLOR regPP_CHROMA_COLOR;

#ifdef DEBUG
__inline void set_PP_CHROMA_COLOR_chroma_color(regPP_CHROMA_COLOR *reg, unsigned int chroma_color)
{
  reg->bitfields.CHROMA_COLOR = chroma_color;
  if (reg->bitfields.CHROMA_COLOR != chroma_color) HSLDPF(E_ERROR_MESSAGE,"PP_CHROMA_COLOR::CHROMA_COLOR data too large\n");
}
#else
#define set_PP_CHROMA_COLOR_chroma_color(reg, chroma_color) (reg)->bitfields.CHROMA_COLOR = chroma_color

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CHROMA_MASK regPP_CHROMA_MASK;

#ifdef DEBUG
__inline void set_PP_CHROMA_MASK_chroma_mask(regPP_CHROMA_MASK *reg, unsigned int chroma_mask)
{
  reg->bitfields.CHROMA_MASK = chroma_mask;
  if (reg->bitfields.CHROMA_MASK != chroma_mask) HSLDPF(E_ERROR_MESSAGE,"PP_CHROMA_MASK::CHROMA_MASK data too large\n");
}
#else
#define set_PP_CHROMA_MASK_chroma_mask(reg, chroma_mask) (reg)->bitfields.CHROMA_MASK = chroma_mask

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_FOG_COLOR regPP_FOG_COLOR;

#ifdef DEBUG
__inline void set_PP_FOG_COLOR_fog_color(regPP_FOG_COLOR *reg, unsigned int fog_color)
{
  reg->bitfields.FOG_COLOR = fog_color;
  if (reg->bitfields.FOG_COLOR != fog_color) HSLDPF(E_ERROR_MESSAGE,"PP_FOG_COLOR::FOG_COLOR data too large\n");
}
__inline void set_PP_FOG_COLOR_fog_table(regPP_FOG_COLOR *reg, unsigned int fog_table)
{
  reg->bitfields.FOG_TABLE = fog_table;
  if (reg->bitfields.FOG_TABLE != fog_table) HSLDPF(E_ERROR_MESSAGE,"PP_FOG_COLOR::FOG_TABLE data too large\n");
}
__inline void set_PP_FOG_COLOR_fog_index_sel_r2(regPP_FOG_COLOR *reg, unsigned int fog_index_sel_r2)
{
  reg->bitfields.FOG_INDEX_SEL_R2 = fog_index_sel_r2;
  if (reg->bitfields.FOG_INDEX_SEL_R2 != fog_index_sel_r2) HSLDPF(E_ERROR_MESSAGE,"PP_FOG_COLOR::FOG_INDEX_SEL_R2 data too large\n");
}
#else
#define set_PP_FOG_COLOR_fog_color(reg, fog_color) (reg)->bitfields.FOG_COLOR = fog_color
#define set_PP_FOG_COLOR_fog_table(reg, fog_table) (reg)->bitfields.FOG_TABLE = fog_table
#define set_PP_FOG_COLOR_fog_index_sel_r2(reg, fog_index_sel_r2) (reg)->bitfields.FOG_INDEX_SEL_R2 = fog_index_sel_r2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PERF_COUNT0 regPP_PERF_COUNT0;

#ifdef DEBUG
__inline void set_PP_PERF_COUNT0_pp_cache_count(regPP_PERF_COUNT0 *reg, unsigned int pp_cache_count)
{
  reg->bitfields.PP_CACHE_COUNT = pp_cache_count;
  if (reg->bitfields.PP_CACHE_COUNT != pp_cache_count) HSLDPF(E_ERROR_MESSAGE,"PP_PERF_COUNT0::PP_CACHE_COUNT data too large\n");
}
#else
#define set_PP_PERF_COUNT0_pp_cache_count(reg, pp_cache_count) (reg)->bitfields.PP_CACHE_COUNT = pp_cache_count

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PERF_COUNT1 regPP_PERF_COUNT1;

#ifdef DEBUG
__inline void set_PP_PERF_COUNT1_pp_cache_count(regPP_PERF_COUNT1 *reg, unsigned int pp_cache_count)
{
  reg->bitfields.PP_CACHE_COUNT = pp_cache_count;
  if (reg->bitfields.PP_CACHE_COUNT != pp_cache_count) HSLDPF(E_ERROR_MESSAGE,"PP_PERF_COUNT1::PP_CACHE_COUNT data too large\n");
}
#else
#define set_PP_PERF_COUNT1_pp_cache_count(reg, pp_cache_count) (reg)->bitfields.PP_CACHE_COUNT = pp_cache_count

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PERF_COUNT2 regPP_PERF_COUNT2;

#ifdef DEBUG
__inline void set_PP_PERF_COUNT2_pp_cache_count(regPP_PERF_COUNT2 *reg, unsigned int pp_cache_count)
{
  reg->bitfields.PP_CACHE_COUNT = pp_cache_count;
  if (reg->bitfields.PP_CACHE_COUNT != pp_cache_count) HSLDPF(E_ERROR_MESSAGE,"PP_PERF_COUNT2::PP_CACHE_COUNT data too large\n");
}
#else
#define set_PP_PERF_COUNT2_pp_cache_count(reg, pp_cache_count) (reg)->bitfields.PP_CACHE_COUNT = pp_cache_count

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_MC_CONTEXT regPP_MC_CONTEXT;

#ifdef DEBUG
__inline void set_PP_MC_CONTEXT_mc_buf_base(regPP_MC_CONTEXT *reg, unsigned int mc_buf_base)
{
  reg->bitfields.MC_BUF_BASE = mc_buf_base;
  if (reg->bitfields.MC_BUF_BASE != mc_buf_base) HSLDPF(E_ERROR_MESSAGE,"PP_MC_CONTEXT::MC_BUF_BASE data too large\n");
}
__inline void set_PP_MC_CONTEXT_src1_index(regPP_MC_CONTEXT *reg, unsigned int src1_index)
{
  reg->bitfields.SRC1_INDEX = src1_index;
  if (reg->bitfields.SRC1_INDEX != src1_index) HSLDPF(E_ERROR_MESSAGE,"PP_MC_CONTEXT::SRC1_INDEX data too large\n");
}
__inline void set_PP_MC_CONTEXT_src2_index(regPP_MC_CONTEXT *reg, unsigned int src2_index)
{
  reg->bitfields.SRC2_INDEX = src2_index;
  if (reg->bitfields.SRC2_INDEX != src2_index) HSLDPF(E_ERROR_MESSAGE,"PP_MC_CONTEXT::SRC2_INDEX data too large\n");
}
__inline void set_PP_MC_CONTEXT_mc_func(regPP_MC_CONTEXT *reg, unsigned int mc_func)
{
  reg->bitfields.MC_FUNC = mc_func;
  if (reg->bitfields.MC_FUNC != mc_func) HSLDPF(E_ERROR_MESSAGE,"PP_MC_CONTEXT::MC_FUNC data too large\n");
}
__inline void set_PP_MC_CONTEXT_dst_pitch_mul(regPP_MC_CONTEXT *reg, unsigned int dst_pitch_mul)
{
  reg->bitfields.DST_PITCH_MUL = dst_pitch_mul;
  if (reg->bitfields.DST_PITCH_MUL != dst_pitch_mul) HSLDPF(E_ERROR_MESSAGE,"PP_MC_CONTEXT::DST_PITCH_MUL data too large\n");
}
__inline void set_PP_MC_CONTEXT_src_2_pitch_mul(regPP_MC_CONTEXT *reg, unsigned int src_2_pitch_mul)
{
  reg->bitfields.SRC_2_PITCH_MUL = src_2_pitch_mul;
  if (reg->bitfields.SRC_2_PITCH_MUL != src_2_pitch_mul) HSLDPF(E_ERROR_MESSAGE,"PP_MC_CONTEXT::SRC_2_PITCH_MUL data too large\n");
}
__inline void set_PP_MC_CONTEXT_src_1_pitch_mul(regPP_MC_CONTEXT *reg, unsigned int src_1_pitch_mul)
{
  reg->bitfields.SRC_1_PITCH_MUL = src_1_pitch_mul;
  if (reg->bitfields.SRC_1_PITCH_MUL != src_1_pitch_mul) HSLDPF(E_ERROR_MESSAGE,"PP_MC_CONTEXT::SRC_1_PITCH_MUL data too large\n");
}
__inline void set_PP_MC_CONTEXT_mc_cntl_width_height_sel(regPP_MC_CONTEXT *reg, unsigned int mc_cntl_width_height_sel)
{
  reg->bitfields.MC_CNTL_WIDTH_HEIGHT_SEL = mc_cntl_width_height_sel;
  if (reg->bitfields.MC_CNTL_WIDTH_HEIGHT_SEL != mc_cntl_width_height_sel) HSLDPF(E_ERROR_MESSAGE,"PP_MC_CONTEXT::MC_CNTL_WIDTH_HEIGHT_SEL data too large\n");
}
#else
#define set_PP_MC_CONTEXT_mc_buf_base(reg, mc_buf_base) (reg)->bitfields.MC_BUF_BASE = mc_buf_base
#define set_PP_MC_CONTEXT_src1_index(reg, src1_index) (reg)->bitfields.SRC1_INDEX = src1_index
#define set_PP_MC_CONTEXT_src2_index(reg, src2_index) (reg)->bitfields.SRC2_INDEX = src2_index
#define set_PP_MC_CONTEXT_mc_func(reg, mc_func) (reg)->bitfields.MC_FUNC = mc_func
#define set_PP_MC_CONTEXT_dst_pitch_mul(reg, dst_pitch_mul) (reg)->bitfields.DST_PITCH_MUL = dst_pitch_mul
#define set_PP_MC_CONTEXT_src_2_pitch_mul(reg, src_2_pitch_mul) (reg)->bitfields.SRC_2_PITCH_MUL = src_2_pitch_mul
#define set_PP_MC_CONTEXT_src_1_pitch_mul(reg, src_1_pitch_mul) (reg)->bitfields.SRC_1_PITCH_MUL = src_1_pitch_mul
#define set_PP_MC_CONTEXT_mc_cntl_width_height_sel(reg, mc_cntl_width_height_sel) (reg)->bitfields.MC_CNTL_WIDTH_HEIGHT_SEL = mc_cntl_width_height_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_LUMI_MATRIX regPP_LUMI_MATRIX;

#ifdef DEBUG
__inline void set_PP_LUMI_MATRIX_lscale(regPP_LUMI_MATRIX *reg, unsigned int lscale)
{
  reg->bitfields.LSCALE = lscale;
  if (reg->bitfields.LSCALE != lscale) HSLDPF(E_ERROR_MESSAGE,"PP_LUMI_MATRIX::LSCALE data too large\n");
}
__inline void set_PP_LUMI_MATRIX_loffset(regPP_LUMI_MATRIX *reg, unsigned int loffset)
{
  reg->bitfields.LOFFSET = loffset;
  if (reg->bitfields.LOFFSET != loffset) HSLDPF(E_ERROR_MESSAGE,"PP_LUMI_MATRIX::LOFFSET data too large\n");
}
#else
#define set_PP_LUMI_MATRIX_lscale(reg, lscale) (reg)->bitfields.LSCALE = lscale
#define set_PP_LUMI_MATRIX_loffset(reg, loffset) (reg)->bitfields.LOFFSET = loffset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ROT_MATRIX0 regPP_ROT_MATRIX0;

#ifdef DEBUG
__inline void set_PP_ROT_MATRIX0_m00(regPP_ROT_MATRIX0 *reg, unsigned int m00)
{
  reg->bitfields.M00 = m00;
  if (reg->bitfields.M00 != m00) HSLDPF(E_ERROR_MESSAGE,"PP_ROT_MATRIX0::M00 data too large\n");
}
__inline void set_PP_ROT_MATRIX0_m10(regPP_ROT_MATRIX0 *reg, unsigned int m10)
{
  reg->bitfields.M10 = m10;
  if (reg->bitfields.M10 != m10) HSLDPF(E_ERROR_MESSAGE,"PP_ROT_MATRIX0::M10 data too large\n");
}
#else
#define set_PP_ROT_MATRIX0_m00(reg, m00) (reg)->bitfields.M00 = m00
#define set_PP_ROT_MATRIX0_m10(reg, m10) (reg)->bitfields.M10 = m10

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ROT_MATRIX1 regPP_ROT_MATRIX1;

#ifdef DEBUG
__inline void set_PP_ROT_MATRIX1_m01(regPP_ROT_MATRIX1 *reg, unsigned int m01)
{
  reg->bitfields.M01 = m01;
  if (reg->bitfields.M01 != m01) HSLDPF(E_ERROR_MESSAGE,"PP_ROT_MATRIX1::M01 data too large\n");
}
__inline void set_PP_ROT_MATRIX1_m11(regPP_ROT_MATRIX1 *reg, unsigned int m11)
{
  reg->bitfields.M11 = m11;
  if (reg->bitfields.M11 != m11) HSLDPF(E_ERROR_MESSAGE,"PP_ROT_MATRIX1::M11 data too large\n");
}
#else
#define set_PP_ROT_MATRIX1_m01(reg, m01) (reg)->bitfields.M01 = m01
#define set_PP_ROT_MATRIX1_m11(reg, m11) (reg)->bitfields.M11 = m11

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TRI_PERF regPP_TRI_PERF;

#ifdef DEBUG
__inline void set_PP_TRI_PERF_tri_juice(regPP_TRI_PERF *reg, unsigned int tri_juice)
{
  reg->bitfields.TRI_JUICE = tri_juice;
  if (reg->bitfields.TRI_JUICE != tri_juice) HSLDPF(E_ERROR_MESSAGE,"PP_TRI_PERF::TRI_JUICE data too large\n");
}
#else
#define set_PP_TRI_PERF_tri_juice(reg, tri_juice) (reg)->bitfields.TRI_JUICE = tri_juice

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PERF_CNTL regPP_PERF_CNTL;

#ifdef DEBUG
__inline void set_PP_PERF_CNTL_rr_fifo_scale(regPP_PERF_CNTL *reg, unsigned int rr_fifo_scale)
{
  reg->bitfields.RR_FIFO_SCALE = rr_fifo_scale;
  if (reg->bitfields.RR_FIFO_SCALE != rr_fifo_scale) HSLDPF(E_ERROR_MESSAGE,"PP_PERF_CNTL::RR_FIFO_SCALE data too large\n");
}
__inline void set_PP_PERF_CNTL_request_scale(regPP_PERF_CNTL *reg, unsigned int request_scale)
{
  reg->bitfields.REQUEST_SCALE = request_scale;
  if (reg->bitfields.REQUEST_SCALE != request_scale) HSLDPF(E_ERROR_MESSAGE,"PP_PERF_CNTL::REQUEST_SCALE data too large\n");
}
__inline void set_PP_PERF_CNTL_pp_count_ctl(regPP_PERF_CNTL *reg, unsigned int pp_count_ctl)
{
  reg->bitfields.PP_COUNT_CTL = pp_count_ctl;
  if (reg->bitfields.PP_COUNT_CTL != pp_count_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_PERF_CNTL::PP_COUNT_CTL data too large\n");
}
#else
#define set_PP_PERF_CNTL_rr_fifo_scale(reg, rr_fifo_scale) (reg)->bitfields.RR_FIFO_SCALE = rr_fifo_scale
#define set_PP_PERF_CNTL_request_scale(reg, request_scale) (reg)->bitfields.REQUEST_SCALE = request_scale
#define set_PP_PERF_CNTL_pp_count_ctl(reg, pp_count_ctl) (reg)->bitfields.PP_COUNT_CTL = pp_count_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXOFFSET_0 regPP_TXOFFSET_0;

#ifdef DEBUG
__inline void set_PP_TXOFFSET_0_endian_swap(regPP_TXOFFSET_0 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_0::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_TXOFFSET_0_macro_tile(regPP_TXOFFSET_0 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_0::MACRO_TILE data too large\n");
}
__inline void set_PP_TXOFFSET_0_micro_tile(regPP_TXOFFSET_0 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_0::MICRO_TILE data too large\n");
}
__inline void set_PP_TXOFFSET_0_txoffset(regPP_TXOFFSET_0 *reg, unsigned int txoffset)
{
  reg->bitfields.TXOFFSET = txoffset;
  if (reg->bitfields.TXOFFSET != txoffset) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_0::TXOFFSET data too large\n");
}
#else
#define set_PP_TXOFFSET_0_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_TXOFFSET_0_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_TXOFFSET_0_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_TXOFFSET_0_txoffset(reg, txoffset) (reg)->bitfields.TXOFFSET = txoffset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXOFFSET_1 regPP_TXOFFSET_1;

#ifdef DEBUG
__inline void set_PP_TXOFFSET_1_endian_swap(regPP_TXOFFSET_1 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_1::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_TXOFFSET_1_macro_tile(regPP_TXOFFSET_1 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_1::MACRO_TILE data too large\n");
}
__inline void set_PP_TXOFFSET_1_micro_tile(regPP_TXOFFSET_1 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_1::MICRO_TILE data too large\n");
}
__inline void set_PP_TXOFFSET_1_txoffset(regPP_TXOFFSET_1 *reg, unsigned int txoffset)
{
  reg->bitfields.TXOFFSET = txoffset;
  if (reg->bitfields.TXOFFSET != txoffset) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_1::TXOFFSET data too large\n");
}
#else
#define set_PP_TXOFFSET_1_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_TXOFFSET_1_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_TXOFFSET_1_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_TXOFFSET_1_txoffset(reg, txoffset) (reg)->bitfields.TXOFFSET = txoffset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXOFFSET_2 regPP_TXOFFSET_2;

#ifdef DEBUG
__inline void set_PP_TXOFFSET_2_endian_swap(regPP_TXOFFSET_2 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_2::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_TXOFFSET_2_macro_tile(regPP_TXOFFSET_2 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_2::MACRO_TILE data too large\n");
}
__inline void set_PP_TXOFFSET_2_micro_tile(regPP_TXOFFSET_2 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_2::MICRO_TILE data too large\n");
}
__inline void set_PP_TXOFFSET_2_txoffset(regPP_TXOFFSET_2 *reg, unsigned int txoffset)
{
  reg->bitfields.TXOFFSET = txoffset;
  if (reg->bitfields.TXOFFSET != txoffset) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_2::TXOFFSET data too large\n");
}
#else
#define set_PP_TXOFFSET_2_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_TXOFFSET_2_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_TXOFFSET_2_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_TXOFFSET_2_txoffset(reg, txoffset) (reg)->bitfields.TXOFFSET = txoffset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXOFFSET_3 regPP_TXOFFSET_3;

#ifdef DEBUG
__inline void set_PP_TXOFFSET_3_endian_swap(regPP_TXOFFSET_3 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_3::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_TXOFFSET_3_macro_tile(regPP_TXOFFSET_3 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_3::MACRO_TILE data too large\n");
}
__inline void set_PP_TXOFFSET_3_micro_tile(regPP_TXOFFSET_3 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_3::MICRO_TILE data too large\n");
}
__inline void set_PP_TXOFFSET_3_txoffset(regPP_TXOFFSET_3 *reg, unsigned int txoffset)
{
  reg->bitfields.TXOFFSET = txoffset;
  if (reg->bitfields.TXOFFSET != txoffset) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_3::TXOFFSET data too large\n");
}
#else
#define set_PP_TXOFFSET_3_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_TXOFFSET_3_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_TXOFFSET_3_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_TXOFFSET_3_txoffset(reg, txoffset) (reg)->bitfields.TXOFFSET = txoffset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXOFFSET_4 regPP_TXOFFSET_4;

#ifdef DEBUG
__inline void set_PP_TXOFFSET_4_endian_swap(regPP_TXOFFSET_4 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_4::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_TXOFFSET_4_macro_tile(regPP_TXOFFSET_4 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_4::MACRO_TILE data too large\n");
}
__inline void set_PP_TXOFFSET_4_micro_tile(regPP_TXOFFSET_4 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_4::MICRO_TILE data too large\n");
}
__inline void set_PP_TXOFFSET_4_txoffset(regPP_TXOFFSET_4 *reg, unsigned int txoffset)
{
  reg->bitfields.TXOFFSET = txoffset;
  if (reg->bitfields.TXOFFSET != txoffset) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_4::TXOFFSET data too large\n");
}
#else
#define set_PP_TXOFFSET_4_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_TXOFFSET_4_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_TXOFFSET_4_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_TXOFFSET_4_txoffset(reg, txoffset) (reg)->bitfields.TXOFFSET = txoffset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TXOFFSET_5 regPP_TXOFFSET_5;

#ifdef DEBUG
__inline void set_PP_TXOFFSET_5_endian_swap(regPP_TXOFFSET_5 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_5::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_TXOFFSET_5_macro_tile(regPP_TXOFFSET_5 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_5::MACRO_TILE data too large\n");
}
__inline void set_PP_TXOFFSET_5_micro_tile(regPP_TXOFFSET_5 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_5::MICRO_TILE data too large\n");
}
__inline void set_PP_TXOFFSET_5_txoffset(regPP_TXOFFSET_5 *reg, unsigned int txoffset)
{
  reg->bitfields.TXOFFSET = txoffset;
  if (reg->bitfields.TXOFFSET != txoffset) HSLDPF(E_ERROR_MESSAGE,"PP_TXOFFSET_5::TXOFFSET data too large\n");
}
#else
#define set_PP_TXOFFSET_5_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_TXOFFSET_5_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_TXOFFSET_5_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_TXOFFSET_5_txoffset(reg, txoffset) (reg)->bitfields.TXOFFSET = txoffset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F1_0 regPP_CUBIC_OFFSET_F1_0;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F1_0_endian_swap(regPP_CUBIC_OFFSET_F1_0 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_0::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F1_0_macro_tile(regPP_CUBIC_OFFSET_F1_0 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_0::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F1_0_micro_tile(regPP_CUBIC_OFFSET_F1_0 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_0::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F1_0_face_offset(regPP_CUBIC_OFFSET_F1_0 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_0::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F1_0_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F1_0_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F1_0_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F1_0_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F1_1 regPP_CUBIC_OFFSET_F1_1;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F1_1_endian_swap(regPP_CUBIC_OFFSET_F1_1 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_1::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F1_1_macro_tile(regPP_CUBIC_OFFSET_F1_1 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_1::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F1_1_micro_tile(regPP_CUBIC_OFFSET_F1_1 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_1::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F1_1_face_offset(regPP_CUBIC_OFFSET_F1_1 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_1::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F1_1_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F1_1_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F1_1_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F1_1_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F1_2 regPP_CUBIC_OFFSET_F1_2;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F1_2_endian_swap(regPP_CUBIC_OFFSET_F1_2 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_2::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F1_2_macro_tile(regPP_CUBIC_OFFSET_F1_2 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_2::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F1_2_micro_tile(regPP_CUBIC_OFFSET_F1_2 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_2::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F1_2_face_offset(regPP_CUBIC_OFFSET_F1_2 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_2::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F1_2_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F1_2_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F1_2_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F1_2_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F1_3 regPP_CUBIC_OFFSET_F1_3;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F1_3_endian_swap(regPP_CUBIC_OFFSET_F1_3 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_3::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F1_3_macro_tile(regPP_CUBIC_OFFSET_F1_3 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_3::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F1_3_micro_tile(regPP_CUBIC_OFFSET_F1_3 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_3::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F1_3_face_offset(regPP_CUBIC_OFFSET_F1_3 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_3::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F1_3_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F1_3_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F1_3_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F1_3_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F1_4 regPP_CUBIC_OFFSET_F1_4;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F1_4_endian_swap(regPP_CUBIC_OFFSET_F1_4 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_4::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F1_4_macro_tile(regPP_CUBIC_OFFSET_F1_4 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_4::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F1_4_micro_tile(regPP_CUBIC_OFFSET_F1_4 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_4::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F1_4_face_offset(regPP_CUBIC_OFFSET_F1_4 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_4::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F1_4_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F1_4_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F1_4_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F1_4_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F1_5 regPP_CUBIC_OFFSET_F1_5;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F1_5_endian_swap(regPP_CUBIC_OFFSET_F1_5 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_5::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F1_5_macro_tile(regPP_CUBIC_OFFSET_F1_5 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_5::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F1_5_micro_tile(regPP_CUBIC_OFFSET_F1_5 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_5::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F1_5_face_offset(regPP_CUBIC_OFFSET_F1_5 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F1_5::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F1_5_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F1_5_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F1_5_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F1_5_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F2_0 regPP_CUBIC_OFFSET_F2_0;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F2_0_endian_swap(regPP_CUBIC_OFFSET_F2_0 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_0::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F2_0_macro_tile(regPP_CUBIC_OFFSET_F2_0 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_0::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F2_0_micro_tile(regPP_CUBIC_OFFSET_F2_0 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_0::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F2_0_face_offset(regPP_CUBIC_OFFSET_F2_0 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_0::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F2_0_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F2_0_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F2_0_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F2_0_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F2_1 regPP_CUBIC_OFFSET_F2_1;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F2_1_endian_swap(regPP_CUBIC_OFFSET_F2_1 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_1::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F2_1_macro_tile(regPP_CUBIC_OFFSET_F2_1 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_1::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F2_1_micro_tile(regPP_CUBIC_OFFSET_F2_1 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_1::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F2_1_face_offset(regPP_CUBIC_OFFSET_F2_1 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_1::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F2_1_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F2_1_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F2_1_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F2_1_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F2_2 regPP_CUBIC_OFFSET_F2_2;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F2_2_endian_swap(regPP_CUBIC_OFFSET_F2_2 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_2::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F2_2_macro_tile(regPP_CUBIC_OFFSET_F2_2 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_2::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F2_2_micro_tile(regPP_CUBIC_OFFSET_F2_2 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_2::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F2_2_face_offset(regPP_CUBIC_OFFSET_F2_2 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_2::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F2_2_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F2_2_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F2_2_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F2_2_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F2_3 regPP_CUBIC_OFFSET_F2_3;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F2_3_endian_swap(regPP_CUBIC_OFFSET_F2_3 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_3::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F2_3_macro_tile(regPP_CUBIC_OFFSET_F2_3 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_3::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F2_3_micro_tile(regPP_CUBIC_OFFSET_F2_3 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_3::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F2_3_face_offset(regPP_CUBIC_OFFSET_F2_3 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_3::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F2_3_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F2_3_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F2_3_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F2_3_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F2_4 regPP_CUBIC_OFFSET_F2_4;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F2_4_endian_swap(regPP_CUBIC_OFFSET_F2_4 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_4::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F2_4_macro_tile(regPP_CUBIC_OFFSET_F2_4 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_4::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F2_4_micro_tile(regPP_CUBIC_OFFSET_F2_4 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_4::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F2_4_face_offset(regPP_CUBIC_OFFSET_F2_4 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_4::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F2_4_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F2_4_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F2_4_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F2_4_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F2_5 regPP_CUBIC_OFFSET_F2_5;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F2_5_endian_swap(regPP_CUBIC_OFFSET_F2_5 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_5::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F2_5_macro_tile(regPP_CUBIC_OFFSET_F2_5 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_5::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F2_5_micro_tile(regPP_CUBIC_OFFSET_F2_5 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_5::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F2_5_face_offset(regPP_CUBIC_OFFSET_F2_5 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F2_5::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F2_5_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F2_5_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F2_5_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F2_5_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F3_0 regPP_CUBIC_OFFSET_F3_0;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F3_0_endian_swap(regPP_CUBIC_OFFSET_F3_0 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_0::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F3_0_macro_tile(regPP_CUBIC_OFFSET_F3_0 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_0::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F3_0_micro_tile(regPP_CUBIC_OFFSET_F3_0 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_0::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F3_0_face_offset(regPP_CUBIC_OFFSET_F3_0 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_0::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F3_0_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F3_0_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F3_0_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F3_0_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F3_1 regPP_CUBIC_OFFSET_F3_1;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F3_1_endian_swap(regPP_CUBIC_OFFSET_F3_1 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_1::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F3_1_macro_tile(regPP_CUBIC_OFFSET_F3_1 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_1::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F3_1_micro_tile(regPP_CUBIC_OFFSET_F3_1 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_1::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F3_1_face_offset(regPP_CUBIC_OFFSET_F3_1 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_1::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F3_1_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F3_1_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F3_1_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F3_1_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F3_2 regPP_CUBIC_OFFSET_F3_2;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F3_2_endian_swap(regPP_CUBIC_OFFSET_F3_2 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_2::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F3_2_macro_tile(regPP_CUBIC_OFFSET_F3_2 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_2::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F3_2_micro_tile(regPP_CUBIC_OFFSET_F3_2 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_2::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F3_2_face_offset(regPP_CUBIC_OFFSET_F3_2 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_2::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F3_2_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F3_2_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F3_2_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F3_2_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F3_3 regPP_CUBIC_OFFSET_F3_3;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F3_3_endian_swap(regPP_CUBIC_OFFSET_F3_3 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_3::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F3_3_macro_tile(regPP_CUBIC_OFFSET_F3_3 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_3::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F3_3_micro_tile(regPP_CUBIC_OFFSET_F3_3 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_3::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F3_3_face_offset(regPP_CUBIC_OFFSET_F3_3 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_3::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F3_3_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F3_3_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F3_3_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F3_3_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F3_4 regPP_CUBIC_OFFSET_F3_4;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F3_4_endian_swap(regPP_CUBIC_OFFSET_F3_4 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_4::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F3_4_macro_tile(regPP_CUBIC_OFFSET_F3_4 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_4::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F3_4_micro_tile(regPP_CUBIC_OFFSET_F3_4 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_4::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F3_4_face_offset(regPP_CUBIC_OFFSET_F3_4 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_4::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F3_4_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F3_4_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F3_4_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F3_4_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F3_5 regPP_CUBIC_OFFSET_F3_5;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F3_5_endian_swap(regPP_CUBIC_OFFSET_F3_5 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_5::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F3_5_macro_tile(regPP_CUBIC_OFFSET_F3_5 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_5::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F3_5_micro_tile(regPP_CUBIC_OFFSET_F3_5 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_5::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F3_5_face_offset(regPP_CUBIC_OFFSET_F3_5 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F3_5::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F3_5_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F3_5_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F3_5_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F3_5_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F4_0 regPP_CUBIC_OFFSET_F4_0;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F4_0_endian_swap(regPP_CUBIC_OFFSET_F4_0 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_0::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F4_0_macro_tile(regPP_CUBIC_OFFSET_F4_0 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_0::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F4_0_micro_tile(regPP_CUBIC_OFFSET_F4_0 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_0::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F4_0_face_offset(regPP_CUBIC_OFFSET_F4_0 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_0::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F4_0_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F4_0_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F4_0_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F4_0_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F4_1 regPP_CUBIC_OFFSET_F4_1;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F4_1_endian_swap(regPP_CUBIC_OFFSET_F4_1 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_1::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F4_1_macro_tile(regPP_CUBIC_OFFSET_F4_1 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_1::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F4_1_micro_tile(regPP_CUBIC_OFFSET_F4_1 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_1::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F4_1_face_offset(regPP_CUBIC_OFFSET_F4_1 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_1::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F4_1_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F4_1_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F4_1_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F4_1_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F4_2 regPP_CUBIC_OFFSET_F4_2;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F4_2_endian_swap(regPP_CUBIC_OFFSET_F4_2 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_2::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F4_2_macro_tile(regPP_CUBIC_OFFSET_F4_2 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_2::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F4_2_micro_tile(regPP_CUBIC_OFFSET_F4_2 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_2::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F4_2_face_offset(regPP_CUBIC_OFFSET_F4_2 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_2::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F4_2_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F4_2_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F4_2_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F4_2_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F4_3 regPP_CUBIC_OFFSET_F4_3;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F4_3_endian_swap(regPP_CUBIC_OFFSET_F4_3 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_3::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F4_3_macro_tile(regPP_CUBIC_OFFSET_F4_3 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_3::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F4_3_micro_tile(regPP_CUBIC_OFFSET_F4_3 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_3::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F4_3_face_offset(regPP_CUBIC_OFFSET_F4_3 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_3::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F4_3_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F4_3_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F4_3_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F4_3_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F4_4 regPP_CUBIC_OFFSET_F4_4;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F4_4_endian_swap(regPP_CUBIC_OFFSET_F4_4 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_4::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F4_4_macro_tile(regPP_CUBIC_OFFSET_F4_4 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_4::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F4_4_micro_tile(regPP_CUBIC_OFFSET_F4_4 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_4::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F4_4_face_offset(regPP_CUBIC_OFFSET_F4_4 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_4::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F4_4_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F4_4_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F4_4_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F4_4_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F4_5 regPP_CUBIC_OFFSET_F4_5;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F4_5_endian_swap(regPP_CUBIC_OFFSET_F4_5 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_5::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F4_5_macro_tile(regPP_CUBIC_OFFSET_F4_5 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_5::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F4_5_micro_tile(regPP_CUBIC_OFFSET_F4_5 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_5::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F4_5_face_offset(regPP_CUBIC_OFFSET_F4_5 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F4_5::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F4_5_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F4_5_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F4_5_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F4_5_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F5_0 regPP_CUBIC_OFFSET_F5_0;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F5_0_endian_swap(regPP_CUBIC_OFFSET_F5_0 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_0::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F5_0_macro_tile(regPP_CUBIC_OFFSET_F5_0 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_0::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F5_0_micro_tile(regPP_CUBIC_OFFSET_F5_0 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_0::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F5_0_face_offset(regPP_CUBIC_OFFSET_F5_0 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_0::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F5_0_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F5_0_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F5_0_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F5_0_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F5_1 regPP_CUBIC_OFFSET_F5_1;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F5_1_endian_swap(regPP_CUBIC_OFFSET_F5_1 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_1::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F5_1_macro_tile(regPP_CUBIC_OFFSET_F5_1 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_1::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F5_1_micro_tile(regPP_CUBIC_OFFSET_F5_1 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_1::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F5_1_face_offset(regPP_CUBIC_OFFSET_F5_1 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_1::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F5_1_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F5_1_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F5_1_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F5_1_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F5_2 regPP_CUBIC_OFFSET_F5_2;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F5_2_endian_swap(regPP_CUBIC_OFFSET_F5_2 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_2::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F5_2_macro_tile(regPP_CUBIC_OFFSET_F5_2 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_2::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F5_2_micro_tile(regPP_CUBIC_OFFSET_F5_2 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_2::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F5_2_face_offset(regPP_CUBIC_OFFSET_F5_2 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_2::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F5_2_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F5_2_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F5_2_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F5_2_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F5_3 regPP_CUBIC_OFFSET_F5_3;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F5_3_endian_swap(regPP_CUBIC_OFFSET_F5_3 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_3::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F5_3_macro_tile(regPP_CUBIC_OFFSET_F5_3 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_3::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F5_3_micro_tile(regPP_CUBIC_OFFSET_F5_3 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_3::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F5_3_face_offset(regPP_CUBIC_OFFSET_F5_3 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_3::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F5_3_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F5_3_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F5_3_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F5_3_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F5_4 regPP_CUBIC_OFFSET_F5_4;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F5_4_endian_swap(regPP_CUBIC_OFFSET_F5_4 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_4::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F5_4_macro_tile(regPP_CUBIC_OFFSET_F5_4 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_4::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F5_4_micro_tile(regPP_CUBIC_OFFSET_F5_4 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_4::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F5_4_face_offset(regPP_CUBIC_OFFSET_F5_4 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_4::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F5_4_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F5_4_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F5_4_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F5_4_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_CUBIC_OFFSET_F5_5 regPP_CUBIC_OFFSET_F5_5;

#ifdef DEBUG
__inline void set_PP_CUBIC_OFFSET_F5_5_endian_swap(regPP_CUBIC_OFFSET_F5_5 *reg, unsigned int endian_swap)
{
  reg->bitfields.ENDIAN_SWAP = endian_swap;
  if (reg->bitfields.ENDIAN_SWAP != endian_swap) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_5::ENDIAN_SWAP data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F5_5_macro_tile(regPP_CUBIC_OFFSET_F5_5 *reg, unsigned int macro_tile)
{
  reg->bitfields.MACRO_TILE = macro_tile;
  if (reg->bitfields.MACRO_TILE != macro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_5::MACRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F5_5_micro_tile(regPP_CUBIC_OFFSET_F5_5 *reg, unsigned int micro_tile)
{
  reg->bitfields.MICRO_TILE = micro_tile;
  if (reg->bitfields.MICRO_TILE != micro_tile) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_5::MICRO_TILE data too large\n");
}
__inline void set_PP_CUBIC_OFFSET_F5_5_face_offset(regPP_CUBIC_OFFSET_F5_5 *reg, unsigned int face_offset)
{
  reg->bitfields.FACE_OFFSET = face_offset;
  if (reg->bitfields.FACE_OFFSET != face_offset) HSLDPF(E_ERROR_MESSAGE,"PP_CUBIC_OFFSET_F5_5::FACE_OFFSET data too large\n");
}
#else
#define set_PP_CUBIC_OFFSET_F5_5_endian_swap(reg, endian_swap) (reg)->bitfields.ENDIAN_SWAP = endian_swap
#define set_PP_CUBIC_OFFSET_F5_5_macro_tile(reg, macro_tile) (reg)->bitfields.MACRO_TILE = macro_tile
#define set_PP_CUBIC_OFFSET_F5_5_micro_tile(reg, micro_tile) (reg)->bitfields.MICRO_TILE = micro_tile
#define set_PP_CUBIC_OFFSET_F5_5_face_offset(reg, face_offset) (reg)->bitfields.FACE_OFFSET = face_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TAM_DEBUG0 regPP_TAM_DEBUG0;

#ifdef DEBUG
__inline void set_PP_TAM_DEBUG0_tam_dword(regPP_TAM_DEBUG0 *reg, unsigned int tam_dword)
{
  reg->bitfields.TAM_DWORD = tam_dword;
  if (reg->bitfields.TAM_DWORD != tam_dword) HSLDPF(E_ERROR_MESSAGE,"PP_TAM_DEBUG0::TAM_DWORD data too large\n");
}
#else
#define set_PP_TAM_DEBUG0_tam_dword(reg, tam_dword) (reg)->bitfields.TAM_DWORD = tam_dword

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TAM_DEBUG1 regPP_TAM_DEBUG1;

#ifdef DEBUG
__inline void set_PP_TAM_DEBUG1_tam_dword(regPP_TAM_DEBUG1 *reg, unsigned int tam_dword)
{
  reg->bitfields.TAM_DWORD = tam_dword;
  if (reg->bitfields.TAM_DWORD != tam_dword) HSLDPF(E_ERROR_MESSAGE,"PP_TAM_DEBUG1::TAM_DWORD data too large\n");
}
#else
#define set_PP_TAM_DEBUG1_tam_dword(reg, tam_dword) (reg)->bitfields.TAM_DWORD = tam_dword

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TAM_DEBUG2 regPP_TAM_DEBUG2;

#ifdef DEBUG
__inline void set_PP_TAM_DEBUG2_tam_dword(regPP_TAM_DEBUG2 *reg, unsigned int tam_dword)
{
  reg->bitfields.TAM_DWORD = tam_dword;
  if (reg->bitfields.TAM_DWORD != tam_dword) HSLDPF(E_ERROR_MESSAGE,"PP_TAM_DEBUG2::TAM_DWORD data too large\n");
}
#else
#define set_PP_TAM_DEBUG2_tam_dword(reg, tam_dword) (reg)->bitfields.TAM_DWORD = tam_dword

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TDM_DEBUG0 regPP_TDM_DEBUG0;

#ifdef DEBUG
__inline void set_PP_TDM_DEBUG0_tdm_dword(regPP_TDM_DEBUG0 *reg, unsigned int tdm_dword)
{
  reg->bitfields.TDM_DWORD = tdm_dword;
  if (reg->bitfields.TDM_DWORD != tdm_dword) HSLDPF(E_ERROR_MESSAGE,"PP_TDM_DEBUG0::TDM_DWORD data too large\n");
}
#else
#define set_PP_TDM_DEBUG0_tdm_dword(reg, tdm_dword) (reg)->bitfields.TDM_DWORD = tdm_dword

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TDM_DEBUG1 regPP_TDM_DEBUG1;

#ifdef DEBUG
__inline void set_PP_TDM_DEBUG1_tdm_dword(regPP_TDM_DEBUG1 *reg, unsigned int tdm_dword)
{
  reg->bitfields.TDM_DWORD = tdm_dword;
  if (reg->bitfields.TDM_DWORD != tdm_dword) HSLDPF(E_ERROR_MESSAGE,"PP_TDM_DEBUG1::TDM_DWORD data too large\n");
}
#else
#define set_PP_TDM_DEBUG1_tdm_dword(reg, tdm_dword) (reg)->bitfields.TDM_DWORD = tdm_dword

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TDM_DEBUG2 regPP_TDM_DEBUG2;

#ifdef DEBUG
__inline void set_PP_TDM_DEBUG2_tdm_dword(regPP_TDM_DEBUG2 *reg, unsigned int tdm_dword)
{
  reg->bitfields.TDM_DWORD = tdm_dword;
  if (reg->bitfields.TDM_DWORD != tdm_dword) HSLDPF(E_ERROR_MESSAGE,"PP_TDM_DEBUG2::TDM_DWORD data too large\n");
}
#else
#define set_PP_TDM_DEBUG2_tdm_dword(reg, tdm_dword) (reg)->bitfields.TDM_DWORD = tdm_dword

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PB_DEBUG0 regPP_PB_DEBUG0;

#ifdef DEBUG
__inline void set_PP_PB_DEBUG0_pb_dword(regPP_PB_DEBUG0 *reg, unsigned int pb_dword)
{
  reg->bitfields.PB_DWORD = pb_dword;
  if (reg->bitfields.PB_DWORD != pb_dword) HSLDPF(E_ERROR_MESSAGE,"PP_PB_DEBUG0::PB_DWORD data too large\n");
}
#else
#define set_PP_PB_DEBUG0_pb_dword(reg, pb_dword) (reg)->bitfields.PB_DWORD = pb_dword

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PB_DEBUG1 regPP_PB_DEBUG1;

#ifdef DEBUG
__inline void set_PP_PB_DEBUG1_pb_dword(regPP_PB_DEBUG1 *reg, unsigned int pb_dword)
{
  reg->bitfields.PB_DWORD = pb_dword;
  if (reg->bitfields.PB_DWORD != pb_dword) HSLDPF(E_ERROR_MESSAGE,"PP_PB_DEBUG1::PB_DWORD data too large\n");
}
#else
#define set_PP_PB_DEBUG1_pb_dword(reg, pb_dword) (reg)->bitfields.PB_DWORD = pb_dword

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PB_DEBUG2 regPP_PB_DEBUG2;

#ifdef DEBUG
__inline void set_PP_PB_DEBUG2_pb_dword(regPP_PB_DEBUG2 *reg, unsigned int pb_dword)
{
  reg->bitfields.PB_DWORD = pb_dword;
  if (reg->bitfields.PB_DWORD != pb_dword) HSLDPF(E_ERROR_MESSAGE,"PP_PB_DEBUG2::PB_DWORD data too large\n");
}
#else
#define set_PP_PB_DEBUG2_pb_dword(reg, pb_dword) (reg)->bitfields.PB_DWORD = pb_dword

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TAM_DEBUG3 regPP_TAM_DEBUG3;

#ifdef DEBUG
__inline void set_PP_TAM_DEBUG3_tam_dword(regPP_TAM_DEBUG3 *reg, unsigned int tam_dword)
{
  reg->bitfields.TAM_DWORD = tam_dword;
  if (reg->bitfields.TAM_DWORD != tam_dword) HSLDPF(E_ERROR_MESSAGE,"PP_TAM_DEBUG3::TAM_DWORD data too large\n");
}
#else
#define set_PP_TAM_DEBUG3_tam_dword(reg, tam_dword) (reg)->bitfields.TAM_DWORD = tam_dword

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TDM_DEBUG3 regPP_TDM_DEBUG3;

#ifdef DEBUG
__inline void set_PP_TDM_DEBUG3_tdm_dword(regPP_TDM_DEBUG3 *reg, unsigned int tdm_dword)
{
  reg->bitfields.TDM_DWORD = tdm_dword;
  if (reg->bitfields.TDM_DWORD != tdm_dword) HSLDPF(E_ERROR_MESSAGE,"PP_TDM_DEBUG3::TDM_DWORD data too large\n");
}
#else
#define set_PP_TDM_DEBUG3_tdm_dword(reg, tdm_dword) (reg)->bitfields.TDM_DWORD = tdm_dword

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PB_DEBUG3 regPP_PB_DEBUG3;

#ifdef DEBUG
__inline void set_PP_PB_DEBUG3_pb_dword(regPP_PB_DEBUG3 *reg, unsigned int pb_dword)
{
  reg->bitfields.PB_DWORD = pb_dword;
  if (reg->bitfields.PB_DWORD != pb_dword) HSLDPF(E_ERROR_MESSAGE,"PP_PB_DEBUG3::PB_DWORD data too large\n");
}
#else
#define set_PP_PB_DEBUG3_pb_dword(reg, pb_dword) (reg)->bitfields.PB_DWORD = pb_dword

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_SRC_OFFSET_0 regPP_SRC_OFFSET_0;

#ifdef DEBUG
__inline void set_PP_SRC_OFFSET_0_mc_offset(regPP_SRC_OFFSET_0 *reg, unsigned int mc_offset)
{
  reg->bitfields.MC_OFFSET = mc_offset;
  if (reg->bitfields.MC_OFFSET != mc_offset) HSLDPF(E_ERROR_MESSAGE,"PP_SRC_OFFSET_0::MC_OFFSET data too large\n");
}
#else
#define set_PP_SRC_OFFSET_0_mc_offset(reg, mc_offset) (reg)->bitfields.MC_OFFSET = mc_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_SRC_OFFSET_1 regPP_SRC_OFFSET_1;

#ifdef DEBUG
__inline void set_PP_SRC_OFFSET_1_mc_offset(regPP_SRC_OFFSET_1 *reg, unsigned int mc_offset)
{
  reg->bitfields.MC_OFFSET = mc_offset;
  if (reg->bitfields.MC_OFFSET != mc_offset) HSLDPF(E_ERROR_MESSAGE,"PP_SRC_OFFSET_1::MC_OFFSET data too large\n");
}
#else
#define set_PP_SRC_OFFSET_1_mc_offset(reg, mc_offset) (reg)->bitfields.MC_OFFSET = mc_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_SRC_OFFSET_2 regPP_SRC_OFFSET_2;

#ifdef DEBUG
__inline void set_PP_SRC_OFFSET_2_mc_offset(regPP_SRC_OFFSET_2 *reg, unsigned int mc_offset)
{
  reg->bitfields.MC_OFFSET = mc_offset;
  if (reg->bitfields.MC_OFFSET != mc_offset) HSLDPF(E_ERROR_MESSAGE,"PP_SRC_OFFSET_2::MC_OFFSET data too large\n");
}
#else
#define set_PP_SRC_OFFSET_2_mc_offset(reg, mc_offset) (reg)->bitfields.MC_OFFSET = mc_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_SRC_OFFSET_3 regPP_SRC_OFFSET_3;

#ifdef DEBUG
__inline void set_PP_SRC_OFFSET_3_mc_offset(regPP_SRC_OFFSET_3 *reg, unsigned int mc_offset)
{
  reg->bitfields.MC_OFFSET = mc_offset;
  if (reg->bitfields.MC_OFFSET != mc_offset) HSLDPF(E_ERROR_MESSAGE,"PP_SRC_OFFSET_3::MC_OFFSET data too large\n");
}
#else
#define set_PP_SRC_OFFSET_3_mc_offset(reg, mc_offset) (reg)->bitfields.MC_OFFSET = mc_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_SRC_OFFSET_4 regPP_SRC_OFFSET_4;

#ifdef DEBUG
__inline void set_PP_SRC_OFFSET_4_mc_offset(regPP_SRC_OFFSET_4 *reg, unsigned int mc_offset)
{
  reg->bitfields.MC_OFFSET = mc_offset;
  if (reg->bitfields.MC_OFFSET != mc_offset) HSLDPF(E_ERROR_MESSAGE,"PP_SRC_OFFSET_4::MC_OFFSET data too large\n");
}
#else
#define set_PP_SRC_OFFSET_4_mc_offset(reg, mc_offset) (reg)->bitfields.MC_OFFSET = mc_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_SRC_OFFSET_5 regPP_SRC_OFFSET_5;

#ifdef DEBUG
__inline void set_PP_SRC_OFFSET_5_mc_offset(regPP_SRC_OFFSET_5 *reg, unsigned int mc_offset)
{
  reg->bitfields.MC_OFFSET = mc_offset;
  if (reg->bitfields.MC_OFFSET != mc_offset) HSLDPF(E_ERROR_MESSAGE,"PP_SRC_OFFSET_5::MC_OFFSET data too large\n");
}
#else
#define set_PP_SRC_OFFSET_5_mc_offset(reg, mc_offset) (reg)->bitfields.MC_OFFSET = mc_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_SRC_OFFSET_6 regPP_SRC_OFFSET_6;

#ifdef DEBUG
__inline void set_PP_SRC_OFFSET_6_mc_offset(regPP_SRC_OFFSET_6 *reg, unsigned int mc_offset)
{
  reg->bitfields.MC_OFFSET = mc_offset;
  if (reg->bitfields.MC_OFFSET != mc_offset) HSLDPF(E_ERROR_MESSAGE,"PP_SRC_OFFSET_6::MC_OFFSET data too large\n");
}
#else
#define set_PP_SRC_OFFSET_6_mc_offset(reg, mc_offset) (reg)->bitfields.MC_OFFSET = mc_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_SRC_OFFSET_7 regPP_SRC_OFFSET_7;

#ifdef DEBUG
__inline void set_PP_SRC_OFFSET_7_mc_offset(regPP_SRC_OFFSET_7 *reg, unsigned int mc_offset)
{
  reg->bitfields.MC_OFFSET = mc_offset;
  if (reg->bitfields.MC_OFFSET != mc_offset) HSLDPF(E_ERROR_MESSAGE,"PP_SRC_OFFSET_7::MC_OFFSET data too large\n");
}
#else
#define set_PP_SRC_OFFSET_7_mc_offset(reg, mc_offset) (reg)->bitfields.MC_OFFSET = mc_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_SRC_OFFSET_8 regPP_SRC_OFFSET_8;

#ifdef DEBUG
__inline void set_PP_SRC_OFFSET_8_mc_offset(regPP_SRC_OFFSET_8 *reg, unsigned int mc_offset)
{
  reg->bitfields.MC_OFFSET = mc_offset;
  if (reg->bitfields.MC_OFFSET != mc_offset) HSLDPF(E_ERROR_MESSAGE,"PP_SRC_OFFSET_8::MC_OFFSET data too large\n");
}
#else
#define set_PP_SRC_OFFSET_8_mc_offset(reg, mc_offset) (reg)->bitfields.MC_OFFSET = mc_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_SRC_OFFSET_9 regPP_SRC_OFFSET_9;

#ifdef DEBUG
__inline void set_PP_SRC_OFFSET_9_mc_offset(regPP_SRC_OFFSET_9 *reg, unsigned int mc_offset)
{
  reg->bitfields.MC_OFFSET = mc_offset;
  if (reg->bitfields.MC_OFFSET != mc_offset) HSLDPF(E_ERROR_MESSAGE,"PP_SRC_OFFSET_9::MC_OFFSET data too large\n");
}
#else
#define set_PP_SRC_OFFSET_9_mc_offset(reg, mc_offset) (reg)->bitfields.MC_OFFSET = mc_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_SRC_OFFSET_10 regPP_SRC_OFFSET_10;

#ifdef DEBUG
__inline void set_PP_SRC_OFFSET_10_mc_offset(regPP_SRC_OFFSET_10 *reg, unsigned int mc_offset)
{
  reg->bitfields.MC_OFFSET = mc_offset;
  if (reg->bitfields.MC_OFFSET != mc_offset) HSLDPF(E_ERROR_MESSAGE,"PP_SRC_OFFSET_10::MC_OFFSET data too large\n");
}
#else
#define set_PP_SRC_OFFSET_10_mc_offset(reg, mc_offset) (reg)->bitfields.MC_OFFSET = mc_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_SRC_OFFSET_11 regPP_SRC_OFFSET_11;

#ifdef DEBUG
__inline void set_PP_SRC_OFFSET_11_mc_offset(regPP_SRC_OFFSET_11 *reg, unsigned int mc_offset)
{
  reg->bitfields.MC_OFFSET = mc_offset;
  if (reg->bitfields.MC_OFFSET != mc_offset) HSLDPF(E_ERROR_MESSAGE,"PP_SRC_OFFSET_11::MC_OFFSET data too large\n");
}
#else
#define set_PP_SRC_OFFSET_11_mc_offset(reg, mc_offset) (reg)->bitfields.MC_OFFSET = mc_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_SRC_OFFSET_12 regPP_SRC_OFFSET_12;

#ifdef DEBUG
__inline void set_PP_SRC_OFFSET_12_mc_offset(regPP_SRC_OFFSET_12 *reg, unsigned int mc_offset)
{
  reg->bitfields.MC_OFFSET = mc_offset;
  if (reg->bitfields.MC_OFFSET != mc_offset) HSLDPF(E_ERROR_MESSAGE,"PP_SRC_OFFSET_12::MC_OFFSET data too large\n");
}
#else
#define set_PP_SRC_OFFSET_12_mc_offset(reg, mc_offset) (reg)->bitfields.MC_OFFSET = mc_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_SRC_OFFSET_13 regPP_SRC_OFFSET_13;

#ifdef DEBUG
__inline void set_PP_SRC_OFFSET_13_mc_offset(regPP_SRC_OFFSET_13 *reg, unsigned int mc_offset)
{
  reg->bitfields.MC_OFFSET = mc_offset;
  if (reg->bitfields.MC_OFFSET != mc_offset) HSLDPF(E_ERROR_MESSAGE,"PP_SRC_OFFSET_13::MC_OFFSET data too large\n");
}
#else
#define set_PP_SRC_OFFSET_13_mc_offset(reg, mc_offset) (reg)->bitfields.MC_OFFSET = mc_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_SRC_OFFSET_14 regPP_SRC_OFFSET_14;

#ifdef DEBUG
__inline void set_PP_SRC_OFFSET_14_mc_offset(regPP_SRC_OFFSET_14 *reg, unsigned int mc_offset)
{
  reg->bitfields.MC_OFFSET = mc_offset;
  if (reg->bitfields.MC_OFFSET != mc_offset) HSLDPF(E_ERROR_MESSAGE,"PP_SRC_OFFSET_14::MC_OFFSET data too large\n");
}
#else
#define set_PP_SRC_OFFSET_14_mc_offset(reg, mc_offset) (reg)->bitfields.MC_OFFSET = mc_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_SRC_OFFSET_15 regPP_SRC_OFFSET_15;

#ifdef DEBUG
__inline void set_PP_SRC_OFFSET_15_mc_offset(regPP_SRC_OFFSET_15 *reg, unsigned int mc_offset)
{
  reg->bitfields.MC_OFFSET = mc_offset;
  if (reg->bitfields.MC_OFFSET != mc_offset) HSLDPF(E_ERROR_MESSAGE,"PP_SRC_OFFSET_15::MC_OFFSET data too large\n");
}
#else
#define set_PP_SRC_OFFSET_15_mc_offset(reg, mc_offset) (reg)->bitfields.MC_OFFSET = mc_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_SRC_OFFSET_16 regPP_SRC_OFFSET_16;

#ifdef DEBUG
__inline void set_PP_SRC_OFFSET_16_mc_offset(regPP_SRC_OFFSET_16 *reg, unsigned int mc_offset)
{
  reg->bitfields.MC_OFFSET = mc_offset;
  if (reg->bitfields.MC_OFFSET != mc_offset) HSLDPF(E_ERROR_MESSAGE,"PP_SRC_OFFSET_16::MC_OFFSET data too large\n");
}
#else
#define set_PP_SRC_OFFSET_16_mc_offset(reg, mc_offset) (reg)->bitfields.MC_OFFSET = mc_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_SRC_OFFSET_17 regPP_SRC_OFFSET_17;

#ifdef DEBUG
__inline void set_PP_SRC_OFFSET_17_mc_offset(regPP_SRC_OFFSET_17 *reg, unsigned int mc_offset)
{
  reg->bitfields.MC_OFFSET = mc_offset;
  if (reg->bitfields.MC_OFFSET != mc_offset) HSLDPF(E_ERROR_MESSAGE,"PP_SRC_OFFSET_17::MC_OFFSET data too large\n");
}
#else
#define set_PP_SRC_OFFSET_17_mc_offset(reg, mc_offset) (reg)->bitfields.MC_OFFSET = mc_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TFACTOR_SIGN regPP_TFACTOR_SIGN;

#ifdef DEBUG
__inline void set_PP_TFACTOR_SIGN_sgn_tf0_b(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf0_b)
{
  reg->bitfields.SGN_TF0_B = sgn_tf0_b;
  if (reg->bitfields.SGN_TF0_B != sgn_tf0_b) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF0_B data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf0_g(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf0_g)
{
  reg->bitfields.SGN_TF0_G = sgn_tf0_g;
  if (reg->bitfields.SGN_TF0_G != sgn_tf0_g) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF0_G data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf0_r(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf0_r)
{
  reg->bitfields.SGN_TF0_R = sgn_tf0_r;
  if (reg->bitfields.SGN_TF0_R != sgn_tf0_r) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF0_R data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf0_a(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf0_a)
{
  reg->bitfields.SGN_TF0_A = sgn_tf0_a;
  if (reg->bitfields.SGN_TF0_A != sgn_tf0_a) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF0_A data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf1_b(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf1_b)
{
  reg->bitfields.SGN_TF1_B = sgn_tf1_b;
  if (reg->bitfields.SGN_TF1_B != sgn_tf1_b) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF1_B data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf1_g(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf1_g)
{
  reg->bitfields.SGN_TF1_G = sgn_tf1_g;
  if (reg->bitfields.SGN_TF1_G != sgn_tf1_g) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF1_G data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf1_r(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf1_r)
{
  reg->bitfields.SGN_TF1_R = sgn_tf1_r;
  if (reg->bitfields.SGN_TF1_R != sgn_tf1_r) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF1_R data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf1_a(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf1_a)
{
  reg->bitfields.SGN_TF1_A = sgn_tf1_a;
  if (reg->bitfields.SGN_TF1_A != sgn_tf1_a) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF1_A data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf2_b(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf2_b)
{
  reg->bitfields.SGN_TF2_B = sgn_tf2_b;
  if (reg->bitfields.SGN_TF2_B != sgn_tf2_b) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF2_B data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf2_g(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf2_g)
{
  reg->bitfields.SGN_TF2_G = sgn_tf2_g;
  if (reg->bitfields.SGN_TF2_G != sgn_tf2_g) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF2_G data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf2_r(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf2_r)
{
  reg->bitfields.SGN_TF2_R = sgn_tf2_r;
  if (reg->bitfields.SGN_TF2_R != sgn_tf2_r) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF2_R data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf2_a(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf2_a)
{
  reg->bitfields.SGN_TF2_A = sgn_tf2_a;
  if (reg->bitfields.SGN_TF2_A != sgn_tf2_a) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF2_A data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf3_b(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf3_b)
{
  reg->bitfields.SGN_TF3_B = sgn_tf3_b;
  if (reg->bitfields.SGN_TF3_B != sgn_tf3_b) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF3_B data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf3_g(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf3_g)
{
  reg->bitfields.SGN_TF3_G = sgn_tf3_g;
  if (reg->bitfields.SGN_TF3_G != sgn_tf3_g) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF3_G data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf3_r(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf3_r)
{
  reg->bitfields.SGN_TF3_R = sgn_tf3_r;
  if (reg->bitfields.SGN_TF3_R != sgn_tf3_r) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF3_R data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf3_a(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf3_a)
{
  reg->bitfields.SGN_TF3_A = sgn_tf3_a;
  if (reg->bitfields.SGN_TF3_A != sgn_tf3_a) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF3_A data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf4_b(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf4_b)
{
  reg->bitfields.SGN_TF4_B = sgn_tf4_b;
  if (reg->bitfields.SGN_TF4_B != sgn_tf4_b) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF4_B data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf4_g(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf4_g)
{
  reg->bitfields.SGN_TF4_G = sgn_tf4_g;
  if (reg->bitfields.SGN_TF4_G != sgn_tf4_g) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF4_G data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf4_r(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf4_r)
{
  reg->bitfields.SGN_TF4_R = sgn_tf4_r;
  if (reg->bitfields.SGN_TF4_R != sgn_tf4_r) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF4_R data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf4_a(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf4_a)
{
  reg->bitfields.SGN_TF4_A = sgn_tf4_a;
  if (reg->bitfields.SGN_TF4_A != sgn_tf4_a) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF4_A data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf5_b(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf5_b)
{
  reg->bitfields.SGN_TF5_B = sgn_tf5_b;
  if (reg->bitfields.SGN_TF5_B != sgn_tf5_b) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF5_B data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf5_g(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf5_g)
{
  reg->bitfields.SGN_TF5_G = sgn_tf5_g;
  if (reg->bitfields.SGN_TF5_G != sgn_tf5_g) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF5_G data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf5_r(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf5_r)
{
  reg->bitfields.SGN_TF5_R = sgn_tf5_r;
  if (reg->bitfields.SGN_TF5_R != sgn_tf5_r) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF5_R data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf5_a(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf5_a)
{
  reg->bitfields.SGN_TF5_A = sgn_tf5_a;
  if (reg->bitfields.SGN_TF5_A != sgn_tf5_a) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF5_A data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf6_b(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf6_b)
{
  reg->bitfields.SGN_TF6_B = sgn_tf6_b;
  if (reg->bitfields.SGN_TF6_B != sgn_tf6_b) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF6_B data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf6_g(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf6_g)
{
  reg->bitfields.SGN_TF6_G = sgn_tf6_g;
  if (reg->bitfields.SGN_TF6_G != sgn_tf6_g) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF6_G data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf6_r(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf6_r)
{
  reg->bitfields.SGN_TF6_R = sgn_tf6_r;
  if (reg->bitfields.SGN_TF6_R != sgn_tf6_r) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF6_R data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf6_a(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf6_a)
{
  reg->bitfields.SGN_TF6_A = sgn_tf6_a;
  if (reg->bitfields.SGN_TF6_A != sgn_tf6_a) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF6_A data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf7_b(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf7_b)
{
  reg->bitfields.SGN_TF7_B = sgn_tf7_b;
  if (reg->bitfields.SGN_TF7_B != sgn_tf7_b) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF7_B data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf7_g(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf7_g)
{
  reg->bitfields.SGN_TF7_G = sgn_tf7_g;
  if (reg->bitfields.SGN_TF7_G != sgn_tf7_g) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF7_G data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf7_r(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf7_r)
{
  reg->bitfields.SGN_TF7_R = sgn_tf7_r;
  if (reg->bitfields.SGN_TF7_R != sgn_tf7_r) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF7_R data too large\n");
}
__inline void set_PP_TFACTOR_SIGN_sgn_tf7_a(regPP_TFACTOR_SIGN *reg, unsigned int sgn_tf7_a)
{
  reg->bitfields.SGN_TF7_A = sgn_tf7_a;
  if (reg->bitfields.SGN_TF7_A != sgn_tf7_a) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_SIGN::SGN_TF7_A data too large\n");
}
#else
#define set_PP_TFACTOR_SIGN_sgn_tf0_b(reg, sgn_tf0_b) (reg)->bitfields.SGN_TF0_B = sgn_tf0_b
#define set_PP_TFACTOR_SIGN_sgn_tf0_g(reg, sgn_tf0_g) (reg)->bitfields.SGN_TF0_G = sgn_tf0_g
#define set_PP_TFACTOR_SIGN_sgn_tf0_r(reg, sgn_tf0_r) (reg)->bitfields.SGN_TF0_R = sgn_tf0_r
#define set_PP_TFACTOR_SIGN_sgn_tf0_a(reg, sgn_tf0_a) (reg)->bitfields.SGN_TF0_A = sgn_tf0_a
#define set_PP_TFACTOR_SIGN_sgn_tf1_b(reg, sgn_tf1_b) (reg)->bitfields.SGN_TF1_B = sgn_tf1_b
#define set_PP_TFACTOR_SIGN_sgn_tf1_g(reg, sgn_tf1_g) (reg)->bitfields.SGN_TF1_G = sgn_tf1_g
#define set_PP_TFACTOR_SIGN_sgn_tf1_r(reg, sgn_tf1_r) (reg)->bitfields.SGN_TF1_R = sgn_tf1_r
#define set_PP_TFACTOR_SIGN_sgn_tf1_a(reg, sgn_tf1_a) (reg)->bitfields.SGN_TF1_A = sgn_tf1_a
#define set_PP_TFACTOR_SIGN_sgn_tf2_b(reg, sgn_tf2_b) (reg)->bitfields.SGN_TF2_B = sgn_tf2_b
#define set_PP_TFACTOR_SIGN_sgn_tf2_g(reg, sgn_tf2_g) (reg)->bitfields.SGN_TF2_G = sgn_tf2_g
#define set_PP_TFACTOR_SIGN_sgn_tf2_r(reg, sgn_tf2_r) (reg)->bitfields.SGN_TF2_R = sgn_tf2_r
#define set_PP_TFACTOR_SIGN_sgn_tf2_a(reg, sgn_tf2_a) (reg)->bitfields.SGN_TF2_A = sgn_tf2_a
#define set_PP_TFACTOR_SIGN_sgn_tf3_b(reg, sgn_tf3_b) (reg)->bitfields.SGN_TF3_B = sgn_tf3_b
#define set_PP_TFACTOR_SIGN_sgn_tf3_g(reg, sgn_tf3_g) (reg)->bitfields.SGN_TF3_G = sgn_tf3_g
#define set_PP_TFACTOR_SIGN_sgn_tf3_r(reg, sgn_tf3_r) (reg)->bitfields.SGN_TF3_R = sgn_tf3_r
#define set_PP_TFACTOR_SIGN_sgn_tf3_a(reg, sgn_tf3_a) (reg)->bitfields.SGN_TF3_A = sgn_tf3_a
#define set_PP_TFACTOR_SIGN_sgn_tf4_b(reg, sgn_tf4_b) (reg)->bitfields.SGN_TF4_B = sgn_tf4_b
#define set_PP_TFACTOR_SIGN_sgn_tf4_g(reg, sgn_tf4_g) (reg)->bitfields.SGN_TF4_G = sgn_tf4_g
#define set_PP_TFACTOR_SIGN_sgn_tf4_r(reg, sgn_tf4_r) (reg)->bitfields.SGN_TF4_R = sgn_tf4_r
#define set_PP_TFACTOR_SIGN_sgn_tf4_a(reg, sgn_tf4_a) (reg)->bitfields.SGN_TF4_A = sgn_tf4_a
#define set_PP_TFACTOR_SIGN_sgn_tf5_b(reg, sgn_tf5_b) (reg)->bitfields.SGN_TF5_B = sgn_tf5_b
#define set_PP_TFACTOR_SIGN_sgn_tf5_g(reg, sgn_tf5_g) (reg)->bitfields.SGN_TF5_G = sgn_tf5_g
#define set_PP_TFACTOR_SIGN_sgn_tf5_r(reg, sgn_tf5_r) (reg)->bitfields.SGN_TF5_R = sgn_tf5_r
#define set_PP_TFACTOR_SIGN_sgn_tf5_a(reg, sgn_tf5_a) (reg)->bitfields.SGN_TF5_A = sgn_tf5_a
#define set_PP_TFACTOR_SIGN_sgn_tf6_b(reg, sgn_tf6_b) (reg)->bitfields.SGN_TF6_B = sgn_tf6_b
#define set_PP_TFACTOR_SIGN_sgn_tf6_g(reg, sgn_tf6_g) (reg)->bitfields.SGN_TF6_G = sgn_tf6_g
#define set_PP_TFACTOR_SIGN_sgn_tf6_r(reg, sgn_tf6_r) (reg)->bitfields.SGN_TF6_R = sgn_tf6_r
#define set_PP_TFACTOR_SIGN_sgn_tf6_a(reg, sgn_tf6_a) (reg)->bitfields.SGN_TF6_A = sgn_tf6_a
#define set_PP_TFACTOR_SIGN_sgn_tf7_b(reg, sgn_tf7_b) (reg)->bitfields.SGN_TF7_B = sgn_tf7_b
#define set_PP_TFACTOR_SIGN_sgn_tf7_g(reg, sgn_tf7_g) (reg)->bitfields.SGN_TF7_G = sgn_tf7_g
#define set_PP_TFACTOR_SIGN_sgn_tf7_r(reg, sgn_tf7_r) (reg)->bitfields.SGN_TF7_R = sgn_tf7_r
#define set_PP_TFACTOR_SIGN_sgn_tf7_a(reg, sgn_tf7_a) (reg)->bitfields.SGN_TF7_A = sgn_tf7_a

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TFACTOR_0 regPP_TFACTOR_0;

#ifdef DEBUG
__inline void set_PP_TFACTOR_0_tfactor(regPP_TFACTOR_0 *reg, unsigned int tfactor)
{
  reg->bitfields.TFACTOR = tfactor;
  if (reg->bitfields.TFACTOR != tfactor) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_0::TFACTOR data too large\n");
}
#else
#define set_PP_TFACTOR_0_tfactor(reg, tfactor) (reg)->bitfields.TFACTOR = tfactor

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TFACTOR_1 regPP_TFACTOR_1;

#ifdef DEBUG
__inline void set_PP_TFACTOR_1_tfactor(regPP_TFACTOR_1 *reg, unsigned int tfactor)
{
  reg->bitfields.TFACTOR = tfactor;
  if (reg->bitfields.TFACTOR != tfactor) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_1::TFACTOR data too large\n");
}
#else
#define set_PP_TFACTOR_1_tfactor(reg, tfactor) (reg)->bitfields.TFACTOR = tfactor

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TFACTOR_2 regPP_TFACTOR_2;

#ifdef DEBUG
__inline void set_PP_TFACTOR_2_tfactor(regPP_TFACTOR_2 *reg, unsigned int tfactor)
{
  reg->bitfields.TFACTOR = tfactor;
  if (reg->bitfields.TFACTOR != tfactor) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_2::TFACTOR data too large\n");
}
#else
#define set_PP_TFACTOR_2_tfactor(reg, tfactor) (reg)->bitfields.TFACTOR = tfactor

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TFACTOR_3 regPP_TFACTOR_3;

#ifdef DEBUG
__inline void set_PP_TFACTOR_3_tfactor(regPP_TFACTOR_3 *reg, unsigned int tfactor)
{
  reg->bitfields.TFACTOR = tfactor;
  if (reg->bitfields.TFACTOR != tfactor) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_3::TFACTOR data too large\n");
}
#else
#define set_PP_TFACTOR_3_tfactor(reg, tfactor) (reg)->bitfields.TFACTOR = tfactor

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TFACTOR_4 regPP_TFACTOR_4;

#ifdef DEBUG
__inline void set_PP_TFACTOR_4_tfactor(regPP_TFACTOR_4 *reg, unsigned int tfactor)
{
  reg->bitfields.TFACTOR = tfactor;
  if (reg->bitfields.TFACTOR != tfactor) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_4::TFACTOR data too large\n");
}
#else
#define set_PP_TFACTOR_4_tfactor(reg, tfactor) (reg)->bitfields.TFACTOR = tfactor

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TFACTOR_5 regPP_TFACTOR_5;

#ifdef DEBUG
__inline void set_PP_TFACTOR_5_tfactor(regPP_TFACTOR_5 *reg, unsigned int tfactor)
{
  reg->bitfields.TFACTOR = tfactor;
  if (reg->bitfields.TFACTOR != tfactor) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_5::TFACTOR data too large\n");
}
#else
#define set_PP_TFACTOR_5_tfactor(reg, tfactor) (reg)->bitfields.TFACTOR = tfactor

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TFACTOR_6 regPP_TFACTOR_6;

#ifdef DEBUG
__inline void set_PP_TFACTOR_6_tfactor(regPP_TFACTOR_6 *reg, unsigned int tfactor)
{
  reg->bitfields.TFACTOR = tfactor;
  if (reg->bitfields.TFACTOR != tfactor) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_6::TFACTOR data too large\n");
}
#else
#define set_PP_TFACTOR_6_tfactor(reg, tfactor) (reg)->bitfields.TFACTOR = tfactor

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_TFACTOR_7 regPP_TFACTOR_7;

#ifdef DEBUG
__inline void set_PP_TFACTOR_7_tfactor(regPP_TFACTOR_7 *reg, unsigned int tfactor)
{
  reg->bitfields.TFACTOR = tfactor;
  if (reg->bitfields.TFACTOR != tfactor) HSLDPF(E_ERROR_MESSAGE,"PP_TFACTOR_7::TFACTOR data too large\n");
}
#else
#define set_PP_TFACTOR_7_tfactor(reg, tfactor) (reg)->bitfields.TFACTOR = tfactor

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I0_C0 regPP_PIXSHADER_I0_C0;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I0_C0_color_arg_a(regPP_PIXSHADER_I0_C0 *reg, unsigned int color_arg_a)
{
  reg->bitfields.COLOR_ARG_A = color_arg_a;
  if (reg->bitfields.COLOR_ARG_A != color_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C0::COLOR_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C0_color_arg_b(regPP_PIXSHADER_I0_C0 *reg, unsigned int color_arg_b)
{
  reg->bitfields.COLOR_ARG_B = color_arg_b;
  if (reg->bitfields.COLOR_ARG_B != color_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C0::COLOR_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C0_color_arg_c(regPP_PIXSHADER_I0_C0 *reg, unsigned int color_arg_c)
{
  reg->bitfields.COLOR_ARG_C = color_arg_c;
  if (reg->bitfields.COLOR_ARG_C != color_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C0::COLOR_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C0_comp_arg_a(regPP_PIXSHADER_I0_C0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C0::COMP_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C0_bias_arg_a(regPP_PIXSHADER_I0_C0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C0_scale_arg_a(regPP_PIXSHADER_I0_C0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C0_neg_arg_a(regPP_PIXSHADER_I0_C0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C0::NEG_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C0_comp_arg_b(regPP_PIXSHADER_I0_C0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C0::COMP_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C0_bias_arg_b(regPP_PIXSHADER_I0_C0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C0_scale_arg_b(regPP_PIXSHADER_I0_C0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C0_neg_arg_b(regPP_PIXSHADER_I0_C0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C0::NEG_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C0_comp_arg_c(regPP_PIXSHADER_I0_C0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C0::COMP_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C0_bias_arg_c(regPP_PIXSHADER_I0_C0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C0_scale_arg_c(regPP_PIXSHADER_I0_C0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C0_neg_arg_c(regPP_PIXSHADER_I0_C0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C0::NEG_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C0_blend_ctl(regPP_PIXSHADER_I0_C0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C0::BLEND_CTL data too large\n");
}
#else
#define set_PP_PIXSHADER_I0_C0_color_arg_a(reg, color_arg_a) (reg)->bitfields.COLOR_ARG_A = color_arg_a
#define set_PP_PIXSHADER_I0_C0_color_arg_b(reg, color_arg_b) (reg)->bitfields.COLOR_ARG_B = color_arg_b
#define set_PP_PIXSHADER_I0_C0_color_arg_c(reg, color_arg_c) (reg)->bitfields.COLOR_ARG_C = color_arg_c
#define set_PP_PIXSHADER_I0_C0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_PIXSHADER_I0_C0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_PIXSHADER_I0_C0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_PIXSHADER_I0_C0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_PIXSHADER_I0_C0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_PIXSHADER_I0_C0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_PIXSHADER_I0_C0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_PIXSHADER_I0_C0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_PIXSHADER_I0_C0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_PIXSHADER_I0_C0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_PIXSHADER_I0_C0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_PIXSHADER_I0_C0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_PIXSHADER_I0_C0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I1_C0 regPP_PIXSHADER_I1_C0;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I1_C0_color_arg_a(regPP_PIXSHADER_I1_C0 *reg, unsigned int color_arg_a)
{
  reg->bitfields.COLOR_ARG_A = color_arg_a;
  if (reg->bitfields.COLOR_ARG_A != color_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C0::COLOR_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C0_color_arg_b(regPP_PIXSHADER_I1_C0 *reg, unsigned int color_arg_b)
{
  reg->bitfields.COLOR_ARG_B = color_arg_b;
  if (reg->bitfields.COLOR_ARG_B != color_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C0::COLOR_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C0_color_arg_c(regPP_PIXSHADER_I1_C0 *reg, unsigned int color_arg_c)
{
  reg->bitfields.COLOR_ARG_C = color_arg_c;
  if (reg->bitfields.COLOR_ARG_C != color_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C0::COLOR_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C0_comp_arg_a(regPP_PIXSHADER_I1_C0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C0::COMP_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C0_bias_arg_a(regPP_PIXSHADER_I1_C0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C0_scale_arg_a(regPP_PIXSHADER_I1_C0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C0_neg_arg_a(regPP_PIXSHADER_I1_C0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C0::NEG_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C0_comp_arg_b(regPP_PIXSHADER_I1_C0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C0::COMP_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C0_bias_arg_b(regPP_PIXSHADER_I1_C0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C0_scale_arg_b(regPP_PIXSHADER_I1_C0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C0_neg_arg_b(regPP_PIXSHADER_I1_C0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C0::NEG_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C0_comp_arg_c(regPP_PIXSHADER_I1_C0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C0::COMP_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C0_bias_arg_c(regPP_PIXSHADER_I1_C0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C0_scale_arg_c(regPP_PIXSHADER_I1_C0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C0_neg_arg_c(regPP_PIXSHADER_I1_C0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C0::NEG_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C0_blend_ctl(regPP_PIXSHADER_I1_C0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C0::BLEND_CTL data too large\n");
}
#else
#define set_PP_PIXSHADER_I1_C0_color_arg_a(reg, color_arg_a) (reg)->bitfields.COLOR_ARG_A = color_arg_a
#define set_PP_PIXSHADER_I1_C0_color_arg_b(reg, color_arg_b) (reg)->bitfields.COLOR_ARG_B = color_arg_b
#define set_PP_PIXSHADER_I1_C0_color_arg_c(reg, color_arg_c) (reg)->bitfields.COLOR_ARG_C = color_arg_c
#define set_PP_PIXSHADER_I1_C0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_PIXSHADER_I1_C0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_PIXSHADER_I1_C0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_PIXSHADER_I1_C0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_PIXSHADER_I1_C0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_PIXSHADER_I1_C0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_PIXSHADER_I1_C0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_PIXSHADER_I1_C0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_PIXSHADER_I1_C0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_PIXSHADER_I1_C0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_PIXSHADER_I1_C0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_PIXSHADER_I1_C0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_PIXSHADER_I1_C0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I2_C0 regPP_PIXSHADER_I2_C0;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I2_C0_color_arg_a(regPP_PIXSHADER_I2_C0 *reg, unsigned int color_arg_a)
{
  reg->bitfields.COLOR_ARG_A = color_arg_a;
  if (reg->bitfields.COLOR_ARG_A != color_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C0::COLOR_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C0_color_arg_b(regPP_PIXSHADER_I2_C0 *reg, unsigned int color_arg_b)
{
  reg->bitfields.COLOR_ARG_B = color_arg_b;
  if (reg->bitfields.COLOR_ARG_B != color_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C0::COLOR_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C0_color_arg_c(regPP_PIXSHADER_I2_C0 *reg, unsigned int color_arg_c)
{
  reg->bitfields.COLOR_ARG_C = color_arg_c;
  if (reg->bitfields.COLOR_ARG_C != color_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C0::COLOR_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C0_comp_arg_a(regPP_PIXSHADER_I2_C0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C0::COMP_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C0_bias_arg_a(regPP_PIXSHADER_I2_C0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C0_scale_arg_a(regPP_PIXSHADER_I2_C0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C0_neg_arg_a(regPP_PIXSHADER_I2_C0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C0::NEG_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C0_comp_arg_b(regPP_PIXSHADER_I2_C0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C0::COMP_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C0_bias_arg_b(regPP_PIXSHADER_I2_C0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C0_scale_arg_b(regPP_PIXSHADER_I2_C0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C0_neg_arg_b(regPP_PIXSHADER_I2_C0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C0::NEG_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C0_comp_arg_c(regPP_PIXSHADER_I2_C0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C0::COMP_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C0_bias_arg_c(regPP_PIXSHADER_I2_C0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C0_scale_arg_c(regPP_PIXSHADER_I2_C0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C0_neg_arg_c(regPP_PIXSHADER_I2_C0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C0::NEG_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C0_blend_ctl(regPP_PIXSHADER_I2_C0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C0::BLEND_CTL data too large\n");
}
#else
#define set_PP_PIXSHADER_I2_C0_color_arg_a(reg, color_arg_a) (reg)->bitfields.COLOR_ARG_A = color_arg_a
#define set_PP_PIXSHADER_I2_C0_color_arg_b(reg, color_arg_b) (reg)->bitfields.COLOR_ARG_B = color_arg_b
#define set_PP_PIXSHADER_I2_C0_color_arg_c(reg, color_arg_c) (reg)->bitfields.COLOR_ARG_C = color_arg_c
#define set_PP_PIXSHADER_I2_C0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_PIXSHADER_I2_C0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_PIXSHADER_I2_C0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_PIXSHADER_I2_C0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_PIXSHADER_I2_C0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_PIXSHADER_I2_C0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_PIXSHADER_I2_C0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_PIXSHADER_I2_C0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_PIXSHADER_I2_C0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_PIXSHADER_I2_C0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_PIXSHADER_I2_C0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_PIXSHADER_I2_C0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_PIXSHADER_I2_C0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I3_C0 regPP_PIXSHADER_I3_C0;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I3_C0_color_arg_a(regPP_PIXSHADER_I3_C0 *reg, unsigned int color_arg_a)
{
  reg->bitfields.COLOR_ARG_A = color_arg_a;
  if (reg->bitfields.COLOR_ARG_A != color_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C0::COLOR_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C0_color_arg_b(regPP_PIXSHADER_I3_C0 *reg, unsigned int color_arg_b)
{
  reg->bitfields.COLOR_ARG_B = color_arg_b;
  if (reg->bitfields.COLOR_ARG_B != color_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C0::COLOR_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C0_color_arg_c(regPP_PIXSHADER_I3_C0 *reg, unsigned int color_arg_c)
{
  reg->bitfields.COLOR_ARG_C = color_arg_c;
  if (reg->bitfields.COLOR_ARG_C != color_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C0::COLOR_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C0_comp_arg_a(regPP_PIXSHADER_I3_C0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C0::COMP_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C0_bias_arg_a(regPP_PIXSHADER_I3_C0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C0_scale_arg_a(regPP_PIXSHADER_I3_C0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C0_neg_arg_a(regPP_PIXSHADER_I3_C0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C0::NEG_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C0_comp_arg_b(regPP_PIXSHADER_I3_C0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C0::COMP_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C0_bias_arg_b(regPP_PIXSHADER_I3_C0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C0_scale_arg_b(regPP_PIXSHADER_I3_C0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C0_neg_arg_b(regPP_PIXSHADER_I3_C0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C0::NEG_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C0_comp_arg_c(regPP_PIXSHADER_I3_C0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C0::COMP_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C0_bias_arg_c(regPP_PIXSHADER_I3_C0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C0_scale_arg_c(regPP_PIXSHADER_I3_C0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C0_neg_arg_c(regPP_PIXSHADER_I3_C0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C0::NEG_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C0_blend_ctl(regPP_PIXSHADER_I3_C0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C0::BLEND_CTL data too large\n");
}
#else
#define set_PP_PIXSHADER_I3_C0_color_arg_a(reg, color_arg_a) (reg)->bitfields.COLOR_ARG_A = color_arg_a
#define set_PP_PIXSHADER_I3_C0_color_arg_b(reg, color_arg_b) (reg)->bitfields.COLOR_ARG_B = color_arg_b
#define set_PP_PIXSHADER_I3_C0_color_arg_c(reg, color_arg_c) (reg)->bitfields.COLOR_ARG_C = color_arg_c
#define set_PP_PIXSHADER_I3_C0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_PIXSHADER_I3_C0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_PIXSHADER_I3_C0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_PIXSHADER_I3_C0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_PIXSHADER_I3_C0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_PIXSHADER_I3_C0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_PIXSHADER_I3_C0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_PIXSHADER_I3_C0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_PIXSHADER_I3_C0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_PIXSHADER_I3_C0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_PIXSHADER_I3_C0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_PIXSHADER_I3_C0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_PIXSHADER_I3_C0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I4_C0 regPP_PIXSHADER_I4_C0;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I4_C0_color_arg_a(regPP_PIXSHADER_I4_C0 *reg, unsigned int color_arg_a)
{
  reg->bitfields.COLOR_ARG_A = color_arg_a;
  if (reg->bitfields.COLOR_ARG_A != color_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C0::COLOR_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C0_color_arg_b(regPP_PIXSHADER_I4_C0 *reg, unsigned int color_arg_b)
{
  reg->bitfields.COLOR_ARG_B = color_arg_b;
  if (reg->bitfields.COLOR_ARG_B != color_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C0::COLOR_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C0_color_arg_c(regPP_PIXSHADER_I4_C0 *reg, unsigned int color_arg_c)
{
  reg->bitfields.COLOR_ARG_C = color_arg_c;
  if (reg->bitfields.COLOR_ARG_C != color_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C0::COLOR_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C0_comp_arg_a(regPP_PIXSHADER_I4_C0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C0::COMP_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C0_bias_arg_a(regPP_PIXSHADER_I4_C0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C0_scale_arg_a(regPP_PIXSHADER_I4_C0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C0_neg_arg_a(regPP_PIXSHADER_I4_C0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C0::NEG_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C0_comp_arg_b(regPP_PIXSHADER_I4_C0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C0::COMP_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C0_bias_arg_b(regPP_PIXSHADER_I4_C0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C0_scale_arg_b(regPP_PIXSHADER_I4_C0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C0_neg_arg_b(regPP_PIXSHADER_I4_C0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C0::NEG_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C0_comp_arg_c(regPP_PIXSHADER_I4_C0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C0::COMP_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C0_bias_arg_c(regPP_PIXSHADER_I4_C0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C0_scale_arg_c(regPP_PIXSHADER_I4_C0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C0_neg_arg_c(regPP_PIXSHADER_I4_C0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C0::NEG_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C0_blend_ctl(regPP_PIXSHADER_I4_C0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C0::BLEND_CTL data too large\n");
}
#else
#define set_PP_PIXSHADER_I4_C0_color_arg_a(reg, color_arg_a) (reg)->bitfields.COLOR_ARG_A = color_arg_a
#define set_PP_PIXSHADER_I4_C0_color_arg_b(reg, color_arg_b) (reg)->bitfields.COLOR_ARG_B = color_arg_b
#define set_PP_PIXSHADER_I4_C0_color_arg_c(reg, color_arg_c) (reg)->bitfields.COLOR_ARG_C = color_arg_c
#define set_PP_PIXSHADER_I4_C0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_PIXSHADER_I4_C0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_PIXSHADER_I4_C0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_PIXSHADER_I4_C0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_PIXSHADER_I4_C0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_PIXSHADER_I4_C0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_PIXSHADER_I4_C0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_PIXSHADER_I4_C0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_PIXSHADER_I4_C0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_PIXSHADER_I4_C0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_PIXSHADER_I4_C0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_PIXSHADER_I4_C0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_PIXSHADER_I4_C0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I5_C0 regPP_PIXSHADER_I5_C0;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I5_C0_color_arg_a(regPP_PIXSHADER_I5_C0 *reg, unsigned int color_arg_a)
{
  reg->bitfields.COLOR_ARG_A = color_arg_a;
  if (reg->bitfields.COLOR_ARG_A != color_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C0::COLOR_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C0_color_arg_b(regPP_PIXSHADER_I5_C0 *reg, unsigned int color_arg_b)
{
  reg->bitfields.COLOR_ARG_B = color_arg_b;
  if (reg->bitfields.COLOR_ARG_B != color_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C0::COLOR_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C0_color_arg_c(regPP_PIXSHADER_I5_C0 *reg, unsigned int color_arg_c)
{
  reg->bitfields.COLOR_ARG_C = color_arg_c;
  if (reg->bitfields.COLOR_ARG_C != color_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C0::COLOR_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C0_comp_arg_a(regPP_PIXSHADER_I5_C0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C0::COMP_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C0_bias_arg_a(regPP_PIXSHADER_I5_C0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C0_scale_arg_a(regPP_PIXSHADER_I5_C0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C0_neg_arg_a(regPP_PIXSHADER_I5_C0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C0::NEG_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C0_comp_arg_b(regPP_PIXSHADER_I5_C0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C0::COMP_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C0_bias_arg_b(regPP_PIXSHADER_I5_C0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C0_scale_arg_b(regPP_PIXSHADER_I5_C0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C0_neg_arg_b(regPP_PIXSHADER_I5_C0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C0::NEG_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C0_comp_arg_c(regPP_PIXSHADER_I5_C0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C0::COMP_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C0_bias_arg_c(regPP_PIXSHADER_I5_C0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C0_scale_arg_c(regPP_PIXSHADER_I5_C0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C0_neg_arg_c(regPP_PIXSHADER_I5_C0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C0::NEG_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C0_blend_ctl(regPP_PIXSHADER_I5_C0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C0::BLEND_CTL data too large\n");
}
#else
#define set_PP_PIXSHADER_I5_C0_color_arg_a(reg, color_arg_a) (reg)->bitfields.COLOR_ARG_A = color_arg_a
#define set_PP_PIXSHADER_I5_C0_color_arg_b(reg, color_arg_b) (reg)->bitfields.COLOR_ARG_B = color_arg_b
#define set_PP_PIXSHADER_I5_C0_color_arg_c(reg, color_arg_c) (reg)->bitfields.COLOR_ARG_C = color_arg_c
#define set_PP_PIXSHADER_I5_C0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_PIXSHADER_I5_C0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_PIXSHADER_I5_C0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_PIXSHADER_I5_C0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_PIXSHADER_I5_C0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_PIXSHADER_I5_C0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_PIXSHADER_I5_C0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_PIXSHADER_I5_C0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_PIXSHADER_I5_C0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_PIXSHADER_I5_C0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_PIXSHADER_I5_C0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_PIXSHADER_I5_C0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_PIXSHADER_I5_C0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I6_C0 regPP_PIXSHADER_I6_C0;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I6_C0_color_arg_a(regPP_PIXSHADER_I6_C0 *reg, unsigned int color_arg_a)
{
  reg->bitfields.COLOR_ARG_A = color_arg_a;
  if (reg->bitfields.COLOR_ARG_A != color_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C0::COLOR_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C0_color_arg_b(regPP_PIXSHADER_I6_C0 *reg, unsigned int color_arg_b)
{
  reg->bitfields.COLOR_ARG_B = color_arg_b;
  if (reg->bitfields.COLOR_ARG_B != color_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C0::COLOR_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C0_color_arg_c(regPP_PIXSHADER_I6_C0 *reg, unsigned int color_arg_c)
{
  reg->bitfields.COLOR_ARG_C = color_arg_c;
  if (reg->bitfields.COLOR_ARG_C != color_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C0::COLOR_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C0_comp_arg_a(regPP_PIXSHADER_I6_C0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C0::COMP_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C0_bias_arg_a(regPP_PIXSHADER_I6_C0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C0_scale_arg_a(regPP_PIXSHADER_I6_C0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C0_neg_arg_a(regPP_PIXSHADER_I6_C0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C0::NEG_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C0_comp_arg_b(regPP_PIXSHADER_I6_C0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C0::COMP_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C0_bias_arg_b(regPP_PIXSHADER_I6_C0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C0_scale_arg_b(regPP_PIXSHADER_I6_C0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C0_neg_arg_b(regPP_PIXSHADER_I6_C0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C0::NEG_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C0_comp_arg_c(regPP_PIXSHADER_I6_C0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C0::COMP_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C0_bias_arg_c(regPP_PIXSHADER_I6_C0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C0_scale_arg_c(regPP_PIXSHADER_I6_C0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C0_neg_arg_c(regPP_PIXSHADER_I6_C0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C0::NEG_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C0_blend_ctl(regPP_PIXSHADER_I6_C0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C0::BLEND_CTL data too large\n");
}
#else
#define set_PP_PIXSHADER_I6_C0_color_arg_a(reg, color_arg_a) (reg)->bitfields.COLOR_ARG_A = color_arg_a
#define set_PP_PIXSHADER_I6_C0_color_arg_b(reg, color_arg_b) (reg)->bitfields.COLOR_ARG_B = color_arg_b
#define set_PP_PIXSHADER_I6_C0_color_arg_c(reg, color_arg_c) (reg)->bitfields.COLOR_ARG_C = color_arg_c
#define set_PP_PIXSHADER_I6_C0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_PIXSHADER_I6_C0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_PIXSHADER_I6_C0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_PIXSHADER_I6_C0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_PIXSHADER_I6_C0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_PIXSHADER_I6_C0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_PIXSHADER_I6_C0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_PIXSHADER_I6_C0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_PIXSHADER_I6_C0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_PIXSHADER_I6_C0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_PIXSHADER_I6_C0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_PIXSHADER_I6_C0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_PIXSHADER_I6_C0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I7_C0 regPP_PIXSHADER_I7_C0;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I7_C0_color_arg_a(regPP_PIXSHADER_I7_C0 *reg, unsigned int color_arg_a)
{
  reg->bitfields.COLOR_ARG_A = color_arg_a;
  if (reg->bitfields.COLOR_ARG_A != color_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C0::COLOR_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C0_color_arg_b(regPP_PIXSHADER_I7_C0 *reg, unsigned int color_arg_b)
{
  reg->bitfields.COLOR_ARG_B = color_arg_b;
  if (reg->bitfields.COLOR_ARG_B != color_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C0::COLOR_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C0_color_arg_c(regPP_PIXSHADER_I7_C0 *reg, unsigned int color_arg_c)
{
  reg->bitfields.COLOR_ARG_C = color_arg_c;
  if (reg->bitfields.COLOR_ARG_C != color_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C0::COLOR_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C0_comp_arg_a(regPP_PIXSHADER_I7_C0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C0::COMP_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C0_bias_arg_a(regPP_PIXSHADER_I7_C0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C0_scale_arg_a(regPP_PIXSHADER_I7_C0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C0_neg_arg_a(regPP_PIXSHADER_I7_C0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C0::NEG_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C0_comp_arg_b(regPP_PIXSHADER_I7_C0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C0::COMP_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C0_bias_arg_b(regPP_PIXSHADER_I7_C0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C0_scale_arg_b(regPP_PIXSHADER_I7_C0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C0_neg_arg_b(regPP_PIXSHADER_I7_C0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C0::NEG_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C0_comp_arg_c(regPP_PIXSHADER_I7_C0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C0::COMP_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C0_bias_arg_c(regPP_PIXSHADER_I7_C0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C0_scale_arg_c(regPP_PIXSHADER_I7_C0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C0_neg_arg_c(regPP_PIXSHADER_I7_C0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C0::NEG_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C0_blend_ctl(regPP_PIXSHADER_I7_C0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C0::BLEND_CTL data too large\n");
}
#else
#define set_PP_PIXSHADER_I7_C0_color_arg_a(reg, color_arg_a) (reg)->bitfields.COLOR_ARG_A = color_arg_a
#define set_PP_PIXSHADER_I7_C0_color_arg_b(reg, color_arg_b) (reg)->bitfields.COLOR_ARG_B = color_arg_b
#define set_PP_PIXSHADER_I7_C0_color_arg_c(reg, color_arg_c) (reg)->bitfields.COLOR_ARG_C = color_arg_c
#define set_PP_PIXSHADER_I7_C0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_PIXSHADER_I7_C0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_PIXSHADER_I7_C0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_PIXSHADER_I7_C0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_PIXSHADER_I7_C0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_PIXSHADER_I7_C0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_PIXSHADER_I7_C0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_PIXSHADER_I7_C0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_PIXSHADER_I7_C0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_PIXSHADER_I7_C0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_PIXSHADER_I7_C0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_PIXSHADER_I7_C0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_PIXSHADER_I7_C0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I0_C1 regPP_PIXSHADER_I0_C1;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I0_C1_f0_sel(regPP_PIXSHADER_I0_C1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C1::F0_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C1_f1_sel(regPP_PIXSHADER_I0_C1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C1::F1_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C1_output_scale(regPP_PIXSHADER_I0_C1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C1_output_clamp(regPP_PIXSHADER_I0_C1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C1_output_select(regPP_PIXSHADER_I0_C1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C1_output_mask(regPP_PIXSHADER_I0_C1 *reg, unsigned int output_mask)
{
  reg->bitfields.OUTPUT_MASK = output_mask;
  if (reg->bitfields.OUTPUT_MASK != output_mask) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C1::OUTPUT_MASK data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C1_output_rotate(regPP_PIXSHADER_I0_C1 *reg, unsigned int output_rotate)
{
  reg->bitfields.OUTPUT_ROTATE = output_rotate;
  if (reg->bitfields.OUTPUT_ROTATE != output_rotate) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C1::OUTPUT_ROTATE data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C1_replicate_arg_a(regPP_PIXSHADER_I0_C1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C1_replicate_arg_b(regPP_PIXSHADER_I0_C1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I0_C1_replicate_arg_c(regPP_PIXSHADER_I0_C1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_C1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_PIXSHADER_I0_C1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_PIXSHADER_I0_C1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_PIXSHADER_I0_C1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_PIXSHADER_I0_C1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_PIXSHADER_I0_C1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_PIXSHADER_I0_C1_output_mask(reg, output_mask) (reg)->bitfields.OUTPUT_MASK = output_mask
#define set_PP_PIXSHADER_I0_C1_output_rotate(reg, output_rotate) (reg)->bitfields.OUTPUT_ROTATE = output_rotate
#define set_PP_PIXSHADER_I0_C1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_PIXSHADER_I0_C1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_PIXSHADER_I0_C1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I1_C1 regPP_PIXSHADER_I1_C1;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I1_C1_f0_sel(regPP_PIXSHADER_I1_C1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C1::F0_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C1_f1_sel(regPP_PIXSHADER_I1_C1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C1::F1_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C1_output_scale(regPP_PIXSHADER_I1_C1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C1_output_clamp(regPP_PIXSHADER_I1_C1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C1_output_select(regPP_PIXSHADER_I1_C1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C1_output_mask(regPP_PIXSHADER_I1_C1 *reg, unsigned int output_mask)
{
  reg->bitfields.OUTPUT_MASK = output_mask;
  if (reg->bitfields.OUTPUT_MASK != output_mask) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C1::OUTPUT_MASK data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C1_output_rotate(regPP_PIXSHADER_I1_C1 *reg, unsigned int output_rotate)
{
  reg->bitfields.OUTPUT_ROTATE = output_rotate;
  if (reg->bitfields.OUTPUT_ROTATE != output_rotate) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C1::OUTPUT_ROTATE data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C1_replicate_arg_a(regPP_PIXSHADER_I1_C1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C1_replicate_arg_b(regPP_PIXSHADER_I1_C1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I1_C1_replicate_arg_c(regPP_PIXSHADER_I1_C1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_C1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_PIXSHADER_I1_C1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_PIXSHADER_I1_C1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_PIXSHADER_I1_C1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_PIXSHADER_I1_C1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_PIXSHADER_I1_C1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_PIXSHADER_I1_C1_output_mask(reg, output_mask) (reg)->bitfields.OUTPUT_MASK = output_mask
#define set_PP_PIXSHADER_I1_C1_output_rotate(reg, output_rotate) (reg)->bitfields.OUTPUT_ROTATE = output_rotate
#define set_PP_PIXSHADER_I1_C1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_PIXSHADER_I1_C1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_PIXSHADER_I1_C1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I2_C1 regPP_PIXSHADER_I2_C1;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I2_C1_f0_sel(regPP_PIXSHADER_I2_C1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C1::F0_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C1_f1_sel(regPP_PIXSHADER_I2_C1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C1::F1_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C1_output_scale(regPP_PIXSHADER_I2_C1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C1_output_clamp(regPP_PIXSHADER_I2_C1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C1_output_select(regPP_PIXSHADER_I2_C1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C1_output_mask(regPP_PIXSHADER_I2_C1 *reg, unsigned int output_mask)
{
  reg->bitfields.OUTPUT_MASK = output_mask;
  if (reg->bitfields.OUTPUT_MASK != output_mask) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C1::OUTPUT_MASK data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C1_output_rotate(regPP_PIXSHADER_I2_C1 *reg, unsigned int output_rotate)
{
  reg->bitfields.OUTPUT_ROTATE = output_rotate;
  if (reg->bitfields.OUTPUT_ROTATE != output_rotate) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C1::OUTPUT_ROTATE data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C1_replicate_arg_a(regPP_PIXSHADER_I2_C1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C1_replicate_arg_b(regPP_PIXSHADER_I2_C1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I2_C1_replicate_arg_c(regPP_PIXSHADER_I2_C1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_C1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_PIXSHADER_I2_C1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_PIXSHADER_I2_C1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_PIXSHADER_I2_C1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_PIXSHADER_I2_C1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_PIXSHADER_I2_C1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_PIXSHADER_I2_C1_output_mask(reg, output_mask) (reg)->bitfields.OUTPUT_MASK = output_mask
#define set_PP_PIXSHADER_I2_C1_output_rotate(reg, output_rotate) (reg)->bitfields.OUTPUT_ROTATE = output_rotate
#define set_PP_PIXSHADER_I2_C1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_PIXSHADER_I2_C1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_PIXSHADER_I2_C1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I3_C1 regPP_PIXSHADER_I3_C1;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I3_C1_f0_sel(regPP_PIXSHADER_I3_C1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C1::F0_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C1_f1_sel(regPP_PIXSHADER_I3_C1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C1::F1_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C1_output_scale(regPP_PIXSHADER_I3_C1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C1_output_clamp(regPP_PIXSHADER_I3_C1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C1_output_select(regPP_PIXSHADER_I3_C1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C1_output_mask(regPP_PIXSHADER_I3_C1 *reg, unsigned int output_mask)
{
  reg->bitfields.OUTPUT_MASK = output_mask;
  if (reg->bitfields.OUTPUT_MASK != output_mask) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C1::OUTPUT_MASK data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C1_output_rotate(regPP_PIXSHADER_I3_C1 *reg, unsigned int output_rotate)
{
  reg->bitfields.OUTPUT_ROTATE = output_rotate;
  if (reg->bitfields.OUTPUT_ROTATE != output_rotate) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C1::OUTPUT_ROTATE data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C1_replicate_arg_a(regPP_PIXSHADER_I3_C1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C1_replicate_arg_b(regPP_PIXSHADER_I3_C1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I3_C1_replicate_arg_c(regPP_PIXSHADER_I3_C1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_C1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_PIXSHADER_I3_C1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_PIXSHADER_I3_C1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_PIXSHADER_I3_C1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_PIXSHADER_I3_C1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_PIXSHADER_I3_C1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_PIXSHADER_I3_C1_output_mask(reg, output_mask) (reg)->bitfields.OUTPUT_MASK = output_mask
#define set_PP_PIXSHADER_I3_C1_output_rotate(reg, output_rotate) (reg)->bitfields.OUTPUT_ROTATE = output_rotate
#define set_PP_PIXSHADER_I3_C1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_PIXSHADER_I3_C1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_PIXSHADER_I3_C1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I4_C1 regPP_PIXSHADER_I4_C1;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I4_C1_f0_sel(regPP_PIXSHADER_I4_C1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C1::F0_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C1_f1_sel(regPP_PIXSHADER_I4_C1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C1::F1_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C1_output_scale(regPP_PIXSHADER_I4_C1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C1_output_clamp(regPP_PIXSHADER_I4_C1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C1_output_select(regPP_PIXSHADER_I4_C1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C1_output_mask(regPP_PIXSHADER_I4_C1 *reg, unsigned int output_mask)
{
  reg->bitfields.OUTPUT_MASK = output_mask;
  if (reg->bitfields.OUTPUT_MASK != output_mask) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C1::OUTPUT_MASK data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C1_output_rotate(regPP_PIXSHADER_I4_C1 *reg, unsigned int output_rotate)
{
  reg->bitfields.OUTPUT_ROTATE = output_rotate;
  if (reg->bitfields.OUTPUT_ROTATE != output_rotate) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C1::OUTPUT_ROTATE data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C1_replicate_arg_a(regPP_PIXSHADER_I4_C1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C1_replicate_arg_b(regPP_PIXSHADER_I4_C1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I4_C1_replicate_arg_c(regPP_PIXSHADER_I4_C1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_C1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_PIXSHADER_I4_C1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_PIXSHADER_I4_C1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_PIXSHADER_I4_C1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_PIXSHADER_I4_C1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_PIXSHADER_I4_C1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_PIXSHADER_I4_C1_output_mask(reg, output_mask) (reg)->bitfields.OUTPUT_MASK = output_mask
#define set_PP_PIXSHADER_I4_C1_output_rotate(reg, output_rotate) (reg)->bitfields.OUTPUT_ROTATE = output_rotate
#define set_PP_PIXSHADER_I4_C1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_PIXSHADER_I4_C1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_PIXSHADER_I4_C1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I5_C1 regPP_PIXSHADER_I5_C1;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I5_C1_f0_sel(regPP_PIXSHADER_I5_C1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C1::F0_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C1_f1_sel(regPP_PIXSHADER_I5_C1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C1::F1_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C1_output_scale(regPP_PIXSHADER_I5_C1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C1_output_clamp(regPP_PIXSHADER_I5_C1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C1_output_select(regPP_PIXSHADER_I5_C1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C1_output_mask(regPP_PIXSHADER_I5_C1 *reg, unsigned int output_mask)
{
  reg->bitfields.OUTPUT_MASK = output_mask;
  if (reg->bitfields.OUTPUT_MASK != output_mask) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C1::OUTPUT_MASK data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C1_output_rotate(regPP_PIXSHADER_I5_C1 *reg, unsigned int output_rotate)
{
  reg->bitfields.OUTPUT_ROTATE = output_rotate;
  if (reg->bitfields.OUTPUT_ROTATE != output_rotate) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C1::OUTPUT_ROTATE data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C1_replicate_arg_a(regPP_PIXSHADER_I5_C1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C1_replicate_arg_b(regPP_PIXSHADER_I5_C1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I5_C1_replicate_arg_c(regPP_PIXSHADER_I5_C1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_C1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_PIXSHADER_I5_C1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_PIXSHADER_I5_C1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_PIXSHADER_I5_C1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_PIXSHADER_I5_C1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_PIXSHADER_I5_C1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_PIXSHADER_I5_C1_output_mask(reg, output_mask) (reg)->bitfields.OUTPUT_MASK = output_mask
#define set_PP_PIXSHADER_I5_C1_output_rotate(reg, output_rotate) (reg)->bitfields.OUTPUT_ROTATE = output_rotate
#define set_PP_PIXSHADER_I5_C1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_PIXSHADER_I5_C1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_PIXSHADER_I5_C1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I6_C1 regPP_PIXSHADER_I6_C1;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I6_C1_f0_sel(regPP_PIXSHADER_I6_C1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C1::F0_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C1_f1_sel(regPP_PIXSHADER_I6_C1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C1::F1_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C1_output_scale(regPP_PIXSHADER_I6_C1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C1_output_clamp(regPP_PIXSHADER_I6_C1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C1_output_select(regPP_PIXSHADER_I6_C1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C1_output_mask(regPP_PIXSHADER_I6_C1 *reg, unsigned int output_mask)
{
  reg->bitfields.OUTPUT_MASK = output_mask;
  if (reg->bitfields.OUTPUT_MASK != output_mask) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C1::OUTPUT_MASK data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C1_output_rotate(regPP_PIXSHADER_I6_C1 *reg, unsigned int output_rotate)
{
  reg->bitfields.OUTPUT_ROTATE = output_rotate;
  if (reg->bitfields.OUTPUT_ROTATE != output_rotate) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C1::OUTPUT_ROTATE data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C1_replicate_arg_a(regPP_PIXSHADER_I6_C1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C1_replicate_arg_b(regPP_PIXSHADER_I6_C1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I6_C1_replicate_arg_c(regPP_PIXSHADER_I6_C1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_C1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_PIXSHADER_I6_C1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_PIXSHADER_I6_C1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_PIXSHADER_I6_C1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_PIXSHADER_I6_C1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_PIXSHADER_I6_C1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_PIXSHADER_I6_C1_output_mask(reg, output_mask) (reg)->bitfields.OUTPUT_MASK = output_mask
#define set_PP_PIXSHADER_I6_C1_output_rotate(reg, output_rotate) (reg)->bitfields.OUTPUT_ROTATE = output_rotate
#define set_PP_PIXSHADER_I6_C1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_PIXSHADER_I6_C1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_PIXSHADER_I6_C1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I7_C1 regPP_PIXSHADER_I7_C1;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I7_C1_f0_sel(regPP_PIXSHADER_I7_C1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C1::F0_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C1_f1_sel(regPP_PIXSHADER_I7_C1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C1::F1_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C1_output_scale(regPP_PIXSHADER_I7_C1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C1_output_clamp(regPP_PIXSHADER_I7_C1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C1_output_select(regPP_PIXSHADER_I7_C1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C1_output_mask(regPP_PIXSHADER_I7_C1 *reg, unsigned int output_mask)
{
  reg->bitfields.OUTPUT_MASK = output_mask;
  if (reg->bitfields.OUTPUT_MASK != output_mask) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C1::OUTPUT_MASK data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C1_output_rotate(regPP_PIXSHADER_I7_C1 *reg, unsigned int output_rotate)
{
  reg->bitfields.OUTPUT_ROTATE = output_rotate;
  if (reg->bitfields.OUTPUT_ROTATE != output_rotate) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C1::OUTPUT_ROTATE data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C1_replicate_arg_a(regPP_PIXSHADER_I7_C1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C1_replicate_arg_b(regPP_PIXSHADER_I7_C1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I7_C1_replicate_arg_c(regPP_PIXSHADER_I7_C1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_C1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_PIXSHADER_I7_C1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_PIXSHADER_I7_C1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_PIXSHADER_I7_C1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_PIXSHADER_I7_C1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_PIXSHADER_I7_C1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_PIXSHADER_I7_C1_output_mask(reg, output_mask) (reg)->bitfields.OUTPUT_MASK = output_mask
#define set_PP_PIXSHADER_I7_C1_output_rotate(reg, output_rotate) (reg)->bitfields.OUTPUT_ROTATE = output_rotate
#define set_PP_PIXSHADER_I7_C1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_PIXSHADER_I7_C1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_PIXSHADER_I7_C1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I0_A0 regPP_PIXSHADER_I0_A0;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I0_A0_alpha_arg_a(regPP_PIXSHADER_I0_A0 *reg, unsigned int alpha_arg_a)
{
  reg->bitfields.ALPHA_ARG_A = alpha_arg_a;
  if (reg->bitfields.ALPHA_ARG_A != alpha_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A0::ALPHA_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A0_alpha_arg_b(regPP_PIXSHADER_I0_A0 *reg, unsigned int alpha_arg_b)
{
  reg->bitfields.ALPHA_ARG_B = alpha_arg_b;
  if (reg->bitfields.ALPHA_ARG_B != alpha_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A0::ALPHA_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A0_alpha_arg_c(regPP_PIXSHADER_I0_A0 *reg, unsigned int alpha_arg_c)
{
  reg->bitfields.ALPHA_ARG_C = alpha_arg_c;
  if (reg->bitfields.ALPHA_ARG_C != alpha_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A0::ALPHA_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A0_comp_arg_a(regPP_PIXSHADER_I0_A0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A0::COMP_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A0_bias_arg_a(regPP_PIXSHADER_I0_A0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A0_scale_arg_a(regPP_PIXSHADER_I0_A0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A0_neg_arg_a(regPP_PIXSHADER_I0_A0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A0::NEG_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A0_comp_arg_b(regPP_PIXSHADER_I0_A0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A0::COMP_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A0_bias_arg_b(regPP_PIXSHADER_I0_A0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A0_scale_arg_b(regPP_PIXSHADER_I0_A0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A0_neg_arg_b(regPP_PIXSHADER_I0_A0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A0::NEG_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A0_comp_arg_c(regPP_PIXSHADER_I0_A0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A0::COMP_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A0_bias_arg_c(regPP_PIXSHADER_I0_A0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A0_scale_arg_c(regPP_PIXSHADER_I0_A0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A0_neg_arg_c(regPP_PIXSHADER_I0_A0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A0::NEG_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A0_blend_ctl(regPP_PIXSHADER_I0_A0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A0::BLEND_CTL data too large\n");
}
#else
#define set_PP_PIXSHADER_I0_A0_alpha_arg_a(reg, alpha_arg_a) (reg)->bitfields.ALPHA_ARG_A = alpha_arg_a
#define set_PP_PIXSHADER_I0_A0_alpha_arg_b(reg, alpha_arg_b) (reg)->bitfields.ALPHA_ARG_B = alpha_arg_b
#define set_PP_PIXSHADER_I0_A0_alpha_arg_c(reg, alpha_arg_c) (reg)->bitfields.ALPHA_ARG_C = alpha_arg_c
#define set_PP_PIXSHADER_I0_A0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_PIXSHADER_I0_A0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_PIXSHADER_I0_A0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_PIXSHADER_I0_A0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_PIXSHADER_I0_A0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_PIXSHADER_I0_A0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_PIXSHADER_I0_A0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_PIXSHADER_I0_A0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_PIXSHADER_I0_A0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_PIXSHADER_I0_A0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_PIXSHADER_I0_A0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_PIXSHADER_I0_A0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_PIXSHADER_I0_A0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I1_A0 regPP_PIXSHADER_I1_A0;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I1_A0_alpha_arg_a(regPP_PIXSHADER_I1_A0 *reg, unsigned int alpha_arg_a)
{
  reg->bitfields.ALPHA_ARG_A = alpha_arg_a;
  if (reg->bitfields.ALPHA_ARG_A != alpha_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A0::ALPHA_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A0_alpha_arg_b(regPP_PIXSHADER_I1_A0 *reg, unsigned int alpha_arg_b)
{
  reg->bitfields.ALPHA_ARG_B = alpha_arg_b;
  if (reg->bitfields.ALPHA_ARG_B != alpha_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A0::ALPHA_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A0_alpha_arg_c(regPP_PIXSHADER_I1_A0 *reg, unsigned int alpha_arg_c)
{
  reg->bitfields.ALPHA_ARG_C = alpha_arg_c;
  if (reg->bitfields.ALPHA_ARG_C != alpha_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A0::ALPHA_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A0_comp_arg_a(regPP_PIXSHADER_I1_A0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A0::COMP_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A0_bias_arg_a(regPP_PIXSHADER_I1_A0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A0_scale_arg_a(regPP_PIXSHADER_I1_A0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A0_neg_arg_a(regPP_PIXSHADER_I1_A0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A0::NEG_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A0_comp_arg_b(regPP_PIXSHADER_I1_A0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A0::COMP_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A0_bias_arg_b(regPP_PIXSHADER_I1_A0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A0_scale_arg_b(regPP_PIXSHADER_I1_A0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A0_neg_arg_b(regPP_PIXSHADER_I1_A0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A0::NEG_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A0_comp_arg_c(regPP_PIXSHADER_I1_A0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A0::COMP_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A0_bias_arg_c(regPP_PIXSHADER_I1_A0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A0_scale_arg_c(regPP_PIXSHADER_I1_A0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A0_neg_arg_c(regPP_PIXSHADER_I1_A0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A0::NEG_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A0_blend_ctl(regPP_PIXSHADER_I1_A0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A0::BLEND_CTL data too large\n");
}
#else
#define set_PP_PIXSHADER_I1_A0_alpha_arg_a(reg, alpha_arg_a) (reg)->bitfields.ALPHA_ARG_A = alpha_arg_a
#define set_PP_PIXSHADER_I1_A0_alpha_arg_b(reg, alpha_arg_b) (reg)->bitfields.ALPHA_ARG_B = alpha_arg_b
#define set_PP_PIXSHADER_I1_A0_alpha_arg_c(reg, alpha_arg_c) (reg)->bitfields.ALPHA_ARG_C = alpha_arg_c
#define set_PP_PIXSHADER_I1_A0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_PIXSHADER_I1_A0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_PIXSHADER_I1_A0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_PIXSHADER_I1_A0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_PIXSHADER_I1_A0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_PIXSHADER_I1_A0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_PIXSHADER_I1_A0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_PIXSHADER_I1_A0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_PIXSHADER_I1_A0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_PIXSHADER_I1_A0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_PIXSHADER_I1_A0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_PIXSHADER_I1_A0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_PIXSHADER_I1_A0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I2_A0 regPP_PIXSHADER_I2_A0;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I2_A0_alpha_arg_a(regPP_PIXSHADER_I2_A0 *reg, unsigned int alpha_arg_a)
{
  reg->bitfields.ALPHA_ARG_A = alpha_arg_a;
  if (reg->bitfields.ALPHA_ARG_A != alpha_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A0::ALPHA_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A0_alpha_arg_b(regPP_PIXSHADER_I2_A0 *reg, unsigned int alpha_arg_b)
{
  reg->bitfields.ALPHA_ARG_B = alpha_arg_b;
  if (reg->bitfields.ALPHA_ARG_B != alpha_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A0::ALPHA_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A0_alpha_arg_c(regPP_PIXSHADER_I2_A0 *reg, unsigned int alpha_arg_c)
{
  reg->bitfields.ALPHA_ARG_C = alpha_arg_c;
  if (reg->bitfields.ALPHA_ARG_C != alpha_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A0::ALPHA_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A0_comp_arg_a(regPP_PIXSHADER_I2_A0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A0::COMP_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A0_bias_arg_a(regPP_PIXSHADER_I2_A0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A0_scale_arg_a(regPP_PIXSHADER_I2_A0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A0_neg_arg_a(regPP_PIXSHADER_I2_A0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A0::NEG_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A0_comp_arg_b(regPP_PIXSHADER_I2_A0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A0::COMP_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A0_bias_arg_b(regPP_PIXSHADER_I2_A0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A0_scale_arg_b(regPP_PIXSHADER_I2_A0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A0_neg_arg_b(regPP_PIXSHADER_I2_A0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A0::NEG_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A0_comp_arg_c(regPP_PIXSHADER_I2_A0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A0::COMP_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A0_bias_arg_c(regPP_PIXSHADER_I2_A0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A0_scale_arg_c(regPP_PIXSHADER_I2_A0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A0_neg_arg_c(regPP_PIXSHADER_I2_A0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A0::NEG_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A0_blend_ctl(regPP_PIXSHADER_I2_A0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A0::BLEND_CTL data too large\n");
}
#else
#define set_PP_PIXSHADER_I2_A0_alpha_arg_a(reg, alpha_arg_a) (reg)->bitfields.ALPHA_ARG_A = alpha_arg_a
#define set_PP_PIXSHADER_I2_A0_alpha_arg_b(reg, alpha_arg_b) (reg)->bitfields.ALPHA_ARG_B = alpha_arg_b
#define set_PP_PIXSHADER_I2_A0_alpha_arg_c(reg, alpha_arg_c) (reg)->bitfields.ALPHA_ARG_C = alpha_arg_c
#define set_PP_PIXSHADER_I2_A0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_PIXSHADER_I2_A0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_PIXSHADER_I2_A0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_PIXSHADER_I2_A0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_PIXSHADER_I2_A0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_PIXSHADER_I2_A0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_PIXSHADER_I2_A0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_PIXSHADER_I2_A0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_PIXSHADER_I2_A0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_PIXSHADER_I2_A0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_PIXSHADER_I2_A0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_PIXSHADER_I2_A0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_PIXSHADER_I2_A0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I3_A0 regPP_PIXSHADER_I3_A0;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I3_A0_alpha_arg_a(regPP_PIXSHADER_I3_A0 *reg, unsigned int alpha_arg_a)
{
  reg->bitfields.ALPHA_ARG_A = alpha_arg_a;
  if (reg->bitfields.ALPHA_ARG_A != alpha_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A0::ALPHA_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A0_alpha_arg_b(regPP_PIXSHADER_I3_A0 *reg, unsigned int alpha_arg_b)
{
  reg->bitfields.ALPHA_ARG_B = alpha_arg_b;
  if (reg->bitfields.ALPHA_ARG_B != alpha_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A0::ALPHA_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A0_alpha_arg_c(regPP_PIXSHADER_I3_A0 *reg, unsigned int alpha_arg_c)
{
  reg->bitfields.ALPHA_ARG_C = alpha_arg_c;
  if (reg->bitfields.ALPHA_ARG_C != alpha_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A0::ALPHA_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A0_comp_arg_a(regPP_PIXSHADER_I3_A0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A0::COMP_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A0_bias_arg_a(regPP_PIXSHADER_I3_A0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A0_scale_arg_a(regPP_PIXSHADER_I3_A0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A0_neg_arg_a(regPP_PIXSHADER_I3_A0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A0::NEG_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A0_comp_arg_b(regPP_PIXSHADER_I3_A0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A0::COMP_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A0_bias_arg_b(regPP_PIXSHADER_I3_A0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A0_scale_arg_b(regPP_PIXSHADER_I3_A0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A0_neg_arg_b(regPP_PIXSHADER_I3_A0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A0::NEG_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A0_comp_arg_c(regPP_PIXSHADER_I3_A0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A0::COMP_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A0_bias_arg_c(regPP_PIXSHADER_I3_A0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A0_scale_arg_c(regPP_PIXSHADER_I3_A0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A0_neg_arg_c(regPP_PIXSHADER_I3_A0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A0::NEG_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A0_blend_ctl(regPP_PIXSHADER_I3_A0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A0::BLEND_CTL data too large\n");
}
#else
#define set_PP_PIXSHADER_I3_A0_alpha_arg_a(reg, alpha_arg_a) (reg)->bitfields.ALPHA_ARG_A = alpha_arg_a
#define set_PP_PIXSHADER_I3_A0_alpha_arg_b(reg, alpha_arg_b) (reg)->bitfields.ALPHA_ARG_B = alpha_arg_b
#define set_PP_PIXSHADER_I3_A0_alpha_arg_c(reg, alpha_arg_c) (reg)->bitfields.ALPHA_ARG_C = alpha_arg_c
#define set_PP_PIXSHADER_I3_A0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_PIXSHADER_I3_A0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_PIXSHADER_I3_A0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_PIXSHADER_I3_A0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_PIXSHADER_I3_A0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_PIXSHADER_I3_A0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_PIXSHADER_I3_A0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_PIXSHADER_I3_A0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_PIXSHADER_I3_A0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_PIXSHADER_I3_A0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_PIXSHADER_I3_A0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_PIXSHADER_I3_A0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_PIXSHADER_I3_A0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I4_A0 regPP_PIXSHADER_I4_A0;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I4_A0_alpha_arg_a(regPP_PIXSHADER_I4_A0 *reg, unsigned int alpha_arg_a)
{
  reg->bitfields.ALPHA_ARG_A = alpha_arg_a;
  if (reg->bitfields.ALPHA_ARG_A != alpha_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A0::ALPHA_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A0_alpha_arg_b(regPP_PIXSHADER_I4_A0 *reg, unsigned int alpha_arg_b)
{
  reg->bitfields.ALPHA_ARG_B = alpha_arg_b;
  if (reg->bitfields.ALPHA_ARG_B != alpha_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A0::ALPHA_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A0_alpha_arg_c(regPP_PIXSHADER_I4_A0 *reg, unsigned int alpha_arg_c)
{
  reg->bitfields.ALPHA_ARG_C = alpha_arg_c;
  if (reg->bitfields.ALPHA_ARG_C != alpha_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A0::ALPHA_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A0_comp_arg_a(regPP_PIXSHADER_I4_A0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A0::COMP_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A0_bias_arg_a(regPP_PIXSHADER_I4_A0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A0_scale_arg_a(regPP_PIXSHADER_I4_A0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A0_neg_arg_a(regPP_PIXSHADER_I4_A0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A0::NEG_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A0_comp_arg_b(regPP_PIXSHADER_I4_A0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A0::COMP_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A0_bias_arg_b(regPP_PIXSHADER_I4_A0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A0_scale_arg_b(regPP_PIXSHADER_I4_A0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A0_neg_arg_b(regPP_PIXSHADER_I4_A0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A0::NEG_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A0_comp_arg_c(regPP_PIXSHADER_I4_A0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A0::COMP_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A0_bias_arg_c(regPP_PIXSHADER_I4_A0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A0_scale_arg_c(regPP_PIXSHADER_I4_A0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A0_neg_arg_c(regPP_PIXSHADER_I4_A0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A0::NEG_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A0_blend_ctl(regPP_PIXSHADER_I4_A0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A0::BLEND_CTL data too large\n");
}
#else
#define set_PP_PIXSHADER_I4_A0_alpha_arg_a(reg, alpha_arg_a) (reg)->bitfields.ALPHA_ARG_A = alpha_arg_a
#define set_PP_PIXSHADER_I4_A0_alpha_arg_b(reg, alpha_arg_b) (reg)->bitfields.ALPHA_ARG_B = alpha_arg_b
#define set_PP_PIXSHADER_I4_A0_alpha_arg_c(reg, alpha_arg_c) (reg)->bitfields.ALPHA_ARG_C = alpha_arg_c
#define set_PP_PIXSHADER_I4_A0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_PIXSHADER_I4_A0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_PIXSHADER_I4_A0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_PIXSHADER_I4_A0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_PIXSHADER_I4_A0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_PIXSHADER_I4_A0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_PIXSHADER_I4_A0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_PIXSHADER_I4_A0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_PIXSHADER_I4_A0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_PIXSHADER_I4_A0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_PIXSHADER_I4_A0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_PIXSHADER_I4_A0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_PIXSHADER_I4_A0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I5_A0 regPP_PIXSHADER_I5_A0;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I5_A0_alpha_arg_a(regPP_PIXSHADER_I5_A0 *reg, unsigned int alpha_arg_a)
{
  reg->bitfields.ALPHA_ARG_A = alpha_arg_a;
  if (reg->bitfields.ALPHA_ARG_A != alpha_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A0::ALPHA_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A0_alpha_arg_b(regPP_PIXSHADER_I5_A0 *reg, unsigned int alpha_arg_b)
{
  reg->bitfields.ALPHA_ARG_B = alpha_arg_b;
  if (reg->bitfields.ALPHA_ARG_B != alpha_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A0::ALPHA_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A0_alpha_arg_c(regPP_PIXSHADER_I5_A0 *reg, unsigned int alpha_arg_c)
{
  reg->bitfields.ALPHA_ARG_C = alpha_arg_c;
  if (reg->bitfields.ALPHA_ARG_C != alpha_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A0::ALPHA_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A0_comp_arg_a(regPP_PIXSHADER_I5_A0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A0::COMP_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A0_bias_arg_a(regPP_PIXSHADER_I5_A0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A0_scale_arg_a(regPP_PIXSHADER_I5_A0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A0_neg_arg_a(regPP_PIXSHADER_I5_A0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A0::NEG_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A0_comp_arg_b(regPP_PIXSHADER_I5_A0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A0::COMP_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A0_bias_arg_b(regPP_PIXSHADER_I5_A0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A0_scale_arg_b(regPP_PIXSHADER_I5_A0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A0_neg_arg_b(regPP_PIXSHADER_I5_A0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A0::NEG_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A0_comp_arg_c(regPP_PIXSHADER_I5_A0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A0::COMP_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A0_bias_arg_c(regPP_PIXSHADER_I5_A0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A0_scale_arg_c(regPP_PIXSHADER_I5_A0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A0_neg_arg_c(regPP_PIXSHADER_I5_A0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A0::NEG_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A0_blend_ctl(regPP_PIXSHADER_I5_A0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A0::BLEND_CTL data too large\n");
}
#else
#define set_PP_PIXSHADER_I5_A0_alpha_arg_a(reg, alpha_arg_a) (reg)->bitfields.ALPHA_ARG_A = alpha_arg_a
#define set_PP_PIXSHADER_I5_A0_alpha_arg_b(reg, alpha_arg_b) (reg)->bitfields.ALPHA_ARG_B = alpha_arg_b
#define set_PP_PIXSHADER_I5_A0_alpha_arg_c(reg, alpha_arg_c) (reg)->bitfields.ALPHA_ARG_C = alpha_arg_c
#define set_PP_PIXSHADER_I5_A0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_PIXSHADER_I5_A0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_PIXSHADER_I5_A0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_PIXSHADER_I5_A0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_PIXSHADER_I5_A0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_PIXSHADER_I5_A0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_PIXSHADER_I5_A0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_PIXSHADER_I5_A0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_PIXSHADER_I5_A0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_PIXSHADER_I5_A0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_PIXSHADER_I5_A0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_PIXSHADER_I5_A0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_PIXSHADER_I5_A0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I6_A0 regPP_PIXSHADER_I6_A0;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I6_A0_alpha_arg_a(regPP_PIXSHADER_I6_A0 *reg, unsigned int alpha_arg_a)
{
  reg->bitfields.ALPHA_ARG_A = alpha_arg_a;
  if (reg->bitfields.ALPHA_ARG_A != alpha_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A0::ALPHA_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A0_alpha_arg_b(regPP_PIXSHADER_I6_A0 *reg, unsigned int alpha_arg_b)
{
  reg->bitfields.ALPHA_ARG_B = alpha_arg_b;
  if (reg->bitfields.ALPHA_ARG_B != alpha_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A0::ALPHA_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A0_alpha_arg_c(regPP_PIXSHADER_I6_A0 *reg, unsigned int alpha_arg_c)
{
  reg->bitfields.ALPHA_ARG_C = alpha_arg_c;
  if (reg->bitfields.ALPHA_ARG_C != alpha_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A0::ALPHA_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A0_comp_arg_a(regPP_PIXSHADER_I6_A0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A0::COMP_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A0_bias_arg_a(regPP_PIXSHADER_I6_A0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A0_scale_arg_a(regPP_PIXSHADER_I6_A0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A0_neg_arg_a(regPP_PIXSHADER_I6_A0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A0::NEG_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A0_comp_arg_b(regPP_PIXSHADER_I6_A0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A0::COMP_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A0_bias_arg_b(regPP_PIXSHADER_I6_A0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A0_scale_arg_b(regPP_PIXSHADER_I6_A0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A0_neg_arg_b(regPP_PIXSHADER_I6_A0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A0::NEG_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A0_comp_arg_c(regPP_PIXSHADER_I6_A0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A0::COMP_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A0_bias_arg_c(regPP_PIXSHADER_I6_A0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A0_scale_arg_c(regPP_PIXSHADER_I6_A0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A0_neg_arg_c(regPP_PIXSHADER_I6_A0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A0::NEG_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A0_blend_ctl(regPP_PIXSHADER_I6_A0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A0::BLEND_CTL data too large\n");
}
#else
#define set_PP_PIXSHADER_I6_A0_alpha_arg_a(reg, alpha_arg_a) (reg)->bitfields.ALPHA_ARG_A = alpha_arg_a
#define set_PP_PIXSHADER_I6_A0_alpha_arg_b(reg, alpha_arg_b) (reg)->bitfields.ALPHA_ARG_B = alpha_arg_b
#define set_PP_PIXSHADER_I6_A0_alpha_arg_c(reg, alpha_arg_c) (reg)->bitfields.ALPHA_ARG_C = alpha_arg_c
#define set_PP_PIXSHADER_I6_A0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_PIXSHADER_I6_A0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_PIXSHADER_I6_A0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_PIXSHADER_I6_A0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_PIXSHADER_I6_A0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_PIXSHADER_I6_A0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_PIXSHADER_I6_A0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_PIXSHADER_I6_A0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_PIXSHADER_I6_A0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_PIXSHADER_I6_A0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_PIXSHADER_I6_A0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_PIXSHADER_I6_A0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_PIXSHADER_I6_A0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I7_A0 regPP_PIXSHADER_I7_A0;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I7_A0_alpha_arg_a(regPP_PIXSHADER_I7_A0 *reg, unsigned int alpha_arg_a)
{
  reg->bitfields.ALPHA_ARG_A = alpha_arg_a;
  if (reg->bitfields.ALPHA_ARG_A != alpha_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A0::ALPHA_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A0_alpha_arg_b(regPP_PIXSHADER_I7_A0 *reg, unsigned int alpha_arg_b)
{
  reg->bitfields.ALPHA_ARG_B = alpha_arg_b;
  if (reg->bitfields.ALPHA_ARG_B != alpha_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A0::ALPHA_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A0_alpha_arg_c(regPP_PIXSHADER_I7_A0 *reg, unsigned int alpha_arg_c)
{
  reg->bitfields.ALPHA_ARG_C = alpha_arg_c;
  if (reg->bitfields.ALPHA_ARG_C != alpha_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A0::ALPHA_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A0_comp_arg_a(regPP_PIXSHADER_I7_A0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A0::COMP_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A0_bias_arg_a(regPP_PIXSHADER_I7_A0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A0_scale_arg_a(regPP_PIXSHADER_I7_A0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A0_neg_arg_a(regPP_PIXSHADER_I7_A0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A0::NEG_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A0_comp_arg_b(regPP_PIXSHADER_I7_A0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A0::COMP_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A0_bias_arg_b(regPP_PIXSHADER_I7_A0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A0_scale_arg_b(regPP_PIXSHADER_I7_A0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A0_neg_arg_b(regPP_PIXSHADER_I7_A0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A0::NEG_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A0_comp_arg_c(regPP_PIXSHADER_I7_A0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A0::COMP_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A0_bias_arg_c(regPP_PIXSHADER_I7_A0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A0_scale_arg_c(regPP_PIXSHADER_I7_A0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A0_neg_arg_c(regPP_PIXSHADER_I7_A0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A0::NEG_ARG_C data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A0_blend_ctl(regPP_PIXSHADER_I7_A0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A0::BLEND_CTL data too large\n");
}
#else
#define set_PP_PIXSHADER_I7_A0_alpha_arg_a(reg, alpha_arg_a) (reg)->bitfields.ALPHA_ARG_A = alpha_arg_a
#define set_PP_PIXSHADER_I7_A0_alpha_arg_b(reg, alpha_arg_b) (reg)->bitfields.ALPHA_ARG_B = alpha_arg_b
#define set_PP_PIXSHADER_I7_A0_alpha_arg_c(reg, alpha_arg_c) (reg)->bitfields.ALPHA_ARG_C = alpha_arg_c
#define set_PP_PIXSHADER_I7_A0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_PIXSHADER_I7_A0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_PIXSHADER_I7_A0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_PIXSHADER_I7_A0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_PIXSHADER_I7_A0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_PIXSHADER_I7_A0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_PIXSHADER_I7_A0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_PIXSHADER_I7_A0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_PIXSHADER_I7_A0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_PIXSHADER_I7_A0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_PIXSHADER_I7_A0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_PIXSHADER_I7_A0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_PIXSHADER_I7_A0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I0_A1 regPP_PIXSHADER_I0_A1;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I0_A1_f0_sel(regPP_PIXSHADER_I0_A1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A1::F0_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A1_f1_sel(regPP_PIXSHADER_I0_A1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A1::F1_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A1_output_scale(regPP_PIXSHADER_I0_A1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A1_output_clamp(regPP_PIXSHADER_I0_A1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A1_output_select(regPP_PIXSHADER_I0_A1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A1_dot_alpha(regPP_PIXSHADER_I0_A1 *reg, unsigned int dot_alpha)
{
  reg->bitfields.DOT_ALPHA = dot_alpha;
  if (reg->bitfields.DOT_ALPHA != dot_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A1::DOT_ALPHA data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A1_replicate_arg_a(regPP_PIXSHADER_I0_A1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A1_replicate_arg_b(regPP_PIXSHADER_I0_A1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I0_A1_replicate_arg_c(regPP_PIXSHADER_I0_A1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I0_A1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_PIXSHADER_I0_A1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_PIXSHADER_I0_A1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_PIXSHADER_I0_A1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_PIXSHADER_I0_A1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_PIXSHADER_I0_A1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_PIXSHADER_I0_A1_dot_alpha(reg, dot_alpha) (reg)->bitfields.DOT_ALPHA = dot_alpha
#define set_PP_PIXSHADER_I0_A1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_PIXSHADER_I0_A1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_PIXSHADER_I0_A1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I1_A1 regPP_PIXSHADER_I1_A1;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I1_A1_f0_sel(regPP_PIXSHADER_I1_A1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A1::F0_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A1_f1_sel(regPP_PIXSHADER_I1_A1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A1::F1_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A1_output_scale(regPP_PIXSHADER_I1_A1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A1_output_clamp(regPP_PIXSHADER_I1_A1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A1_output_select(regPP_PIXSHADER_I1_A1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A1_dot_alpha(regPP_PIXSHADER_I1_A1 *reg, unsigned int dot_alpha)
{
  reg->bitfields.DOT_ALPHA = dot_alpha;
  if (reg->bitfields.DOT_ALPHA != dot_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A1::DOT_ALPHA data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A1_replicate_arg_a(regPP_PIXSHADER_I1_A1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A1_replicate_arg_b(regPP_PIXSHADER_I1_A1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I1_A1_replicate_arg_c(regPP_PIXSHADER_I1_A1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I1_A1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_PIXSHADER_I1_A1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_PIXSHADER_I1_A1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_PIXSHADER_I1_A1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_PIXSHADER_I1_A1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_PIXSHADER_I1_A1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_PIXSHADER_I1_A1_dot_alpha(reg, dot_alpha) (reg)->bitfields.DOT_ALPHA = dot_alpha
#define set_PP_PIXSHADER_I1_A1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_PIXSHADER_I1_A1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_PIXSHADER_I1_A1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I2_A1 regPP_PIXSHADER_I2_A1;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I2_A1_f0_sel(regPP_PIXSHADER_I2_A1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A1::F0_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A1_f1_sel(regPP_PIXSHADER_I2_A1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A1::F1_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A1_output_scale(regPP_PIXSHADER_I2_A1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A1_output_clamp(regPP_PIXSHADER_I2_A1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A1_output_select(regPP_PIXSHADER_I2_A1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A1_dot_alpha(regPP_PIXSHADER_I2_A1 *reg, unsigned int dot_alpha)
{
  reg->bitfields.DOT_ALPHA = dot_alpha;
  if (reg->bitfields.DOT_ALPHA != dot_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A1::DOT_ALPHA data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A1_replicate_arg_a(regPP_PIXSHADER_I2_A1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A1_replicate_arg_b(regPP_PIXSHADER_I2_A1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I2_A1_replicate_arg_c(regPP_PIXSHADER_I2_A1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I2_A1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_PIXSHADER_I2_A1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_PIXSHADER_I2_A1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_PIXSHADER_I2_A1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_PIXSHADER_I2_A1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_PIXSHADER_I2_A1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_PIXSHADER_I2_A1_dot_alpha(reg, dot_alpha) (reg)->bitfields.DOT_ALPHA = dot_alpha
#define set_PP_PIXSHADER_I2_A1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_PIXSHADER_I2_A1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_PIXSHADER_I2_A1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I3_A1 regPP_PIXSHADER_I3_A1;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I3_A1_f0_sel(regPP_PIXSHADER_I3_A1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A1::F0_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A1_f1_sel(regPP_PIXSHADER_I3_A1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A1::F1_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A1_output_scale(regPP_PIXSHADER_I3_A1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A1_output_clamp(regPP_PIXSHADER_I3_A1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A1_output_select(regPP_PIXSHADER_I3_A1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A1_dot_alpha(regPP_PIXSHADER_I3_A1 *reg, unsigned int dot_alpha)
{
  reg->bitfields.DOT_ALPHA = dot_alpha;
  if (reg->bitfields.DOT_ALPHA != dot_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A1::DOT_ALPHA data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A1_replicate_arg_a(regPP_PIXSHADER_I3_A1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A1_replicate_arg_b(regPP_PIXSHADER_I3_A1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I3_A1_replicate_arg_c(regPP_PIXSHADER_I3_A1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I3_A1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_PIXSHADER_I3_A1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_PIXSHADER_I3_A1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_PIXSHADER_I3_A1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_PIXSHADER_I3_A1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_PIXSHADER_I3_A1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_PIXSHADER_I3_A1_dot_alpha(reg, dot_alpha) (reg)->bitfields.DOT_ALPHA = dot_alpha
#define set_PP_PIXSHADER_I3_A1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_PIXSHADER_I3_A1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_PIXSHADER_I3_A1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I4_A1 regPP_PIXSHADER_I4_A1;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I4_A1_f0_sel(regPP_PIXSHADER_I4_A1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A1::F0_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A1_f1_sel(regPP_PIXSHADER_I4_A1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A1::F1_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A1_output_scale(regPP_PIXSHADER_I4_A1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A1_output_clamp(regPP_PIXSHADER_I4_A1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A1_output_select(regPP_PIXSHADER_I4_A1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A1_dot_alpha(regPP_PIXSHADER_I4_A1 *reg, unsigned int dot_alpha)
{
  reg->bitfields.DOT_ALPHA = dot_alpha;
  if (reg->bitfields.DOT_ALPHA != dot_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A1::DOT_ALPHA data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A1_replicate_arg_a(regPP_PIXSHADER_I4_A1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A1_replicate_arg_b(regPP_PIXSHADER_I4_A1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I4_A1_replicate_arg_c(regPP_PIXSHADER_I4_A1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I4_A1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_PIXSHADER_I4_A1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_PIXSHADER_I4_A1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_PIXSHADER_I4_A1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_PIXSHADER_I4_A1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_PIXSHADER_I4_A1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_PIXSHADER_I4_A1_dot_alpha(reg, dot_alpha) (reg)->bitfields.DOT_ALPHA = dot_alpha
#define set_PP_PIXSHADER_I4_A1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_PIXSHADER_I4_A1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_PIXSHADER_I4_A1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I5_A1 regPP_PIXSHADER_I5_A1;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I5_A1_f0_sel(regPP_PIXSHADER_I5_A1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A1::F0_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A1_f1_sel(regPP_PIXSHADER_I5_A1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A1::F1_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A1_output_scale(regPP_PIXSHADER_I5_A1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A1_output_clamp(regPP_PIXSHADER_I5_A1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A1_output_select(regPP_PIXSHADER_I5_A1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A1_dot_alpha(regPP_PIXSHADER_I5_A1 *reg, unsigned int dot_alpha)
{
  reg->bitfields.DOT_ALPHA = dot_alpha;
  if (reg->bitfields.DOT_ALPHA != dot_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A1::DOT_ALPHA data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A1_replicate_arg_a(regPP_PIXSHADER_I5_A1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A1_replicate_arg_b(regPP_PIXSHADER_I5_A1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I5_A1_replicate_arg_c(regPP_PIXSHADER_I5_A1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I5_A1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_PIXSHADER_I5_A1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_PIXSHADER_I5_A1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_PIXSHADER_I5_A1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_PIXSHADER_I5_A1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_PIXSHADER_I5_A1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_PIXSHADER_I5_A1_dot_alpha(reg, dot_alpha) (reg)->bitfields.DOT_ALPHA = dot_alpha
#define set_PP_PIXSHADER_I5_A1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_PIXSHADER_I5_A1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_PIXSHADER_I5_A1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I6_A1 regPP_PIXSHADER_I6_A1;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I6_A1_f0_sel(regPP_PIXSHADER_I6_A1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A1::F0_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A1_f1_sel(regPP_PIXSHADER_I6_A1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A1::F1_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A1_output_scale(regPP_PIXSHADER_I6_A1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A1_output_clamp(regPP_PIXSHADER_I6_A1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A1_output_select(regPP_PIXSHADER_I6_A1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A1_dot_alpha(regPP_PIXSHADER_I6_A1 *reg, unsigned int dot_alpha)
{
  reg->bitfields.DOT_ALPHA = dot_alpha;
  if (reg->bitfields.DOT_ALPHA != dot_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A1::DOT_ALPHA data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A1_replicate_arg_a(regPP_PIXSHADER_I6_A1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A1_replicate_arg_b(regPP_PIXSHADER_I6_A1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I6_A1_replicate_arg_c(regPP_PIXSHADER_I6_A1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I6_A1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_PIXSHADER_I6_A1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_PIXSHADER_I6_A1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_PIXSHADER_I6_A1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_PIXSHADER_I6_A1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_PIXSHADER_I6_A1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_PIXSHADER_I6_A1_dot_alpha(reg, dot_alpha) (reg)->bitfields.DOT_ALPHA = dot_alpha
#define set_PP_PIXSHADER_I6_A1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_PIXSHADER_I6_A1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_PIXSHADER_I6_A1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_PIXSHADER_I7_A1 regPP_PIXSHADER_I7_A1;

#ifdef DEBUG
__inline void set_PP_PIXSHADER_I7_A1_f0_sel(regPP_PIXSHADER_I7_A1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A1::F0_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A1_f1_sel(regPP_PIXSHADER_I7_A1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A1::F1_SEL data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A1_output_scale(regPP_PIXSHADER_I7_A1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A1_output_clamp(regPP_PIXSHADER_I7_A1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A1_output_select(regPP_PIXSHADER_I7_A1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A1_dot_alpha(regPP_PIXSHADER_I7_A1 *reg, unsigned int dot_alpha)
{
  reg->bitfields.DOT_ALPHA = dot_alpha;
  if (reg->bitfields.DOT_ALPHA != dot_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A1::DOT_ALPHA data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A1_replicate_arg_a(regPP_PIXSHADER_I7_A1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A1_replicate_arg_b(regPP_PIXSHADER_I7_A1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_PIXSHADER_I7_A1_replicate_arg_c(regPP_PIXSHADER_I7_A1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_PIXSHADER_I7_A1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_PIXSHADER_I7_A1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_PIXSHADER_I7_A1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_PIXSHADER_I7_A1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_PIXSHADER_I7_A1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_PIXSHADER_I7_A1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_PIXSHADER_I7_A1_dot_alpha(reg, dot_alpha) (reg)->bitfields.DOT_ALPHA = dot_alpha
#define set_PP_PIXSHADER_I7_A1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_PIXSHADER_I7_A1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_PIXSHADER_I7_A1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I0_C0 regPP_ADRSHADER_I0_C0;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I0_C0_color_arg_a(regPP_ADRSHADER_I0_C0 *reg, unsigned int color_arg_a)
{
  reg->bitfields.COLOR_ARG_A = color_arg_a;
  if (reg->bitfields.COLOR_ARG_A != color_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C0::COLOR_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C0_color_arg_b(regPP_ADRSHADER_I0_C0 *reg, unsigned int color_arg_b)
{
  reg->bitfields.COLOR_ARG_B = color_arg_b;
  if (reg->bitfields.COLOR_ARG_B != color_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C0::COLOR_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C0_color_arg_c(regPP_ADRSHADER_I0_C0 *reg, unsigned int color_arg_c)
{
  reg->bitfields.COLOR_ARG_C = color_arg_c;
  if (reg->bitfields.COLOR_ARG_C != color_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C0::COLOR_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C0_comp_arg_a(regPP_ADRSHADER_I0_C0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C0::COMP_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C0_bias_arg_a(regPP_ADRSHADER_I0_C0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C0_scale_arg_a(regPP_ADRSHADER_I0_C0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C0_neg_arg_a(regPP_ADRSHADER_I0_C0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C0::NEG_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C0_comp_arg_b(regPP_ADRSHADER_I0_C0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C0::COMP_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C0_bias_arg_b(regPP_ADRSHADER_I0_C0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C0_scale_arg_b(regPP_ADRSHADER_I0_C0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C0_neg_arg_b(regPP_ADRSHADER_I0_C0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C0::NEG_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C0_comp_arg_c(regPP_ADRSHADER_I0_C0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C0::COMP_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C0_bias_arg_c(regPP_ADRSHADER_I0_C0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C0_scale_arg_c(regPP_ADRSHADER_I0_C0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C0_neg_arg_c(regPP_ADRSHADER_I0_C0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C0::NEG_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C0_blend_ctl(regPP_ADRSHADER_I0_C0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C0::BLEND_CTL data too large\n");
}
#else
#define set_PP_ADRSHADER_I0_C0_color_arg_a(reg, color_arg_a) (reg)->bitfields.COLOR_ARG_A = color_arg_a
#define set_PP_ADRSHADER_I0_C0_color_arg_b(reg, color_arg_b) (reg)->bitfields.COLOR_ARG_B = color_arg_b
#define set_PP_ADRSHADER_I0_C0_color_arg_c(reg, color_arg_c) (reg)->bitfields.COLOR_ARG_C = color_arg_c
#define set_PP_ADRSHADER_I0_C0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_ADRSHADER_I0_C0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_ADRSHADER_I0_C0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_ADRSHADER_I0_C0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_ADRSHADER_I0_C0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_ADRSHADER_I0_C0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_ADRSHADER_I0_C0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_ADRSHADER_I0_C0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_ADRSHADER_I0_C0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_ADRSHADER_I0_C0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_ADRSHADER_I0_C0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_ADRSHADER_I0_C0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_ADRSHADER_I0_C0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I1_C0 regPP_ADRSHADER_I1_C0;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I1_C0_color_arg_a(regPP_ADRSHADER_I1_C0 *reg, unsigned int color_arg_a)
{
  reg->bitfields.COLOR_ARG_A = color_arg_a;
  if (reg->bitfields.COLOR_ARG_A != color_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C0::COLOR_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C0_color_arg_b(regPP_ADRSHADER_I1_C0 *reg, unsigned int color_arg_b)
{
  reg->bitfields.COLOR_ARG_B = color_arg_b;
  if (reg->bitfields.COLOR_ARG_B != color_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C0::COLOR_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C0_color_arg_c(regPP_ADRSHADER_I1_C0 *reg, unsigned int color_arg_c)
{
  reg->bitfields.COLOR_ARG_C = color_arg_c;
  if (reg->bitfields.COLOR_ARG_C != color_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C0::COLOR_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C0_comp_arg_a(regPP_ADRSHADER_I1_C0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C0::COMP_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C0_bias_arg_a(regPP_ADRSHADER_I1_C0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C0_scale_arg_a(regPP_ADRSHADER_I1_C0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C0_neg_arg_a(regPP_ADRSHADER_I1_C0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C0::NEG_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C0_comp_arg_b(regPP_ADRSHADER_I1_C0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C0::COMP_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C0_bias_arg_b(regPP_ADRSHADER_I1_C0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C0_scale_arg_b(regPP_ADRSHADER_I1_C0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C0_neg_arg_b(regPP_ADRSHADER_I1_C0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C0::NEG_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C0_comp_arg_c(regPP_ADRSHADER_I1_C0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C0::COMP_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C0_bias_arg_c(regPP_ADRSHADER_I1_C0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C0_scale_arg_c(regPP_ADRSHADER_I1_C0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C0_neg_arg_c(regPP_ADRSHADER_I1_C0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C0::NEG_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C0_blend_ctl(regPP_ADRSHADER_I1_C0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C0::BLEND_CTL data too large\n");
}
#else
#define set_PP_ADRSHADER_I1_C0_color_arg_a(reg, color_arg_a) (reg)->bitfields.COLOR_ARG_A = color_arg_a
#define set_PP_ADRSHADER_I1_C0_color_arg_b(reg, color_arg_b) (reg)->bitfields.COLOR_ARG_B = color_arg_b
#define set_PP_ADRSHADER_I1_C0_color_arg_c(reg, color_arg_c) (reg)->bitfields.COLOR_ARG_C = color_arg_c
#define set_PP_ADRSHADER_I1_C0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_ADRSHADER_I1_C0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_ADRSHADER_I1_C0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_ADRSHADER_I1_C0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_ADRSHADER_I1_C0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_ADRSHADER_I1_C0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_ADRSHADER_I1_C0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_ADRSHADER_I1_C0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_ADRSHADER_I1_C0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_ADRSHADER_I1_C0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_ADRSHADER_I1_C0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_ADRSHADER_I1_C0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_ADRSHADER_I1_C0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I2_C0 regPP_ADRSHADER_I2_C0;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I2_C0_color_arg_a(regPP_ADRSHADER_I2_C0 *reg, unsigned int color_arg_a)
{
  reg->bitfields.COLOR_ARG_A = color_arg_a;
  if (reg->bitfields.COLOR_ARG_A != color_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C0::COLOR_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C0_color_arg_b(regPP_ADRSHADER_I2_C0 *reg, unsigned int color_arg_b)
{
  reg->bitfields.COLOR_ARG_B = color_arg_b;
  if (reg->bitfields.COLOR_ARG_B != color_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C0::COLOR_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C0_color_arg_c(regPP_ADRSHADER_I2_C0 *reg, unsigned int color_arg_c)
{
  reg->bitfields.COLOR_ARG_C = color_arg_c;
  if (reg->bitfields.COLOR_ARG_C != color_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C0::COLOR_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C0_comp_arg_a(regPP_ADRSHADER_I2_C0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C0::COMP_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C0_bias_arg_a(regPP_ADRSHADER_I2_C0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C0_scale_arg_a(regPP_ADRSHADER_I2_C0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C0_neg_arg_a(regPP_ADRSHADER_I2_C0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C0::NEG_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C0_comp_arg_b(regPP_ADRSHADER_I2_C0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C0::COMP_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C0_bias_arg_b(regPP_ADRSHADER_I2_C0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C0_scale_arg_b(regPP_ADRSHADER_I2_C0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C0_neg_arg_b(regPP_ADRSHADER_I2_C0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C0::NEG_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C0_comp_arg_c(regPP_ADRSHADER_I2_C0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C0::COMP_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C0_bias_arg_c(regPP_ADRSHADER_I2_C0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C0_scale_arg_c(regPP_ADRSHADER_I2_C0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C0_neg_arg_c(regPP_ADRSHADER_I2_C0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C0::NEG_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C0_blend_ctl(regPP_ADRSHADER_I2_C0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C0::BLEND_CTL data too large\n");
}
#else
#define set_PP_ADRSHADER_I2_C0_color_arg_a(reg, color_arg_a) (reg)->bitfields.COLOR_ARG_A = color_arg_a
#define set_PP_ADRSHADER_I2_C0_color_arg_b(reg, color_arg_b) (reg)->bitfields.COLOR_ARG_B = color_arg_b
#define set_PP_ADRSHADER_I2_C0_color_arg_c(reg, color_arg_c) (reg)->bitfields.COLOR_ARG_C = color_arg_c
#define set_PP_ADRSHADER_I2_C0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_ADRSHADER_I2_C0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_ADRSHADER_I2_C0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_ADRSHADER_I2_C0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_ADRSHADER_I2_C0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_ADRSHADER_I2_C0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_ADRSHADER_I2_C0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_ADRSHADER_I2_C0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_ADRSHADER_I2_C0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_ADRSHADER_I2_C0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_ADRSHADER_I2_C0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_ADRSHADER_I2_C0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_ADRSHADER_I2_C0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I3_C0 regPP_ADRSHADER_I3_C0;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I3_C0_color_arg_a(regPP_ADRSHADER_I3_C0 *reg, unsigned int color_arg_a)
{
  reg->bitfields.COLOR_ARG_A = color_arg_a;
  if (reg->bitfields.COLOR_ARG_A != color_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C0::COLOR_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C0_color_arg_b(regPP_ADRSHADER_I3_C0 *reg, unsigned int color_arg_b)
{
  reg->bitfields.COLOR_ARG_B = color_arg_b;
  if (reg->bitfields.COLOR_ARG_B != color_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C0::COLOR_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C0_color_arg_c(regPP_ADRSHADER_I3_C0 *reg, unsigned int color_arg_c)
{
  reg->bitfields.COLOR_ARG_C = color_arg_c;
  if (reg->bitfields.COLOR_ARG_C != color_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C0::COLOR_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C0_comp_arg_a(regPP_ADRSHADER_I3_C0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C0::COMP_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C0_bias_arg_a(regPP_ADRSHADER_I3_C0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C0_scale_arg_a(regPP_ADRSHADER_I3_C0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C0_neg_arg_a(regPP_ADRSHADER_I3_C0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C0::NEG_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C0_comp_arg_b(regPP_ADRSHADER_I3_C0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C0::COMP_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C0_bias_arg_b(regPP_ADRSHADER_I3_C0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C0_scale_arg_b(regPP_ADRSHADER_I3_C0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C0_neg_arg_b(regPP_ADRSHADER_I3_C0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C0::NEG_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C0_comp_arg_c(regPP_ADRSHADER_I3_C0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C0::COMP_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C0_bias_arg_c(regPP_ADRSHADER_I3_C0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C0_scale_arg_c(regPP_ADRSHADER_I3_C0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C0_neg_arg_c(regPP_ADRSHADER_I3_C0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C0::NEG_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C0_blend_ctl(regPP_ADRSHADER_I3_C0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C0::BLEND_CTL data too large\n");
}
#else
#define set_PP_ADRSHADER_I3_C0_color_arg_a(reg, color_arg_a) (reg)->bitfields.COLOR_ARG_A = color_arg_a
#define set_PP_ADRSHADER_I3_C0_color_arg_b(reg, color_arg_b) (reg)->bitfields.COLOR_ARG_B = color_arg_b
#define set_PP_ADRSHADER_I3_C0_color_arg_c(reg, color_arg_c) (reg)->bitfields.COLOR_ARG_C = color_arg_c
#define set_PP_ADRSHADER_I3_C0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_ADRSHADER_I3_C0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_ADRSHADER_I3_C0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_ADRSHADER_I3_C0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_ADRSHADER_I3_C0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_ADRSHADER_I3_C0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_ADRSHADER_I3_C0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_ADRSHADER_I3_C0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_ADRSHADER_I3_C0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_ADRSHADER_I3_C0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_ADRSHADER_I3_C0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_ADRSHADER_I3_C0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_ADRSHADER_I3_C0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I4_C0 regPP_ADRSHADER_I4_C0;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I4_C0_color_arg_a(regPP_ADRSHADER_I4_C0 *reg, unsigned int color_arg_a)
{
  reg->bitfields.COLOR_ARG_A = color_arg_a;
  if (reg->bitfields.COLOR_ARG_A != color_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C0::COLOR_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C0_color_arg_b(regPP_ADRSHADER_I4_C0 *reg, unsigned int color_arg_b)
{
  reg->bitfields.COLOR_ARG_B = color_arg_b;
  if (reg->bitfields.COLOR_ARG_B != color_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C0::COLOR_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C0_color_arg_c(regPP_ADRSHADER_I4_C0 *reg, unsigned int color_arg_c)
{
  reg->bitfields.COLOR_ARG_C = color_arg_c;
  if (reg->bitfields.COLOR_ARG_C != color_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C0::COLOR_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C0_comp_arg_a(regPP_ADRSHADER_I4_C0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C0::COMP_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C0_bias_arg_a(regPP_ADRSHADER_I4_C0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C0_scale_arg_a(regPP_ADRSHADER_I4_C0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C0_neg_arg_a(regPP_ADRSHADER_I4_C0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C0::NEG_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C0_comp_arg_b(regPP_ADRSHADER_I4_C0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C0::COMP_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C0_bias_arg_b(regPP_ADRSHADER_I4_C0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C0_scale_arg_b(regPP_ADRSHADER_I4_C0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C0_neg_arg_b(regPP_ADRSHADER_I4_C0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C0::NEG_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C0_comp_arg_c(regPP_ADRSHADER_I4_C0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C0::COMP_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C0_bias_arg_c(regPP_ADRSHADER_I4_C0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C0_scale_arg_c(regPP_ADRSHADER_I4_C0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C0_neg_arg_c(regPP_ADRSHADER_I4_C0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C0::NEG_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C0_blend_ctl(regPP_ADRSHADER_I4_C0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C0::BLEND_CTL data too large\n");
}
#else
#define set_PP_ADRSHADER_I4_C0_color_arg_a(reg, color_arg_a) (reg)->bitfields.COLOR_ARG_A = color_arg_a
#define set_PP_ADRSHADER_I4_C0_color_arg_b(reg, color_arg_b) (reg)->bitfields.COLOR_ARG_B = color_arg_b
#define set_PP_ADRSHADER_I4_C0_color_arg_c(reg, color_arg_c) (reg)->bitfields.COLOR_ARG_C = color_arg_c
#define set_PP_ADRSHADER_I4_C0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_ADRSHADER_I4_C0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_ADRSHADER_I4_C0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_ADRSHADER_I4_C0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_ADRSHADER_I4_C0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_ADRSHADER_I4_C0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_ADRSHADER_I4_C0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_ADRSHADER_I4_C0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_ADRSHADER_I4_C0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_ADRSHADER_I4_C0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_ADRSHADER_I4_C0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_ADRSHADER_I4_C0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_ADRSHADER_I4_C0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I5_C0 regPP_ADRSHADER_I5_C0;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I5_C0_color_arg_a(regPP_ADRSHADER_I5_C0 *reg, unsigned int color_arg_a)
{
  reg->bitfields.COLOR_ARG_A = color_arg_a;
  if (reg->bitfields.COLOR_ARG_A != color_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C0::COLOR_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C0_color_arg_b(regPP_ADRSHADER_I5_C0 *reg, unsigned int color_arg_b)
{
  reg->bitfields.COLOR_ARG_B = color_arg_b;
  if (reg->bitfields.COLOR_ARG_B != color_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C0::COLOR_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C0_color_arg_c(regPP_ADRSHADER_I5_C0 *reg, unsigned int color_arg_c)
{
  reg->bitfields.COLOR_ARG_C = color_arg_c;
  if (reg->bitfields.COLOR_ARG_C != color_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C0::COLOR_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C0_comp_arg_a(regPP_ADRSHADER_I5_C0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C0::COMP_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C0_bias_arg_a(regPP_ADRSHADER_I5_C0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C0_scale_arg_a(regPP_ADRSHADER_I5_C0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C0_neg_arg_a(regPP_ADRSHADER_I5_C0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C0::NEG_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C0_comp_arg_b(regPP_ADRSHADER_I5_C0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C0::COMP_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C0_bias_arg_b(regPP_ADRSHADER_I5_C0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C0_scale_arg_b(regPP_ADRSHADER_I5_C0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C0_neg_arg_b(regPP_ADRSHADER_I5_C0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C0::NEG_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C0_comp_arg_c(regPP_ADRSHADER_I5_C0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C0::COMP_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C0_bias_arg_c(regPP_ADRSHADER_I5_C0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C0_scale_arg_c(regPP_ADRSHADER_I5_C0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C0_neg_arg_c(regPP_ADRSHADER_I5_C0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C0::NEG_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C0_blend_ctl(regPP_ADRSHADER_I5_C0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C0::BLEND_CTL data too large\n");
}
#else
#define set_PP_ADRSHADER_I5_C0_color_arg_a(reg, color_arg_a) (reg)->bitfields.COLOR_ARG_A = color_arg_a
#define set_PP_ADRSHADER_I5_C0_color_arg_b(reg, color_arg_b) (reg)->bitfields.COLOR_ARG_B = color_arg_b
#define set_PP_ADRSHADER_I5_C0_color_arg_c(reg, color_arg_c) (reg)->bitfields.COLOR_ARG_C = color_arg_c
#define set_PP_ADRSHADER_I5_C0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_ADRSHADER_I5_C0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_ADRSHADER_I5_C0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_ADRSHADER_I5_C0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_ADRSHADER_I5_C0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_ADRSHADER_I5_C0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_ADRSHADER_I5_C0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_ADRSHADER_I5_C0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_ADRSHADER_I5_C0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_ADRSHADER_I5_C0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_ADRSHADER_I5_C0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_ADRSHADER_I5_C0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_ADRSHADER_I5_C0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I6_C0 regPP_ADRSHADER_I6_C0;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I6_C0_color_arg_a(regPP_ADRSHADER_I6_C0 *reg, unsigned int color_arg_a)
{
  reg->bitfields.COLOR_ARG_A = color_arg_a;
  if (reg->bitfields.COLOR_ARG_A != color_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C0::COLOR_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C0_color_arg_b(regPP_ADRSHADER_I6_C0 *reg, unsigned int color_arg_b)
{
  reg->bitfields.COLOR_ARG_B = color_arg_b;
  if (reg->bitfields.COLOR_ARG_B != color_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C0::COLOR_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C0_color_arg_c(regPP_ADRSHADER_I6_C0 *reg, unsigned int color_arg_c)
{
  reg->bitfields.COLOR_ARG_C = color_arg_c;
  if (reg->bitfields.COLOR_ARG_C != color_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C0::COLOR_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C0_comp_arg_a(regPP_ADRSHADER_I6_C0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C0::COMP_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C0_bias_arg_a(regPP_ADRSHADER_I6_C0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C0_scale_arg_a(regPP_ADRSHADER_I6_C0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C0_neg_arg_a(regPP_ADRSHADER_I6_C0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C0::NEG_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C0_comp_arg_b(regPP_ADRSHADER_I6_C0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C0::COMP_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C0_bias_arg_b(regPP_ADRSHADER_I6_C0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C0_scale_arg_b(regPP_ADRSHADER_I6_C0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C0_neg_arg_b(regPP_ADRSHADER_I6_C0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C0::NEG_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C0_comp_arg_c(regPP_ADRSHADER_I6_C0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C0::COMP_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C0_bias_arg_c(regPP_ADRSHADER_I6_C0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C0_scale_arg_c(regPP_ADRSHADER_I6_C0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C0_neg_arg_c(regPP_ADRSHADER_I6_C0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C0::NEG_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C0_blend_ctl(regPP_ADRSHADER_I6_C0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C0::BLEND_CTL data too large\n");
}
#else
#define set_PP_ADRSHADER_I6_C0_color_arg_a(reg, color_arg_a) (reg)->bitfields.COLOR_ARG_A = color_arg_a
#define set_PP_ADRSHADER_I6_C0_color_arg_b(reg, color_arg_b) (reg)->bitfields.COLOR_ARG_B = color_arg_b
#define set_PP_ADRSHADER_I6_C0_color_arg_c(reg, color_arg_c) (reg)->bitfields.COLOR_ARG_C = color_arg_c
#define set_PP_ADRSHADER_I6_C0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_ADRSHADER_I6_C0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_ADRSHADER_I6_C0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_ADRSHADER_I6_C0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_ADRSHADER_I6_C0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_ADRSHADER_I6_C0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_ADRSHADER_I6_C0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_ADRSHADER_I6_C0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_ADRSHADER_I6_C0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_ADRSHADER_I6_C0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_ADRSHADER_I6_C0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_ADRSHADER_I6_C0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_ADRSHADER_I6_C0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I7_C0 regPP_ADRSHADER_I7_C0;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I7_C0_color_arg_a(regPP_ADRSHADER_I7_C0 *reg, unsigned int color_arg_a)
{
  reg->bitfields.COLOR_ARG_A = color_arg_a;
  if (reg->bitfields.COLOR_ARG_A != color_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C0::COLOR_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C0_color_arg_b(regPP_ADRSHADER_I7_C0 *reg, unsigned int color_arg_b)
{
  reg->bitfields.COLOR_ARG_B = color_arg_b;
  if (reg->bitfields.COLOR_ARG_B != color_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C0::COLOR_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C0_color_arg_c(regPP_ADRSHADER_I7_C0 *reg, unsigned int color_arg_c)
{
  reg->bitfields.COLOR_ARG_C = color_arg_c;
  if (reg->bitfields.COLOR_ARG_C != color_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C0::COLOR_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C0_comp_arg_a(regPP_ADRSHADER_I7_C0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C0::COMP_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C0_bias_arg_a(regPP_ADRSHADER_I7_C0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C0_scale_arg_a(regPP_ADRSHADER_I7_C0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C0_neg_arg_a(regPP_ADRSHADER_I7_C0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C0::NEG_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C0_comp_arg_b(regPP_ADRSHADER_I7_C0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C0::COMP_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C0_bias_arg_b(regPP_ADRSHADER_I7_C0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C0_scale_arg_b(regPP_ADRSHADER_I7_C0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C0_neg_arg_b(regPP_ADRSHADER_I7_C0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C0::NEG_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C0_comp_arg_c(regPP_ADRSHADER_I7_C0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C0::COMP_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C0_bias_arg_c(regPP_ADRSHADER_I7_C0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C0_scale_arg_c(regPP_ADRSHADER_I7_C0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C0_neg_arg_c(regPP_ADRSHADER_I7_C0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C0::NEG_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C0_blend_ctl(regPP_ADRSHADER_I7_C0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C0::BLEND_CTL data too large\n");
}
#else
#define set_PP_ADRSHADER_I7_C0_color_arg_a(reg, color_arg_a) (reg)->bitfields.COLOR_ARG_A = color_arg_a
#define set_PP_ADRSHADER_I7_C0_color_arg_b(reg, color_arg_b) (reg)->bitfields.COLOR_ARG_B = color_arg_b
#define set_PP_ADRSHADER_I7_C0_color_arg_c(reg, color_arg_c) (reg)->bitfields.COLOR_ARG_C = color_arg_c
#define set_PP_ADRSHADER_I7_C0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_ADRSHADER_I7_C0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_ADRSHADER_I7_C0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_ADRSHADER_I7_C0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_ADRSHADER_I7_C0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_ADRSHADER_I7_C0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_ADRSHADER_I7_C0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_ADRSHADER_I7_C0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_ADRSHADER_I7_C0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_ADRSHADER_I7_C0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_ADRSHADER_I7_C0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_ADRSHADER_I7_C0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_ADRSHADER_I7_C0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I0_C1 regPP_ADRSHADER_I0_C1;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I0_C1_f0_sel(regPP_ADRSHADER_I0_C1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C1::F0_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C1_f1_sel(regPP_ADRSHADER_I0_C1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C1::F1_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C1_output_scale(regPP_ADRSHADER_I0_C1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C1_output_clamp(regPP_ADRSHADER_I0_C1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C1_output_select(regPP_ADRSHADER_I0_C1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C1_output_mask(regPP_ADRSHADER_I0_C1 *reg, unsigned int output_mask)
{
  reg->bitfields.OUTPUT_MASK = output_mask;
  if (reg->bitfields.OUTPUT_MASK != output_mask) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C1::OUTPUT_MASK data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C1_output_rotate(regPP_ADRSHADER_I0_C1 *reg, unsigned int output_rotate)
{
  reg->bitfields.OUTPUT_ROTATE = output_rotate;
  if (reg->bitfields.OUTPUT_ROTATE != output_rotate) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C1::OUTPUT_ROTATE data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C1_replicate_arg_a(regPP_ADRSHADER_I0_C1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C1_replicate_arg_b(regPP_ADRSHADER_I0_C1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I0_C1_replicate_arg_c(regPP_ADRSHADER_I0_C1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_C1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_ADRSHADER_I0_C1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_ADRSHADER_I0_C1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_ADRSHADER_I0_C1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_ADRSHADER_I0_C1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_ADRSHADER_I0_C1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_ADRSHADER_I0_C1_output_mask(reg, output_mask) (reg)->bitfields.OUTPUT_MASK = output_mask
#define set_PP_ADRSHADER_I0_C1_output_rotate(reg, output_rotate) (reg)->bitfields.OUTPUT_ROTATE = output_rotate
#define set_PP_ADRSHADER_I0_C1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_ADRSHADER_I0_C1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_ADRSHADER_I0_C1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I1_C1 regPP_ADRSHADER_I1_C1;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I1_C1_f0_sel(regPP_ADRSHADER_I1_C1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C1::F0_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C1_f1_sel(regPP_ADRSHADER_I1_C1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C1::F1_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C1_output_scale(regPP_ADRSHADER_I1_C1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C1_output_clamp(regPP_ADRSHADER_I1_C1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C1_output_select(regPP_ADRSHADER_I1_C1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C1_output_mask(regPP_ADRSHADER_I1_C1 *reg, unsigned int output_mask)
{
  reg->bitfields.OUTPUT_MASK = output_mask;
  if (reg->bitfields.OUTPUT_MASK != output_mask) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C1::OUTPUT_MASK data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C1_output_rotate(regPP_ADRSHADER_I1_C1 *reg, unsigned int output_rotate)
{
  reg->bitfields.OUTPUT_ROTATE = output_rotate;
  if (reg->bitfields.OUTPUT_ROTATE != output_rotate) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C1::OUTPUT_ROTATE data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C1_replicate_arg_a(regPP_ADRSHADER_I1_C1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C1_replicate_arg_b(regPP_ADRSHADER_I1_C1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I1_C1_replicate_arg_c(regPP_ADRSHADER_I1_C1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_C1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_ADRSHADER_I1_C1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_ADRSHADER_I1_C1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_ADRSHADER_I1_C1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_ADRSHADER_I1_C1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_ADRSHADER_I1_C1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_ADRSHADER_I1_C1_output_mask(reg, output_mask) (reg)->bitfields.OUTPUT_MASK = output_mask
#define set_PP_ADRSHADER_I1_C1_output_rotate(reg, output_rotate) (reg)->bitfields.OUTPUT_ROTATE = output_rotate
#define set_PP_ADRSHADER_I1_C1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_ADRSHADER_I1_C1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_ADRSHADER_I1_C1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I2_C1 regPP_ADRSHADER_I2_C1;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I2_C1_f0_sel(regPP_ADRSHADER_I2_C1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C1::F0_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C1_f1_sel(regPP_ADRSHADER_I2_C1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C1::F1_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C1_output_scale(regPP_ADRSHADER_I2_C1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C1_output_clamp(regPP_ADRSHADER_I2_C1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C1_output_select(regPP_ADRSHADER_I2_C1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C1_output_mask(regPP_ADRSHADER_I2_C1 *reg, unsigned int output_mask)
{
  reg->bitfields.OUTPUT_MASK = output_mask;
  if (reg->bitfields.OUTPUT_MASK != output_mask) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C1::OUTPUT_MASK data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C1_output_rotate(regPP_ADRSHADER_I2_C1 *reg, unsigned int output_rotate)
{
  reg->bitfields.OUTPUT_ROTATE = output_rotate;
  if (reg->bitfields.OUTPUT_ROTATE != output_rotate) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C1::OUTPUT_ROTATE data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C1_replicate_arg_a(regPP_ADRSHADER_I2_C1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C1_replicate_arg_b(regPP_ADRSHADER_I2_C1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I2_C1_replicate_arg_c(regPP_ADRSHADER_I2_C1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_C1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_ADRSHADER_I2_C1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_ADRSHADER_I2_C1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_ADRSHADER_I2_C1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_ADRSHADER_I2_C1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_ADRSHADER_I2_C1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_ADRSHADER_I2_C1_output_mask(reg, output_mask) (reg)->bitfields.OUTPUT_MASK = output_mask
#define set_PP_ADRSHADER_I2_C1_output_rotate(reg, output_rotate) (reg)->bitfields.OUTPUT_ROTATE = output_rotate
#define set_PP_ADRSHADER_I2_C1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_ADRSHADER_I2_C1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_ADRSHADER_I2_C1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I3_C1 regPP_ADRSHADER_I3_C1;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I3_C1_f0_sel(regPP_ADRSHADER_I3_C1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C1::F0_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C1_f1_sel(regPP_ADRSHADER_I3_C1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C1::F1_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C1_output_scale(regPP_ADRSHADER_I3_C1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C1_output_clamp(regPP_ADRSHADER_I3_C1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C1_output_select(regPP_ADRSHADER_I3_C1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C1_output_mask(regPP_ADRSHADER_I3_C1 *reg, unsigned int output_mask)
{
  reg->bitfields.OUTPUT_MASK = output_mask;
  if (reg->bitfields.OUTPUT_MASK != output_mask) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C1::OUTPUT_MASK data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C1_output_rotate(regPP_ADRSHADER_I3_C1 *reg, unsigned int output_rotate)
{
  reg->bitfields.OUTPUT_ROTATE = output_rotate;
  if (reg->bitfields.OUTPUT_ROTATE != output_rotate) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C1::OUTPUT_ROTATE data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C1_replicate_arg_a(regPP_ADRSHADER_I3_C1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C1_replicate_arg_b(regPP_ADRSHADER_I3_C1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I3_C1_replicate_arg_c(regPP_ADRSHADER_I3_C1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_C1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_ADRSHADER_I3_C1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_ADRSHADER_I3_C1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_ADRSHADER_I3_C1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_ADRSHADER_I3_C1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_ADRSHADER_I3_C1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_ADRSHADER_I3_C1_output_mask(reg, output_mask) (reg)->bitfields.OUTPUT_MASK = output_mask
#define set_PP_ADRSHADER_I3_C1_output_rotate(reg, output_rotate) (reg)->bitfields.OUTPUT_ROTATE = output_rotate
#define set_PP_ADRSHADER_I3_C1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_ADRSHADER_I3_C1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_ADRSHADER_I3_C1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I4_C1 regPP_ADRSHADER_I4_C1;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I4_C1_f0_sel(regPP_ADRSHADER_I4_C1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C1::F0_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C1_f1_sel(regPP_ADRSHADER_I4_C1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C1::F1_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C1_output_scale(regPP_ADRSHADER_I4_C1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C1_output_clamp(regPP_ADRSHADER_I4_C1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C1_output_select(regPP_ADRSHADER_I4_C1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C1_output_mask(regPP_ADRSHADER_I4_C1 *reg, unsigned int output_mask)
{
  reg->bitfields.OUTPUT_MASK = output_mask;
  if (reg->bitfields.OUTPUT_MASK != output_mask) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C1::OUTPUT_MASK data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C1_output_rotate(regPP_ADRSHADER_I4_C1 *reg, unsigned int output_rotate)
{
  reg->bitfields.OUTPUT_ROTATE = output_rotate;
  if (reg->bitfields.OUTPUT_ROTATE != output_rotate) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C1::OUTPUT_ROTATE data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C1_replicate_arg_a(regPP_ADRSHADER_I4_C1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C1_replicate_arg_b(regPP_ADRSHADER_I4_C1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I4_C1_replicate_arg_c(regPP_ADRSHADER_I4_C1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_C1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_ADRSHADER_I4_C1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_ADRSHADER_I4_C1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_ADRSHADER_I4_C1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_ADRSHADER_I4_C1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_ADRSHADER_I4_C1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_ADRSHADER_I4_C1_output_mask(reg, output_mask) (reg)->bitfields.OUTPUT_MASK = output_mask
#define set_PP_ADRSHADER_I4_C1_output_rotate(reg, output_rotate) (reg)->bitfields.OUTPUT_ROTATE = output_rotate
#define set_PP_ADRSHADER_I4_C1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_ADRSHADER_I4_C1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_ADRSHADER_I4_C1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I5_C1 regPP_ADRSHADER_I5_C1;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I5_C1_f0_sel(regPP_ADRSHADER_I5_C1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C1::F0_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C1_f1_sel(regPP_ADRSHADER_I5_C1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C1::F1_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C1_output_scale(regPP_ADRSHADER_I5_C1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C1_output_clamp(regPP_ADRSHADER_I5_C1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C1_output_select(regPP_ADRSHADER_I5_C1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C1_output_mask(regPP_ADRSHADER_I5_C1 *reg, unsigned int output_mask)
{
  reg->bitfields.OUTPUT_MASK = output_mask;
  if (reg->bitfields.OUTPUT_MASK != output_mask) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C1::OUTPUT_MASK data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C1_output_rotate(regPP_ADRSHADER_I5_C1 *reg, unsigned int output_rotate)
{
  reg->bitfields.OUTPUT_ROTATE = output_rotate;
  if (reg->bitfields.OUTPUT_ROTATE != output_rotate) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C1::OUTPUT_ROTATE data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C1_replicate_arg_a(regPP_ADRSHADER_I5_C1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C1_replicate_arg_b(regPP_ADRSHADER_I5_C1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I5_C1_replicate_arg_c(regPP_ADRSHADER_I5_C1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_C1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_ADRSHADER_I5_C1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_ADRSHADER_I5_C1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_ADRSHADER_I5_C1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_ADRSHADER_I5_C1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_ADRSHADER_I5_C1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_ADRSHADER_I5_C1_output_mask(reg, output_mask) (reg)->bitfields.OUTPUT_MASK = output_mask
#define set_PP_ADRSHADER_I5_C1_output_rotate(reg, output_rotate) (reg)->bitfields.OUTPUT_ROTATE = output_rotate
#define set_PP_ADRSHADER_I5_C1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_ADRSHADER_I5_C1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_ADRSHADER_I5_C1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I6_C1 regPP_ADRSHADER_I6_C1;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I6_C1_f0_sel(regPP_ADRSHADER_I6_C1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C1::F0_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C1_f1_sel(regPP_ADRSHADER_I6_C1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C1::F1_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C1_output_scale(regPP_ADRSHADER_I6_C1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C1_output_clamp(regPP_ADRSHADER_I6_C1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C1_output_select(regPP_ADRSHADER_I6_C1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C1_output_mask(regPP_ADRSHADER_I6_C1 *reg, unsigned int output_mask)
{
  reg->bitfields.OUTPUT_MASK = output_mask;
  if (reg->bitfields.OUTPUT_MASK != output_mask) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C1::OUTPUT_MASK data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C1_output_rotate(regPP_ADRSHADER_I6_C1 *reg, unsigned int output_rotate)
{
  reg->bitfields.OUTPUT_ROTATE = output_rotate;
  if (reg->bitfields.OUTPUT_ROTATE != output_rotate) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C1::OUTPUT_ROTATE data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C1_replicate_arg_a(regPP_ADRSHADER_I6_C1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C1_replicate_arg_b(regPP_ADRSHADER_I6_C1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I6_C1_replicate_arg_c(regPP_ADRSHADER_I6_C1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_C1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_ADRSHADER_I6_C1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_ADRSHADER_I6_C1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_ADRSHADER_I6_C1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_ADRSHADER_I6_C1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_ADRSHADER_I6_C1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_ADRSHADER_I6_C1_output_mask(reg, output_mask) (reg)->bitfields.OUTPUT_MASK = output_mask
#define set_PP_ADRSHADER_I6_C1_output_rotate(reg, output_rotate) (reg)->bitfields.OUTPUT_ROTATE = output_rotate
#define set_PP_ADRSHADER_I6_C1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_ADRSHADER_I6_C1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_ADRSHADER_I6_C1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I7_C1 regPP_ADRSHADER_I7_C1;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I7_C1_f0_sel(regPP_ADRSHADER_I7_C1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C1::F0_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C1_f1_sel(regPP_ADRSHADER_I7_C1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C1::F1_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C1_output_scale(regPP_ADRSHADER_I7_C1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C1_output_clamp(regPP_ADRSHADER_I7_C1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C1_output_select(regPP_ADRSHADER_I7_C1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C1_output_mask(regPP_ADRSHADER_I7_C1 *reg, unsigned int output_mask)
{
  reg->bitfields.OUTPUT_MASK = output_mask;
  if (reg->bitfields.OUTPUT_MASK != output_mask) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C1::OUTPUT_MASK data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C1_output_rotate(regPP_ADRSHADER_I7_C1 *reg, unsigned int output_rotate)
{
  reg->bitfields.OUTPUT_ROTATE = output_rotate;
  if (reg->bitfields.OUTPUT_ROTATE != output_rotate) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C1::OUTPUT_ROTATE data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C1_replicate_arg_a(regPP_ADRSHADER_I7_C1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C1_replicate_arg_b(regPP_ADRSHADER_I7_C1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I7_C1_replicate_arg_c(regPP_ADRSHADER_I7_C1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_C1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_ADRSHADER_I7_C1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_ADRSHADER_I7_C1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_ADRSHADER_I7_C1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_ADRSHADER_I7_C1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_ADRSHADER_I7_C1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_ADRSHADER_I7_C1_output_mask(reg, output_mask) (reg)->bitfields.OUTPUT_MASK = output_mask
#define set_PP_ADRSHADER_I7_C1_output_rotate(reg, output_rotate) (reg)->bitfields.OUTPUT_ROTATE = output_rotate
#define set_PP_ADRSHADER_I7_C1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_ADRSHADER_I7_C1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_ADRSHADER_I7_C1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I0_A0 regPP_ADRSHADER_I0_A0;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I0_A0_alpha_arg_a(regPP_ADRSHADER_I0_A0 *reg, unsigned int alpha_arg_a)
{
  reg->bitfields.ALPHA_ARG_A = alpha_arg_a;
  if (reg->bitfields.ALPHA_ARG_A != alpha_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A0::ALPHA_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A0_alpha_arg_b(regPP_ADRSHADER_I0_A0 *reg, unsigned int alpha_arg_b)
{
  reg->bitfields.ALPHA_ARG_B = alpha_arg_b;
  if (reg->bitfields.ALPHA_ARG_B != alpha_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A0::ALPHA_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A0_alpha_arg_c(regPP_ADRSHADER_I0_A0 *reg, unsigned int alpha_arg_c)
{
  reg->bitfields.ALPHA_ARG_C = alpha_arg_c;
  if (reg->bitfields.ALPHA_ARG_C != alpha_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A0::ALPHA_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A0_comp_arg_a(regPP_ADRSHADER_I0_A0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A0::COMP_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A0_bias_arg_a(regPP_ADRSHADER_I0_A0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A0_scale_arg_a(regPP_ADRSHADER_I0_A0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A0_neg_arg_a(regPP_ADRSHADER_I0_A0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A0::NEG_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A0_comp_arg_b(regPP_ADRSHADER_I0_A0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A0::COMP_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A0_bias_arg_b(regPP_ADRSHADER_I0_A0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A0_scale_arg_b(regPP_ADRSHADER_I0_A0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A0_neg_arg_b(regPP_ADRSHADER_I0_A0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A0::NEG_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A0_comp_arg_c(regPP_ADRSHADER_I0_A0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A0::COMP_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A0_bias_arg_c(regPP_ADRSHADER_I0_A0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A0_scale_arg_c(regPP_ADRSHADER_I0_A0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A0_neg_arg_c(regPP_ADRSHADER_I0_A0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A0::NEG_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A0_blend_ctl(regPP_ADRSHADER_I0_A0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A0::BLEND_CTL data too large\n");
}
#else
#define set_PP_ADRSHADER_I0_A0_alpha_arg_a(reg, alpha_arg_a) (reg)->bitfields.ALPHA_ARG_A = alpha_arg_a
#define set_PP_ADRSHADER_I0_A0_alpha_arg_b(reg, alpha_arg_b) (reg)->bitfields.ALPHA_ARG_B = alpha_arg_b
#define set_PP_ADRSHADER_I0_A0_alpha_arg_c(reg, alpha_arg_c) (reg)->bitfields.ALPHA_ARG_C = alpha_arg_c
#define set_PP_ADRSHADER_I0_A0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_ADRSHADER_I0_A0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_ADRSHADER_I0_A0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_ADRSHADER_I0_A0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_ADRSHADER_I0_A0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_ADRSHADER_I0_A0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_ADRSHADER_I0_A0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_ADRSHADER_I0_A0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_ADRSHADER_I0_A0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_ADRSHADER_I0_A0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_ADRSHADER_I0_A0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_ADRSHADER_I0_A0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_ADRSHADER_I0_A0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I1_A0 regPP_ADRSHADER_I1_A0;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I1_A0_alpha_arg_a(regPP_ADRSHADER_I1_A0 *reg, unsigned int alpha_arg_a)
{
  reg->bitfields.ALPHA_ARG_A = alpha_arg_a;
  if (reg->bitfields.ALPHA_ARG_A != alpha_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A0::ALPHA_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A0_alpha_arg_b(regPP_ADRSHADER_I1_A0 *reg, unsigned int alpha_arg_b)
{
  reg->bitfields.ALPHA_ARG_B = alpha_arg_b;
  if (reg->bitfields.ALPHA_ARG_B != alpha_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A0::ALPHA_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A0_alpha_arg_c(regPP_ADRSHADER_I1_A0 *reg, unsigned int alpha_arg_c)
{
  reg->bitfields.ALPHA_ARG_C = alpha_arg_c;
  if (reg->bitfields.ALPHA_ARG_C != alpha_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A0::ALPHA_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A0_comp_arg_a(regPP_ADRSHADER_I1_A0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A0::COMP_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A0_bias_arg_a(regPP_ADRSHADER_I1_A0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A0_scale_arg_a(regPP_ADRSHADER_I1_A0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A0_neg_arg_a(regPP_ADRSHADER_I1_A0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A0::NEG_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A0_comp_arg_b(regPP_ADRSHADER_I1_A0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A0::COMP_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A0_bias_arg_b(regPP_ADRSHADER_I1_A0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A0_scale_arg_b(regPP_ADRSHADER_I1_A0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A0_neg_arg_b(regPP_ADRSHADER_I1_A0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A0::NEG_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A0_comp_arg_c(regPP_ADRSHADER_I1_A0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A0::COMP_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A0_bias_arg_c(regPP_ADRSHADER_I1_A0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A0_scale_arg_c(regPP_ADRSHADER_I1_A0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A0_neg_arg_c(regPP_ADRSHADER_I1_A0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A0::NEG_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A0_blend_ctl(regPP_ADRSHADER_I1_A0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A0::BLEND_CTL data too large\n");
}
#else
#define set_PP_ADRSHADER_I1_A0_alpha_arg_a(reg, alpha_arg_a) (reg)->bitfields.ALPHA_ARG_A = alpha_arg_a
#define set_PP_ADRSHADER_I1_A0_alpha_arg_b(reg, alpha_arg_b) (reg)->bitfields.ALPHA_ARG_B = alpha_arg_b
#define set_PP_ADRSHADER_I1_A0_alpha_arg_c(reg, alpha_arg_c) (reg)->bitfields.ALPHA_ARG_C = alpha_arg_c
#define set_PP_ADRSHADER_I1_A0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_ADRSHADER_I1_A0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_ADRSHADER_I1_A0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_ADRSHADER_I1_A0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_ADRSHADER_I1_A0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_ADRSHADER_I1_A0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_ADRSHADER_I1_A0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_ADRSHADER_I1_A0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_ADRSHADER_I1_A0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_ADRSHADER_I1_A0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_ADRSHADER_I1_A0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_ADRSHADER_I1_A0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_ADRSHADER_I1_A0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I2_A0 regPP_ADRSHADER_I2_A0;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I2_A0_alpha_arg_a(regPP_ADRSHADER_I2_A0 *reg, unsigned int alpha_arg_a)
{
  reg->bitfields.ALPHA_ARG_A = alpha_arg_a;
  if (reg->bitfields.ALPHA_ARG_A != alpha_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A0::ALPHA_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A0_alpha_arg_b(regPP_ADRSHADER_I2_A0 *reg, unsigned int alpha_arg_b)
{
  reg->bitfields.ALPHA_ARG_B = alpha_arg_b;
  if (reg->bitfields.ALPHA_ARG_B != alpha_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A0::ALPHA_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A0_alpha_arg_c(regPP_ADRSHADER_I2_A0 *reg, unsigned int alpha_arg_c)
{
  reg->bitfields.ALPHA_ARG_C = alpha_arg_c;
  if (reg->bitfields.ALPHA_ARG_C != alpha_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A0::ALPHA_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A0_comp_arg_a(regPP_ADRSHADER_I2_A0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A0::COMP_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A0_bias_arg_a(regPP_ADRSHADER_I2_A0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A0_scale_arg_a(regPP_ADRSHADER_I2_A0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A0_neg_arg_a(regPP_ADRSHADER_I2_A0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A0::NEG_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A0_comp_arg_b(regPP_ADRSHADER_I2_A0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A0::COMP_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A0_bias_arg_b(regPP_ADRSHADER_I2_A0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A0_scale_arg_b(regPP_ADRSHADER_I2_A0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A0_neg_arg_b(regPP_ADRSHADER_I2_A0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A0::NEG_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A0_comp_arg_c(regPP_ADRSHADER_I2_A0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A0::COMP_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A0_bias_arg_c(regPP_ADRSHADER_I2_A0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A0_scale_arg_c(regPP_ADRSHADER_I2_A0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A0_neg_arg_c(regPP_ADRSHADER_I2_A0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A0::NEG_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A0_blend_ctl(regPP_ADRSHADER_I2_A0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A0::BLEND_CTL data too large\n");
}
#else
#define set_PP_ADRSHADER_I2_A0_alpha_arg_a(reg, alpha_arg_a) (reg)->bitfields.ALPHA_ARG_A = alpha_arg_a
#define set_PP_ADRSHADER_I2_A0_alpha_arg_b(reg, alpha_arg_b) (reg)->bitfields.ALPHA_ARG_B = alpha_arg_b
#define set_PP_ADRSHADER_I2_A0_alpha_arg_c(reg, alpha_arg_c) (reg)->bitfields.ALPHA_ARG_C = alpha_arg_c
#define set_PP_ADRSHADER_I2_A0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_ADRSHADER_I2_A0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_ADRSHADER_I2_A0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_ADRSHADER_I2_A0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_ADRSHADER_I2_A0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_ADRSHADER_I2_A0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_ADRSHADER_I2_A0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_ADRSHADER_I2_A0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_ADRSHADER_I2_A0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_ADRSHADER_I2_A0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_ADRSHADER_I2_A0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_ADRSHADER_I2_A0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_ADRSHADER_I2_A0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I3_A0 regPP_ADRSHADER_I3_A0;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I3_A0_alpha_arg_a(regPP_ADRSHADER_I3_A0 *reg, unsigned int alpha_arg_a)
{
  reg->bitfields.ALPHA_ARG_A = alpha_arg_a;
  if (reg->bitfields.ALPHA_ARG_A != alpha_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A0::ALPHA_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A0_alpha_arg_b(regPP_ADRSHADER_I3_A0 *reg, unsigned int alpha_arg_b)
{
  reg->bitfields.ALPHA_ARG_B = alpha_arg_b;
  if (reg->bitfields.ALPHA_ARG_B != alpha_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A0::ALPHA_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A0_alpha_arg_c(regPP_ADRSHADER_I3_A0 *reg, unsigned int alpha_arg_c)
{
  reg->bitfields.ALPHA_ARG_C = alpha_arg_c;
  if (reg->bitfields.ALPHA_ARG_C != alpha_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A0::ALPHA_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A0_comp_arg_a(regPP_ADRSHADER_I3_A0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A0::COMP_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A0_bias_arg_a(regPP_ADRSHADER_I3_A0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A0_scale_arg_a(regPP_ADRSHADER_I3_A0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A0_neg_arg_a(regPP_ADRSHADER_I3_A0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A0::NEG_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A0_comp_arg_b(regPP_ADRSHADER_I3_A0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A0::COMP_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A0_bias_arg_b(regPP_ADRSHADER_I3_A0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A0_scale_arg_b(regPP_ADRSHADER_I3_A0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A0_neg_arg_b(regPP_ADRSHADER_I3_A0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A0::NEG_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A0_comp_arg_c(regPP_ADRSHADER_I3_A0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A0::COMP_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A0_bias_arg_c(regPP_ADRSHADER_I3_A0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A0_scale_arg_c(regPP_ADRSHADER_I3_A0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A0_neg_arg_c(regPP_ADRSHADER_I3_A0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A0::NEG_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A0_blend_ctl(regPP_ADRSHADER_I3_A0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A0::BLEND_CTL data too large\n");
}
#else
#define set_PP_ADRSHADER_I3_A0_alpha_arg_a(reg, alpha_arg_a) (reg)->bitfields.ALPHA_ARG_A = alpha_arg_a
#define set_PP_ADRSHADER_I3_A0_alpha_arg_b(reg, alpha_arg_b) (reg)->bitfields.ALPHA_ARG_B = alpha_arg_b
#define set_PP_ADRSHADER_I3_A0_alpha_arg_c(reg, alpha_arg_c) (reg)->bitfields.ALPHA_ARG_C = alpha_arg_c
#define set_PP_ADRSHADER_I3_A0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_ADRSHADER_I3_A0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_ADRSHADER_I3_A0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_ADRSHADER_I3_A0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_ADRSHADER_I3_A0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_ADRSHADER_I3_A0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_ADRSHADER_I3_A0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_ADRSHADER_I3_A0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_ADRSHADER_I3_A0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_ADRSHADER_I3_A0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_ADRSHADER_I3_A0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_ADRSHADER_I3_A0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_ADRSHADER_I3_A0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I4_A0 regPP_ADRSHADER_I4_A0;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I4_A0_alpha_arg_a(regPP_ADRSHADER_I4_A0 *reg, unsigned int alpha_arg_a)
{
  reg->bitfields.ALPHA_ARG_A = alpha_arg_a;
  if (reg->bitfields.ALPHA_ARG_A != alpha_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A0::ALPHA_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A0_alpha_arg_b(regPP_ADRSHADER_I4_A0 *reg, unsigned int alpha_arg_b)
{
  reg->bitfields.ALPHA_ARG_B = alpha_arg_b;
  if (reg->bitfields.ALPHA_ARG_B != alpha_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A0::ALPHA_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A0_alpha_arg_c(regPP_ADRSHADER_I4_A0 *reg, unsigned int alpha_arg_c)
{
  reg->bitfields.ALPHA_ARG_C = alpha_arg_c;
  if (reg->bitfields.ALPHA_ARG_C != alpha_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A0::ALPHA_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A0_comp_arg_a(regPP_ADRSHADER_I4_A0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A0::COMP_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A0_bias_arg_a(regPP_ADRSHADER_I4_A0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A0_scale_arg_a(regPP_ADRSHADER_I4_A0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A0_neg_arg_a(regPP_ADRSHADER_I4_A0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A0::NEG_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A0_comp_arg_b(regPP_ADRSHADER_I4_A0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A0::COMP_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A0_bias_arg_b(regPP_ADRSHADER_I4_A0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A0_scale_arg_b(regPP_ADRSHADER_I4_A0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A0_neg_arg_b(regPP_ADRSHADER_I4_A0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A0::NEG_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A0_comp_arg_c(regPP_ADRSHADER_I4_A0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A0::COMP_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A0_bias_arg_c(regPP_ADRSHADER_I4_A0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A0_scale_arg_c(regPP_ADRSHADER_I4_A0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A0_neg_arg_c(regPP_ADRSHADER_I4_A0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A0::NEG_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A0_blend_ctl(regPP_ADRSHADER_I4_A0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A0::BLEND_CTL data too large\n");
}
#else
#define set_PP_ADRSHADER_I4_A0_alpha_arg_a(reg, alpha_arg_a) (reg)->bitfields.ALPHA_ARG_A = alpha_arg_a
#define set_PP_ADRSHADER_I4_A0_alpha_arg_b(reg, alpha_arg_b) (reg)->bitfields.ALPHA_ARG_B = alpha_arg_b
#define set_PP_ADRSHADER_I4_A0_alpha_arg_c(reg, alpha_arg_c) (reg)->bitfields.ALPHA_ARG_C = alpha_arg_c
#define set_PP_ADRSHADER_I4_A0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_ADRSHADER_I4_A0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_ADRSHADER_I4_A0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_ADRSHADER_I4_A0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_ADRSHADER_I4_A0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_ADRSHADER_I4_A0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_ADRSHADER_I4_A0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_ADRSHADER_I4_A0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_ADRSHADER_I4_A0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_ADRSHADER_I4_A0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_ADRSHADER_I4_A0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_ADRSHADER_I4_A0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_ADRSHADER_I4_A0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I5_A0 regPP_ADRSHADER_I5_A0;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I5_A0_alpha_arg_a(regPP_ADRSHADER_I5_A0 *reg, unsigned int alpha_arg_a)
{
  reg->bitfields.ALPHA_ARG_A = alpha_arg_a;
  if (reg->bitfields.ALPHA_ARG_A != alpha_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A0::ALPHA_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A0_alpha_arg_b(regPP_ADRSHADER_I5_A0 *reg, unsigned int alpha_arg_b)
{
  reg->bitfields.ALPHA_ARG_B = alpha_arg_b;
  if (reg->bitfields.ALPHA_ARG_B != alpha_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A0::ALPHA_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A0_alpha_arg_c(regPP_ADRSHADER_I5_A0 *reg, unsigned int alpha_arg_c)
{
  reg->bitfields.ALPHA_ARG_C = alpha_arg_c;
  if (reg->bitfields.ALPHA_ARG_C != alpha_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A0::ALPHA_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A0_comp_arg_a(regPP_ADRSHADER_I5_A0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A0::COMP_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A0_bias_arg_a(regPP_ADRSHADER_I5_A0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A0_scale_arg_a(regPP_ADRSHADER_I5_A0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A0_neg_arg_a(regPP_ADRSHADER_I5_A0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A0::NEG_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A0_comp_arg_b(regPP_ADRSHADER_I5_A0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A0::COMP_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A0_bias_arg_b(regPP_ADRSHADER_I5_A0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A0_scale_arg_b(regPP_ADRSHADER_I5_A0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A0_neg_arg_b(regPP_ADRSHADER_I5_A0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A0::NEG_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A0_comp_arg_c(regPP_ADRSHADER_I5_A0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A0::COMP_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A0_bias_arg_c(regPP_ADRSHADER_I5_A0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A0_scale_arg_c(regPP_ADRSHADER_I5_A0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A0_neg_arg_c(regPP_ADRSHADER_I5_A0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A0::NEG_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A0_blend_ctl(regPP_ADRSHADER_I5_A0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A0::BLEND_CTL data too large\n");
}
#else
#define set_PP_ADRSHADER_I5_A0_alpha_arg_a(reg, alpha_arg_a) (reg)->bitfields.ALPHA_ARG_A = alpha_arg_a
#define set_PP_ADRSHADER_I5_A0_alpha_arg_b(reg, alpha_arg_b) (reg)->bitfields.ALPHA_ARG_B = alpha_arg_b
#define set_PP_ADRSHADER_I5_A0_alpha_arg_c(reg, alpha_arg_c) (reg)->bitfields.ALPHA_ARG_C = alpha_arg_c
#define set_PP_ADRSHADER_I5_A0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_ADRSHADER_I5_A0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_ADRSHADER_I5_A0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_ADRSHADER_I5_A0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_ADRSHADER_I5_A0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_ADRSHADER_I5_A0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_ADRSHADER_I5_A0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_ADRSHADER_I5_A0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_ADRSHADER_I5_A0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_ADRSHADER_I5_A0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_ADRSHADER_I5_A0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_ADRSHADER_I5_A0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_ADRSHADER_I5_A0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I6_A0 regPP_ADRSHADER_I6_A0;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I6_A0_alpha_arg_a(regPP_ADRSHADER_I6_A0 *reg, unsigned int alpha_arg_a)
{
  reg->bitfields.ALPHA_ARG_A = alpha_arg_a;
  if (reg->bitfields.ALPHA_ARG_A != alpha_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A0::ALPHA_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A0_alpha_arg_b(regPP_ADRSHADER_I6_A0 *reg, unsigned int alpha_arg_b)
{
  reg->bitfields.ALPHA_ARG_B = alpha_arg_b;
  if (reg->bitfields.ALPHA_ARG_B != alpha_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A0::ALPHA_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A0_alpha_arg_c(regPP_ADRSHADER_I6_A0 *reg, unsigned int alpha_arg_c)
{
  reg->bitfields.ALPHA_ARG_C = alpha_arg_c;
  if (reg->bitfields.ALPHA_ARG_C != alpha_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A0::ALPHA_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A0_comp_arg_a(regPP_ADRSHADER_I6_A0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A0::COMP_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A0_bias_arg_a(regPP_ADRSHADER_I6_A0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A0_scale_arg_a(regPP_ADRSHADER_I6_A0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A0_neg_arg_a(regPP_ADRSHADER_I6_A0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A0::NEG_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A0_comp_arg_b(regPP_ADRSHADER_I6_A0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A0::COMP_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A0_bias_arg_b(regPP_ADRSHADER_I6_A0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A0_scale_arg_b(regPP_ADRSHADER_I6_A0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A0_neg_arg_b(regPP_ADRSHADER_I6_A0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A0::NEG_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A0_comp_arg_c(regPP_ADRSHADER_I6_A0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A0::COMP_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A0_bias_arg_c(regPP_ADRSHADER_I6_A0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A0_scale_arg_c(regPP_ADRSHADER_I6_A0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A0_neg_arg_c(regPP_ADRSHADER_I6_A0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A0::NEG_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A0_blend_ctl(regPP_ADRSHADER_I6_A0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A0::BLEND_CTL data too large\n");
}
#else
#define set_PP_ADRSHADER_I6_A0_alpha_arg_a(reg, alpha_arg_a) (reg)->bitfields.ALPHA_ARG_A = alpha_arg_a
#define set_PP_ADRSHADER_I6_A0_alpha_arg_b(reg, alpha_arg_b) (reg)->bitfields.ALPHA_ARG_B = alpha_arg_b
#define set_PP_ADRSHADER_I6_A0_alpha_arg_c(reg, alpha_arg_c) (reg)->bitfields.ALPHA_ARG_C = alpha_arg_c
#define set_PP_ADRSHADER_I6_A0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_ADRSHADER_I6_A0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_ADRSHADER_I6_A0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_ADRSHADER_I6_A0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_ADRSHADER_I6_A0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_ADRSHADER_I6_A0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_ADRSHADER_I6_A0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_ADRSHADER_I6_A0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_ADRSHADER_I6_A0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_ADRSHADER_I6_A0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_ADRSHADER_I6_A0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_ADRSHADER_I6_A0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_ADRSHADER_I6_A0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I7_A0 regPP_ADRSHADER_I7_A0;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I7_A0_alpha_arg_a(regPP_ADRSHADER_I7_A0 *reg, unsigned int alpha_arg_a)
{
  reg->bitfields.ALPHA_ARG_A = alpha_arg_a;
  if (reg->bitfields.ALPHA_ARG_A != alpha_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A0::ALPHA_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A0_alpha_arg_b(regPP_ADRSHADER_I7_A0 *reg, unsigned int alpha_arg_b)
{
  reg->bitfields.ALPHA_ARG_B = alpha_arg_b;
  if (reg->bitfields.ALPHA_ARG_B != alpha_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A0::ALPHA_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A0_alpha_arg_c(regPP_ADRSHADER_I7_A0 *reg, unsigned int alpha_arg_c)
{
  reg->bitfields.ALPHA_ARG_C = alpha_arg_c;
  if (reg->bitfields.ALPHA_ARG_C != alpha_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A0::ALPHA_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A0_comp_arg_a(regPP_ADRSHADER_I7_A0 *reg, unsigned int comp_arg_a)
{
  reg->bitfields.COMP_ARG_A = comp_arg_a;
  if (reg->bitfields.COMP_ARG_A != comp_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A0::COMP_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A0_bias_arg_a(regPP_ADRSHADER_I7_A0 *reg, unsigned int bias_arg_a)
{
  reg->bitfields.BIAS_ARG_A = bias_arg_a;
  if (reg->bitfields.BIAS_ARG_A != bias_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A0::BIAS_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A0_scale_arg_a(regPP_ADRSHADER_I7_A0 *reg, unsigned int scale_arg_a)
{
  reg->bitfields.SCALE_ARG_A = scale_arg_a;
  if (reg->bitfields.SCALE_ARG_A != scale_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A0::SCALE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A0_neg_arg_a(regPP_ADRSHADER_I7_A0 *reg, unsigned int neg_arg_a)
{
  reg->bitfields.NEG_ARG_A = neg_arg_a;
  if (reg->bitfields.NEG_ARG_A != neg_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A0::NEG_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A0_comp_arg_b(regPP_ADRSHADER_I7_A0 *reg, unsigned int comp_arg_b)
{
  reg->bitfields.COMP_ARG_B = comp_arg_b;
  if (reg->bitfields.COMP_ARG_B != comp_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A0::COMP_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A0_bias_arg_b(regPP_ADRSHADER_I7_A0 *reg, unsigned int bias_arg_b)
{
  reg->bitfields.BIAS_ARG_B = bias_arg_b;
  if (reg->bitfields.BIAS_ARG_B != bias_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A0::BIAS_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A0_scale_arg_b(regPP_ADRSHADER_I7_A0 *reg, unsigned int scale_arg_b)
{
  reg->bitfields.SCALE_ARG_B = scale_arg_b;
  if (reg->bitfields.SCALE_ARG_B != scale_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A0::SCALE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A0_neg_arg_b(regPP_ADRSHADER_I7_A0 *reg, unsigned int neg_arg_b)
{
  reg->bitfields.NEG_ARG_B = neg_arg_b;
  if (reg->bitfields.NEG_ARG_B != neg_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A0::NEG_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A0_comp_arg_c(regPP_ADRSHADER_I7_A0 *reg, unsigned int comp_arg_c)
{
  reg->bitfields.COMP_ARG_C = comp_arg_c;
  if (reg->bitfields.COMP_ARG_C != comp_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A0::COMP_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A0_bias_arg_c(regPP_ADRSHADER_I7_A0 *reg, unsigned int bias_arg_c)
{
  reg->bitfields.BIAS_ARG_C = bias_arg_c;
  if (reg->bitfields.BIAS_ARG_C != bias_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A0::BIAS_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A0_scale_arg_c(regPP_ADRSHADER_I7_A0 *reg, unsigned int scale_arg_c)
{
  reg->bitfields.SCALE_ARG_C = scale_arg_c;
  if (reg->bitfields.SCALE_ARG_C != scale_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A0::SCALE_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A0_neg_arg_c(regPP_ADRSHADER_I7_A0 *reg, unsigned int neg_arg_c)
{
  reg->bitfields.NEG_ARG_C = neg_arg_c;
  if (reg->bitfields.NEG_ARG_C != neg_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A0::NEG_ARG_C data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A0_blend_ctl(regPP_ADRSHADER_I7_A0 *reg, unsigned int blend_ctl)
{
  reg->bitfields.BLEND_CTL = blend_ctl;
  if (reg->bitfields.BLEND_CTL != blend_ctl) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A0::BLEND_CTL data too large\n");
}
#else
#define set_PP_ADRSHADER_I7_A0_alpha_arg_a(reg, alpha_arg_a) (reg)->bitfields.ALPHA_ARG_A = alpha_arg_a
#define set_PP_ADRSHADER_I7_A0_alpha_arg_b(reg, alpha_arg_b) (reg)->bitfields.ALPHA_ARG_B = alpha_arg_b
#define set_PP_ADRSHADER_I7_A0_alpha_arg_c(reg, alpha_arg_c) (reg)->bitfields.ALPHA_ARG_C = alpha_arg_c
#define set_PP_ADRSHADER_I7_A0_comp_arg_a(reg, comp_arg_a) (reg)->bitfields.COMP_ARG_A = comp_arg_a
#define set_PP_ADRSHADER_I7_A0_bias_arg_a(reg, bias_arg_a) (reg)->bitfields.BIAS_ARG_A = bias_arg_a
#define set_PP_ADRSHADER_I7_A0_scale_arg_a(reg, scale_arg_a) (reg)->bitfields.SCALE_ARG_A = scale_arg_a
#define set_PP_ADRSHADER_I7_A0_neg_arg_a(reg, neg_arg_a) (reg)->bitfields.NEG_ARG_A = neg_arg_a
#define set_PP_ADRSHADER_I7_A0_comp_arg_b(reg, comp_arg_b) (reg)->bitfields.COMP_ARG_B = comp_arg_b
#define set_PP_ADRSHADER_I7_A0_bias_arg_b(reg, bias_arg_b) (reg)->bitfields.BIAS_ARG_B = bias_arg_b
#define set_PP_ADRSHADER_I7_A0_scale_arg_b(reg, scale_arg_b) (reg)->bitfields.SCALE_ARG_B = scale_arg_b
#define set_PP_ADRSHADER_I7_A0_neg_arg_b(reg, neg_arg_b) (reg)->bitfields.NEG_ARG_B = neg_arg_b
#define set_PP_ADRSHADER_I7_A0_comp_arg_c(reg, comp_arg_c) (reg)->bitfields.COMP_ARG_C = comp_arg_c
#define set_PP_ADRSHADER_I7_A0_bias_arg_c(reg, bias_arg_c) (reg)->bitfields.BIAS_ARG_C = bias_arg_c
#define set_PP_ADRSHADER_I7_A0_scale_arg_c(reg, scale_arg_c) (reg)->bitfields.SCALE_ARG_C = scale_arg_c
#define set_PP_ADRSHADER_I7_A0_neg_arg_c(reg, neg_arg_c) (reg)->bitfields.NEG_ARG_C = neg_arg_c
#define set_PP_ADRSHADER_I7_A0_blend_ctl(reg, blend_ctl) (reg)->bitfields.BLEND_CTL = blend_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I0_A1 regPP_ADRSHADER_I0_A1;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I0_A1_f0_sel(regPP_ADRSHADER_I0_A1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A1::F0_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A1_f1_sel(regPP_ADRSHADER_I0_A1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A1::F1_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A1_output_scale(regPP_ADRSHADER_I0_A1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A1_output_clamp(regPP_ADRSHADER_I0_A1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A1_output_select(regPP_ADRSHADER_I0_A1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A1_dot_alpha(regPP_ADRSHADER_I0_A1 *reg, unsigned int dot_alpha)
{
  reg->bitfields.DOT_ALPHA = dot_alpha;
  if (reg->bitfields.DOT_ALPHA != dot_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A1::DOT_ALPHA data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A1_replicate_arg_a(regPP_ADRSHADER_I0_A1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A1_replicate_arg_b(regPP_ADRSHADER_I0_A1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I0_A1_replicate_arg_c(regPP_ADRSHADER_I0_A1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I0_A1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_ADRSHADER_I0_A1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_ADRSHADER_I0_A1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_ADRSHADER_I0_A1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_ADRSHADER_I0_A1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_ADRSHADER_I0_A1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_ADRSHADER_I0_A1_dot_alpha(reg, dot_alpha) (reg)->bitfields.DOT_ALPHA = dot_alpha
#define set_PP_ADRSHADER_I0_A1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_ADRSHADER_I0_A1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_ADRSHADER_I0_A1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I1_A1 regPP_ADRSHADER_I1_A1;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I1_A1_f0_sel(regPP_ADRSHADER_I1_A1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A1::F0_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A1_f1_sel(regPP_ADRSHADER_I1_A1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A1::F1_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A1_output_scale(regPP_ADRSHADER_I1_A1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A1_output_clamp(regPP_ADRSHADER_I1_A1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A1_output_select(regPP_ADRSHADER_I1_A1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A1_dot_alpha(regPP_ADRSHADER_I1_A1 *reg, unsigned int dot_alpha)
{
  reg->bitfields.DOT_ALPHA = dot_alpha;
  if (reg->bitfields.DOT_ALPHA != dot_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A1::DOT_ALPHA data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A1_replicate_arg_a(regPP_ADRSHADER_I1_A1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A1_replicate_arg_b(regPP_ADRSHADER_I1_A1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I1_A1_replicate_arg_c(regPP_ADRSHADER_I1_A1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I1_A1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_ADRSHADER_I1_A1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_ADRSHADER_I1_A1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_ADRSHADER_I1_A1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_ADRSHADER_I1_A1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_ADRSHADER_I1_A1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_ADRSHADER_I1_A1_dot_alpha(reg, dot_alpha) (reg)->bitfields.DOT_ALPHA = dot_alpha
#define set_PP_ADRSHADER_I1_A1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_ADRSHADER_I1_A1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_ADRSHADER_I1_A1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I2_A1 regPP_ADRSHADER_I2_A1;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I2_A1_f0_sel(regPP_ADRSHADER_I2_A1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A1::F0_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A1_f1_sel(regPP_ADRSHADER_I2_A1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A1::F1_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A1_output_scale(regPP_ADRSHADER_I2_A1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A1_output_clamp(regPP_ADRSHADER_I2_A1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A1_output_select(regPP_ADRSHADER_I2_A1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A1_dot_alpha(regPP_ADRSHADER_I2_A1 *reg, unsigned int dot_alpha)
{
  reg->bitfields.DOT_ALPHA = dot_alpha;
  if (reg->bitfields.DOT_ALPHA != dot_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A1::DOT_ALPHA data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A1_replicate_arg_a(regPP_ADRSHADER_I2_A1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A1_replicate_arg_b(regPP_ADRSHADER_I2_A1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I2_A1_replicate_arg_c(regPP_ADRSHADER_I2_A1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I2_A1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_ADRSHADER_I2_A1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_ADRSHADER_I2_A1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_ADRSHADER_I2_A1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_ADRSHADER_I2_A1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_ADRSHADER_I2_A1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_ADRSHADER_I2_A1_dot_alpha(reg, dot_alpha) (reg)->bitfields.DOT_ALPHA = dot_alpha
#define set_PP_ADRSHADER_I2_A1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_ADRSHADER_I2_A1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_ADRSHADER_I2_A1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I3_A1 regPP_ADRSHADER_I3_A1;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I3_A1_f0_sel(regPP_ADRSHADER_I3_A1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A1::F0_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A1_f1_sel(regPP_ADRSHADER_I3_A1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A1::F1_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A1_output_scale(regPP_ADRSHADER_I3_A1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A1_output_clamp(regPP_ADRSHADER_I3_A1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A1_output_select(regPP_ADRSHADER_I3_A1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A1_dot_alpha(regPP_ADRSHADER_I3_A1 *reg, unsigned int dot_alpha)
{
  reg->bitfields.DOT_ALPHA = dot_alpha;
  if (reg->bitfields.DOT_ALPHA != dot_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A1::DOT_ALPHA data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A1_replicate_arg_a(regPP_ADRSHADER_I3_A1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A1_replicate_arg_b(regPP_ADRSHADER_I3_A1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I3_A1_replicate_arg_c(regPP_ADRSHADER_I3_A1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I3_A1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_ADRSHADER_I3_A1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_ADRSHADER_I3_A1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_ADRSHADER_I3_A1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_ADRSHADER_I3_A1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_ADRSHADER_I3_A1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_ADRSHADER_I3_A1_dot_alpha(reg, dot_alpha) (reg)->bitfields.DOT_ALPHA = dot_alpha
#define set_PP_ADRSHADER_I3_A1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_ADRSHADER_I3_A1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_ADRSHADER_I3_A1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I4_A1 regPP_ADRSHADER_I4_A1;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I4_A1_f0_sel(regPP_ADRSHADER_I4_A1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A1::F0_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A1_f1_sel(regPP_ADRSHADER_I4_A1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A1::F1_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A1_output_scale(regPP_ADRSHADER_I4_A1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A1_output_clamp(regPP_ADRSHADER_I4_A1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A1_output_select(regPP_ADRSHADER_I4_A1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A1_dot_alpha(regPP_ADRSHADER_I4_A1 *reg, unsigned int dot_alpha)
{
  reg->bitfields.DOT_ALPHA = dot_alpha;
  if (reg->bitfields.DOT_ALPHA != dot_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A1::DOT_ALPHA data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A1_replicate_arg_a(regPP_ADRSHADER_I4_A1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A1_replicate_arg_b(regPP_ADRSHADER_I4_A1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I4_A1_replicate_arg_c(regPP_ADRSHADER_I4_A1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I4_A1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_ADRSHADER_I4_A1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_ADRSHADER_I4_A1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_ADRSHADER_I4_A1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_ADRSHADER_I4_A1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_ADRSHADER_I4_A1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_ADRSHADER_I4_A1_dot_alpha(reg, dot_alpha) (reg)->bitfields.DOT_ALPHA = dot_alpha
#define set_PP_ADRSHADER_I4_A1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_ADRSHADER_I4_A1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_ADRSHADER_I4_A1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I5_A1 regPP_ADRSHADER_I5_A1;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I5_A1_f0_sel(regPP_ADRSHADER_I5_A1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A1::F0_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A1_f1_sel(regPP_ADRSHADER_I5_A1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A1::F1_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A1_output_scale(regPP_ADRSHADER_I5_A1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A1_output_clamp(regPP_ADRSHADER_I5_A1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A1_output_select(regPP_ADRSHADER_I5_A1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A1_dot_alpha(regPP_ADRSHADER_I5_A1 *reg, unsigned int dot_alpha)
{
  reg->bitfields.DOT_ALPHA = dot_alpha;
  if (reg->bitfields.DOT_ALPHA != dot_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A1::DOT_ALPHA data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A1_replicate_arg_a(regPP_ADRSHADER_I5_A1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A1_replicate_arg_b(regPP_ADRSHADER_I5_A1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I5_A1_replicate_arg_c(regPP_ADRSHADER_I5_A1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I5_A1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_ADRSHADER_I5_A1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_ADRSHADER_I5_A1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_ADRSHADER_I5_A1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_ADRSHADER_I5_A1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_ADRSHADER_I5_A1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_ADRSHADER_I5_A1_dot_alpha(reg, dot_alpha) (reg)->bitfields.DOT_ALPHA = dot_alpha
#define set_PP_ADRSHADER_I5_A1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_ADRSHADER_I5_A1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_ADRSHADER_I5_A1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I6_A1 regPP_ADRSHADER_I6_A1;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I6_A1_f0_sel(regPP_ADRSHADER_I6_A1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A1::F0_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A1_f1_sel(regPP_ADRSHADER_I6_A1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A1::F1_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A1_output_scale(regPP_ADRSHADER_I6_A1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A1_output_clamp(regPP_ADRSHADER_I6_A1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A1_output_select(regPP_ADRSHADER_I6_A1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A1_dot_alpha(regPP_ADRSHADER_I6_A1 *reg, unsigned int dot_alpha)
{
  reg->bitfields.DOT_ALPHA = dot_alpha;
  if (reg->bitfields.DOT_ALPHA != dot_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A1::DOT_ALPHA data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A1_replicate_arg_a(regPP_ADRSHADER_I6_A1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A1_replicate_arg_b(regPP_ADRSHADER_I6_A1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I6_A1_replicate_arg_c(regPP_ADRSHADER_I6_A1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I6_A1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_ADRSHADER_I6_A1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_ADRSHADER_I6_A1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_ADRSHADER_I6_A1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_ADRSHADER_I6_A1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_ADRSHADER_I6_A1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_ADRSHADER_I6_A1_dot_alpha(reg, dot_alpha) (reg)->bitfields.DOT_ALPHA = dot_alpha
#define set_PP_ADRSHADER_I6_A1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_ADRSHADER_I6_A1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_ADRSHADER_I6_A1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PP_ADRSHADER_I7_A1 regPP_ADRSHADER_I7_A1;

#ifdef DEBUG
__inline void set_PP_ADRSHADER_I7_A1_f0_sel(regPP_ADRSHADER_I7_A1 *reg, unsigned int f0_sel)
{
  reg->bitfields.F0_SEL = f0_sel;
  if (reg->bitfields.F0_SEL != f0_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A1::F0_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A1_f1_sel(regPP_ADRSHADER_I7_A1 *reg, unsigned int f1_sel)
{
  reg->bitfields.F1_SEL = f1_sel;
  if (reg->bitfields.F1_SEL != f1_sel) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A1::F1_SEL data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A1_output_scale(regPP_ADRSHADER_I7_A1 *reg, unsigned int output_scale)
{
  reg->bitfields.OUTPUT_SCALE = output_scale;
  if (reg->bitfields.OUTPUT_SCALE != output_scale) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A1::OUTPUT_SCALE data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A1_output_clamp(regPP_ADRSHADER_I7_A1 *reg, unsigned int output_clamp)
{
  reg->bitfields.OUTPUT_CLAMP = output_clamp;
  if (reg->bitfields.OUTPUT_CLAMP != output_clamp) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A1::OUTPUT_CLAMP data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A1_output_select(regPP_ADRSHADER_I7_A1 *reg, unsigned int output_select)
{
  reg->bitfields.OUTPUT_SELECT = output_select;
  if (reg->bitfields.OUTPUT_SELECT != output_select) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A1::OUTPUT_SELECT data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A1_dot_alpha(regPP_ADRSHADER_I7_A1 *reg, unsigned int dot_alpha)
{
  reg->bitfields.DOT_ALPHA = dot_alpha;
  if (reg->bitfields.DOT_ALPHA != dot_alpha) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A1::DOT_ALPHA data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A1_replicate_arg_a(regPP_ADRSHADER_I7_A1 *reg, unsigned int replicate_arg_a)
{
  reg->bitfields.REPLICATE_ARG_A = replicate_arg_a;
  if (reg->bitfields.REPLICATE_ARG_A != replicate_arg_a) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A1::REPLICATE_ARG_A data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A1_replicate_arg_b(regPP_ADRSHADER_I7_A1 *reg, unsigned int replicate_arg_b)
{
  reg->bitfields.REPLICATE_ARG_B = replicate_arg_b;
  if (reg->bitfields.REPLICATE_ARG_B != replicate_arg_b) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A1::REPLICATE_ARG_B data too large\n");
}
__inline void set_PP_ADRSHADER_I7_A1_replicate_arg_c(regPP_ADRSHADER_I7_A1 *reg, unsigned int replicate_arg_c)
{
  reg->bitfields.REPLICATE_ARG_C = replicate_arg_c;
  if (reg->bitfields.REPLICATE_ARG_C != replicate_arg_c) HSLDPF(E_ERROR_MESSAGE,"PP_ADRSHADER_I7_A1::REPLICATE_ARG_C data too large\n");
}
#else
#define set_PP_ADRSHADER_I7_A1_f0_sel(reg, f0_sel) (reg)->bitfields.F0_SEL = f0_sel
#define set_PP_ADRSHADER_I7_A1_f1_sel(reg, f1_sel) (reg)->bitfields.F1_SEL = f1_sel
#define set_PP_ADRSHADER_I7_A1_output_scale(reg, output_scale) (reg)->bitfields.OUTPUT_SCALE = output_scale
#define set_PP_ADRSHADER_I7_A1_output_clamp(reg, output_clamp) (reg)->bitfields.OUTPUT_CLAMP = output_clamp
#define set_PP_ADRSHADER_I7_A1_output_select(reg, output_select) (reg)->bitfields.OUTPUT_SELECT = output_select
#define set_PP_ADRSHADER_I7_A1_dot_alpha(reg, dot_alpha) (reg)->bitfields.DOT_ALPHA = dot_alpha
#define set_PP_ADRSHADER_I7_A1_replicate_arg_a(reg, replicate_arg_a) (reg)->bitfields.REPLICATE_ARG_A = replicate_arg_a
#define set_PP_ADRSHADER_I7_A1_replicate_arg_b(reg, replicate_arg_b) (reg)->bitfields.REPLICATE_ARG_B = replicate_arg_b
#define set_PP_ADRSHADER_I7_A1_replicate_arg_c(reg, replicate_arg_c) (reg)->bitfields.REPLICATE_ARG_C = replicate_arg_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_ROP regRB2D_ROP;

#ifdef DEBUG
__inline void set_RB2D_ROP_rop(regRB2D_ROP *reg, unsigned int rop)
{
  reg->bitfields.ROP = rop;
  if (reg->bitfields.ROP != rop) HSLDPF(E_ERROR_MESSAGE,"RB2D_ROP::ROP data too large\n");
}
#else
#define set_RB2D_ROP_rop(reg, rop) (reg)->bitfields.ROP = rop

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_CLRCMP_SRC regRB2D_CLRCMP_SRC;

#ifdef DEBUG
__inline void set_RB2D_CLRCMP_SRC_clrcmp_src(regRB2D_CLRCMP_SRC *reg, unsigned int clrcmp_src)
{
  reg->bitfields.CLRCMP_SRC = clrcmp_src;
  if (reg->bitfields.CLRCMP_SRC != clrcmp_src) HSLDPF(E_ERROR_MESSAGE,"RB2D_CLRCMP_SRC::CLRCMP_SRC data too large\n");
}
#else
#define set_RB2D_CLRCMP_SRC_clrcmp_src(reg, clrcmp_src) (reg)->bitfields.CLRCMP_SRC = clrcmp_src

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_CLRCMP_DST regRB2D_CLRCMP_DST;

#ifdef DEBUG
__inline void set_RB2D_CLRCMP_DST_clrcmp_dst(regRB2D_CLRCMP_DST *reg, unsigned int clrcmp_dst)
{
  reg->bitfields.CLRCMP_DST = clrcmp_dst;
  if (reg->bitfields.CLRCMP_DST != clrcmp_dst) HSLDPF(E_ERROR_MESSAGE,"RB2D_CLRCMP_DST::CLRCMP_DST data too large\n");
}
#else
#define set_RB2D_CLRCMP_DST_clrcmp_dst(reg, clrcmp_dst) (reg)->bitfields.CLRCMP_DST = clrcmp_dst

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_CLRCMP_FLIPE regRB2D_CLRCMP_FLIPE;

#ifdef DEBUG
__inline void set_RB2D_CLRCMP_FLIPE_clrcmp_flipe(regRB2D_CLRCMP_FLIPE *reg, unsigned int clrcmp_flipe)
{
  reg->bitfields.CLRCMP_FLIPE = clrcmp_flipe;
  if (reg->bitfields.CLRCMP_FLIPE != clrcmp_flipe) HSLDPF(E_ERROR_MESSAGE,"RB2D_CLRCMP_FLIPE::CLRCMP_FLIPE data too large\n");
}
#else
#define set_RB2D_CLRCMP_FLIPE_clrcmp_flipe(reg, clrcmp_flipe) (reg)->bitfields.CLRCMP_FLIPE = clrcmp_flipe

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_CLRCMP_CNTL regRB2D_CLRCMP_CNTL;

#ifdef DEBUG
__inline void set_RB2D_CLRCMP_CNTL_fcn_src(regRB2D_CLRCMP_CNTL *reg, unsigned int fcn_src)
{
  reg->bitfields.FCN_SRC = fcn_src;
  if (reg->bitfields.FCN_SRC != fcn_src) HSLDPF(E_ERROR_MESSAGE,"RB2D_CLRCMP_CNTL::FCN_SRC data too large\n");
}
__inline void set_RB2D_CLRCMP_CNTL_fcn_dst(regRB2D_CLRCMP_CNTL *reg, unsigned int fcn_dst)
{
  reg->bitfields.FCN_DST = fcn_dst;
  if (reg->bitfields.FCN_DST != fcn_dst) HSLDPF(E_ERROR_MESSAGE,"RB2D_CLRCMP_CNTL::FCN_DST data too large\n");
}
__inline void set_RB2D_CLRCMP_CNTL_src(regRB2D_CLRCMP_CNTL *reg, unsigned int src)
{
  reg->bitfields.SRC = src;
  if (reg->bitfields.SRC != src) HSLDPF(E_ERROR_MESSAGE,"RB2D_CLRCMP_CNTL::SRC data too large\n");
}
#else
#define set_RB2D_CLRCMP_CNTL_fcn_src(reg, fcn_src) (reg)->bitfields.FCN_SRC = fcn_src
#define set_RB2D_CLRCMP_CNTL_fcn_dst(reg, fcn_dst) (reg)->bitfields.FCN_DST = fcn_dst
#define set_RB2D_CLRCMP_CNTL_src(reg, src) (reg)->bitfields.SRC = src

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_CLRCMP_MSK regRB2D_CLRCMP_MSK;

#ifdef DEBUG
__inline void set_RB2D_CLRCMP_MSK_clrcmp_msk(regRB2D_CLRCMP_MSK *reg, unsigned int clrcmp_msk)
{
  reg->bitfields.CLRCMP_MSK = clrcmp_msk;
  if (reg->bitfields.CLRCMP_MSK != clrcmp_msk) HSLDPF(E_ERROR_MESSAGE,"RB2D_CLRCMP_MSK::CLRCMP_MSK data too large\n");
}
#else
#define set_RB2D_CLRCMP_MSK_clrcmp_msk(reg, clrcmp_msk) (reg)->bitfields.CLRCMP_MSK = clrcmp_msk

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_WRITEMASK regRB2D_WRITEMASK;

#ifdef DEBUG
__inline void set_RB2D_WRITEMASK_writemask(regRB2D_WRITEMASK *reg, unsigned int writemask)
{
  reg->bitfields.WRITEMASK = writemask;
  if (reg->bitfields.WRITEMASK != writemask) HSLDPF(E_ERROR_MESSAGE,"RB2D_WRITEMASK::WRITEMASK data too large\n");
}
#else
#define set_RB2D_WRITEMASK_writemask(reg, writemask) (reg)->bitfields.WRITEMASK = writemask

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_DATATYPE regRB2D_DATATYPE;

#ifdef DEBUG
__inline void set_RB2D_DATATYPE_dp_dst_datatype(regRB2D_DATATYPE *reg, unsigned int dp_dst_datatype)
{
  reg->bitfields.DP_DST_DATATYPE = dp_dst_datatype;
  if (reg->bitfields.DP_DST_DATATYPE != dp_dst_datatype) HSLDPF(E_ERROR_MESSAGE,"RB2D_DATATYPE::DP_DST_DATATYPE data too large\n");
}
__inline void set_RB2D_DATATYPE_dp_brush_datatype(regRB2D_DATATYPE *reg, unsigned int dp_brush_datatype)
{
  reg->bitfields.DP_BRUSH_DATATYPE = dp_brush_datatype;
  if (reg->bitfields.DP_BRUSH_DATATYPE != dp_brush_datatype) HSLDPF(E_ERROR_MESSAGE,"RB2D_DATATYPE::DP_BRUSH_DATATYPE data too large\n");
}
#else
#define set_RB2D_DATATYPE_dp_dst_datatype(reg, dp_dst_datatype) (reg)->bitfields.DP_DST_DATATYPE = dp_dst_datatype
#define set_RB2D_DATATYPE_dp_brush_datatype(reg, dp_brush_datatype) (reg)->bitfields.DP_BRUSH_DATATYPE = dp_brush_datatype

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_GUI_MASTER_CNTL regRB2D_GUI_MASTER_CNTL;

#ifdef DEBUG
__inline void set_RB2D_GUI_MASTER_CNTL_gmc_brush_datatype(regRB2D_GUI_MASTER_CNTL *reg, unsigned int gmc_brush_datatype)
{
  reg->bitfields.GMC_BRUSH_DATATYPE = gmc_brush_datatype;
  if (reg->bitfields.GMC_BRUSH_DATATYPE != gmc_brush_datatype) HSLDPF(E_ERROR_MESSAGE,"RB2D_GUI_MASTER_CNTL::GMC_BRUSH_DATATYPE data too large\n");
}
__inline void set_RB2D_GUI_MASTER_CNTL_gmc_dst_datatype(regRB2D_GUI_MASTER_CNTL *reg, unsigned int gmc_dst_datatype)
{
  reg->bitfields.GMC_DST_DATATYPE = gmc_dst_datatype;
  if (reg->bitfields.GMC_DST_DATATYPE != gmc_dst_datatype) HSLDPF(E_ERROR_MESSAGE,"RB2D_GUI_MASTER_CNTL::GMC_DST_DATATYPE data too large\n");
}
__inline void set_RB2D_GUI_MASTER_CNTL_gmc_rop(regRB2D_GUI_MASTER_CNTL *reg, unsigned int gmc_rop)
{
  reg->bitfields.GMC_ROP = gmc_rop;
  if (reg->bitfields.GMC_ROP != gmc_rop) HSLDPF(E_ERROR_MESSAGE,"RB2D_GUI_MASTER_CNTL::GMC_ROP data too large\n");
}
__inline void set_RB2D_GUI_MASTER_CNTL_gmc_clr_cmp_fcn_dis(regRB2D_GUI_MASTER_CNTL *reg, unsigned int gmc_clr_cmp_fcn_dis)
{
  reg->bitfields.GMC_CLR_CMP_FCN_DIS = gmc_clr_cmp_fcn_dis;
  if (reg->bitfields.GMC_CLR_CMP_FCN_DIS != gmc_clr_cmp_fcn_dis) HSLDPF(E_ERROR_MESSAGE,"RB2D_GUI_MASTER_CNTL::GMC_CLR_CMP_FCN_DIS data too large\n");
}
__inline void set_RB2D_GUI_MASTER_CNTL_gmc_wr_msk_dis(regRB2D_GUI_MASTER_CNTL *reg, unsigned int gmc_wr_msk_dis)
{
  reg->bitfields.GMC_WR_MSK_DIS = gmc_wr_msk_dis;
  if (reg->bitfields.GMC_WR_MSK_DIS != gmc_wr_msk_dis) HSLDPF(E_ERROR_MESSAGE,"RB2D_GUI_MASTER_CNTL::GMC_WR_MSK_DIS data too large\n");
}
#else
#define set_RB2D_GUI_MASTER_CNTL_gmc_brush_datatype(reg, gmc_brush_datatype) (reg)->bitfields.GMC_BRUSH_DATATYPE = gmc_brush_datatype
#define set_RB2D_GUI_MASTER_CNTL_gmc_dst_datatype(reg, gmc_dst_datatype) (reg)->bitfields.GMC_DST_DATATYPE = gmc_dst_datatype
#define set_RB2D_GUI_MASTER_CNTL_gmc_rop(reg, gmc_rop) (reg)->bitfields.GMC_ROP = gmc_rop
#define set_RB2D_GUI_MASTER_CNTL_gmc_clr_cmp_fcn_dis(reg, gmc_clr_cmp_fcn_dis) (reg)->bitfields.GMC_CLR_CMP_FCN_DIS = gmc_clr_cmp_fcn_dis
#define set_RB2D_GUI_MASTER_CNTL_gmc_wr_msk_dis(reg, gmc_wr_msk_dis) (reg)->bitfields.GMC_WR_MSK_DIS = gmc_wr_msk_dis

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_0 regRB2D_BRUSHDATA_0;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_0_brushdata(regRB2D_BRUSHDATA_0 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_0::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_0_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_1 regRB2D_BRUSHDATA_1;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_1_brushdata(regRB2D_BRUSHDATA_1 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_1::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_1_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_2 regRB2D_BRUSHDATA_2;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_2_brushdata(regRB2D_BRUSHDATA_2 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_2::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_2_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_3 regRB2D_BRUSHDATA_3;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_3_brushdata(regRB2D_BRUSHDATA_3 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_3::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_3_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_4 regRB2D_BRUSHDATA_4;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_4_brushdata(regRB2D_BRUSHDATA_4 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_4::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_4_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_5 regRB2D_BRUSHDATA_5;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_5_brushdata(regRB2D_BRUSHDATA_5 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_5::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_5_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_6 regRB2D_BRUSHDATA_6;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_6_brushdata(regRB2D_BRUSHDATA_6 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_6::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_6_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_7 regRB2D_BRUSHDATA_7;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_7_brushdata(regRB2D_BRUSHDATA_7 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_7::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_7_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_8 regRB2D_BRUSHDATA_8;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_8_brushdata(regRB2D_BRUSHDATA_8 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_8::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_8_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_9 regRB2D_BRUSHDATA_9;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_9_brushdata(regRB2D_BRUSHDATA_9 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_9::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_9_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_10 regRB2D_BRUSHDATA_10;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_10_brushdata(regRB2D_BRUSHDATA_10 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_10::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_10_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_11 regRB2D_BRUSHDATA_11;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_11_brushdata(regRB2D_BRUSHDATA_11 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_11::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_11_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_12 regRB2D_BRUSHDATA_12;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_12_brushdata(regRB2D_BRUSHDATA_12 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_12::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_12_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_13 regRB2D_BRUSHDATA_13;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_13_brushdata(regRB2D_BRUSHDATA_13 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_13::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_13_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_14 regRB2D_BRUSHDATA_14;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_14_brushdata(regRB2D_BRUSHDATA_14 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_14::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_14_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_15 regRB2D_BRUSHDATA_15;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_15_brushdata(regRB2D_BRUSHDATA_15 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_15::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_15_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_16 regRB2D_BRUSHDATA_16;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_16_brushdata(regRB2D_BRUSHDATA_16 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_16::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_16_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_17 regRB2D_BRUSHDATA_17;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_17_brushdata(regRB2D_BRUSHDATA_17 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_17::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_17_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_18 regRB2D_BRUSHDATA_18;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_18_brushdata(regRB2D_BRUSHDATA_18 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_18::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_18_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_19 regRB2D_BRUSHDATA_19;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_19_brushdata(regRB2D_BRUSHDATA_19 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_19::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_19_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_20 regRB2D_BRUSHDATA_20;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_20_brushdata(regRB2D_BRUSHDATA_20 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_20::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_20_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_21 regRB2D_BRUSHDATA_21;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_21_brushdata(regRB2D_BRUSHDATA_21 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_21::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_21_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_22 regRB2D_BRUSHDATA_22;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_22_brushdata(regRB2D_BRUSHDATA_22 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_22::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_22_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_23 regRB2D_BRUSHDATA_23;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_23_brushdata(regRB2D_BRUSHDATA_23 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_23::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_23_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_24 regRB2D_BRUSHDATA_24;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_24_brushdata(regRB2D_BRUSHDATA_24 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_24::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_24_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_25 regRB2D_BRUSHDATA_25;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_25_brushdata(regRB2D_BRUSHDATA_25 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_25::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_25_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_26 regRB2D_BRUSHDATA_26;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_26_brushdata(regRB2D_BRUSHDATA_26 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_26::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_26_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_27 regRB2D_BRUSHDATA_27;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_27_brushdata(regRB2D_BRUSHDATA_27 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_27::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_27_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_28 regRB2D_BRUSHDATA_28;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_28_brushdata(regRB2D_BRUSHDATA_28 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_28::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_28_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_29 regRB2D_BRUSHDATA_29;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_29_brushdata(regRB2D_BRUSHDATA_29 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_29::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_29_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_30 regRB2D_BRUSHDATA_30;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_30_brushdata(regRB2D_BRUSHDATA_30 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_30::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_30_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_31 regRB2D_BRUSHDATA_31;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_31_brushdata(regRB2D_BRUSHDATA_31 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_31::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_31_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_32 regRB2D_BRUSHDATA_32;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_32_brushdata(regRB2D_BRUSHDATA_32 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_32::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_32_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_33 regRB2D_BRUSHDATA_33;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_33_brushdata(regRB2D_BRUSHDATA_33 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_33::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_33_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_34 regRB2D_BRUSHDATA_34;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_34_brushdata(regRB2D_BRUSHDATA_34 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_34::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_34_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_35 regRB2D_BRUSHDATA_35;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_35_brushdata(regRB2D_BRUSHDATA_35 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_35::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_35_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_36 regRB2D_BRUSHDATA_36;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_36_brushdata(regRB2D_BRUSHDATA_36 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_36::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_36_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_37 regRB2D_BRUSHDATA_37;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_37_brushdata(regRB2D_BRUSHDATA_37 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_37::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_37_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_38 regRB2D_BRUSHDATA_38;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_38_brushdata(regRB2D_BRUSHDATA_38 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_38::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_38_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_39 regRB2D_BRUSHDATA_39;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_39_brushdata(regRB2D_BRUSHDATA_39 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_39::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_39_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_40 regRB2D_BRUSHDATA_40;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_40_brushdata(regRB2D_BRUSHDATA_40 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_40::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_40_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_41 regRB2D_BRUSHDATA_41;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_41_brushdata(regRB2D_BRUSHDATA_41 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_41::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_41_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_42 regRB2D_BRUSHDATA_42;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_42_brushdata(regRB2D_BRUSHDATA_42 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_42::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_42_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_43 regRB2D_BRUSHDATA_43;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_43_brushdata(regRB2D_BRUSHDATA_43 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_43::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_43_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_44 regRB2D_BRUSHDATA_44;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_44_brushdata(regRB2D_BRUSHDATA_44 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_44::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_44_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_45 regRB2D_BRUSHDATA_45;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_45_brushdata(regRB2D_BRUSHDATA_45 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_45::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_45_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_46 regRB2D_BRUSHDATA_46;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_46_brushdata(regRB2D_BRUSHDATA_46 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_46::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_46_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_47 regRB2D_BRUSHDATA_47;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_47_brushdata(regRB2D_BRUSHDATA_47 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_47::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_47_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_48 regRB2D_BRUSHDATA_48;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_48_brushdata(regRB2D_BRUSHDATA_48 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_48::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_48_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_49 regRB2D_BRUSHDATA_49;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_49_brushdata(regRB2D_BRUSHDATA_49 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_49::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_49_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_50 regRB2D_BRUSHDATA_50;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_50_brushdata(regRB2D_BRUSHDATA_50 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_50::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_50_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_51 regRB2D_BRUSHDATA_51;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_51_brushdata(regRB2D_BRUSHDATA_51 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_51::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_51_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_52 regRB2D_BRUSHDATA_52;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_52_brushdata(regRB2D_BRUSHDATA_52 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_52::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_52_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_53 regRB2D_BRUSHDATA_53;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_53_brushdata(regRB2D_BRUSHDATA_53 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_53::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_53_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_54 regRB2D_BRUSHDATA_54;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_54_brushdata(regRB2D_BRUSHDATA_54 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_54::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_54_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_55 regRB2D_BRUSHDATA_55;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_55_brushdata(regRB2D_BRUSHDATA_55 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_55::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_55_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_56 regRB2D_BRUSHDATA_56;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_56_brushdata(regRB2D_BRUSHDATA_56 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_56::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_56_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_57 regRB2D_BRUSHDATA_57;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_57_brushdata(regRB2D_BRUSHDATA_57 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_57::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_57_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_58 regRB2D_BRUSHDATA_58;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_58_brushdata(regRB2D_BRUSHDATA_58 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_58::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_58_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_59 regRB2D_BRUSHDATA_59;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_59_brushdata(regRB2D_BRUSHDATA_59 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_59::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_59_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_60 regRB2D_BRUSHDATA_60;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_60_brushdata(regRB2D_BRUSHDATA_60 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_60::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_60_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_61 regRB2D_BRUSHDATA_61;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_61_brushdata(regRB2D_BRUSHDATA_61 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_61::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_61_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_62 regRB2D_BRUSHDATA_62;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_62_brushdata(regRB2D_BRUSHDATA_62 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_62::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_62_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_BRUSHDATA_63 regRB2D_BRUSHDATA_63;

#ifdef DEBUG
__inline void set_RB2D_BRUSHDATA_63_brushdata(regRB2D_BRUSHDATA_63 *reg, unsigned int brushdata)
{
  reg->bitfields.BRUSHDATA = brushdata;
  if (reg->bitfields.BRUSHDATA != brushdata) HSLDPF(E_ERROR_MESSAGE,"RB2D_BRUSHDATA_63::BRUSHDATA data too large\n");
}
#else
#define set_RB2D_BRUSHDATA_63_brushdata(reg, brushdata) (reg)->bitfields.BRUSHDATA = brushdata

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_DSTCACHE_MODE regRB2D_DSTCACHE_MODE;

#ifdef DEBUG
__inline void set_RB2D_DSTCACHE_MODE_dc_bypass(regRB2D_DSTCACHE_MODE *reg, unsigned int dc_bypass)
{
  reg->bitfields.DC_BYPASS = dc_bypass;
  if (reg->bitfields.DC_BYPASS != dc_bypass) HSLDPF(E_ERROR_MESSAGE,"RB2D_DSTCACHE_MODE::DC_BYPASS data too large\n");
}
__inline void set_RB2D_DSTCACHE_MODE_dc_line_size(regRB2D_DSTCACHE_MODE *reg, unsigned int dc_line_size)
{
  reg->bitfields.DC_LINE_SIZE = dc_line_size;
  if (reg->bitfields.DC_LINE_SIZE != dc_line_size) HSLDPF(E_ERROR_MESSAGE,"RB2D_DSTCACHE_MODE::DC_LINE_SIZE data too large\n");
}
__inline void set_RB2D_DSTCACHE_MODE_dc_autoflush_enable(regRB2D_DSTCACHE_MODE *reg, unsigned int dc_autoflush_enable)
{
  reg->bitfields.DC_AUTOFLUSH_ENABLE = dc_autoflush_enable;
  if (reg->bitfields.DC_AUTOFLUSH_ENABLE != dc_autoflush_enable) HSLDPF(E_ERROR_MESSAGE,"RB2D_DSTCACHE_MODE::DC_AUTOFLUSH_ENABLE data too large\n");
}
__inline void set_RB2D_DSTCACHE_MODE_dc_autofree_enable(regRB2D_DSTCACHE_MODE *reg, unsigned int dc_autofree_enable)
{
  reg->bitfields.DC_AUTOFREE_ENABLE = dc_autofree_enable;
  if (reg->bitfields.DC_AUTOFREE_ENABLE != dc_autofree_enable) HSLDPF(E_ERROR_MESSAGE,"RB2D_DSTCACHE_MODE::DC_AUTOFREE_ENABLE data too large\n");
}
__inline void set_RB2D_DSTCACHE_MODE_dc_force_rmw(regRB2D_DSTCACHE_MODE *reg, unsigned int dc_force_rmw)
{
  reg->bitfields.DC_FORCE_RMW = dc_force_rmw;
  if (reg->bitfields.DC_FORCE_RMW != dc_force_rmw) HSLDPF(E_ERROR_MESSAGE,"RB2D_DSTCACHE_MODE::DC_FORCE_RMW data too large\n");
}
__inline void set_RB2D_DSTCACHE_MODE_dc_disable_ri_fill(regRB2D_DSTCACHE_MODE *reg, unsigned int dc_disable_ri_fill)
{
  reg->bitfields.DC_DISABLE_RI_FILL = dc_disable_ri_fill;
  if (reg->bitfields.DC_DISABLE_RI_FILL != dc_disable_ri_fill) HSLDPF(E_ERROR_MESSAGE,"RB2D_DSTCACHE_MODE::DC_DISABLE_RI_FILL data too large\n");
}
__inline void set_RB2D_DSTCACHE_MODE_dc_disable_ri_read(regRB2D_DSTCACHE_MODE *reg, unsigned int dc_disable_ri_read)
{
  reg->bitfields.DC_DISABLE_RI_READ = dc_disable_ri_read;
  if (reg->bitfields.DC_DISABLE_RI_READ != dc_disable_ri_read) HSLDPF(E_ERROR_MESSAGE,"RB2D_DSTCACHE_MODE::DC_DISABLE_RI_READ data too large\n");
}
__inline void set_RB2D_DSTCACHE_MODE_dc_disable_mask_chk(regRB2D_DSTCACHE_MODE *reg, unsigned int dc_disable_mask_chk)
{
  reg->bitfields.DC_DISABLE_MASK_CHK = dc_disable_mask_chk;
  if (reg->bitfields.DC_DISABLE_MASK_CHK != dc_disable_mask_chk) HSLDPF(E_ERROR_MESSAGE,"RB2D_DSTCACHE_MODE::DC_DISABLE_MASK_CHK data too large\n");
}
#else
#define set_RB2D_DSTCACHE_MODE_dc_bypass(reg, dc_bypass) (reg)->bitfields.DC_BYPASS = dc_bypass
#define set_RB2D_DSTCACHE_MODE_dc_line_size(reg, dc_line_size) (reg)->bitfields.DC_LINE_SIZE = dc_line_size
#define set_RB2D_DSTCACHE_MODE_dc_autoflush_enable(reg, dc_autoflush_enable) (reg)->bitfields.DC_AUTOFLUSH_ENABLE = dc_autoflush_enable
#define set_RB2D_DSTCACHE_MODE_dc_autofree_enable(reg, dc_autofree_enable) (reg)->bitfields.DC_AUTOFREE_ENABLE = dc_autofree_enable
#define set_RB2D_DSTCACHE_MODE_dc_force_rmw(reg, dc_force_rmw) (reg)->bitfields.DC_FORCE_RMW = dc_force_rmw
#define set_RB2D_DSTCACHE_MODE_dc_disable_ri_fill(reg, dc_disable_ri_fill) (reg)->bitfields.DC_DISABLE_RI_FILL = dc_disable_ri_fill
#define set_RB2D_DSTCACHE_MODE_dc_disable_ri_read(reg, dc_disable_ri_read) (reg)->bitfields.DC_DISABLE_RI_READ = dc_disable_ri_read
#define set_RB2D_DSTCACHE_MODE_dc_disable_mask_chk(reg, dc_disable_mask_chk) (reg)->bitfields.DC_DISABLE_MASK_CHK = dc_disable_mask_chk

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_DSTCACHE_CTLSTAT regRB2D_DSTCACHE_CTLSTAT;

#ifdef DEBUG
__inline void set_RB2D_DSTCACHE_CTLSTAT_dc_flush(regRB2D_DSTCACHE_CTLSTAT *reg, unsigned int dc_flush)
{
  reg->bitfields.DC_FLUSH = dc_flush;
  if (reg->bitfields.DC_FLUSH != dc_flush) HSLDPF(E_ERROR_MESSAGE,"RB2D_DSTCACHE_CTLSTAT::DC_FLUSH data too large\n");
}
__inline void set_RB2D_DSTCACHE_CTLSTAT_dc_free(regRB2D_DSTCACHE_CTLSTAT *reg, unsigned int dc_free)
{
  reg->bitfields.DC_FREE = dc_free;
  if (reg->bitfields.DC_FREE != dc_free) HSLDPF(E_ERROR_MESSAGE,"RB2D_DSTCACHE_CTLSTAT::DC_FREE data too large\n");
}
__inline void set_RB2D_DSTCACHE_CTLSTAT_dc_busy(regRB2D_DSTCACHE_CTLSTAT *reg, unsigned int dc_busy)
{
  reg->bitfields.DC_BUSY = dc_busy;
  if (reg->bitfields.DC_BUSY != dc_busy) HSLDPF(E_ERROR_MESSAGE,"RB2D_DSTCACHE_CTLSTAT::DC_BUSY data too large\n");
}
#else
#define set_RB2D_DSTCACHE_CTLSTAT_dc_flush(reg, dc_flush) (reg)->bitfields.DC_FLUSH = dc_flush
#define set_RB2D_DSTCACHE_CTLSTAT_dc_free(reg, dc_free) (reg)->bitfields.DC_FREE = dc_free
#define set_RB2D_DSTCACHE_CTLSTAT_dc_busy(reg, dc_busy) (reg)->bitfields.DC_BUSY = dc_busy

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_SRC_ENDIAN regRB2D_SRC_ENDIAN;

#ifdef DEBUG
__inline void set_RB2D_SRC_ENDIAN_src_endian(regRB2D_SRC_ENDIAN *reg, unsigned int src_endian)
{
  reg->bitfields.SRC_ENDIAN = src_endian;
  if (reg->bitfields.SRC_ENDIAN != src_endian) HSLDPF(E_ERROR_MESSAGE,"RB2D_SRC_ENDIAN::SRC_ENDIAN data too large\n");
}
#else
#define set_RB2D_SRC_ENDIAN_src_endian(reg, src_endian) (reg)->bitfields.SRC_ENDIAN = src_endian

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_DST_ENDIAN regRB2D_DST_ENDIAN;

#ifdef DEBUG
__inline void set_RB2D_DST_ENDIAN_dst_endian(regRB2D_DST_ENDIAN *reg, unsigned int dst_endian)
{
  reg->bitfields.DST_ENDIAN = dst_endian;
  if (reg->bitfields.DST_ENDIAN != dst_endian) HSLDPF(E_ERROR_MESSAGE,"RB2D_DST_ENDIAN::DST_ENDIAN data too large\n");
}
#else
#define set_RB2D_DST_ENDIAN_dst_endian(reg, dst_endian) (reg)->bitfields.DST_ENDIAN = dst_endian

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_PD1_DATA regRB2D_PD1_DATA;

#ifdef DEBUG
__inline void set_RB2D_PD1_DATA_pd1_data(regRB2D_PD1_DATA *reg, unsigned int pd1_data)
{
  reg->bitfields.PD1_DATA = pd1_data;
  if (reg->bitfields.PD1_DATA != pd1_data) HSLDPF(E_ERROR_MESSAGE,"RB2D_PD1_DATA::PD1_DATA data too large\n");
}
#else
#define set_RB2D_PD1_DATA_pd1_data(reg, pd1_data) (reg)->bitfields.PD1_DATA = pd1_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_PD2_DATA regRB2D_PD2_DATA;

#ifdef DEBUG
__inline void set_RB2D_PD2_DATA_pd2_data(regRB2D_PD2_DATA *reg, unsigned int pd2_data)
{
  reg->bitfields.PD2_DATA = pd2_data;
  if (reg->bitfields.PD2_DATA != pd2_data) HSLDPF(E_ERROR_MESSAGE,"RB2D_PD2_DATA::PD2_DATA data too large\n");
}
#else
#define set_RB2D_PD2_DATA_pd2_data(reg, pd2_data) (reg)->bitfields.PD2_DATA = pd2_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_WRITEBACK_DATA_LO regRB2D_WRITEBACK_DATA_LO;

#ifdef DEBUG
__inline void set_RB2D_WRITEBACK_DATA_LO_writeback_data_lo(regRB2D_WRITEBACK_DATA_LO *reg, unsigned int writeback_data_lo)
{
  reg->bitfields.WRITEBACK_DATA_LO = writeback_data_lo;
  if (reg->bitfields.WRITEBACK_DATA_LO != writeback_data_lo) HSLDPF(E_ERROR_MESSAGE,"RB2D_WRITEBACK_DATA_LO::WRITEBACK_DATA_LO data too large\n");
}
#else
#define set_RB2D_WRITEBACK_DATA_LO_writeback_data_lo(reg, writeback_data_lo) (reg)->bitfields.WRITEBACK_DATA_LO = writeback_data_lo

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_WRITEBACK_DATA_HI regRB2D_WRITEBACK_DATA_HI;

#ifdef DEBUG
__inline void set_RB2D_WRITEBACK_DATA_HI_writeback_data_hi(regRB2D_WRITEBACK_DATA_HI *reg, unsigned int writeback_data_hi)
{
  reg->bitfields.WRITEBACK_DATA_HI = writeback_data_hi;
  if (reg->bitfields.WRITEBACK_DATA_HI != writeback_data_hi) HSLDPF(E_ERROR_MESSAGE,"RB2D_WRITEBACK_DATA_HI::WRITEBACK_DATA_HI data too large\n");
}
#else
#define set_RB2D_WRITEBACK_DATA_HI_writeback_data_hi(reg, writeback_data_hi) (reg)->bitfields.WRITEBACK_DATA_HI = writeback_data_hi

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB2D_WRITEBACK_ADDR regRB2D_WRITEBACK_ADDR;

#ifdef DEBUG
__inline void set_RB2D_WRITEBACK_ADDR_writeback_addr(regRB2D_WRITEBACK_ADDR *reg, unsigned int writeback_addr)
{
  reg->bitfields.WRITEBACK_ADDR = writeback_addr;
  if (reg->bitfields.WRITEBACK_ADDR != writeback_addr) HSLDPF(E_ERROR_MESSAGE,"RB2D_WRITEBACK_ADDR::WRITEBACK_ADDR data too large\n");
}
#else
#define set_RB2D_WRITEBACK_ADDR_writeback_addr(reg, writeback_addr) (reg)->bitfields.WRITEBACK_ADDR = writeback_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_BLENDCOLOR regRB3D_BLENDCOLOR;

#ifdef DEBUG
__inline void set_RB3D_BLENDCOLOR_argb(regRB3D_BLENDCOLOR *reg, unsigned int argb)
{
  reg->bitfields.ARGB = argb;
  if (reg->bitfields.ARGB != argb) HSLDPF(E_ERROR_MESSAGE,"RB3D_BLENDCOLOR::ARGB data too large\n");
}
#else
#define set_RB3D_BLENDCOLOR_argb(reg, argb) (reg)->bitfields.ARGB = argb

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_ABLENDCNTL regRB3D_ABLENDCNTL;

#ifdef DEBUG
__inline void set_RB3D_ABLENDCNTL_comb_fcn(regRB3D_ABLENDCNTL *reg, unsigned int comb_fcn)
{
  reg->bitfields.COMB_FCN = comb_fcn;
  if (reg->bitfields.COMB_FCN != comb_fcn) HSLDPF(E_ERROR_MESSAGE,"RB3D_ABLENDCNTL::COMB_FCN data too large\n");
}
__inline void set_RB3D_ABLENDCNTL_srcblend(regRB3D_ABLENDCNTL *reg, unsigned int srcblend)
{
  reg->bitfields.SRCBLEND = srcblend;
  if (reg->bitfields.SRCBLEND != srcblend) HSLDPF(E_ERROR_MESSAGE,"RB3D_ABLENDCNTL::SRCBLEND data too large\n");
}
__inline void set_RB3D_ABLENDCNTL_destblend(regRB3D_ABLENDCNTL *reg, unsigned int destblend)
{
  reg->bitfields.DESTBLEND = destblend;
  if (reg->bitfields.DESTBLEND != destblend) HSLDPF(E_ERROR_MESSAGE,"RB3D_ABLENDCNTL::DESTBLEND data too large\n");
}
#else
#define set_RB3D_ABLENDCNTL_comb_fcn(reg, comb_fcn) (reg)->bitfields.COMB_FCN = comb_fcn
#define set_RB3D_ABLENDCNTL_srcblend(reg, srcblend) (reg)->bitfields.SRCBLEND = srcblend
#define set_RB3D_ABLENDCNTL_destblend(reg, destblend) (reg)->bitfields.DESTBLEND = destblend

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_BLENDCNTL regRB3D_BLENDCNTL;

#ifdef DEBUG
__inline void set_RB3D_BLENDCNTL_comb_fcn_r2(regRB3D_BLENDCNTL *reg, unsigned int comb_fcn_r2)
{
  reg->bitfields.COMB_FCN_R2 = comb_fcn_r2;
  if (reg->bitfields.COMB_FCN_R2 != comb_fcn_r2) HSLDPF(E_ERROR_MESSAGE,"RB3D_BLENDCNTL::COMB_FCN_R2 data too large\n");
}
__inline void set_RB3D_BLENDCNTL_srcblend(regRB3D_BLENDCNTL *reg, unsigned int srcblend)
{
  reg->bitfields.SRCBLEND = srcblend;
  if (reg->bitfields.SRCBLEND != srcblend) HSLDPF(E_ERROR_MESSAGE,"RB3D_BLENDCNTL::SRCBLEND data too large\n");
}
__inline void set_RB3D_BLENDCNTL_destblend(regRB3D_BLENDCNTL *reg, unsigned int destblend)
{
  reg->bitfields.DESTBLEND = destblend;
  if (reg->bitfields.DESTBLEND != destblend) HSLDPF(E_ERROR_MESSAGE,"RB3D_BLENDCNTL::DESTBLEND data too large\n");
}
#else
#define set_RB3D_BLENDCNTL_comb_fcn_r2(reg, comb_fcn_r2) (reg)->bitfields.COMB_FCN_R2 = comb_fcn_r2
#define set_RB3D_BLENDCNTL_srcblend(reg, srcblend) (reg)->bitfields.SRCBLEND = srcblend
#define set_RB3D_BLENDCNTL_destblend(reg, destblend) (reg)->bitfields.DESTBLEND = destblend

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_DEPTHOFFSET regRB3D_DEPTHOFFSET;

#ifdef DEBUG
__inline void set_RB3D_DEPTHOFFSET_depthoffset_r2(regRB3D_DEPTHOFFSET *reg, unsigned int depthoffset_r2)
{
  reg->bitfields.DEPTHOFFSET_R2 = depthoffset_r2;
  if (reg->bitfields.DEPTHOFFSET_R2 != depthoffset_r2) HSLDPF(E_ERROR_MESSAGE,"RB3D_DEPTHOFFSET::DEPTHOFFSET_R2 data too large\n");
}
#else
#define set_RB3D_DEPTHOFFSET_depthoffset_r2(reg, depthoffset_r2) (reg)->bitfields.DEPTHOFFSET_R2 = depthoffset_r2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_DEPTHPITCH regRB3D_DEPTHPITCH;

#ifdef DEBUG
__inline void set_RB3D_DEPTHPITCH_depthpitch_r2(regRB3D_DEPTHPITCH *reg, unsigned int depthpitch_r2)
{
  reg->bitfields.DEPTHPITCH_R2 = depthpitch_r2;
  if (reg->bitfields.DEPTHPITCH_R2 != depthpitch_r2) HSLDPF(E_ERROR_MESSAGE,"RB3D_DEPTHPITCH::DEPTHPITCH_R2 data too large\n");
}
__inline void set_RB3D_DEPTHPITCH_depthendian(regRB3D_DEPTHPITCH *reg, unsigned int depthendian)
{
  reg->bitfields.DEPTHENDIAN = depthendian;
  if (reg->bitfields.DEPTHENDIAN != depthendian) HSLDPF(E_ERROR_MESSAGE,"RB3D_DEPTHPITCH::DEPTHENDIAN data too large\n");
}
#else
#define set_RB3D_DEPTHPITCH_depthpitch_r2(reg, depthpitch_r2) (reg)->bitfields.DEPTHPITCH_R2 = depthpitch_r2
#define set_RB3D_DEPTHPITCH_depthendian(reg, depthendian) (reg)->bitfields.DEPTHENDIAN = depthendian

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_DEPTHCLEARVALUE regRB3D_DEPTHCLEARVALUE;

#ifdef DEBUG
__inline void set_RB3D_DEPTHCLEARVALUE_depthclearvalue(regRB3D_DEPTHCLEARVALUE *reg, unsigned int depthclearvalue)
{
  reg->bitfields.DEPTHCLEARVALUE = depthclearvalue;
  if (reg->bitfields.DEPTHCLEARVALUE != depthclearvalue) HSLDPF(E_ERROR_MESSAGE,"RB3D_DEPTHCLEARVALUE::DEPTHCLEARVALUE data too large\n");
}
#else
#define set_RB3D_DEPTHCLEARVALUE_depthclearvalue(reg, depthclearvalue) (reg)->bitfields.DEPTHCLEARVALUE = depthclearvalue

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_ZMASKOFFSET regRB3D_ZMASKOFFSET;

#ifdef DEBUG
__inline void set_RB3D_ZMASKOFFSET_zmaskoffset(regRB3D_ZMASKOFFSET *reg, unsigned int zmaskoffset)
{
  reg->bitfields.ZMASKOFFSET = zmaskoffset;
  if (reg->bitfields.ZMASKOFFSET != zmaskoffset) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZMASKOFFSET::ZMASKOFFSET data too large\n");
}
#else
#define set_RB3D_ZMASKOFFSET_zmaskoffset(reg, zmaskoffset) (reg)->bitfields.ZMASKOFFSET = zmaskoffset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_CNTL regRB3D_CNTL;

#ifdef DEBUG
__inline void set_RB3D_CNTL_alpha_blend_enable(regRB3D_CNTL *reg, unsigned int alpha_blend_enable)
{
  reg->bitfields.ALPHA_BLEND_ENABLE = alpha_blend_enable;
  if (reg->bitfields.ALPHA_BLEND_ENABLE != alpha_blend_enable) HSLDPF(E_ERROR_MESSAGE,"RB3D_CNTL::ALPHA_BLEND_ENABLE data too large\n");
}
__inline void set_RB3D_CNTL_plane_mask_enable(regRB3D_CNTL *reg, unsigned int plane_mask_enable)
{
  reg->bitfields.PLANE_MASK_ENABLE = plane_mask_enable;
  if (reg->bitfields.PLANE_MASK_ENABLE != plane_mask_enable) HSLDPF(E_ERROR_MESSAGE,"RB3D_CNTL::PLANE_MASK_ENABLE data too large\n");
}
__inline void set_RB3D_CNTL_dither_enable(regRB3D_CNTL *reg, unsigned int dither_enable)
{
  reg->bitfields.DITHER_ENABLE = dither_enable;
  if (reg->bitfields.DITHER_ENABLE != dither_enable) HSLDPF(E_ERROR_MESSAGE,"RB3D_CNTL::DITHER_ENABLE data too large\n");
}
__inline void set_RB3D_CNTL_round_enable(regRB3D_CNTL *reg, unsigned int round_enable)
{
  reg->bitfields.ROUND_ENABLE = round_enable;
  if (reg->bitfields.ROUND_ENABLE != round_enable) HSLDPF(E_ERROR_MESSAGE,"RB3D_CNTL::ROUND_ENABLE data too large\n");
}
__inline void set_RB3D_CNTL_scale_dither(regRB3D_CNTL *reg, unsigned int scale_dither)
{
  reg->bitfields.SCALE_DITHER = scale_dither;
  if (reg->bitfields.SCALE_DITHER != scale_dither) HSLDPF(E_ERROR_MESSAGE,"RB3D_CNTL::SCALE_DITHER data too large\n");
}
__inline void set_RB3D_CNTL_dither_init(regRB3D_CNTL *reg, unsigned int dither_init)
{
  reg->bitfields.DITHER_INIT = dither_init;
  if (reg->bitfields.DITHER_INIT != dither_init) HSLDPF(E_ERROR_MESSAGE,"RB3D_CNTL::DITHER_INIT data too large\n");
}
__inline void set_RB3D_CNTL_rop_enable(regRB3D_CNTL *reg, unsigned int rop_enable)
{
  reg->bitfields.ROP_ENABLE = rop_enable;
  if (reg->bitfields.ROP_ENABLE != rop_enable) HSLDPF(E_ERROR_MESSAGE,"RB3D_CNTL::ROP_ENABLE data too large\n");
}
__inline void set_RB3D_CNTL_stencil_enable(regRB3D_CNTL *reg, unsigned int stencil_enable)
{
  reg->bitfields.STENCIL_ENABLE = stencil_enable;
  if (reg->bitfields.STENCIL_ENABLE != stencil_enable) HSLDPF(E_ERROR_MESSAGE,"RB3D_CNTL::STENCIL_ENABLE data too large\n");
}
__inline void set_RB3D_CNTL_z_enable(regRB3D_CNTL *reg, unsigned int z_enable)
{
  reg->bitfields.Z_ENABLE = z_enable;
  if (reg->bitfields.Z_ENABLE != z_enable) HSLDPF(E_ERROR_MESSAGE,"RB3D_CNTL::Z_ENABLE data too large\n");
}
__inline void set_RB3D_CNTL_depthxy_offset_enable(regRB3D_CNTL *reg, unsigned int depthxy_offset_enable)
{
  reg->bitfields.DEPTHXY_OFFSET_ENABLE = depthxy_offset_enable;
  if (reg->bitfields.DEPTHXY_OFFSET_ENABLE != depthxy_offset_enable) HSLDPF(E_ERROR_MESSAGE,"RB3D_CNTL::DEPTHXY_OFFSET_ENABLE data too large\n");
}
__inline void set_RB3D_CNTL_colorformat(regRB3D_CNTL *reg, unsigned int colorformat)
{
  reg->bitfields.COLORFORMAT = colorformat;
  if (reg->bitfields.COLORFORMAT != colorformat) HSLDPF(E_ERROR_MESSAGE,"RB3D_CNTL::COLORFORMAT data too large\n");
}
__inline void set_RB3D_CNTL_clrcmp_flipe_enable(regRB3D_CNTL *reg, unsigned int clrcmp_flipe_enable)
{
  reg->bitfields.CLRCMP_FLIPE_ENABLE = clrcmp_flipe_enable;
  if (reg->bitfields.CLRCMP_FLIPE_ENABLE != clrcmp_flipe_enable) HSLDPF(E_ERROR_MESSAGE,"RB3D_CNTL::CLRCMP_FLIPE_ENABLE data too large\n");
}
__inline void set_RB3D_CNTL_separate_alpha_enable(regRB3D_CNTL *reg, unsigned int separate_alpha_enable)
{
  reg->bitfields.SEPARATE_ALPHA_ENABLE = separate_alpha_enable;
  if (reg->bitfields.SEPARATE_ALPHA_ENABLE != separate_alpha_enable) HSLDPF(E_ERROR_MESSAGE,"RB3D_CNTL::SEPARATE_ALPHA_ENABLE data too large\n");
}
#else
#define set_RB3D_CNTL_alpha_blend_enable(reg, alpha_blend_enable) (reg)->bitfields.ALPHA_BLEND_ENABLE = alpha_blend_enable
#define set_RB3D_CNTL_plane_mask_enable(reg, plane_mask_enable) (reg)->bitfields.PLANE_MASK_ENABLE = plane_mask_enable
#define set_RB3D_CNTL_dither_enable(reg, dither_enable) (reg)->bitfields.DITHER_ENABLE = dither_enable
#define set_RB3D_CNTL_round_enable(reg, round_enable) (reg)->bitfields.ROUND_ENABLE = round_enable
#define set_RB3D_CNTL_scale_dither(reg, scale_dither) (reg)->bitfields.SCALE_DITHER = scale_dither
#define set_RB3D_CNTL_dither_init(reg, dither_init) (reg)->bitfields.DITHER_INIT = dither_init
#define set_RB3D_CNTL_rop_enable(reg, rop_enable) (reg)->bitfields.ROP_ENABLE = rop_enable
#define set_RB3D_CNTL_stencil_enable(reg, stencil_enable) (reg)->bitfields.STENCIL_ENABLE = stencil_enable
#define set_RB3D_CNTL_z_enable(reg, z_enable) (reg)->bitfields.Z_ENABLE = z_enable
#define set_RB3D_CNTL_depthxy_offset_enable(reg, depthxy_offset_enable) (reg)->bitfields.DEPTHXY_OFFSET_ENABLE = depthxy_offset_enable
#define set_RB3D_CNTL_colorformat(reg, colorformat) (reg)->bitfields.COLORFORMAT = colorformat
#define set_RB3D_CNTL_clrcmp_flipe_enable(reg, clrcmp_flipe_enable) (reg)->bitfields.CLRCMP_FLIPE_ENABLE = clrcmp_flipe_enable
#define set_RB3D_CNTL_separate_alpha_enable(reg, separate_alpha_enable) (reg)->bitfields.SEPARATE_ALPHA_ENABLE = separate_alpha_enable

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_COLOROFFSET regRB3D_COLOROFFSET;

#ifdef DEBUG
__inline void set_RB3D_COLOROFFSET_coloroffset(regRB3D_COLOROFFSET *reg, unsigned int coloroffset)
{
  reg->bitfields.COLOROFFSET = coloroffset;
  if (reg->bitfields.COLOROFFSET != coloroffset) HSLDPF(E_ERROR_MESSAGE,"RB3D_COLOROFFSET::COLOROFFSET data too large\n");
}
#else
#define set_RB3D_COLOROFFSET_coloroffset(reg, coloroffset) (reg)->bitfields.COLOROFFSET = coloroffset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_COLORPITCH regRB3D_COLORPITCH;

#ifdef DEBUG
__inline void set_RB3D_COLORPITCH_colorpitch(regRB3D_COLORPITCH *reg, unsigned int colorpitch)
{
  reg->bitfields.COLORPITCH = colorpitch;
  if (reg->bitfields.COLORPITCH != colorpitch) HSLDPF(E_ERROR_MESSAGE,"RB3D_COLORPITCH::COLORPITCH data too large\n");
}
__inline void set_RB3D_COLORPITCH_colortile(regRB3D_COLORPITCH *reg, unsigned int colortile)
{
  reg->bitfields.COLORTILE = colortile;
  if (reg->bitfields.COLORTILE != colortile) HSLDPF(E_ERROR_MESSAGE,"RB3D_COLORPITCH::COLORTILE data too large\n");
}
__inline void set_RB3D_COLORPITCH_colormicrotile(regRB3D_COLORPITCH *reg, unsigned int colormicrotile)
{
  reg->bitfields.COLORMICROTILE = colormicrotile;
  if (reg->bitfields.COLORMICROTILE != colormicrotile) HSLDPF(E_ERROR_MESSAGE,"RB3D_COLORPITCH::COLORMICROTILE data too large\n");
}
__inline void set_RB3D_COLORPITCH_colorendian(regRB3D_COLORPITCH *reg, unsigned int colorendian)
{
  reg->bitfields.COLORENDIAN = colorendian;
  if (reg->bitfields.COLORENDIAN != colorendian) HSLDPF(E_ERROR_MESSAGE,"RB3D_COLORPITCH::COLORENDIAN data too large\n");
}
#else
#define set_RB3D_COLORPITCH_colorpitch(reg, colorpitch) (reg)->bitfields.COLORPITCH = colorpitch
#define set_RB3D_COLORPITCH_colortile(reg, colortile) (reg)->bitfields.COLORTILE = colortile
#define set_RB3D_COLORPITCH_colormicrotile(reg, colormicrotile) (reg)->bitfields.COLORMICROTILE = colormicrotile
#define set_RB3D_COLORPITCH_colorendian(reg, colorendian) (reg)->bitfields.COLORENDIAN = colorendian

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_DEPTHXY_OFFSET regRB3D_DEPTHXY_OFFSET;

#ifdef DEBUG
__inline void set_RB3D_DEPTHXY_OFFSET_depthx_offset(regRB3D_DEPTHXY_OFFSET *reg, unsigned int depthx_offset)
{
  reg->bitfields.DEPTHX_OFFSET = depthx_offset;
  if (reg->bitfields.DEPTHX_OFFSET != depthx_offset) HSLDPF(E_ERROR_MESSAGE,"RB3D_DEPTHXY_OFFSET::DEPTHX_OFFSET data too large\n");
}
__inline void set_RB3D_DEPTHXY_OFFSET_depthy_offset(regRB3D_DEPTHXY_OFFSET *reg, unsigned int depthy_offset)
{
  reg->bitfields.DEPTHY_OFFSET = depthy_offset;
  if (reg->bitfields.DEPTHY_OFFSET != depthy_offset) HSLDPF(E_ERROR_MESSAGE,"RB3D_DEPTHXY_OFFSET::DEPTHY_OFFSET data too large\n");
}
#else
#define set_RB3D_DEPTHXY_OFFSET_depthx_offset(reg, depthx_offset) (reg)->bitfields.DEPTHX_OFFSET = depthx_offset
#define set_RB3D_DEPTHXY_OFFSET_depthy_offset(reg, depthy_offset) (reg)->bitfields.DEPTHY_OFFSET = depthy_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_CLRCMP_FLIPE regRB3D_CLRCMP_FLIPE;

#ifdef DEBUG
__inline void set_RB3D_CLRCMP_FLIPE_clrcmp_flipe(regRB3D_CLRCMP_FLIPE *reg, unsigned int clrcmp_flipe)
{
  reg->bitfields.CLRCMP_FLIPE = clrcmp_flipe;
  if (reg->bitfields.CLRCMP_FLIPE != clrcmp_flipe) HSLDPF(E_ERROR_MESSAGE,"RB3D_CLRCMP_FLIPE::CLRCMP_FLIPE data too large\n");
}
#else
#define set_RB3D_CLRCMP_FLIPE_clrcmp_flipe(reg, clrcmp_flipe) (reg)->bitfields.CLRCMP_FLIPE = clrcmp_flipe

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_CLRCMP_CLR regRB3D_CLRCMP_CLR;

#ifdef DEBUG
__inline void set_RB3D_CLRCMP_CLR_clrcmp_clr(regRB3D_CLRCMP_CLR *reg, unsigned int clrcmp_clr)
{
  reg->bitfields.CLRCMP_CLR = clrcmp_clr;
  if (reg->bitfields.CLRCMP_CLR != clrcmp_clr) HSLDPF(E_ERROR_MESSAGE,"RB3D_CLRCMP_CLR::CLRCMP_CLR data too large\n");
}
#else
#define set_RB3D_CLRCMP_CLR_clrcmp_clr(reg, clrcmp_clr) (reg)->bitfields.CLRCMP_CLR = clrcmp_clr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_CLRCMP_MSK regRB3D_CLRCMP_MSK;

#ifdef DEBUG
__inline void set_RB3D_CLRCMP_MSK_clrcmp_msk(regRB3D_CLRCMP_MSK *reg, unsigned int clrcmp_msk)
{
  reg->bitfields.CLRCMP_MSK = clrcmp_msk;
  if (reg->bitfields.CLRCMP_MSK != clrcmp_msk) HSLDPF(E_ERROR_MESSAGE,"RB3D_CLRCMP_MSK::CLRCMP_MSK data too large\n");
}
#else
#define set_RB3D_CLRCMP_MSK_clrcmp_msk(reg, clrcmp_msk) (reg)->bitfields.CLRCMP_MSK = clrcmp_msk

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_ZMASK_WRINDEX regRB3D_ZMASK_WRINDEX;

#ifdef DEBUG
__inline void set_RB3D_ZMASK_WRINDEX_zmask_wrindex(regRB3D_ZMASK_WRINDEX *reg, unsigned int zmask_wrindex)
{
  reg->bitfields.ZMASK_WRINDEX = zmask_wrindex;
  if (reg->bitfields.ZMASK_WRINDEX != zmask_wrindex) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZMASK_WRINDEX::ZMASK_WRINDEX data too large\n");
}
#else
#define set_RB3D_ZMASK_WRINDEX_zmask_wrindex(reg, zmask_wrindex) (reg)->bitfields.ZMASK_WRINDEX = zmask_wrindex

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_ZMASK_DWORD regRB3D_ZMASK_DWORD;

#ifdef DEBUG
__inline void set_RB3D_ZMASK_DWORD_zmaskdword(regRB3D_ZMASK_DWORD *reg, unsigned int zmaskdword)
{
  reg->bitfields.ZMASKDWORD = zmaskdword;
  if (reg->bitfields.ZMASKDWORD != zmaskdword) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZMASK_DWORD::ZMASKDWORD data too large\n");
}
#else
#define set_RB3D_ZMASK_DWORD_zmaskdword(reg, zmaskdword) (reg)->bitfields.ZMASKDWORD = zmaskdword

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_ZMASK_RDINDEX regRB3D_ZMASK_RDINDEX;

#ifdef DEBUG
__inline void set_RB3D_ZMASK_RDINDEX_zmask_rdindex(regRB3D_ZMASK_RDINDEX *reg, unsigned int zmask_rdindex)
{
  reg->bitfields.ZMASK_RDINDEX = zmask_rdindex;
  if (reg->bitfields.ZMASK_RDINDEX != zmask_rdindex) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZMASK_RDINDEX::ZMASK_RDINDEX data too large\n");
}
#else
#define set_RB3D_ZMASK_RDINDEX_zmask_rdindex(reg, zmask_rdindex) (reg)->bitfields.ZMASK_RDINDEX = zmask_rdindex

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_STENCILREFMASK regRB3D_STENCILREFMASK;

#ifdef DEBUG
__inline void set_RB3D_STENCILREFMASK_stencilref(regRB3D_STENCILREFMASK *reg, unsigned int stencilref)
{
  reg->bitfields.STENCILREF = stencilref;
  if (reg->bitfields.STENCILREF != stencilref) HSLDPF(E_ERROR_MESSAGE,"RB3D_STENCILREFMASK::STENCILREF data too large\n");
}
__inline void set_RB3D_STENCILREFMASK_stencilmask(regRB3D_STENCILREFMASK *reg, unsigned int stencilmask)
{
  reg->bitfields.STENCILMASK = stencilmask;
  if (reg->bitfields.STENCILMASK != stencilmask) HSLDPF(E_ERROR_MESSAGE,"RB3D_STENCILREFMASK::STENCILMASK data too large\n");
}
__inline void set_RB3D_STENCILREFMASK_stencilwritemask(regRB3D_STENCILREFMASK *reg, unsigned int stencilwritemask)
{
  reg->bitfields.STENCILWRITEMASK = stencilwritemask;
  if (reg->bitfields.STENCILWRITEMASK != stencilwritemask) HSLDPF(E_ERROR_MESSAGE,"RB3D_STENCILREFMASK::STENCILWRITEMASK data too large\n");
}
#else
#define set_RB3D_STENCILREFMASK_stencilref(reg, stencilref) (reg)->bitfields.STENCILREF = stencilref
#define set_RB3D_STENCILREFMASK_stencilmask(reg, stencilmask) (reg)->bitfields.STENCILMASK = stencilmask
#define set_RB3D_STENCILREFMASK_stencilwritemask(reg, stencilwritemask) (reg)->bitfields.STENCILWRITEMASK = stencilwritemask

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_ROPCNTL regRB3D_ROPCNTL;

#ifdef DEBUG
__inline void set_RB3D_ROPCNTL_rop(regRB3D_ROPCNTL *reg, unsigned int rop)
{
  reg->bitfields.ROP = rop;
  if (reg->bitfields.ROP != rop) HSLDPF(E_ERROR_MESSAGE,"RB3D_ROPCNTL::ROP data too large\n");
}
#else
#define set_RB3D_ROPCNTL_rop(reg, rop) (reg)->bitfields.ROP = rop

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_PLANEMASK regRB3D_PLANEMASK;

#ifdef DEBUG
__inline void set_RB3D_PLANEMASK_planemask(regRB3D_PLANEMASK *reg, unsigned int planemask)
{
  reg->bitfields.PLANEMASK = planemask;
  if (reg->bitfields.PLANEMASK != planemask) HSLDPF(E_ERROR_MESSAGE,"RB3D_PLANEMASK::PLANEMASK data too large\n");
}
#else
#define set_RB3D_PLANEMASK_planemask(reg, planemask) (reg)->bitfields.PLANEMASK = planemask

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_ZCACHE_MODE regRB3D_ZCACHE_MODE;

#ifdef DEBUG
__inline void set_RB3D_ZCACHE_MODE_zmask_ram_rm(regRB3D_ZCACHE_MODE *reg, unsigned int zmask_ram_rm)
{
  reg->bitfields.ZMASK_RAM_RM = zmask_ram_rm;
  if (reg->bitfields.ZMASK_RAM_RM != zmask_ram_rm) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZCACHE_MODE::ZMASK_RAM_RM data too large\n");
}
__inline void set_RB3D_ZCACHE_MODE_zc_disable_ri_fill(regRB3D_ZCACHE_MODE *reg, unsigned int zc_disable_ri_fill)
{
  reg->bitfields.ZC_DISABLE_RI_FILL = zc_disable_ri_fill;
  if (reg->bitfields.ZC_DISABLE_RI_FILL != zc_disable_ri_fill) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZCACHE_MODE::ZC_DISABLE_RI_FILL data too large\n");
}
__inline void set_RB3D_ZCACHE_MODE_zc_disable_ri_read(regRB3D_ZCACHE_MODE *reg, unsigned int zc_disable_ri_read)
{
  reg->bitfields.ZC_DISABLE_RI_READ = zc_disable_ri_read;
  if (reg->bitfields.ZC_DISABLE_RI_READ != zc_disable_ri_read) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZCACHE_MODE::ZC_DISABLE_RI_READ data too large\n");
}
__inline void set_RB3D_ZCACHE_MODE_zc_disable_ri_flush(regRB3D_ZCACHE_MODE *reg, unsigned int zc_disable_ri_flush)
{
  reg->bitfields.ZC_DISABLE_RI_FLUSH = zc_disable_ri_flush;
  if (reg->bitfields.ZC_DISABLE_RI_FLUSH != zc_disable_ri_flush) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZCACHE_MODE::ZC_DISABLE_RI_FLUSH data too large\n");
}
#else
#define set_RB3D_ZCACHE_MODE_zmask_ram_rm(reg, zmask_ram_rm) (reg)->bitfields.ZMASK_RAM_RM = zmask_ram_rm
#define set_RB3D_ZCACHE_MODE_zc_disable_ri_fill(reg, zc_disable_ri_fill) (reg)->bitfields.ZC_DISABLE_RI_FILL = zc_disable_ri_fill
#define set_RB3D_ZCACHE_MODE_zc_disable_ri_read(reg, zc_disable_ri_read) (reg)->bitfields.ZC_DISABLE_RI_READ = zc_disable_ri_read
#define set_RB3D_ZCACHE_MODE_zc_disable_ri_flush(reg, zc_disable_ri_flush) (reg)->bitfields.ZC_DISABLE_RI_FLUSH = zc_disable_ri_flush

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_ZCACHE_CTLSTAT regRB3D_ZCACHE_CTLSTAT;

#ifdef DEBUG
__inline void set_RB3D_ZCACHE_CTLSTAT_zc_flush(regRB3D_ZCACHE_CTLSTAT *reg, unsigned int zc_flush)
{
  reg->bitfields.ZC_FLUSH = zc_flush;
  if (reg->bitfields.ZC_FLUSH != zc_flush) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZCACHE_CTLSTAT::ZC_FLUSH data too large\n");
}
__inline void set_RB3D_ZCACHE_CTLSTAT_zc_free(regRB3D_ZCACHE_CTLSTAT *reg, unsigned int zc_free)
{
  reg->bitfields.ZC_FREE = zc_free;
  if (reg->bitfields.ZC_FREE != zc_free) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZCACHE_CTLSTAT::ZC_FREE data too large\n");
}
__inline void set_RB3D_ZCACHE_CTLSTAT_zc_busy(regRB3D_ZCACHE_CTLSTAT *reg, unsigned int zc_busy)
{
  reg->bitfields.ZC_BUSY = zc_busy;
  if (reg->bitfields.ZC_BUSY != zc_busy) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZCACHE_CTLSTAT::ZC_BUSY data too large\n");
}
#else
#define set_RB3D_ZCACHE_CTLSTAT_zc_flush(reg, zc_flush) (reg)->bitfields.ZC_FLUSH = zc_flush
#define set_RB3D_ZCACHE_CTLSTAT_zc_free(reg, zc_free) (reg)->bitfields.ZC_FREE = zc_free
#define set_RB3D_ZCACHE_CTLSTAT_zc_busy(reg, zc_busy) (reg)->bitfields.ZC_BUSY = zc_busy

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_DSTCACHE_MODE regRB3D_DSTCACHE_MODE;

#ifdef DEBUG
__inline void set_RB3D_DSTCACHE_MODE_dc_bypass(regRB3D_DSTCACHE_MODE *reg, unsigned int dc_bypass)
{
  reg->bitfields.DC_BYPASS = dc_bypass;
  if (reg->bitfields.DC_BYPASS != dc_bypass) HSLDPF(E_ERROR_MESSAGE,"RB3D_DSTCACHE_MODE::DC_BYPASS data too large\n");
}
__inline void set_RB3D_DSTCACHE_MODE_dc_line_size(regRB3D_DSTCACHE_MODE *reg, unsigned int dc_line_size)
{
  reg->bitfields.DC_LINE_SIZE = dc_line_size;
  if (reg->bitfields.DC_LINE_SIZE != dc_line_size) HSLDPF(E_ERROR_MESSAGE,"RB3D_DSTCACHE_MODE::DC_LINE_SIZE data too large\n");
}
__inline void set_RB3D_DSTCACHE_MODE_dc_autoflush_enable(regRB3D_DSTCACHE_MODE *reg, unsigned int dc_autoflush_enable)
{
  reg->bitfields.DC_AUTOFLUSH_ENABLE = dc_autoflush_enable;
  if (reg->bitfields.DC_AUTOFLUSH_ENABLE != dc_autoflush_enable) HSLDPF(E_ERROR_MESSAGE,"RB3D_DSTCACHE_MODE::DC_AUTOFLUSH_ENABLE data too large\n");
}
__inline void set_RB3D_DSTCACHE_MODE_dc_autofree_enable(regRB3D_DSTCACHE_MODE *reg, unsigned int dc_autofree_enable)
{
  reg->bitfields.DC_AUTOFREE_ENABLE = dc_autofree_enable;
  if (reg->bitfields.DC_AUTOFREE_ENABLE != dc_autofree_enable) HSLDPF(E_ERROR_MESSAGE,"RB3D_DSTCACHE_MODE::DC_AUTOFREE_ENABLE data too large\n");
}
__inline void set_RB3D_DSTCACHE_MODE_dc_force_rmw(regRB3D_DSTCACHE_MODE *reg, unsigned int dc_force_rmw)
{
  reg->bitfields.DC_FORCE_RMW = dc_force_rmw;
  if (reg->bitfields.DC_FORCE_RMW != dc_force_rmw) HSLDPF(E_ERROR_MESSAGE,"RB3D_DSTCACHE_MODE::DC_FORCE_RMW data too large\n");
}
__inline void set_RB3D_DSTCACHE_MODE_dc_disable_ri_fill(regRB3D_DSTCACHE_MODE *reg, unsigned int dc_disable_ri_fill)
{
  reg->bitfields.DC_DISABLE_RI_FILL = dc_disable_ri_fill;
  if (reg->bitfields.DC_DISABLE_RI_FILL != dc_disable_ri_fill) HSLDPF(E_ERROR_MESSAGE,"RB3D_DSTCACHE_MODE::DC_DISABLE_RI_FILL data too large\n");
}
__inline void set_RB3D_DSTCACHE_MODE_dc_disable_ri_read(regRB3D_DSTCACHE_MODE *reg, unsigned int dc_disable_ri_read)
{
  reg->bitfields.DC_DISABLE_RI_READ = dc_disable_ri_read;
  if (reg->bitfields.DC_DISABLE_RI_READ != dc_disable_ri_read) HSLDPF(E_ERROR_MESSAGE,"RB3D_DSTCACHE_MODE::DC_DISABLE_RI_READ data too large\n");
}
__inline void set_RB3D_DSTCACHE_MODE_dc_disable_mask_chk(regRB3D_DSTCACHE_MODE *reg, unsigned int dc_disable_mask_chk)
{
  reg->bitfields.DC_DISABLE_MASK_CHK = dc_disable_mask_chk;
  if (reg->bitfields.DC_DISABLE_MASK_CHK != dc_disable_mask_chk) HSLDPF(E_ERROR_MESSAGE,"RB3D_DSTCACHE_MODE::DC_DISABLE_MASK_CHK data too large\n");
}
#else
#define set_RB3D_DSTCACHE_MODE_dc_bypass(reg, dc_bypass) (reg)->bitfields.DC_BYPASS = dc_bypass
#define set_RB3D_DSTCACHE_MODE_dc_line_size(reg, dc_line_size) (reg)->bitfields.DC_LINE_SIZE = dc_line_size
#define set_RB3D_DSTCACHE_MODE_dc_autoflush_enable(reg, dc_autoflush_enable) (reg)->bitfields.DC_AUTOFLUSH_ENABLE = dc_autoflush_enable
#define set_RB3D_DSTCACHE_MODE_dc_autofree_enable(reg, dc_autofree_enable) (reg)->bitfields.DC_AUTOFREE_ENABLE = dc_autofree_enable
#define set_RB3D_DSTCACHE_MODE_dc_force_rmw(reg, dc_force_rmw) (reg)->bitfields.DC_FORCE_RMW = dc_force_rmw
#define set_RB3D_DSTCACHE_MODE_dc_disable_ri_fill(reg, dc_disable_ri_fill) (reg)->bitfields.DC_DISABLE_RI_FILL = dc_disable_ri_fill
#define set_RB3D_DSTCACHE_MODE_dc_disable_ri_read(reg, dc_disable_ri_read) (reg)->bitfields.DC_DISABLE_RI_READ = dc_disable_ri_read
#define set_RB3D_DSTCACHE_MODE_dc_disable_mask_chk(reg, dc_disable_mask_chk) (reg)->bitfields.DC_DISABLE_MASK_CHK = dc_disable_mask_chk

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_DSTCACHE_CTLSTAT regRB3D_DSTCACHE_CTLSTAT;

#ifdef DEBUG
__inline void set_RB3D_DSTCACHE_CTLSTAT_dc_flush(regRB3D_DSTCACHE_CTLSTAT *reg, unsigned int dc_flush)
{
  reg->bitfields.DC_FLUSH = dc_flush;
  if (reg->bitfields.DC_FLUSH != dc_flush) HSLDPF(E_ERROR_MESSAGE,"RB3D_DSTCACHE_CTLSTAT::DC_FLUSH data too large\n");
}
__inline void set_RB3D_DSTCACHE_CTLSTAT_dc_free(regRB3D_DSTCACHE_CTLSTAT *reg, unsigned int dc_free)
{
  reg->bitfields.DC_FREE = dc_free;
  if (reg->bitfields.DC_FREE != dc_free) HSLDPF(E_ERROR_MESSAGE,"RB3D_DSTCACHE_CTLSTAT::DC_FREE data too large\n");
}
__inline void set_RB3D_DSTCACHE_CTLSTAT_dc_busy(regRB3D_DSTCACHE_CTLSTAT *reg, unsigned int dc_busy)
{
  reg->bitfields.DC_BUSY = dc_busy;
  if (reg->bitfields.DC_BUSY != dc_busy) HSLDPF(E_ERROR_MESSAGE,"RB3D_DSTCACHE_CTLSTAT::DC_BUSY data too large\n");
}
#else
#define set_RB3D_DSTCACHE_CTLSTAT_dc_flush(reg, dc_flush) (reg)->bitfields.DC_FLUSH = dc_flush
#define set_RB3D_DSTCACHE_CTLSTAT_dc_free(reg, dc_free) (reg)->bitfields.DC_FREE = dc_free
#define set_RB3D_DSTCACHE_CTLSTAT_dc_busy(reg, dc_busy) (reg)->bitfields.DC_BUSY = dc_busy

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_PD0_DATA regRB3D_PD0_DATA;

#ifdef DEBUG
__inline void set_RB3D_PD0_DATA_disable_rb(regRB3D_PD0_DATA *reg, unsigned int disable_rb)
{
  reg->bitfields.DISABLE_RB = disable_rb;
  if (reg->bitfields.DISABLE_RB != disable_rb) HSLDPF(E_ERROR_MESSAGE,"RB3D_PD0_DATA::DISABLE_RB data too large\n");
}
#else
#define set_RB3D_PD0_DATA_disable_rb(reg, disable_rb) (reg)->bitfields.DISABLE_RB = disable_rb

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_DSTPERF_CNTL regRB3D_DSTPERF_CNTL;

#ifdef DEBUG
__inline void set_RB3D_DSTPERF_CNTL_perfsel0(regRB3D_DSTPERF_CNTL *reg, unsigned int perfsel0)
{
  reg->bitfields.PERFSEL0 = perfsel0;
  if (reg->bitfields.PERFSEL0 != perfsel0) HSLDPF(E_ERROR_MESSAGE,"RB3D_DSTPERF_CNTL::PERFSEL0 data too large\n");
}
__inline void set_RB3D_DSTPERF_CNTL_clr_perf0(regRB3D_DSTPERF_CNTL *reg, unsigned int clr_perf0)
{
  reg->bitfields.CLR_PERF0 = clr_perf0;
  if (reg->bitfields.CLR_PERF0 != clr_perf0) HSLDPF(E_ERROR_MESSAGE,"RB3D_DSTPERF_CNTL::CLR_PERF0 data too large\n");
}
__inline void set_RB3D_DSTPERF_CNTL_en_perf0(regRB3D_DSTPERF_CNTL *reg, unsigned int en_perf0)
{
  reg->bitfields.EN_PERF0 = en_perf0;
  if (reg->bitfields.EN_PERF0 != en_perf0) HSLDPF(E_ERROR_MESSAGE,"RB3D_DSTPERF_CNTL::EN_PERF0 data too large\n");
}
__inline void set_RB3D_DSTPERF_CNTL_perfsel1(regRB3D_DSTPERF_CNTL *reg, unsigned int perfsel1)
{
  reg->bitfields.PERFSEL1 = perfsel1;
  if (reg->bitfields.PERFSEL1 != perfsel1) HSLDPF(E_ERROR_MESSAGE,"RB3D_DSTPERF_CNTL::PERFSEL1 data too large\n");
}
__inline void set_RB3D_DSTPERF_CNTL_clr_perf1(regRB3D_DSTPERF_CNTL *reg, unsigned int clr_perf1)
{
  reg->bitfields.CLR_PERF1 = clr_perf1;
  if (reg->bitfields.CLR_PERF1 != clr_perf1) HSLDPF(E_ERROR_MESSAGE,"RB3D_DSTPERF_CNTL::CLR_PERF1 data too large\n");
}
__inline void set_RB3D_DSTPERF_CNTL_en_perf1(regRB3D_DSTPERF_CNTL *reg, unsigned int en_perf1)
{
  reg->bitfields.EN_PERF1 = en_perf1;
  if (reg->bitfields.EN_PERF1 != en_perf1) HSLDPF(E_ERROR_MESSAGE,"RB3D_DSTPERF_CNTL::EN_PERF1 data too large\n");
}
#else
#define set_RB3D_DSTPERF_CNTL_perfsel0(reg, perfsel0) (reg)->bitfields.PERFSEL0 = perfsel0
#define set_RB3D_DSTPERF_CNTL_clr_perf0(reg, clr_perf0) (reg)->bitfields.CLR_PERF0 = clr_perf0
#define set_RB3D_DSTPERF_CNTL_en_perf0(reg, en_perf0) (reg)->bitfields.EN_PERF0 = en_perf0
#define set_RB3D_DSTPERF_CNTL_perfsel1(reg, perfsel1) (reg)->bitfields.PERFSEL1 = perfsel1
#define set_RB3D_DSTPERF_CNTL_clr_perf1(reg, clr_perf1) (reg)->bitfields.CLR_PERF1 = clr_perf1
#define set_RB3D_DSTPERF_CNTL_en_perf1(reg, en_perf1) (reg)->bitfields.EN_PERF1 = en_perf1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_PD1_DATA regRB3D_PD1_DATA;

#ifdef DEBUG
__inline void set_RB3D_PD1_DATA_rb3d_dbg_disable_zmask_l0(regRB3D_PD1_DATA *reg, unsigned int rb3d_dbg_disable_zmask_l0)
{
  reg->bitfields.RB3D_DBG_DISABLE_ZMASK_L0 = rb3d_dbg_disable_zmask_l0;
  if (reg->bitfields.RB3D_DBG_DISABLE_ZMASK_L0 != rb3d_dbg_disable_zmask_l0) HSLDPF(E_ERROR_MESSAGE,"RB3D_PD1_DATA::RB3D_DBG_DISABLE_ZMASK_L0 data too large\n");
}
__inline void set_RB3D_PD1_DATA_pd1_data(regRB3D_PD1_DATA *reg, unsigned int pd1_data)
{
  reg->bitfields.PD1_DATA = pd1_data;
  if (reg->bitfields.PD1_DATA != pd1_data) HSLDPF(E_ERROR_MESSAGE,"RB3D_PD1_DATA::PD1_DATA data too large\n");
}
#else
#define set_RB3D_PD1_DATA_rb3d_dbg_disable_zmask_l0(reg, rb3d_dbg_disable_zmask_l0) (reg)->bitfields.RB3D_DBG_DISABLE_ZMASK_L0 = rb3d_dbg_disable_zmask_l0
#define set_RB3D_PD1_DATA_pd1_data(reg, pd1_data) (reg)->bitfields.PD1_DATA = pd1_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_PD1_ADDR regRB3D_PD1_ADDR;

#ifdef DEBUG
__inline void set_RB3D_PD1_ADDR_pd1_addr(regRB3D_PD1_ADDR *reg, unsigned int pd1_addr)
{
  reg->bitfields.PD1_ADDR = pd1_addr;
  if (reg->bitfields.PD1_ADDR != pd1_addr) HSLDPF(E_ERROR_MESSAGE,"RB3D_PD1_ADDR::PD1_ADDR data too large\n");
}
#else
#define set_RB3D_PD1_ADDR_pd1_addr(reg, pd1_addr) (reg)->bitfields.PD1_ADDR = pd1_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_PD2_DATA regRB3D_PD2_DATA;

#ifdef DEBUG
__inline void set_RB3D_PD2_DATA_pd2_data(regRB3D_PD2_DATA *reg, unsigned int pd2_data)
{
  reg->bitfields.PD2_DATA = pd2_data;
  if (reg->bitfields.PD2_DATA != pd2_data) HSLDPF(E_ERROR_MESSAGE,"RB3D_PD2_DATA::PD2_DATA data too large\n");
}
#else
#define set_RB3D_PD2_DATA_pd2_data(reg, pd2_data) (reg)->bitfields.PD2_DATA = pd2_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_PD3_DATA regRB3D_PD3_DATA;

#ifdef DEBUG
__inline void set_RB3D_PD3_DATA_pd3_data(regRB3D_PD3_DATA *reg, unsigned int pd3_data)
{
  reg->bitfields.PD3_DATA = pd3_data;
  if (reg->bitfields.PD3_DATA != pd3_data) HSLDPF(E_ERROR_MESSAGE,"RB3D_PD3_DATA::PD3_DATA data too large\n");
}
#else
#define set_RB3D_PD3_DATA_pd3_data(reg, pd3_data) (reg)->bitfields.PD3_DATA = pd3_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_WRITEBACK_DATA_LO regRB3D_WRITEBACK_DATA_LO;

#ifdef DEBUG
__inline void set_RB3D_WRITEBACK_DATA_LO_writeback_data_lo(regRB3D_WRITEBACK_DATA_LO *reg, unsigned int writeback_data_lo)
{
  reg->bitfields.WRITEBACK_DATA_LO = writeback_data_lo;
  if (reg->bitfields.WRITEBACK_DATA_LO != writeback_data_lo) HSLDPF(E_ERROR_MESSAGE,"RB3D_WRITEBACK_DATA_LO::WRITEBACK_DATA_LO data too large\n");
}
#else
#define set_RB3D_WRITEBACK_DATA_LO_writeback_data_lo(reg, writeback_data_lo) (reg)->bitfields.WRITEBACK_DATA_LO = writeback_data_lo

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_WRITEBACK_DATA_HI regRB3D_WRITEBACK_DATA_HI;

#ifdef DEBUG
__inline void set_RB3D_WRITEBACK_DATA_HI_writeback_data_hi(regRB3D_WRITEBACK_DATA_HI *reg, unsigned int writeback_data_hi)
{
  reg->bitfields.WRITEBACK_DATA_HI = writeback_data_hi;
  if (reg->bitfields.WRITEBACK_DATA_HI != writeback_data_hi) HSLDPF(E_ERROR_MESSAGE,"RB3D_WRITEBACK_DATA_HI::WRITEBACK_DATA_HI data too large\n");
}
#else
#define set_RB3D_WRITEBACK_DATA_HI_writeback_data_hi(reg, writeback_data_hi) (reg)->bitfields.WRITEBACK_DATA_HI = writeback_data_hi

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_WRITEBACK_ADDR regRB3D_WRITEBACK_ADDR;

#ifdef DEBUG
__inline void set_RB3D_WRITEBACK_ADDR_writeback_addr(regRB3D_WRITEBACK_ADDR *reg, unsigned int writeback_addr)
{
  reg->bitfields.WRITEBACK_ADDR = writeback_addr;
  if (reg->bitfields.WRITEBACK_ADDR != writeback_addr) HSLDPF(E_ERROR_MESSAGE,"RB3D_WRITEBACK_ADDR::WRITEBACK_ADDR data too large\n");
}
#else
#define set_RB3D_WRITEBACK_ADDR_writeback_addr(reg, writeback_addr) (reg)->bitfields.WRITEBACK_ADDR = writeback_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_ZPERF_CNTL regRB3D_ZPERF_CNTL;

#ifdef DEBUG
__inline void set_RB3D_ZPERF_CNTL_perfsel0(regRB3D_ZPERF_CNTL *reg, unsigned int perfsel0)
{
  reg->bitfields.PERFSEL0 = perfsel0;
  if (reg->bitfields.PERFSEL0 != perfsel0) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZPERF_CNTL::PERFSEL0 data too large\n");
}
__inline void set_RB3D_ZPERF_CNTL_clr_perf0(regRB3D_ZPERF_CNTL *reg, unsigned int clr_perf0)
{
  reg->bitfields.CLR_PERF0 = clr_perf0;
  if (reg->bitfields.CLR_PERF0 != clr_perf0) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZPERF_CNTL::CLR_PERF0 data too large\n");
}
__inline void set_RB3D_ZPERF_CNTL_en_perf0(regRB3D_ZPERF_CNTL *reg, unsigned int en_perf0)
{
  reg->bitfields.EN_PERF0 = en_perf0;
  if (reg->bitfields.EN_PERF0 != en_perf0) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZPERF_CNTL::EN_PERF0 data too large\n");
}
__inline void set_RB3D_ZPERF_CNTL_perfsel1(regRB3D_ZPERF_CNTL *reg, unsigned int perfsel1)
{
  reg->bitfields.PERFSEL1 = perfsel1;
  if (reg->bitfields.PERFSEL1 != perfsel1) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZPERF_CNTL::PERFSEL1 data too large\n");
}
__inline void set_RB3D_ZPERF_CNTL_clr_perf1(regRB3D_ZPERF_CNTL *reg, unsigned int clr_perf1)
{
  reg->bitfields.CLR_PERF1 = clr_perf1;
  if (reg->bitfields.CLR_PERF1 != clr_perf1) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZPERF_CNTL::CLR_PERF1 data too large\n");
}
__inline void set_RB3D_ZPERF_CNTL_en_perf1(regRB3D_ZPERF_CNTL *reg, unsigned int en_perf1)
{
  reg->bitfields.EN_PERF1 = en_perf1;
  if (reg->bitfields.EN_PERF1 != en_perf1) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZPERF_CNTL::EN_PERF1 data too large\n");
}
#else
#define set_RB3D_ZPERF_CNTL_perfsel0(reg, perfsel0) (reg)->bitfields.PERFSEL0 = perfsel0
#define set_RB3D_ZPERF_CNTL_clr_perf0(reg, clr_perf0) (reg)->bitfields.CLR_PERF0 = clr_perf0
#define set_RB3D_ZPERF_CNTL_en_perf0(reg, en_perf0) (reg)->bitfields.EN_PERF0 = en_perf0
#define set_RB3D_ZPERF_CNTL_perfsel1(reg, perfsel1) (reg)->bitfields.PERFSEL1 = perfsel1
#define set_RB3D_ZPERF_CNTL_clr_perf1(reg, clr_perf1) (reg)->bitfields.CLR_PERF1 = clr_perf1
#define set_RB3D_ZPERF_CNTL_en_perf1(reg, en_perf1) (reg)->bitfields.EN_PERF1 = en_perf1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_ZPASS_DATA regRB3D_ZPASS_DATA;

#ifdef DEBUG
__inline void set_RB3D_ZPASS_DATA_zpass_data(regRB3D_ZPASS_DATA *reg, unsigned int zpass_data)
{
  reg->bitfields.ZPASS_DATA = zpass_data;
  if (reg->bitfields.ZPASS_DATA != zpass_data) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZPASS_DATA::ZPASS_DATA data too large\n");
}
#else
#define set_RB3D_ZPASS_DATA_zpass_data(reg, zpass_data) (reg)->bitfields.ZPASS_DATA = zpass_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_ZPASS_ADDR regRB3D_ZPASS_ADDR;

#ifdef DEBUG
__inline void set_RB3D_ZPASS_ADDR_zpass_addr(regRB3D_ZPASS_ADDR *reg, unsigned int zpass_addr)
{
  reg->bitfields.ZPASS_ADDR = zpass_addr;
  if (reg->bitfields.ZPASS_ADDR != zpass_addr) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZPASS_ADDR::ZPASS_ADDR data too large\n");
}
#else
#define set_RB3D_ZPASS_ADDR_zpass_addr(reg, zpass_addr) (reg)->bitfields.ZPASS_ADDR = zpass_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_ZPERF_COUNT_0 regRB3D_ZPERF_COUNT_0;

#ifdef DEBUG
__inline void set_RB3D_ZPERF_COUNT_0_perf_count(regRB3D_ZPERF_COUNT_0 *reg, unsigned int perf_count)
{
  reg->bitfields.PERF_COUNT = perf_count;
  if (reg->bitfields.PERF_COUNT != perf_count) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZPERF_COUNT_0::PERF_COUNT data too large\n");
}
#else
#define set_RB3D_ZPERF_COUNT_0_perf_count(reg, perf_count) (reg)->bitfields.PERF_COUNT = perf_count

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_ZPERF_COUNT_1 regRB3D_ZPERF_COUNT_1;

#ifdef DEBUG
__inline void set_RB3D_ZPERF_COUNT_1_perf_count(regRB3D_ZPERF_COUNT_1 *reg, unsigned int perf_count)
{
  reg->bitfields.PERF_COUNT = perf_count;
  if (reg->bitfields.PERF_COUNT != perf_count) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZPERF_COUNT_1::PERF_COUNT data too large\n");
}
#else
#define set_RB3D_ZPERF_COUNT_1_perf_count(reg, perf_count) (reg)->bitfields.PERF_COUNT = perf_count

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DST_OFFSET regDST_OFFSET;

#ifdef DEBUG
__inline void set_DST_OFFSET_dst_offset(regDST_OFFSET *reg, unsigned int dst_offset)
{
  reg->bitfields.DST_OFFSET = dst_offset;
  if (reg->bitfields.DST_OFFSET != dst_offset) HSLDPF(E_ERROR_MESSAGE,"DST_OFFSET::DST_OFFSET data too large\n");
}
#else
#define set_DST_OFFSET_dst_offset(reg, dst_offset) (reg)->bitfields.DST_OFFSET = dst_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DST_PITCH regDST_PITCH;

#ifdef DEBUG
__inline void set_DST_PITCH_dst_pitch(regDST_PITCH *reg, unsigned int dst_pitch)
{
  reg->bitfields.DST_PITCH = dst_pitch;
  if (reg->bitfields.DST_PITCH != dst_pitch) HSLDPF(E_ERROR_MESSAGE,"DST_PITCH::DST_PITCH data too large\n");
}
#else
#define set_DST_PITCH_dst_pitch(reg, dst_pitch) (reg)->bitfields.DST_PITCH = dst_pitch

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DST_TILE regDST_TILE;

#ifdef DEBUG
__inline void set_DST_TILE_dst_tile(regDST_TILE *reg, unsigned int dst_tile)
{
  reg->bitfields.DST_TILE = dst_tile;
  if (reg->bitfields.DST_TILE != dst_tile) HSLDPF(E_ERROR_MESSAGE,"DST_TILE::DST_TILE data too large\n");
}
#else
#define set_DST_TILE_dst_tile(reg, dst_tile) (reg)->bitfields.DST_TILE = dst_tile

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DST_PITCH_OFFSET regDST_PITCH_OFFSET;

#ifdef DEBUG
__inline void set_DST_PITCH_OFFSET_dst_offset(regDST_PITCH_OFFSET *reg, unsigned int dst_offset)
{
  reg->bitfields.DST_OFFSET = dst_offset;
  if (reg->bitfields.DST_OFFSET != dst_offset) HSLDPF(E_ERROR_MESSAGE,"DST_PITCH_OFFSET::DST_OFFSET data too large\n");
}
__inline void set_DST_PITCH_OFFSET_dst_pitch(regDST_PITCH_OFFSET *reg, unsigned int dst_pitch)
{
  reg->bitfields.DST_PITCH = dst_pitch;
  if (reg->bitfields.DST_PITCH != dst_pitch) HSLDPF(E_ERROR_MESSAGE,"DST_PITCH_OFFSET::DST_PITCH data too large\n");
}
__inline void set_DST_PITCH_OFFSET_dst_tile(regDST_PITCH_OFFSET *reg, unsigned int dst_tile)
{
  reg->bitfields.DST_TILE = dst_tile;
  if (reg->bitfields.DST_TILE != dst_tile) HSLDPF(E_ERROR_MESSAGE,"DST_PITCH_OFFSET::DST_TILE data too large\n");
}
#else
#define set_DST_PITCH_OFFSET_dst_offset(reg, dst_offset) (reg)->bitfields.DST_OFFSET = dst_offset
#define set_DST_PITCH_OFFSET_dst_pitch(reg, dst_pitch) (reg)->bitfields.DST_PITCH = dst_pitch
#define set_DST_PITCH_OFFSET_dst_tile(reg, dst_tile) (reg)->bitfields.DST_TILE = dst_tile

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DST_X regDST_X;

#ifdef DEBUG
__inline void set_DST_X_dst_x(regDST_X *reg, unsigned int dst_x)
{
  reg->bitfields.DST_X = dst_x;
  if (reg->bitfields.DST_X != dst_x) HSLDPF(E_ERROR_MESSAGE,"DST_X::DST_X data too large\n");
}
#else
#define set_DST_X_dst_x(reg, dst_x) (reg)->bitfields.DST_X = dst_x

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DST_Y regDST_Y;

#ifdef DEBUG
__inline void set_DST_Y_dst_y(regDST_Y *reg, unsigned int dst_y)
{
  reg->bitfields.DST_Y = dst_y;
  if (reg->bitfields.DST_Y != dst_y) HSLDPF(E_ERROR_MESSAGE,"DST_Y::DST_Y data too large\n");
}
#else
#define set_DST_Y_dst_y(reg, dst_y) (reg)->bitfields.DST_Y = dst_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DST_X_Y regDST_X_Y;

#ifdef DEBUG
__inline void set_DST_X_Y_dst_y(regDST_X_Y *reg, unsigned int dst_y)
{
  reg->bitfields.DST_Y = dst_y;
  if (reg->bitfields.DST_Y != dst_y) HSLDPF(E_ERROR_MESSAGE,"DST_X_Y::DST_Y data too large\n");
}
__inline void set_DST_X_Y_dst_x(regDST_X_Y *reg, unsigned int dst_x)
{
  reg->bitfields.DST_X = dst_x;
  if (reg->bitfields.DST_X != dst_x) HSLDPF(E_ERROR_MESSAGE,"DST_X_Y::DST_X data too large\n");
}
#else
#define set_DST_X_Y_dst_y(reg, dst_y) (reg)->bitfields.DST_Y = dst_y
#define set_DST_X_Y_dst_x(reg, dst_x) (reg)->bitfields.DST_X = dst_x

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DST_Y_X regDST_Y_X;

#ifdef DEBUG
__inline void set_DST_Y_X_dst_x(regDST_Y_X *reg, unsigned int dst_x)
{
  reg->bitfields.DST_X = dst_x;
  if (reg->bitfields.DST_X != dst_x) HSLDPF(E_ERROR_MESSAGE,"DST_Y_X::DST_X data too large\n");
}
__inline void set_DST_Y_X_dst_y(regDST_Y_X *reg, unsigned int dst_y)
{
  reg->bitfields.DST_Y = dst_y;
  if (reg->bitfields.DST_Y != dst_y) HSLDPF(E_ERROR_MESSAGE,"DST_Y_X::DST_Y data too large\n");
}
#else
#define set_DST_Y_X_dst_x(reg, dst_x) (reg)->bitfields.DST_X = dst_x
#define set_DST_Y_X_dst_y(reg, dst_y) (reg)->bitfields.DST_Y = dst_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DST_WIDTH regDST_WIDTH;

#ifdef DEBUG
__inline void set_DST_WIDTH_dst_width(regDST_WIDTH *reg, unsigned int dst_width)
{
  reg->bitfields.DST_WIDTH = dst_width;
  if (reg->bitfields.DST_WIDTH != dst_width) HSLDPF(E_ERROR_MESSAGE,"DST_WIDTH::DST_WIDTH data too large\n");
}
#else
#define set_DST_WIDTH_dst_width(reg, dst_width) (reg)->bitfields.DST_WIDTH = dst_width

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DST_HEIGHT regDST_HEIGHT;

#ifdef DEBUG
__inline void set_DST_HEIGHT_dst_height(regDST_HEIGHT *reg, unsigned int dst_height)
{
  reg->bitfields.DST_HEIGHT = dst_height;
  if (reg->bitfields.DST_HEIGHT != dst_height) HSLDPF(E_ERROR_MESSAGE,"DST_HEIGHT::DST_HEIGHT data too large\n");
}
#else
#define set_DST_HEIGHT_dst_height(reg, dst_height) (reg)->bitfields.DST_HEIGHT = dst_height

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DST_WIDTH_HEIGHT regDST_WIDTH_HEIGHT;

#ifdef DEBUG
__inline void set_DST_WIDTH_HEIGHT_dst_height(regDST_WIDTH_HEIGHT *reg, unsigned int dst_height)
{
  reg->bitfields.DST_HEIGHT = dst_height;
  if (reg->bitfields.DST_HEIGHT != dst_height) HSLDPF(E_ERROR_MESSAGE,"DST_WIDTH_HEIGHT::DST_HEIGHT data too large\n");
}
__inline void set_DST_WIDTH_HEIGHT_dst_width(regDST_WIDTH_HEIGHT *reg, unsigned int dst_width)
{
  reg->bitfields.DST_WIDTH = dst_width;
  if (reg->bitfields.DST_WIDTH != dst_width) HSLDPF(E_ERROR_MESSAGE,"DST_WIDTH_HEIGHT::DST_WIDTH data too large\n");
}
#else
#define set_DST_WIDTH_HEIGHT_dst_height(reg, dst_height) (reg)->bitfields.DST_HEIGHT = dst_height
#define set_DST_WIDTH_HEIGHT_dst_width(reg, dst_width) (reg)->bitfields.DST_WIDTH = dst_width

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DST_HEIGHT_WIDTH regDST_HEIGHT_WIDTH;

#ifdef DEBUG
__inline void set_DST_HEIGHT_WIDTH_dst_width(regDST_HEIGHT_WIDTH *reg, unsigned int dst_width)
{
  reg->bitfields.DST_WIDTH = dst_width;
  if (reg->bitfields.DST_WIDTH != dst_width) HSLDPF(E_ERROR_MESSAGE,"DST_HEIGHT_WIDTH::DST_WIDTH data too large\n");
}
__inline void set_DST_HEIGHT_WIDTH_dst_height(regDST_HEIGHT_WIDTH *reg, unsigned int dst_height)
{
  reg->bitfields.DST_HEIGHT = dst_height;
  if (reg->bitfields.DST_HEIGHT != dst_height) HSLDPF(E_ERROR_MESSAGE,"DST_HEIGHT_WIDTH::DST_HEIGHT data too large\n");
}
#else
#define set_DST_HEIGHT_WIDTH_dst_width(reg, dst_width) (reg)->bitfields.DST_WIDTH = dst_width
#define set_DST_HEIGHT_WIDTH_dst_height(reg, dst_height) (reg)->bitfields.DST_HEIGHT = dst_height

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DST_HEIGHT_WIDTH_8 regDST_HEIGHT_WIDTH_8;

#ifdef DEBUG
__inline void set_DST_HEIGHT_WIDTH_8_dst_width(regDST_HEIGHT_WIDTH_8 *reg, unsigned int dst_width)
{
  reg->bitfields.DST_WIDTH = dst_width;
  if (reg->bitfields.DST_WIDTH != dst_width) HSLDPF(E_ERROR_MESSAGE,"DST_HEIGHT_WIDTH_8::DST_WIDTH data too large\n");
}
__inline void set_DST_HEIGHT_WIDTH_8_dst_height(regDST_HEIGHT_WIDTH_8 *reg, unsigned int dst_height)
{
  reg->bitfields.DST_HEIGHT = dst_height;
  if (reg->bitfields.DST_HEIGHT != dst_height) HSLDPF(E_ERROR_MESSAGE,"DST_HEIGHT_WIDTH_8::DST_HEIGHT data too large\n");
}
#else
#define set_DST_HEIGHT_WIDTH_8_dst_width(reg, dst_width) (reg)->bitfields.DST_WIDTH = dst_width
#define set_DST_HEIGHT_WIDTH_8_dst_height(reg, dst_height) (reg)->bitfields.DST_HEIGHT = dst_height

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DST_HEIGHT_Y regDST_HEIGHT_Y;

#ifdef DEBUG
__inline void set_DST_HEIGHT_Y_dst_y(regDST_HEIGHT_Y *reg, unsigned int dst_y)
{
  reg->bitfields.DST_Y = dst_y;
  if (reg->bitfields.DST_Y != dst_y) HSLDPF(E_ERROR_MESSAGE,"DST_HEIGHT_Y::DST_Y data too large\n");
}
__inline void set_DST_HEIGHT_Y_dst_height(regDST_HEIGHT_Y *reg, unsigned int dst_height)
{
  reg->bitfields.DST_HEIGHT = dst_height;
  if (reg->bitfields.DST_HEIGHT != dst_height) HSLDPF(E_ERROR_MESSAGE,"DST_HEIGHT_Y::DST_HEIGHT data too large\n");
}
#else
#define set_DST_HEIGHT_Y_dst_y(reg, dst_y) (reg)->bitfields.DST_Y = dst_y
#define set_DST_HEIGHT_Y_dst_height(reg, dst_height) (reg)->bitfields.DST_HEIGHT = dst_height

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DST_WIDTH_X regDST_WIDTH_X;

#ifdef DEBUG
__inline void set_DST_WIDTH_X_dst_x(regDST_WIDTH_X *reg, unsigned int dst_x)
{
  reg->bitfields.DST_X = dst_x;
  if (reg->bitfields.DST_X != dst_x) HSLDPF(E_ERROR_MESSAGE,"DST_WIDTH_X::DST_X data too large\n");
}
__inline void set_DST_WIDTH_X_dst_width(regDST_WIDTH_X *reg, unsigned int dst_width)
{
  reg->bitfields.DST_WIDTH = dst_width;
  if (reg->bitfields.DST_WIDTH != dst_width) HSLDPF(E_ERROR_MESSAGE,"DST_WIDTH_X::DST_WIDTH data too large\n");
}
#else
#define set_DST_WIDTH_X_dst_x(reg, dst_x) (reg)->bitfields.DST_X = dst_x
#define set_DST_WIDTH_X_dst_width(reg, dst_width) (reg)->bitfields.DST_WIDTH = dst_width

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DST_WIDTH_X_INCY regDST_WIDTH_X_INCY;

#ifdef DEBUG
__inline void set_DST_WIDTH_X_INCY_dst_x(regDST_WIDTH_X_INCY *reg, unsigned int dst_x)
{
  reg->bitfields.DST_X = dst_x;
  if (reg->bitfields.DST_X != dst_x) HSLDPF(E_ERROR_MESSAGE,"DST_WIDTH_X_INCY::DST_X data too large\n");
}
__inline void set_DST_WIDTH_X_INCY_dst_width(regDST_WIDTH_X_INCY *reg, unsigned int dst_width)
{
  reg->bitfields.DST_WIDTH = dst_width;
  if (reg->bitfields.DST_WIDTH != dst_width) HSLDPF(E_ERROR_MESSAGE,"DST_WIDTH_X_INCY::DST_WIDTH data too large\n");
}
#else
#define set_DST_WIDTH_X_INCY_dst_x(reg, dst_x) (reg)->bitfields.DST_X = dst_x
#define set_DST_WIDTH_X_INCY_dst_width(reg, dst_width) (reg)->bitfields.DST_WIDTH = dst_width

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DST_LINE_START regDST_LINE_START;

#ifdef DEBUG
__inline void set_DST_LINE_START_dst_start_x(regDST_LINE_START *reg, unsigned int dst_start_x)
{
  reg->bitfields.DST_START_X = dst_start_x;
  if (reg->bitfields.DST_START_X != dst_start_x) HSLDPF(E_ERROR_MESSAGE,"DST_LINE_START::DST_START_X data too large\n");
}
__inline void set_DST_LINE_START_dst_start_y(regDST_LINE_START *reg, unsigned int dst_start_y)
{
  reg->bitfields.DST_START_Y = dst_start_y;
  if (reg->bitfields.DST_START_Y != dst_start_y) HSLDPF(E_ERROR_MESSAGE,"DST_LINE_START::DST_START_Y data too large\n");
}
#else
#define set_DST_LINE_START_dst_start_x(reg, dst_start_x) (reg)->bitfields.DST_START_X = dst_start_x
#define set_DST_LINE_START_dst_start_y(reg, dst_start_y) (reg)->bitfields.DST_START_Y = dst_start_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DST_LINE_END regDST_LINE_END;

#ifdef DEBUG
__inline void set_DST_LINE_END_dst_end_x(regDST_LINE_END *reg, unsigned int dst_end_x)
{
  reg->bitfields.DST_END_X = dst_end_x;
  if (reg->bitfields.DST_END_X != dst_end_x) HSLDPF(E_ERROR_MESSAGE,"DST_LINE_END::DST_END_X data too large\n");
}
__inline void set_DST_LINE_END_dst_end_y(regDST_LINE_END *reg, unsigned int dst_end_y)
{
  reg->bitfields.DST_END_Y = dst_end_y;
  if (reg->bitfields.DST_END_Y != dst_end_y) HSLDPF(E_ERROR_MESSAGE,"DST_LINE_END::DST_END_Y data too large\n");
}
#else
#define set_DST_LINE_END_dst_end_x(reg, dst_end_x) (reg)->bitfields.DST_END_X = dst_end_x
#define set_DST_LINE_END_dst_end_y(reg, dst_end_y) (reg)->bitfields.DST_END_Y = dst_end_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DST_LINE_PATCOUNT regDST_LINE_PATCOUNT;

#ifdef DEBUG
__inline void set_DST_LINE_PATCOUNT_line_patcount(regDST_LINE_PATCOUNT *reg, unsigned int line_patcount)
{
  reg->bitfields.LINE_PATCOUNT = line_patcount;
  if (reg->bitfields.LINE_PATCOUNT != line_patcount) HSLDPF(E_ERROR_MESSAGE,"DST_LINE_PATCOUNT::LINE_PATCOUNT data too large\n");
}
__inline void set_DST_LINE_PATCOUNT_bres_cntl(regDST_LINE_PATCOUNT *reg, unsigned int bres_cntl)
{
  reg->bitfields.BRES_CNTL = bres_cntl;
  if (reg->bitfields.BRES_CNTL != bres_cntl) HSLDPF(E_ERROR_MESSAGE,"DST_LINE_PATCOUNT::BRES_CNTL data too large\n");
}
#else
#define set_DST_LINE_PATCOUNT_line_patcount(reg, line_patcount) (reg)->bitfields.LINE_PATCOUNT = line_patcount
#define set_DST_LINE_PATCOUNT_bres_cntl(reg, bres_cntl) (reg)->bitfields.BRES_CNTL = bres_cntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DP_DST_ENDIAN regDP_DST_ENDIAN;

#ifdef DEBUG
__inline void set_DP_DST_ENDIAN_dst_endian(regDP_DST_ENDIAN *reg, unsigned int dst_endian)
{
  reg->bitfields.DST_ENDIAN = dst_endian;
  if (reg->bitfields.DST_ENDIAN != dst_endian) HSLDPF(E_ERROR_MESSAGE,"DP_DST_ENDIAN::DST_ENDIAN data too large\n");
}
#else
#define set_DP_DST_ENDIAN_dst_endian(reg, dst_endian) (reg)->bitfields.DST_ENDIAN = dst_endian

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_Y_X regBRUSH_Y_X;

#ifdef DEBUG
__inline void set_BRUSH_Y_X_brush_x(regBRUSH_Y_X *reg, unsigned int brush_x)
{
  reg->bitfields.BRUSH_X = brush_x;
  if (reg->bitfields.BRUSH_X != brush_x) HSLDPF(E_ERROR_MESSAGE,"BRUSH_Y_X::BRUSH_X data too large\n");
}
__inline void set_BRUSH_Y_X_brush_y(regBRUSH_Y_X *reg, unsigned int brush_y)
{
  reg->bitfields.BRUSH_Y = brush_y;
  if (reg->bitfields.BRUSH_Y != brush_y) HSLDPF(E_ERROR_MESSAGE,"BRUSH_Y_X::BRUSH_Y data too large\n");
}
#else
#define set_BRUSH_Y_X_brush_x(reg, brush_x) (reg)->bitfields.BRUSH_X = brush_x
#define set_BRUSH_Y_X_brush_y(reg, brush_y) (reg)->bitfields.BRUSH_Y = brush_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA0 regBRUSH_DATA0;

#ifdef DEBUG
__inline void set_BRUSH_DATA0_brush_data(regBRUSH_DATA0 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA0::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA0_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA1 regBRUSH_DATA1;

#ifdef DEBUG
__inline void set_BRUSH_DATA1_brush_data(regBRUSH_DATA1 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA1::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA1_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA2 regBRUSH_DATA2;

#ifdef DEBUG
__inline void set_BRUSH_DATA2_brush_data(regBRUSH_DATA2 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA2::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA2_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA3 regBRUSH_DATA3;

#ifdef DEBUG
__inline void set_BRUSH_DATA3_brush_data(regBRUSH_DATA3 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA3::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA3_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA4 regBRUSH_DATA4;

#ifdef DEBUG
__inline void set_BRUSH_DATA4_brush_data(regBRUSH_DATA4 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA4::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA4_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA5 regBRUSH_DATA5;

#ifdef DEBUG
__inline void set_BRUSH_DATA5_brush_data(regBRUSH_DATA5 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA5::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA5_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA6 regBRUSH_DATA6;

#ifdef DEBUG
__inline void set_BRUSH_DATA6_brush_data(regBRUSH_DATA6 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA6::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA6_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA7 regBRUSH_DATA7;

#ifdef DEBUG
__inline void set_BRUSH_DATA7_brush_data(regBRUSH_DATA7 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA7::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA7_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA8 regBRUSH_DATA8;

#ifdef DEBUG
__inline void set_BRUSH_DATA8_brush_data(regBRUSH_DATA8 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA8::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA8_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA9 regBRUSH_DATA9;

#ifdef DEBUG
__inline void set_BRUSH_DATA9_brush_data(regBRUSH_DATA9 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA9::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA9_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA10 regBRUSH_DATA10;

#ifdef DEBUG
__inline void set_BRUSH_DATA10_brush_data(regBRUSH_DATA10 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA10::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA10_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA11 regBRUSH_DATA11;

#ifdef DEBUG
__inline void set_BRUSH_DATA11_brush_data(regBRUSH_DATA11 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA11::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA11_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA12 regBRUSH_DATA12;

#ifdef DEBUG
__inline void set_BRUSH_DATA12_brush_data(regBRUSH_DATA12 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA12::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA12_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA13 regBRUSH_DATA13;

#ifdef DEBUG
__inline void set_BRUSH_DATA13_brush_data(regBRUSH_DATA13 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA13::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA13_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA14 regBRUSH_DATA14;

#ifdef DEBUG
__inline void set_BRUSH_DATA14_brush_data(regBRUSH_DATA14 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA14::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA14_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA15 regBRUSH_DATA15;

#ifdef DEBUG
__inline void set_BRUSH_DATA15_brush_data(regBRUSH_DATA15 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA15::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA15_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA16 regBRUSH_DATA16;

#ifdef DEBUG
__inline void set_BRUSH_DATA16_brush_data(regBRUSH_DATA16 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA16::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA16_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA17 regBRUSH_DATA17;

#ifdef DEBUG
__inline void set_BRUSH_DATA17_brush_data(regBRUSH_DATA17 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA17::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA17_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA18 regBRUSH_DATA18;

#ifdef DEBUG
__inline void set_BRUSH_DATA18_brush_data(regBRUSH_DATA18 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA18::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA18_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA19 regBRUSH_DATA19;

#ifdef DEBUG
__inline void set_BRUSH_DATA19_brush_data(regBRUSH_DATA19 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA19::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA19_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA20 regBRUSH_DATA20;

#ifdef DEBUG
__inline void set_BRUSH_DATA20_brush_data(regBRUSH_DATA20 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA20::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA20_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA21 regBRUSH_DATA21;

#ifdef DEBUG
__inline void set_BRUSH_DATA21_brush_data(regBRUSH_DATA21 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA21::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA21_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA22 regBRUSH_DATA22;

#ifdef DEBUG
__inline void set_BRUSH_DATA22_brush_data(regBRUSH_DATA22 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA22::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA22_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA23 regBRUSH_DATA23;

#ifdef DEBUG
__inline void set_BRUSH_DATA23_brush_data(regBRUSH_DATA23 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA23::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA23_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA24 regBRUSH_DATA24;

#ifdef DEBUG
__inline void set_BRUSH_DATA24_brush_data(regBRUSH_DATA24 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA24::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA24_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA25 regBRUSH_DATA25;

#ifdef DEBUG
__inline void set_BRUSH_DATA25_brush_data(regBRUSH_DATA25 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA25::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA25_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA26 regBRUSH_DATA26;

#ifdef DEBUG
__inline void set_BRUSH_DATA26_brush_data(regBRUSH_DATA26 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA26::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA26_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA27 regBRUSH_DATA27;

#ifdef DEBUG
__inline void set_BRUSH_DATA27_brush_data(regBRUSH_DATA27 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA27::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA27_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA28 regBRUSH_DATA28;

#ifdef DEBUG
__inline void set_BRUSH_DATA28_brush_data(regBRUSH_DATA28 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA28::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA28_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA29 regBRUSH_DATA29;

#ifdef DEBUG
__inline void set_BRUSH_DATA29_brush_data(regBRUSH_DATA29 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA29::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA29_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA30 regBRUSH_DATA30;

#ifdef DEBUG
__inline void set_BRUSH_DATA30_brush_data(regBRUSH_DATA30 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA30::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA30_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA31 regBRUSH_DATA31;

#ifdef DEBUG
__inline void set_BRUSH_DATA31_brush_data(regBRUSH_DATA31 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA31::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA31_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA32 regBRUSH_DATA32;

#ifdef DEBUG
__inline void set_BRUSH_DATA32_brush_data(regBRUSH_DATA32 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA32::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA32_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA33 regBRUSH_DATA33;

#ifdef DEBUG
__inline void set_BRUSH_DATA33_brush_data(regBRUSH_DATA33 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA33::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA33_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA34 regBRUSH_DATA34;

#ifdef DEBUG
__inline void set_BRUSH_DATA34_brush_data(regBRUSH_DATA34 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA34::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA34_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA35 regBRUSH_DATA35;

#ifdef DEBUG
__inline void set_BRUSH_DATA35_brush_data(regBRUSH_DATA35 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA35::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA35_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA36 regBRUSH_DATA36;

#ifdef DEBUG
__inline void set_BRUSH_DATA36_brush_data(regBRUSH_DATA36 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA36::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA36_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA37 regBRUSH_DATA37;

#ifdef DEBUG
__inline void set_BRUSH_DATA37_brush_data(regBRUSH_DATA37 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA37::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA37_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA38 regBRUSH_DATA38;

#ifdef DEBUG
__inline void set_BRUSH_DATA38_brush_data(regBRUSH_DATA38 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA38::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA38_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA39 regBRUSH_DATA39;

#ifdef DEBUG
__inline void set_BRUSH_DATA39_brush_data(regBRUSH_DATA39 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA39::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA39_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA40 regBRUSH_DATA40;

#ifdef DEBUG
__inline void set_BRUSH_DATA40_brush_data(regBRUSH_DATA40 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA40::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA40_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA41 regBRUSH_DATA41;

#ifdef DEBUG
__inline void set_BRUSH_DATA41_brush_data(regBRUSH_DATA41 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA41::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA41_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA42 regBRUSH_DATA42;

#ifdef DEBUG
__inline void set_BRUSH_DATA42_brush_data(regBRUSH_DATA42 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA42::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA42_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA43 regBRUSH_DATA43;

#ifdef DEBUG
__inline void set_BRUSH_DATA43_brush_data(regBRUSH_DATA43 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA43::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA43_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA44 regBRUSH_DATA44;

#ifdef DEBUG
__inline void set_BRUSH_DATA44_brush_data(regBRUSH_DATA44 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA44::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA44_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA45 regBRUSH_DATA45;

#ifdef DEBUG
__inline void set_BRUSH_DATA45_brush_data(regBRUSH_DATA45 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA45::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA45_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA46 regBRUSH_DATA46;

#ifdef DEBUG
__inline void set_BRUSH_DATA46_brush_data(regBRUSH_DATA46 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA46::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA46_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA47 regBRUSH_DATA47;

#ifdef DEBUG
__inline void set_BRUSH_DATA47_brush_data(regBRUSH_DATA47 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA47::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA47_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA48 regBRUSH_DATA48;

#ifdef DEBUG
__inline void set_BRUSH_DATA48_brush_data(regBRUSH_DATA48 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA48::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA48_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA49 regBRUSH_DATA49;

#ifdef DEBUG
__inline void set_BRUSH_DATA49_brush_data(regBRUSH_DATA49 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA49::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA49_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA50 regBRUSH_DATA50;

#ifdef DEBUG
__inline void set_BRUSH_DATA50_brush_data(regBRUSH_DATA50 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA50::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA50_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA51 regBRUSH_DATA51;

#ifdef DEBUG
__inline void set_BRUSH_DATA51_brush_data(regBRUSH_DATA51 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA51::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA51_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA52 regBRUSH_DATA52;

#ifdef DEBUG
__inline void set_BRUSH_DATA52_brush_data(regBRUSH_DATA52 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA52::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA52_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA53 regBRUSH_DATA53;

#ifdef DEBUG
__inline void set_BRUSH_DATA53_brush_data(regBRUSH_DATA53 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA53::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA53_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA54 regBRUSH_DATA54;

#ifdef DEBUG
__inline void set_BRUSH_DATA54_brush_data(regBRUSH_DATA54 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA54::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA54_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA55 regBRUSH_DATA55;

#ifdef DEBUG
__inline void set_BRUSH_DATA55_brush_data(regBRUSH_DATA55 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA55::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA55_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA56 regBRUSH_DATA56;

#ifdef DEBUG
__inline void set_BRUSH_DATA56_brush_data(regBRUSH_DATA56 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA56::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA56_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA57 regBRUSH_DATA57;

#ifdef DEBUG
__inline void set_BRUSH_DATA57_brush_data(regBRUSH_DATA57 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA57::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA57_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA58 regBRUSH_DATA58;

#ifdef DEBUG
__inline void set_BRUSH_DATA58_brush_data(regBRUSH_DATA58 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA58::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA58_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA59 regBRUSH_DATA59;

#ifdef DEBUG
__inline void set_BRUSH_DATA59_brush_data(regBRUSH_DATA59 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA59::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA59_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA60 regBRUSH_DATA60;

#ifdef DEBUG
__inline void set_BRUSH_DATA60_brush_data(regBRUSH_DATA60 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA60::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA60_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA61 regBRUSH_DATA61;

#ifdef DEBUG
__inline void set_BRUSH_DATA61_brush_data(regBRUSH_DATA61 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA61::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA61_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA62 regBRUSH_DATA62;

#ifdef DEBUG
__inline void set_BRUSH_DATA62_brush_data(regBRUSH_DATA62 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA62::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA62_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BRUSH_DATA63 regBRUSH_DATA63;

#ifdef DEBUG
__inline void set_BRUSH_DATA63_brush_data(regBRUSH_DATA63 *reg, unsigned int brush_data)
{
  reg->bitfields.BRUSH_DATA = brush_data;
  if (reg->bitfields.BRUSH_DATA != brush_data) HSLDPF(E_ERROR_MESSAGE,"BRUSH_DATA63::BRUSH_DATA data too large\n");
}
#else
#define set_BRUSH_DATA63_brush_data(reg, brush_data) (reg)->bitfields.BRUSH_DATA = brush_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DP_BRUSH_FRGD_CLR regDP_BRUSH_FRGD_CLR;

#ifdef DEBUG
__inline void set_DP_BRUSH_FRGD_CLR_dp_brush_frgd_clr(regDP_BRUSH_FRGD_CLR *reg, unsigned int dp_brush_frgd_clr)
{
  reg->bitfields.DP_BRUSH_FRGD_CLR = dp_brush_frgd_clr;
  if (reg->bitfields.DP_BRUSH_FRGD_CLR != dp_brush_frgd_clr) HSLDPF(E_ERROR_MESSAGE,"DP_BRUSH_FRGD_CLR::DP_BRUSH_FRGD_CLR data too large\n");
}
#else
#define set_DP_BRUSH_FRGD_CLR_dp_brush_frgd_clr(reg, dp_brush_frgd_clr) (reg)->bitfields.DP_BRUSH_FRGD_CLR = dp_brush_frgd_clr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DP_BRUSH_BKGD_CLR regDP_BRUSH_BKGD_CLR;

#ifdef DEBUG
__inline void set_DP_BRUSH_BKGD_CLR_dp_brush_bkgd_clr(regDP_BRUSH_BKGD_CLR *reg, unsigned int dp_brush_bkgd_clr)
{
  reg->bitfields.DP_BRUSH_BKGD_CLR = dp_brush_bkgd_clr;
  if (reg->bitfields.DP_BRUSH_BKGD_CLR != dp_brush_bkgd_clr) HSLDPF(E_ERROR_MESSAGE,"DP_BRUSH_BKGD_CLR::DP_BRUSH_BKGD_CLR data too large\n");
}
#else
#define set_DP_BRUSH_BKGD_CLR_dp_brush_bkgd_clr(reg, dp_brush_bkgd_clr) (reg)->bitfields.DP_BRUSH_BKGD_CLR = dp_brush_bkgd_clr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SRC_OFFSET regSRC_OFFSET;

#ifdef DEBUG
__inline void set_SRC_OFFSET_src_offset(regSRC_OFFSET *reg, unsigned int src_offset)
{
  reg->bitfields.SRC_OFFSET = src_offset;
  if (reg->bitfields.SRC_OFFSET != src_offset) HSLDPF(E_ERROR_MESSAGE,"SRC_OFFSET::SRC_OFFSET data too large\n");
}
#else
#define set_SRC_OFFSET_src_offset(reg, src_offset) (reg)->bitfields.SRC_OFFSET = src_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SRC_PITCH regSRC_PITCH;

#ifdef DEBUG
__inline void set_SRC_PITCH_src_pitch(regSRC_PITCH *reg, unsigned int src_pitch)
{
  reg->bitfields.SRC_PITCH = src_pitch;
  if (reg->bitfields.SRC_PITCH != src_pitch) HSLDPF(E_ERROR_MESSAGE,"SRC_PITCH::SRC_PITCH data too large\n");
}
#else
#define set_SRC_PITCH_src_pitch(reg, src_pitch) (reg)->bitfields.SRC_PITCH = src_pitch

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SRC_TILE regSRC_TILE;

#ifdef DEBUG
__inline void set_SRC_TILE_src_tile(regSRC_TILE *reg, unsigned int src_tile)
{
  reg->bitfields.SRC_TILE = src_tile;
  if (reg->bitfields.SRC_TILE != src_tile) HSLDPF(E_ERROR_MESSAGE,"SRC_TILE::SRC_TILE data too large\n");
}
#else
#define set_SRC_TILE_src_tile(reg, src_tile) (reg)->bitfields.SRC_TILE = src_tile

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SRC_PITCH_OFFSET regSRC_PITCH_OFFSET;

#ifdef DEBUG
__inline void set_SRC_PITCH_OFFSET_src_offset(regSRC_PITCH_OFFSET *reg, unsigned int src_offset)
{
  reg->bitfields.SRC_OFFSET = src_offset;
  if (reg->bitfields.SRC_OFFSET != src_offset) HSLDPF(E_ERROR_MESSAGE,"SRC_PITCH_OFFSET::SRC_OFFSET data too large\n");
}
__inline void set_SRC_PITCH_OFFSET_src_pitch(regSRC_PITCH_OFFSET *reg, unsigned int src_pitch)
{
  reg->bitfields.SRC_PITCH = src_pitch;
  if (reg->bitfields.SRC_PITCH != src_pitch) HSLDPF(E_ERROR_MESSAGE,"SRC_PITCH_OFFSET::SRC_PITCH data too large\n");
}
__inline void set_SRC_PITCH_OFFSET_src_tile(regSRC_PITCH_OFFSET *reg, unsigned int src_tile)
{
  reg->bitfields.SRC_TILE = src_tile;
  if (reg->bitfields.SRC_TILE != src_tile) HSLDPF(E_ERROR_MESSAGE,"SRC_PITCH_OFFSET::SRC_TILE data too large\n");
}
#else
#define set_SRC_PITCH_OFFSET_src_offset(reg, src_offset) (reg)->bitfields.SRC_OFFSET = src_offset
#define set_SRC_PITCH_OFFSET_src_pitch(reg, src_pitch) (reg)->bitfields.SRC_PITCH = src_pitch
#define set_SRC_PITCH_OFFSET_src_tile(reg, src_tile) (reg)->bitfields.SRC_TILE = src_tile

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SRC_X regSRC_X;

#ifdef DEBUG
__inline void set_SRC_X_src_x(regSRC_X *reg, unsigned int src_x)
{
  reg->bitfields.SRC_X = src_x;
  if (reg->bitfields.SRC_X != src_x) HSLDPF(E_ERROR_MESSAGE,"SRC_X::SRC_X data too large\n");
}
#else
#define set_SRC_X_src_x(reg, src_x) (reg)->bitfields.SRC_X = src_x

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SRC_Y regSRC_Y;

#ifdef DEBUG
__inline void set_SRC_Y_src_y(regSRC_Y *reg, unsigned int src_y)
{
  reg->bitfields.SRC_Y = src_y;
  if (reg->bitfields.SRC_Y != src_y) HSLDPF(E_ERROR_MESSAGE,"SRC_Y::SRC_Y data too large\n");
}
#else
#define set_SRC_Y_src_y(reg, src_y) (reg)->bitfields.SRC_Y = src_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SRC_X_Y regSRC_X_Y;

#ifdef DEBUG
__inline void set_SRC_X_Y_src_y(regSRC_X_Y *reg, unsigned int src_y)
{
  reg->bitfields.SRC_Y = src_y;
  if (reg->bitfields.SRC_Y != src_y) HSLDPF(E_ERROR_MESSAGE,"SRC_X_Y::SRC_Y data too large\n");
}
__inline void set_SRC_X_Y_src_x(regSRC_X_Y *reg, unsigned int src_x)
{
  reg->bitfields.SRC_X = src_x;
  if (reg->bitfields.SRC_X != src_x) HSLDPF(E_ERROR_MESSAGE,"SRC_X_Y::SRC_X data too large\n");
}
#else
#define set_SRC_X_Y_src_y(reg, src_y) (reg)->bitfields.SRC_Y = src_y
#define set_SRC_X_Y_src_x(reg, src_x) (reg)->bitfields.SRC_X = src_x

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SRC_Y_X regSRC_Y_X;

#ifdef DEBUG
__inline void set_SRC_Y_X_src_x(regSRC_Y_X *reg, unsigned int src_x)
{
  reg->bitfields.SRC_X = src_x;
  if (reg->bitfields.SRC_X != src_x) HSLDPF(E_ERROR_MESSAGE,"SRC_Y_X::SRC_X data too large\n");
}
__inline void set_SRC_Y_X_src_y(regSRC_Y_X *reg, unsigned int src_y)
{
  reg->bitfields.SRC_Y = src_y;
  if (reg->bitfields.SRC_Y != src_y) HSLDPF(E_ERROR_MESSAGE,"SRC_Y_X::SRC_Y data too large\n");
}
#else
#define set_SRC_Y_X_src_x(reg, src_x) (reg)->bitfields.SRC_X = src_x
#define set_SRC_Y_X_src_y(reg, src_y) (reg)->bitfields.SRC_Y = src_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SRC_CLUT_ADDRESS regSRC_CLUT_ADDRESS;

#ifdef DEBUG
__inline void set_SRC_CLUT_ADDRESS_src_clut_address(regSRC_CLUT_ADDRESS *reg, unsigned int src_clut_address)
{
  reg->bitfields.SRC_CLUT_ADDRESS = src_clut_address;
  if (reg->bitfields.SRC_CLUT_ADDRESS != src_clut_address) HSLDPF(E_ERROR_MESSAGE,"SRC_CLUT_ADDRESS::SRC_CLUT_ADDRESS data too large\n");
}
#else
#define set_SRC_CLUT_ADDRESS_src_clut_address(reg, src_clut_address) (reg)->bitfields.SRC_CLUT_ADDRESS = src_clut_address

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SRC_CLUT_DATA regSRC_CLUT_DATA;

#ifdef DEBUG
__inline void set_SRC_CLUT_DATA_src_clut_data(regSRC_CLUT_DATA *reg, unsigned int src_clut_data)
{
  reg->bitfields.SRC_CLUT_DATA = src_clut_data;
  if (reg->bitfields.SRC_CLUT_DATA != src_clut_data) HSLDPF(E_ERROR_MESSAGE,"SRC_CLUT_DATA::SRC_CLUT_DATA data too large\n");
}
#else
#define set_SRC_CLUT_DATA_src_clut_data(reg, src_clut_data) (reg)->bitfields.SRC_CLUT_DATA = src_clut_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SRC_CLUT_DATA_RD regSRC_CLUT_DATA_RD;

#ifdef DEBUG
__inline void set_SRC_CLUT_DATA_RD_src_clut_data(regSRC_CLUT_DATA_RD *reg, unsigned int src_clut_data)
{
  reg->bitfields.SRC_CLUT_DATA = src_clut_data;
  if (reg->bitfields.SRC_CLUT_DATA != src_clut_data) HSLDPF(E_ERROR_MESSAGE,"SRC_CLUT_DATA_RD::SRC_CLUT_DATA data too large\n");
}
#else
#define set_SRC_CLUT_DATA_RD_src_clut_data(reg, src_clut_data) (reg)->bitfields.SRC_CLUT_DATA = src_clut_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union HOST_DATA0 regHOST_DATA0;

#ifdef DEBUG
__inline void set_HOST_DATA0_host_data(regHOST_DATA0 *reg, unsigned int host_data)
{
  reg->bitfields.HOST_DATA = host_data;
  if (reg->bitfields.HOST_DATA != host_data) HSLDPF(E_ERROR_MESSAGE,"HOST_DATA0::HOST_DATA data too large\n");
}
#else
#define set_HOST_DATA0_host_data(reg, host_data) (reg)->bitfields.HOST_DATA = host_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union HOST_DATA1 regHOST_DATA1;

#ifdef DEBUG
__inline void set_HOST_DATA1_host_data(regHOST_DATA1 *reg, unsigned int host_data)
{
  reg->bitfields.HOST_DATA = host_data;
  if (reg->bitfields.HOST_DATA != host_data) HSLDPF(E_ERROR_MESSAGE,"HOST_DATA1::HOST_DATA data too large\n");
}
#else
#define set_HOST_DATA1_host_data(reg, host_data) (reg)->bitfields.HOST_DATA = host_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union HOST_DATA2 regHOST_DATA2;

#ifdef DEBUG
__inline void set_HOST_DATA2_host_data(regHOST_DATA2 *reg, unsigned int host_data)
{
  reg->bitfields.HOST_DATA = host_data;
  if (reg->bitfields.HOST_DATA != host_data) HSLDPF(E_ERROR_MESSAGE,"HOST_DATA2::HOST_DATA data too large\n");
}
#else
#define set_HOST_DATA2_host_data(reg, host_data) (reg)->bitfields.HOST_DATA = host_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union HOST_DATA3 regHOST_DATA3;

#ifdef DEBUG
__inline void set_HOST_DATA3_host_data(regHOST_DATA3 *reg, unsigned int host_data)
{
  reg->bitfields.HOST_DATA = host_data;
  if (reg->bitfields.HOST_DATA != host_data) HSLDPF(E_ERROR_MESSAGE,"HOST_DATA3::HOST_DATA data too large\n");
}
#else
#define set_HOST_DATA3_host_data(reg, host_data) (reg)->bitfields.HOST_DATA = host_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union HOST_DATA4 regHOST_DATA4;

#ifdef DEBUG
__inline void set_HOST_DATA4_host_data(regHOST_DATA4 *reg, unsigned int host_data)
{
  reg->bitfields.HOST_DATA = host_data;
  if (reg->bitfields.HOST_DATA != host_data) HSLDPF(E_ERROR_MESSAGE,"HOST_DATA4::HOST_DATA data too large\n");
}
#else
#define set_HOST_DATA4_host_data(reg, host_data) (reg)->bitfields.HOST_DATA = host_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union HOST_DATA5 regHOST_DATA5;

#ifdef DEBUG
__inline void set_HOST_DATA5_host_data(regHOST_DATA5 *reg, unsigned int host_data)
{
  reg->bitfields.HOST_DATA = host_data;
  if (reg->bitfields.HOST_DATA != host_data) HSLDPF(E_ERROR_MESSAGE,"HOST_DATA5::HOST_DATA data too large\n");
}
#else
#define set_HOST_DATA5_host_data(reg, host_data) (reg)->bitfields.HOST_DATA = host_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union HOST_DATA6 regHOST_DATA6;

#ifdef DEBUG
__inline void set_HOST_DATA6_host_data(regHOST_DATA6 *reg, unsigned int host_data)
{
  reg->bitfields.HOST_DATA = host_data;
  if (reg->bitfields.HOST_DATA != host_data) HSLDPF(E_ERROR_MESSAGE,"HOST_DATA6::HOST_DATA data too large\n");
}
#else
#define set_HOST_DATA6_host_data(reg, host_data) (reg)->bitfields.HOST_DATA = host_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union HOST_DATA7 regHOST_DATA7;

#ifdef DEBUG
__inline void set_HOST_DATA7_host_data(regHOST_DATA7 *reg, unsigned int host_data)
{
  reg->bitfields.HOST_DATA = host_data;
  if (reg->bitfields.HOST_DATA != host_data) HSLDPF(E_ERROR_MESSAGE,"HOST_DATA7::HOST_DATA data too large\n");
}
#else
#define set_HOST_DATA7_host_data(reg, host_data) (reg)->bitfields.HOST_DATA = host_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union HOST_DATA_LAST regHOST_DATA_LAST;

#ifdef DEBUG
__inline void set_HOST_DATA_LAST_host_data_last(regHOST_DATA_LAST *reg, unsigned int host_data_last)
{
  reg->bitfields.HOST_DATA_LAST = host_data_last;
  if (reg->bitfields.HOST_DATA_LAST != host_data_last) HSLDPF(E_ERROR_MESSAGE,"HOST_DATA_LAST::HOST_DATA_LAST data too large\n");
}
#else
#define set_HOST_DATA_LAST_host_data_last(reg, host_data_last) (reg)->bitfields.HOST_DATA_LAST = host_data_last

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DP_SRC_ENDIAN regDP_SRC_ENDIAN;

#ifdef DEBUG
__inline void set_DP_SRC_ENDIAN_src_endian(regDP_SRC_ENDIAN *reg, unsigned int src_endian)
{
  reg->bitfields.SRC_ENDIAN = src_endian;
  if (reg->bitfields.SRC_ENDIAN != src_endian) HSLDPF(E_ERROR_MESSAGE,"DP_SRC_ENDIAN::SRC_ENDIAN data too large\n");
}
#else
#define set_DP_SRC_ENDIAN_src_endian(reg, src_endian) (reg)->bitfields.SRC_ENDIAN = src_endian

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DP_SRC_FRGD_CLR regDP_SRC_FRGD_CLR;

#ifdef DEBUG
__inline void set_DP_SRC_FRGD_CLR_dp_src_frgd_clr(regDP_SRC_FRGD_CLR *reg, unsigned int dp_src_frgd_clr)
{
  reg->bitfields.DP_SRC_FRGD_CLR = dp_src_frgd_clr;
  if (reg->bitfields.DP_SRC_FRGD_CLR != dp_src_frgd_clr) HSLDPF(E_ERROR_MESSAGE,"DP_SRC_FRGD_CLR::DP_SRC_FRGD_CLR data too large\n");
}
#else
#define set_DP_SRC_FRGD_CLR_dp_src_frgd_clr(reg, dp_src_frgd_clr) (reg)->bitfields.DP_SRC_FRGD_CLR = dp_src_frgd_clr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DP_SRC_BKGD_CLR regDP_SRC_BKGD_CLR;

#ifdef DEBUG
__inline void set_DP_SRC_BKGD_CLR_dp_src_bkgd_clr(regDP_SRC_BKGD_CLR *reg, unsigned int dp_src_bkgd_clr)
{
  reg->bitfields.DP_SRC_BKGD_CLR = dp_src_bkgd_clr;
  if (reg->bitfields.DP_SRC_BKGD_CLR != dp_src_bkgd_clr) HSLDPF(E_ERROR_MESSAGE,"DP_SRC_BKGD_CLR::DP_SRC_BKGD_CLR data too large\n");
}
#else
#define set_DP_SRC_BKGD_CLR_dp_src_bkgd_clr(reg, dp_src_bkgd_clr) (reg)->bitfields.DP_SRC_BKGD_CLR = dp_src_bkgd_clr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SC_LEFT regSC_LEFT;

#ifdef DEBUG
__inline void set_SC_LEFT_sc_left(regSC_LEFT *reg, unsigned int sc_left)
{
  reg->bitfields.SC_LEFT = sc_left;
  if (reg->bitfields.SC_LEFT != sc_left) HSLDPF(E_ERROR_MESSAGE,"SC_LEFT::SC_LEFT data too large\n");
}
#else
#define set_SC_LEFT_sc_left(reg, sc_left) (reg)->bitfields.SC_LEFT = sc_left

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SC_RIGHT regSC_RIGHT;

#ifdef DEBUG
__inline void set_SC_RIGHT_sc_right(regSC_RIGHT *reg, unsigned int sc_right)
{
  reg->bitfields.SC_RIGHT = sc_right;
  if (reg->bitfields.SC_RIGHT != sc_right) HSLDPF(E_ERROR_MESSAGE,"SC_RIGHT::SC_RIGHT data too large\n");
}
#else
#define set_SC_RIGHT_sc_right(reg, sc_right) (reg)->bitfields.SC_RIGHT = sc_right

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SC_TOP regSC_TOP;

#ifdef DEBUG
__inline void set_SC_TOP_sc_top(regSC_TOP *reg, unsigned int sc_top)
{
  reg->bitfields.SC_TOP = sc_top;
  if (reg->bitfields.SC_TOP != sc_top) HSLDPF(E_ERROR_MESSAGE,"SC_TOP::SC_TOP data too large\n");
}
#else
#define set_SC_TOP_sc_top(reg, sc_top) (reg)->bitfields.SC_TOP = sc_top

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SC_BOTTOM regSC_BOTTOM;

#ifdef DEBUG
__inline void set_SC_BOTTOM_sc_bottom(regSC_BOTTOM *reg, unsigned int sc_bottom)
{
  reg->bitfields.SC_BOTTOM = sc_bottom;
  if (reg->bitfields.SC_BOTTOM != sc_bottom) HSLDPF(E_ERROR_MESSAGE,"SC_BOTTOM::SC_BOTTOM data too large\n");
}
#else
#define set_SC_BOTTOM_sc_bottom(reg, sc_bottom) (reg)->bitfields.SC_BOTTOM = sc_bottom

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SRC_SC_RIGHT regSRC_SC_RIGHT;

#ifdef DEBUG
__inline void set_SRC_SC_RIGHT_sc_right(regSRC_SC_RIGHT *reg, unsigned int sc_right)
{
  reg->bitfields.SC_RIGHT = sc_right;
  if (reg->bitfields.SC_RIGHT != sc_right) HSLDPF(E_ERROR_MESSAGE,"SRC_SC_RIGHT::SC_RIGHT data too large\n");
}
#else
#define set_SRC_SC_RIGHT_sc_right(reg, sc_right) (reg)->bitfields.SC_RIGHT = sc_right

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SRC_SC_BOTTOM regSRC_SC_BOTTOM;

#ifdef DEBUG
__inline void set_SRC_SC_BOTTOM_sc_bottom(regSRC_SC_BOTTOM *reg, unsigned int sc_bottom)
{
  reg->bitfields.SC_BOTTOM = sc_bottom;
  if (reg->bitfields.SC_BOTTOM != sc_bottom) HSLDPF(E_ERROR_MESSAGE,"SRC_SC_BOTTOM::SC_BOTTOM data too large\n");
}
#else
#define set_SRC_SC_BOTTOM_sc_bottom(reg, sc_bottom) (reg)->bitfields.SC_BOTTOM = sc_bottom

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DP_CNTL regDP_CNTL;

#ifdef DEBUG
__inline void set_DP_CNTL_dst_x_dir(regDP_CNTL *reg, unsigned int dst_x_dir)
{
  reg->bitfields.DST_X_DIR = dst_x_dir;
  if (reg->bitfields.DST_X_DIR != dst_x_dir) HSLDPF(E_ERROR_MESSAGE,"DP_CNTL::DST_X_DIR data too large\n");
}
__inline void set_DP_CNTL_dst_y_dir(regDP_CNTL *reg, unsigned int dst_y_dir)
{
  reg->bitfields.DST_Y_DIR = dst_y_dir;
  if (reg->bitfields.DST_Y_DIR != dst_y_dir) HSLDPF(E_ERROR_MESSAGE,"DP_CNTL::DST_Y_DIR data too large\n");
}
__inline void set_DP_CNTL_dst_tile(regDP_CNTL *reg, unsigned int dst_tile)
{
  reg->bitfields.DST_TILE = dst_tile;
  if (reg->bitfields.DST_TILE != dst_tile) HSLDPF(E_ERROR_MESSAGE,"DP_CNTL::DST_TILE data too large\n");
}
#else
#define set_DP_CNTL_dst_x_dir(reg, dst_x_dir) (reg)->bitfields.DST_X_DIR = dst_x_dir
#define set_DP_CNTL_dst_y_dir(reg, dst_y_dir) (reg)->bitfields.DST_Y_DIR = dst_y_dir
#define set_DP_CNTL_dst_tile(reg, dst_tile) (reg)->bitfields.DST_TILE = dst_tile

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DP_CNTL_XDIR_YDIR_YMAJOR regDP_CNTL_XDIR_YDIR_YMAJOR;

#ifdef DEBUG
__inline void set_DP_CNTL_XDIR_YDIR_YMAJOR_dst_y_dir(regDP_CNTL_XDIR_YDIR_YMAJOR *reg, unsigned int dst_y_dir)
{
  reg->bitfields.DST_Y_DIR = dst_y_dir;
  if (reg->bitfields.DST_Y_DIR != dst_y_dir) HSLDPF(E_ERROR_MESSAGE,"DP_CNTL_XDIR_YDIR_YMAJOR::DST_Y_DIR data too large\n");
}
__inline void set_DP_CNTL_XDIR_YDIR_YMAJOR_dst_x_dir(regDP_CNTL_XDIR_YDIR_YMAJOR *reg, unsigned int dst_x_dir)
{
  reg->bitfields.DST_X_DIR = dst_x_dir;
  if (reg->bitfields.DST_X_DIR != dst_x_dir) HSLDPF(E_ERROR_MESSAGE,"DP_CNTL_XDIR_YDIR_YMAJOR::DST_X_DIR data too large\n");
}
#else
#define set_DP_CNTL_XDIR_YDIR_YMAJOR_dst_y_dir(reg, dst_y_dir) (reg)->bitfields.DST_Y_DIR = dst_y_dir
#define set_DP_CNTL_XDIR_YDIR_YMAJOR_dst_x_dir(reg, dst_x_dir) (reg)->bitfields.DST_X_DIR = dst_x_dir

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DP_DATATYPE regDP_DATATYPE;

#ifdef DEBUG
__inline void set_DP_DATATYPE_dp_dst_datatype(regDP_DATATYPE *reg, unsigned int dp_dst_datatype)
{
  reg->bitfields.DP_DST_DATATYPE = dp_dst_datatype;
  if (reg->bitfields.DP_DST_DATATYPE != dp_dst_datatype) HSLDPF(E_ERROR_MESSAGE,"DP_DATATYPE::DP_DST_DATATYPE data too large\n");
}
__inline void set_DP_DATATYPE_dp_brush_datatype(regDP_DATATYPE *reg, unsigned int dp_brush_datatype)
{
  reg->bitfields.DP_BRUSH_DATATYPE = dp_brush_datatype;
  if (reg->bitfields.DP_BRUSH_DATATYPE != dp_brush_datatype) HSLDPF(E_ERROR_MESSAGE,"DP_DATATYPE::DP_BRUSH_DATATYPE data too large\n");
}
__inline void set_DP_DATATYPE_dp_src_datatype(regDP_DATATYPE *reg, unsigned int dp_src_datatype)
{
  reg->bitfields.DP_SRC_DATATYPE = dp_src_datatype;
  if (reg->bitfields.DP_SRC_DATATYPE != dp_src_datatype) HSLDPF(E_ERROR_MESSAGE,"DP_DATATYPE::DP_SRC_DATATYPE data too large\n");
}
__inline void set_DP_DATATYPE_dp_byte_pix_order(regDP_DATATYPE *reg, unsigned int dp_byte_pix_order)
{
  reg->bitfields.DP_BYTE_PIX_ORDER = dp_byte_pix_order;
  if (reg->bitfields.DP_BYTE_PIX_ORDER != dp_byte_pix_order) HSLDPF(E_ERROR_MESSAGE,"DP_DATATYPE::DP_BYTE_PIX_ORDER data too large\n");
}
#else
#define set_DP_DATATYPE_dp_dst_datatype(reg, dp_dst_datatype) (reg)->bitfields.DP_DST_DATATYPE = dp_dst_datatype
#define set_DP_DATATYPE_dp_brush_datatype(reg, dp_brush_datatype) (reg)->bitfields.DP_BRUSH_DATATYPE = dp_brush_datatype
#define set_DP_DATATYPE_dp_src_datatype(reg, dp_src_datatype) (reg)->bitfields.DP_SRC_DATATYPE = dp_src_datatype
#define set_DP_DATATYPE_dp_byte_pix_order(reg, dp_byte_pix_order) (reg)->bitfields.DP_BYTE_PIX_ORDER = dp_byte_pix_order

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DP_MIX regDP_MIX;

#ifdef DEBUG
__inline void set_DP_MIX_dp_src_source(regDP_MIX *reg, unsigned int dp_src_source)
{
  reg->bitfields.DP_SRC_SOURCE = dp_src_source;
  if (reg->bitfields.DP_SRC_SOURCE != dp_src_source) HSLDPF(E_ERROR_MESSAGE,"DP_MIX::DP_SRC_SOURCE data too large\n");
}
__inline void set_DP_MIX_dp_rop3(regDP_MIX *reg, unsigned int dp_rop3)
{
  reg->bitfields.DP_ROP3 = dp_rop3;
  if (reg->bitfields.DP_ROP3 != dp_rop3) HSLDPF(E_ERROR_MESSAGE,"DP_MIX::DP_ROP3 data too large\n");
}
#else
#define set_DP_MIX_dp_src_source(reg, dp_src_source) (reg)->bitfields.DP_SRC_SOURCE = dp_src_source
#define set_DP_MIX_dp_rop3(reg, dp_rop3) (reg)->bitfields.DP_ROP3 = dp_rop3

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DP_WRITE_MSK regDP_WRITE_MSK;

#ifdef DEBUG
__inline void set_DP_WRITE_MSK_dp_write_msk(regDP_WRITE_MSK *reg, unsigned int dp_write_msk)
{
  reg->bitfields.DP_WRITE_MSK = dp_write_msk;
  if (reg->bitfields.DP_WRITE_MSK != dp_write_msk) HSLDPF(E_ERROR_MESSAGE,"DP_WRITE_MSK::DP_WRITE_MSK data too large\n");
}
#else
#define set_DP_WRITE_MSK_dp_write_msk(reg, dp_write_msk) (reg)->bitfields.DP_WRITE_MSK = dp_write_msk

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DP_XOP regDP_XOP;

#ifdef DEBUG
__inline void set_DP_XOP_xop_a(regDP_XOP *reg, unsigned int xop_a)
{
  reg->bitfields.XOP_A = xop_a;
  if (reg->bitfields.XOP_A != xop_a) HSLDPF(E_ERROR_MESSAGE,"DP_XOP::XOP_A data too large\n");
}
__inline void set_DP_XOP_xop_b(regDP_XOP *reg, unsigned int xop_b)
{
  reg->bitfields.XOP_B = xop_b;
  if (reg->bitfields.XOP_B != xop_b) HSLDPF(E_ERROR_MESSAGE,"DP_XOP::XOP_B data too large\n");
}
__inline void set_DP_XOP_xop_c(regDP_XOP *reg, unsigned int xop_c)
{
  reg->bitfields.XOP_C = xop_c;
  if (reg->bitfields.XOP_C != xop_c) HSLDPF(E_ERROR_MESSAGE,"DP_XOP::XOP_C data too large\n");
}
__inline void set_DP_XOP_xop_op(regDP_XOP *reg, unsigned int xop_op)
{
  reg->bitfields.XOP_OP = xop_op;
  if (reg->bitfields.XOP_OP != xop_op) HSLDPF(E_ERROR_MESSAGE,"DP_XOP::XOP_OP data too large\n");
}
#else
#define set_DP_XOP_xop_a(reg, xop_a) (reg)->bitfields.XOP_A = xop_a
#define set_DP_XOP_xop_b(reg, xop_b) (reg)->bitfields.XOP_B = xop_b
#define set_DP_XOP_xop_c(reg, xop_c) (reg)->bitfields.XOP_C = xop_c
#define set_DP_XOP_xop_op(reg, xop_op) (reg)->bitfields.XOP_OP = xop_op

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CLR_CMP_CLR_SRC regCLR_CMP_CLR_SRC;

#ifdef DEBUG
__inline void set_CLR_CMP_CLR_SRC_clr_cmp_clr_src(regCLR_CMP_CLR_SRC *reg, unsigned int clr_cmp_clr_src)
{
  reg->bitfields.CLR_CMP_CLR_SRC = clr_cmp_clr_src;
  if (reg->bitfields.CLR_CMP_CLR_SRC != clr_cmp_clr_src) HSLDPF(E_ERROR_MESSAGE,"CLR_CMP_CLR_SRC::CLR_CMP_CLR_SRC data too large\n");
}
#else
#define set_CLR_CMP_CLR_SRC_clr_cmp_clr_src(reg, clr_cmp_clr_src) (reg)->bitfields.CLR_CMP_CLR_SRC = clr_cmp_clr_src

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CLR_CMP_CLR_DST regCLR_CMP_CLR_DST;

#ifdef DEBUG
__inline void set_CLR_CMP_CLR_DST_clr_cmp_clr_dst(regCLR_CMP_CLR_DST *reg, unsigned int clr_cmp_clr_dst)
{
  reg->bitfields.CLR_CMP_CLR_DST = clr_cmp_clr_dst;
  if (reg->bitfields.CLR_CMP_CLR_DST != clr_cmp_clr_dst) HSLDPF(E_ERROR_MESSAGE,"CLR_CMP_CLR_DST::CLR_CMP_CLR_DST data too large\n");
}
#else
#define set_CLR_CMP_CLR_DST_clr_cmp_clr_dst(reg, clr_cmp_clr_dst) (reg)->bitfields.CLR_CMP_CLR_DST = clr_cmp_clr_dst

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CLR_CMP_CNTL regCLR_CMP_CNTL;

#ifdef DEBUG
__inline void set_CLR_CMP_CNTL_clr_cmp_fcn_src(regCLR_CMP_CNTL *reg, unsigned int clr_cmp_fcn_src)
{
  reg->bitfields.CLR_CMP_FCN_SRC = clr_cmp_fcn_src;
  if (reg->bitfields.CLR_CMP_FCN_SRC != clr_cmp_fcn_src) HSLDPF(E_ERROR_MESSAGE,"CLR_CMP_CNTL::CLR_CMP_FCN_SRC data too large\n");
}
__inline void set_CLR_CMP_CNTL_clr_cmp_fcn_dst(regCLR_CMP_CNTL *reg, unsigned int clr_cmp_fcn_dst)
{
  reg->bitfields.CLR_CMP_FCN_DST = clr_cmp_fcn_dst;
  if (reg->bitfields.CLR_CMP_FCN_DST != clr_cmp_fcn_dst) HSLDPF(E_ERROR_MESSAGE,"CLR_CMP_CNTL::CLR_CMP_FCN_DST data too large\n");
}
__inline void set_CLR_CMP_CNTL_clr_cmp_src(regCLR_CMP_CNTL *reg, unsigned int clr_cmp_src)
{
  reg->bitfields.CLR_CMP_SRC = clr_cmp_src;
  if (reg->bitfields.CLR_CMP_SRC != clr_cmp_src) HSLDPF(E_ERROR_MESSAGE,"CLR_CMP_CNTL::CLR_CMP_SRC data too large\n");
}
#else
#define set_CLR_CMP_CNTL_clr_cmp_fcn_src(reg, clr_cmp_fcn_src) (reg)->bitfields.CLR_CMP_FCN_SRC = clr_cmp_fcn_src
#define set_CLR_CMP_CNTL_clr_cmp_fcn_dst(reg, clr_cmp_fcn_dst) (reg)->bitfields.CLR_CMP_FCN_DST = clr_cmp_fcn_dst
#define set_CLR_CMP_CNTL_clr_cmp_src(reg, clr_cmp_src) (reg)->bitfields.CLR_CMP_SRC = clr_cmp_src

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CLR_CMP_MSK regCLR_CMP_MSK;

#ifdef DEBUG
__inline void set_CLR_CMP_MSK_clr_cmp_msk(regCLR_CMP_MSK *reg, unsigned int clr_cmp_msk)
{
  reg->bitfields.CLR_CMP_MSK = clr_cmp_msk;
  if (reg->bitfields.CLR_CMP_MSK != clr_cmp_msk) HSLDPF(E_ERROR_MESSAGE,"CLR_CMP_MSK::CLR_CMP_MSK data too large\n");
}
#else
#define set_CLR_CMP_MSK_clr_cmp_msk(reg, clr_cmp_msk) (reg)->bitfields.CLR_CMP_MSK = clr_cmp_msk

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DSTCACHE_MODE regDSTCACHE_MODE;

#ifdef DEBUG
__inline void set_DSTCACHE_MODE_dstcache_mode(regDSTCACHE_MODE *reg, unsigned int dstcache_mode)
{
  reg->bitfields.DSTCACHE_MODE = dstcache_mode;
  if (reg->bitfields.DSTCACHE_MODE != dstcache_mode) HSLDPF(E_ERROR_MESSAGE,"DSTCACHE_MODE::DSTCACHE_MODE data too large\n");
}
#else
#define set_DSTCACHE_MODE_dstcache_mode(reg, dstcache_mode) (reg)->bitfields.DSTCACHE_MODE = dstcache_mode

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DSTCACHE_CTLSTAT regDSTCACHE_CTLSTAT;

#ifdef DEBUG
__inline void set_DSTCACHE_CTLSTAT_dstcache_ctlstat(regDSTCACHE_CTLSTAT *reg, unsigned int dstcache_ctlstat)
{
  reg->bitfields.DSTCACHE_CTLSTAT = dstcache_ctlstat;
  if (reg->bitfields.DSTCACHE_CTLSTAT != dstcache_ctlstat) HSLDPF(E_ERROR_MESSAGE,"DSTCACHE_CTLSTAT::DSTCACHE_CTLSTAT data too large\n");
}
#else
#define set_DSTCACHE_CTLSTAT_dstcache_ctlstat(reg, dstcache_ctlstat) (reg)->bitfields.DSTCACHE_CTLSTAT = dstcache_ctlstat

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PD2_DATA regPD2_DATA;

#ifdef DEBUG
__inline void set_PD2_DATA_pd2_data(regPD2_DATA *reg, unsigned int pd2_data)
{
  reg->bitfields.PD2_DATA = pd2_data;
  if (reg->bitfields.PD2_DATA != pd2_data) HSLDPF(E_ERROR_MESSAGE,"PD2_DATA::PD2_DATA data too large\n");
}
#else
#define set_PD2_DATA_pd2_data(reg, pd2_data) (reg)->bitfields.PD2_DATA = pd2_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DEFAULT_PITCH_OFFSET regDEFAULT_PITCH_OFFSET;

#ifdef DEBUG
__inline void set_DEFAULT_PITCH_OFFSET_default_offset(regDEFAULT_PITCH_OFFSET *reg, unsigned int default_offset)
{
  reg->bitfields.DEFAULT_OFFSET = default_offset;
  if (reg->bitfields.DEFAULT_OFFSET != default_offset) HSLDPF(E_ERROR_MESSAGE,"DEFAULT_PITCH_OFFSET::DEFAULT_OFFSET data too large\n");
}
__inline void set_DEFAULT_PITCH_OFFSET_default_pitch(regDEFAULT_PITCH_OFFSET *reg, unsigned int default_pitch)
{
  reg->bitfields.DEFAULT_PITCH = default_pitch;
  if (reg->bitfields.DEFAULT_PITCH != default_pitch) HSLDPF(E_ERROR_MESSAGE,"DEFAULT_PITCH_OFFSET::DEFAULT_PITCH data too large\n");
}
__inline void set_DEFAULT_PITCH_OFFSET_default_tile(regDEFAULT_PITCH_OFFSET *reg, unsigned int default_tile)
{
  reg->bitfields.DEFAULT_TILE = default_tile;
  if (reg->bitfields.DEFAULT_TILE != default_tile) HSLDPF(E_ERROR_MESSAGE,"DEFAULT_PITCH_OFFSET::DEFAULT_TILE data too large\n");
}
#else
#define set_DEFAULT_PITCH_OFFSET_default_offset(reg, default_offset) (reg)->bitfields.DEFAULT_OFFSET = default_offset
#define set_DEFAULT_PITCH_OFFSET_default_pitch(reg, default_pitch) (reg)->bitfields.DEFAULT_PITCH = default_pitch
#define set_DEFAULT_PITCH_OFFSET_default_tile(reg, default_tile) (reg)->bitfields.DEFAULT_TILE = default_tile

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DEFAULT_SC_BOTTOM_RIGHT regDEFAULT_SC_BOTTOM_RIGHT;

#ifdef DEBUG
__inline void set_DEFAULT_SC_BOTTOM_RIGHT_default_sc_right(regDEFAULT_SC_BOTTOM_RIGHT *reg, unsigned int default_sc_right)
{
  reg->bitfields.DEFAULT_SC_RIGHT = default_sc_right;
  if (reg->bitfields.DEFAULT_SC_RIGHT != default_sc_right) HSLDPF(E_ERROR_MESSAGE,"DEFAULT_SC_BOTTOM_RIGHT::DEFAULT_SC_RIGHT data too large\n");
}
__inline void set_DEFAULT_SC_BOTTOM_RIGHT_default_sc_bottom(regDEFAULT_SC_BOTTOM_RIGHT *reg, unsigned int default_sc_bottom)
{
  reg->bitfields.DEFAULT_SC_BOTTOM = default_sc_bottom;
  if (reg->bitfields.DEFAULT_SC_BOTTOM != default_sc_bottom) HSLDPF(E_ERROR_MESSAGE,"DEFAULT_SC_BOTTOM_RIGHT::DEFAULT_SC_BOTTOM data too large\n");
}
#else
#define set_DEFAULT_SC_BOTTOM_RIGHT_default_sc_right(reg, default_sc_right) (reg)->bitfields.DEFAULT_SC_RIGHT = default_sc_right
#define set_DEFAULT_SC_BOTTOM_RIGHT_default_sc_bottom(reg, default_sc_bottom) (reg)->bitfields.DEFAULT_SC_BOTTOM = default_sc_bottom

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DEFAULT2_PITCH_OFFSET regDEFAULT2_PITCH_OFFSET;

#ifdef DEBUG
__inline void set_DEFAULT2_PITCH_OFFSET_default_offset(regDEFAULT2_PITCH_OFFSET *reg, unsigned int default_offset)
{
  reg->bitfields.DEFAULT_OFFSET = default_offset;
  if (reg->bitfields.DEFAULT_OFFSET != default_offset) HSLDPF(E_ERROR_MESSAGE,"DEFAULT2_PITCH_OFFSET::DEFAULT_OFFSET data too large\n");
}
__inline void set_DEFAULT2_PITCH_OFFSET_default_pitch(regDEFAULT2_PITCH_OFFSET *reg, unsigned int default_pitch)
{
  reg->bitfields.DEFAULT_PITCH = default_pitch;
  if (reg->bitfields.DEFAULT_PITCH != default_pitch) HSLDPF(E_ERROR_MESSAGE,"DEFAULT2_PITCH_OFFSET::DEFAULT_PITCH data too large\n");
}
__inline void set_DEFAULT2_PITCH_OFFSET_default_tile(regDEFAULT2_PITCH_OFFSET *reg, unsigned int default_tile)
{
  reg->bitfields.DEFAULT_TILE = default_tile;
  if (reg->bitfields.DEFAULT_TILE != default_tile) HSLDPF(E_ERROR_MESSAGE,"DEFAULT2_PITCH_OFFSET::DEFAULT_TILE data too large\n");
}
#else
#define set_DEFAULT2_PITCH_OFFSET_default_offset(reg, default_offset) (reg)->bitfields.DEFAULT_OFFSET = default_offset
#define set_DEFAULT2_PITCH_OFFSET_default_pitch(reg, default_pitch) (reg)->bitfields.DEFAULT_PITCH = default_pitch
#define set_DEFAULT2_PITCH_OFFSET_default_tile(reg, default_tile) (reg)->bitfields.DEFAULT_TILE = default_tile

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DEFAULT2_SC_BOTTOM_RIGHT regDEFAULT2_SC_BOTTOM_RIGHT;

#ifdef DEBUG
__inline void set_DEFAULT2_SC_BOTTOM_RIGHT_default_sc_right(regDEFAULT2_SC_BOTTOM_RIGHT *reg, unsigned int default_sc_right)
{
  reg->bitfields.DEFAULT_SC_RIGHT = default_sc_right;
  if (reg->bitfields.DEFAULT_SC_RIGHT != default_sc_right) HSLDPF(E_ERROR_MESSAGE,"DEFAULT2_SC_BOTTOM_RIGHT::DEFAULT_SC_RIGHT data too large\n");
}
__inline void set_DEFAULT2_SC_BOTTOM_RIGHT_default_sc_bottom(regDEFAULT2_SC_BOTTOM_RIGHT *reg, unsigned int default_sc_bottom)
{
  reg->bitfields.DEFAULT_SC_BOTTOM = default_sc_bottom;
  if (reg->bitfields.DEFAULT_SC_BOTTOM != default_sc_bottom) HSLDPF(E_ERROR_MESSAGE,"DEFAULT2_SC_BOTTOM_RIGHT::DEFAULT_SC_BOTTOM data too large\n");
}
#else
#define set_DEFAULT2_SC_BOTTOM_RIGHT_default_sc_right(reg, default_sc_right) (reg)->bitfields.DEFAULT_SC_RIGHT = default_sc_right
#define set_DEFAULT2_SC_BOTTOM_RIGHT_default_sc_bottom(reg, default_sc_bottom) (reg)->bitfields.DEFAULT_SC_BOTTOM = default_sc_bottom

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DP_GUI_MASTER_CNTL regDP_GUI_MASTER_CNTL;

#ifdef DEBUG
__inline void set_DP_GUI_MASTER_CNTL_gmc_src_pitch_offset_cntl(regDP_GUI_MASTER_CNTL *reg, unsigned int gmc_src_pitch_offset_cntl)
{
  reg->bitfields.GMC_SRC_PITCH_OFFSET_CNTL = gmc_src_pitch_offset_cntl;
  if (reg->bitfields.GMC_SRC_PITCH_OFFSET_CNTL != gmc_src_pitch_offset_cntl) HSLDPF(E_ERROR_MESSAGE,"DP_GUI_MASTER_CNTL::GMC_SRC_PITCH_OFFSET_CNTL data too large\n");
}
__inline void set_DP_GUI_MASTER_CNTL_gmc_dst_pitch_offset_cntl(regDP_GUI_MASTER_CNTL *reg, unsigned int gmc_dst_pitch_offset_cntl)
{
  reg->bitfields.GMC_DST_PITCH_OFFSET_CNTL = gmc_dst_pitch_offset_cntl;
  if (reg->bitfields.GMC_DST_PITCH_OFFSET_CNTL != gmc_dst_pitch_offset_cntl) HSLDPF(E_ERROR_MESSAGE,"DP_GUI_MASTER_CNTL::GMC_DST_PITCH_OFFSET_CNTL data too large\n");
}
__inline void set_DP_GUI_MASTER_CNTL_gmc_src_clipping(regDP_GUI_MASTER_CNTL *reg, unsigned int gmc_src_clipping)
{
  reg->bitfields.GMC_SRC_CLIPPING = gmc_src_clipping;
  if (reg->bitfields.GMC_SRC_CLIPPING != gmc_src_clipping) HSLDPF(E_ERROR_MESSAGE,"DP_GUI_MASTER_CNTL::GMC_SRC_CLIPPING data too large\n");
}
__inline void set_DP_GUI_MASTER_CNTL_gmc_dst_clipping(regDP_GUI_MASTER_CNTL *reg, unsigned int gmc_dst_clipping)
{
  reg->bitfields.GMC_DST_CLIPPING = gmc_dst_clipping;
  if (reg->bitfields.GMC_DST_CLIPPING != gmc_dst_clipping) HSLDPF(E_ERROR_MESSAGE,"DP_GUI_MASTER_CNTL::GMC_DST_CLIPPING data too large\n");
}
__inline void set_DP_GUI_MASTER_CNTL_gmc_brush_datatype(regDP_GUI_MASTER_CNTL *reg, unsigned int gmc_brush_datatype)
{
  reg->bitfields.GMC_BRUSH_DATATYPE = gmc_brush_datatype;
  if (reg->bitfields.GMC_BRUSH_DATATYPE != gmc_brush_datatype) HSLDPF(E_ERROR_MESSAGE,"DP_GUI_MASTER_CNTL::GMC_BRUSH_DATATYPE data too large\n");
}
__inline void set_DP_GUI_MASTER_CNTL_gmc_dst_datatype(regDP_GUI_MASTER_CNTL *reg, unsigned int gmc_dst_datatype)
{
  reg->bitfields.GMC_DST_DATATYPE = gmc_dst_datatype;
  if (reg->bitfields.GMC_DST_DATATYPE != gmc_dst_datatype) HSLDPF(E_ERROR_MESSAGE,"DP_GUI_MASTER_CNTL::GMC_DST_DATATYPE data too large\n");
}
__inline void set_DP_GUI_MASTER_CNTL_gmc_src_datatype(regDP_GUI_MASTER_CNTL *reg, unsigned int gmc_src_datatype)
{
  reg->bitfields.GMC_SRC_DATATYPE = gmc_src_datatype;
  if (reg->bitfields.GMC_SRC_DATATYPE != gmc_src_datatype) HSLDPF(E_ERROR_MESSAGE,"DP_GUI_MASTER_CNTL::GMC_SRC_DATATYPE data too large\n");
}
__inline void set_DP_GUI_MASTER_CNTL_gmc_byte_pix_order(regDP_GUI_MASTER_CNTL *reg, unsigned int gmc_byte_pix_order)
{
  reg->bitfields.GMC_BYTE_PIX_ORDER = gmc_byte_pix_order;
  if (reg->bitfields.GMC_BYTE_PIX_ORDER != gmc_byte_pix_order) HSLDPF(E_ERROR_MESSAGE,"DP_GUI_MASTER_CNTL::GMC_BYTE_PIX_ORDER data too large\n");
}
__inline void set_DP_GUI_MASTER_CNTL_gmc_default_sel(regDP_GUI_MASTER_CNTL *reg, unsigned int gmc_default_sel)
{
  reg->bitfields.GMC_DEFAULT_SEL = gmc_default_sel;
  if (reg->bitfields.GMC_DEFAULT_SEL != gmc_default_sel) HSLDPF(E_ERROR_MESSAGE,"DP_GUI_MASTER_CNTL::GMC_DEFAULT_SEL data too large\n");
}
__inline void set_DP_GUI_MASTER_CNTL_gmc_rop3(regDP_GUI_MASTER_CNTL *reg, unsigned int gmc_rop3)
{
  reg->bitfields.GMC_ROP3 = gmc_rop3;
  if (reg->bitfields.GMC_ROP3 != gmc_rop3) HSLDPF(E_ERROR_MESSAGE,"DP_GUI_MASTER_CNTL::GMC_ROP3 data too large\n");
}
__inline void set_DP_GUI_MASTER_CNTL_gmc_dp_src_source(regDP_GUI_MASTER_CNTL *reg, unsigned int gmc_dp_src_source)
{
  reg->bitfields.GMC_DP_SRC_SOURCE = gmc_dp_src_source;
  if (reg->bitfields.GMC_DP_SRC_SOURCE != gmc_dp_src_source) HSLDPF(E_ERROR_MESSAGE,"DP_GUI_MASTER_CNTL::GMC_DP_SRC_SOURCE data too large\n");
}
__inline void set_DP_GUI_MASTER_CNTL_gmc_src_datatype2(regDP_GUI_MASTER_CNTL *reg, unsigned int gmc_src_datatype2)
{
  reg->bitfields.GMC_SRC_DATATYPE2 = gmc_src_datatype2;
  if (reg->bitfields.GMC_SRC_DATATYPE2 != gmc_src_datatype2) HSLDPF(E_ERROR_MESSAGE,"DP_GUI_MASTER_CNTL::GMC_SRC_DATATYPE2 data too large\n");
}
__inline void set_DP_GUI_MASTER_CNTL_gmc_clr_cmp_fcn_dis(regDP_GUI_MASTER_CNTL *reg, unsigned int gmc_clr_cmp_fcn_dis)
{
  reg->bitfields.GMC_CLR_CMP_FCN_DIS = gmc_clr_cmp_fcn_dis;
  if (reg->bitfields.GMC_CLR_CMP_FCN_DIS != gmc_clr_cmp_fcn_dis) HSLDPF(E_ERROR_MESSAGE,"DP_GUI_MASTER_CNTL::GMC_CLR_CMP_FCN_DIS data too large\n");
}
__inline void set_DP_GUI_MASTER_CNTL_gmc_wr_msk_dis(regDP_GUI_MASTER_CNTL *reg, unsigned int gmc_wr_msk_dis)
{
  reg->bitfields.GMC_WR_MSK_DIS = gmc_wr_msk_dis;
  if (reg->bitfields.GMC_WR_MSK_DIS != gmc_wr_msk_dis) HSLDPF(E_ERROR_MESSAGE,"DP_GUI_MASTER_CNTL::GMC_WR_MSK_DIS data too large\n");
}
#else
#define set_DP_GUI_MASTER_CNTL_gmc_src_pitch_offset_cntl(reg, gmc_src_pitch_offset_cntl) (reg)->bitfields.GMC_SRC_PITCH_OFFSET_CNTL = gmc_src_pitch_offset_cntl
#define set_DP_GUI_MASTER_CNTL_gmc_dst_pitch_offset_cntl(reg, gmc_dst_pitch_offset_cntl) (reg)->bitfields.GMC_DST_PITCH_OFFSET_CNTL = gmc_dst_pitch_offset_cntl
#define set_DP_GUI_MASTER_CNTL_gmc_src_clipping(reg, gmc_src_clipping) (reg)->bitfields.GMC_SRC_CLIPPING = gmc_src_clipping
#define set_DP_GUI_MASTER_CNTL_gmc_dst_clipping(reg, gmc_dst_clipping) (reg)->bitfields.GMC_DST_CLIPPING = gmc_dst_clipping
#define set_DP_GUI_MASTER_CNTL_gmc_brush_datatype(reg, gmc_brush_datatype) (reg)->bitfields.GMC_BRUSH_DATATYPE = gmc_brush_datatype
#define set_DP_GUI_MASTER_CNTL_gmc_dst_datatype(reg, gmc_dst_datatype) (reg)->bitfields.GMC_DST_DATATYPE = gmc_dst_datatype
#define set_DP_GUI_MASTER_CNTL_gmc_src_datatype(reg, gmc_src_datatype) (reg)->bitfields.GMC_SRC_DATATYPE = gmc_src_datatype
#define set_DP_GUI_MASTER_CNTL_gmc_byte_pix_order(reg, gmc_byte_pix_order) (reg)->bitfields.GMC_BYTE_PIX_ORDER = gmc_byte_pix_order
#define set_DP_GUI_MASTER_CNTL_gmc_default_sel(reg, gmc_default_sel) (reg)->bitfields.GMC_DEFAULT_SEL = gmc_default_sel
#define set_DP_GUI_MASTER_CNTL_gmc_rop3(reg, gmc_rop3) (reg)->bitfields.GMC_ROP3 = gmc_rop3
#define set_DP_GUI_MASTER_CNTL_gmc_dp_src_source(reg, gmc_dp_src_source) (reg)->bitfields.GMC_DP_SRC_SOURCE = gmc_dp_src_source
#define set_DP_GUI_MASTER_CNTL_gmc_src_datatype2(reg, gmc_src_datatype2) (reg)->bitfields.GMC_SRC_DATATYPE2 = gmc_src_datatype2
#define set_DP_GUI_MASTER_CNTL_gmc_clr_cmp_fcn_dis(reg, gmc_clr_cmp_fcn_dis) (reg)->bitfields.GMC_CLR_CMP_FCN_DIS = gmc_clr_cmp_fcn_dis
#define set_DP_GUI_MASTER_CNTL_gmc_wr_msk_dis(reg, gmc_wr_msk_dis) (reg)->bitfields.GMC_WR_MSK_DIS = gmc_wr_msk_dis

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SC_TOP_LEFT regSC_TOP_LEFT;

#ifdef DEBUG
__inline void set_SC_TOP_LEFT_sc_left(regSC_TOP_LEFT *reg, unsigned int sc_left)
{
  reg->bitfields.SC_LEFT = sc_left;
  if (reg->bitfields.SC_LEFT != sc_left) HSLDPF(E_ERROR_MESSAGE,"SC_TOP_LEFT::SC_LEFT data too large\n");
}
__inline void set_SC_TOP_LEFT_sc_top(regSC_TOP_LEFT *reg, unsigned int sc_top)
{
  reg->bitfields.SC_TOP = sc_top;
  if (reg->bitfields.SC_TOP != sc_top) HSLDPF(E_ERROR_MESSAGE,"SC_TOP_LEFT::SC_TOP data too large\n");
}
#else
#define set_SC_TOP_LEFT_sc_left(reg, sc_left) (reg)->bitfields.SC_LEFT = sc_left
#define set_SC_TOP_LEFT_sc_top(reg, sc_top) (reg)->bitfields.SC_TOP = sc_top

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SC_BOTTOM_RIGHT regSC_BOTTOM_RIGHT;

#ifdef DEBUG
__inline void set_SC_BOTTOM_RIGHT_sc_right(regSC_BOTTOM_RIGHT *reg, unsigned int sc_right)
{
  reg->bitfields.SC_RIGHT = sc_right;
  if (reg->bitfields.SC_RIGHT != sc_right) HSLDPF(E_ERROR_MESSAGE,"SC_BOTTOM_RIGHT::SC_RIGHT data too large\n");
}
__inline void set_SC_BOTTOM_RIGHT_sc_bottom(regSC_BOTTOM_RIGHT *reg, unsigned int sc_bottom)
{
  reg->bitfields.SC_BOTTOM = sc_bottom;
  if (reg->bitfields.SC_BOTTOM != sc_bottom) HSLDPF(E_ERROR_MESSAGE,"SC_BOTTOM_RIGHT::SC_BOTTOM data too large\n");
}
#else
#define set_SC_BOTTOM_RIGHT_sc_right(reg, sc_right) (reg)->bitfields.SC_RIGHT = sc_right
#define set_SC_BOTTOM_RIGHT_sc_bottom(reg, sc_bottom) (reg)->bitfields.SC_BOTTOM = sc_bottom

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SRC_SC_BOTTOM_RIGHT regSRC_SC_BOTTOM_RIGHT;

#ifdef DEBUG
__inline void set_SRC_SC_BOTTOM_RIGHT_sc_right(regSRC_SC_BOTTOM_RIGHT *reg, unsigned int sc_right)
{
  reg->bitfields.SC_RIGHT = sc_right;
  if (reg->bitfields.SC_RIGHT != sc_right) HSLDPF(E_ERROR_MESSAGE,"SRC_SC_BOTTOM_RIGHT::SC_RIGHT data too large\n");
}
__inline void set_SRC_SC_BOTTOM_RIGHT_sc_bottom(regSRC_SC_BOTTOM_RIGHT *reg, unsigned int sc_bottom)
{
  reg->bitfields.SC_BOTTOM = sc_bottom;
  if (reg->bitfields.SC_BOTTOM != sc_bottom) HSLDPF(E_ERROR_MESSAGE,"SRC_SC_BOTTOM_RIGHT::SC_BOTTOM data too large\n");
}
#else
#define set_SRC_SC_BOTTOM_RIGHT_sc_right(reg, sc_right) (reg)->bitfields.SC_RIGHT = sc_right
#define set_SRC_SC_BOTTOM_RIGHT_sc_bottom(reg, sc_bottom) (reg)->bitfields.SC_BOTTOM = sc_bottom

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DEBUG0 regDEBUG0;

#ifdef DEBUG
#else

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DEBUG1 regDEBUG1;

#ifdef DEBUG
#else

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DEBUG2 regDEBUG2;

#ifdef DEBUG
#else

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DEBUG3 regDEBUG3;

#ifdef DEBUG
#else

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DEBUG4 regDEBUG4;

#ifdef DEBUG
#else

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DEBUG5 regDEBUG5;

#ifdef DEBUG
#else

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DEBUG6 regDEBUG6;

#ifdef DEBUG
#else

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DEBUG7 regDEBUG7;

#ifdef DEBUG
#else

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DEBUG8 regDEBUG8;

#ifdef DEBUG
#else

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DEBUG9 regDEBUG9;

#ifdef DEBUG
#else

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DEBUG10 regDEBUG10;

#ifdef DEBUG
#else

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DEBUG11 regDEBUG11;

#ifdef DEBUG
#else

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DEBUG12 regDEBUG12;

#ifdef DEBUG
#else

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DEBUG13 regDEBUG13;

#ifdef DEBUG
#else

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DEBUG14 regDEBUG14;

#ifdef DEBUG
#else

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DEBUG15 regDEBUG15;

#ifdef DEBUG
#else

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BIOS_0_SCRATCH regBIOS_0_SCRATCH;

#ifdef DEBUG
__inline void set_BIOS_0_SCRATCH_bios_scratch(regBIOS_0_SCRATCH *reg, unsigned int bios_scratch)
{
  reg->bitfields.BIOS_SCRATCH = bios_scratch;
  if (reg->bitfields.BIOS_SCRATCH != bios_scratch) HSLDPF(E_ERROR_MESSAGE,"BIOS_0_SCRATCH::BIOS_SCRATCH data too large\n");
}
#else
#define set_BIOS_0_SCRATCH_bios_scratch(reg, bios_scratch) (reg)->bitfields.BIOS_SCRATCH = bios_scratch

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BIOS_1_SCRATCH regBIOS_1_SCRATCH;

#ifdef DEBUG
__inline void set_BIOS_1_SCRATCH_bios_scratch(regBIOS_1_SCRATCH *reg, unsigned int bios_scratch)
{
  reg->bitfields.BIOS_SCRATCH = bios_scratch;
  if (reg->bitfields.BIOS_SCRATCH != bios_scratch) HSLDPF(E_ERROR_MESSAGE,"BIOS_1_SCRATCH::BIOS_SCRATCH data too large\n");
}
#else
#define set_BIOS_1_SCRATCH_bios_scratch(reg, bios_scratch) (reg)->bitfields.BIOS_SCRATCH = bios_scratch

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BIOS_2_SCRATCH regBIOS_2_SCRATCH;

#ifdef DEBUG
__inline void set_BIOS_2_SCRATCH_bios_scratch(regBIOS_2_SCRATCH *reg, unsigned int bios_scratch)
{
  reg->bitfields.BIOS_SCRATCH = bios_scratch;
  if (reg->bitfields.BIOS_SCRATCH != bios_scratch) HSLDPF(E_ERROR_MESSAGE,"BIOS_2_SCRATCH::BIOS_SCRATCH data too large\n");
}
#else
#define set_BIOS_2_SCRATCH_bios_scratch(reg, bios_scratch) (reg)->bitfields.BIOS_SCRATCH = bios_scratch

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BIOS_3_SCRATCH regBIOS_3_SCRATCH;

#ifdef DEBUG
__inline void set_BIOS_3_SCRATCH_bios_scratch(regBIOS_3_SCRATCH *reg, unsigned int bios_scratch)
{
  reg->bitfields.BIOS_SCRATCH = bios_scratch;
  if (reg->bitfields.BIOS_SCRATCH != bios_scratch) HSLDPF(E_ERROR_MESSAGE,"BIOS_3_SCRATCH::BIOS_SCRATCH data too large\n");
}
#else
#define set_BIOS_3_SCRATCH_bios_scratch(reg, bios_scratch) (reg)->bitfields.BIOS_SCRATCH = bios_scratch

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BIOS_4_SCRATCH regBIOS_4_SCRATCH;

#ifdef DEBUG
__inline void set_BIOS_4_SCRATCH_bios_scratch(regBIOS_4_SCRATCH *reg, unsigned int bios_scratch)
{
  reg->bitfields.BIOS_SCRATCH = bios_scratch;
  if (reg->bitfields.BIOS_SCRATCH != bios_scratch) HSLDPF(E_ERROR_MESSAGE,"BIOS_4_SCRATCH::BIOS_SCRATCH data too large\n");
}
#else
#define set_BIOS_4_SCRATCH_bios_scratch(reg, bios_scratch) (reg)->bitfields.BIOS_SCRATCH = bios_scratch

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BIOS_5_SCRATCH regBIOS_5_SCRATCH;

#ifdef DEBUG
__inline void set_BIOS_5_SCRATCH_bios_scratch(regBIOS_5_SCRATCH *reg, unsigned int bios_scratch)
{
  reg->bitfields.BIOS_SCRATCH = bios_scratch;
  if (reg->bitfields.BIOS_SCRATCH != bios_scratch) HSLDPF(E_ERROR_MESSAGE,"BIOS_5_SCRATCH::BIOS_SCRATCH data too large\n");
}
#else
#define set_BIOS_5_SCRATCH_bios_scratch(reg, bios_scratch) (reg)->bitfields.BIOS_SCRATCH = bios_scratch

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BIOS_6_SCRATCH regBIOS_6_SCRATCH;

#ifdef DEBUG
__inline void set_BIOS_6_SCRATCH_bios_scratch(regBIOS_6_SCRATCH *reg, unsigned int bios_scratch)
{
  reg->bitfields.BIOS_SCRATCH = bios_scratch;
  if (reg->bitfields.BIOS_SCRATCH != bios_scratch) HSLDPF(E_ERROR_MESSAGE,"BIOS_6_SCRATCH::BIOS_SCRATCH data too large\n");
}
#else
#define set_BIOS_6_SCRATCH_bios_scratch(reg, bios_scratch) (reg)->bitfields.BIOS_SCRATCH = bios_scratch

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BIOS_7_SCRATCH regBIOS_7_SCRATCH;

#ifdef DEBUG
__inline void set_BIOS_7_SCRATCH_bios_scratch(regBIOS_7_SCRATCH *reg, unsigned int bios_scratch)
{
  reg->bitfields.BIOS_SCRATCH = bios_scratch;
  if (reg->bitfields.BIOS_SCRATCH != bios_scratch) HSLDPF(E_ERROR_MESSAGE,"BIOS_7_SCRATCH::BIOS_SCRATCH data too large\n");
}
#else
#define set_BIOS_7_SCRATCH_bios_scratch(reg, bios_scratch) (reg)->bitfields.BIOS_SCRATCH = bios_scratch

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union I2C_CNTL_0 regI2C_CNTL_0;

#ifdef DEBUG
__inline void set_I2C_CNTL_0_i2c_done(regI2C_CNTL_0 *reg, unsigned int i2c_done)
{
  reg->bitfields.I2C_DONE = i2c_done;
  if (reg->bitfields.I2C_DONE != i2c_done) HSLDPF(E_ERROR_MESSAGE,"I2C_CNTL_0::I2C_DONE data too large\n");
}
__inline void set_I2C_CNTL_0_i2c_nack(regI2C_CNTL_0 *reg, unsigned int i2c_nack)
{
  reg->bitfields.I2C_NACK = i2c_nack;
  if (reg->bitfields.I2C_NACK != i2c_nack) HSLDPF(E_ERROR_MESSAGE,"I2C_CNTL_0::I2C_NACK data too large\n");
}
__inline void set_I2C_CNTL_0_i2c_halt(regI2C_CNTL_0 *reg, unsigned int i2c_halt)
{
  reg->bitfields.I2C_HALT = i2c_halt;
  if (reg->bitfields.I2C_HALT != i2c_halt) HSLDPF(E_ERROR_MESSAGE,"I2C_CNTL_0::I2C_HALT data too large\n");
}
__inline void set_I2C_CNTL_0_i2c_soft_rst(regI2C_CNTL_0 *reg, unsigned int i2c_soft_rst)
{
  reg->bitfields.I2C_SOFT_RST = i2c_soft_rst;
  if (reg->bitfields.I2C_SOFT_RST != i2c_soft_rst) HSLDPF(E_ERROR_MESSAGE,"I2C_CNTL_0::I2C_SOFT_RST data too large\n");
}
__inline void set_I2C_CNTL_0_i2c_drive_en(regI2C_CNTL_0 *reg, unsigned int i2c_drive_en)
{
  reg->bitfields.I2C_DRIVE_EN = i2c_drive_en;
  if (reg->bitfields.I2C_DRIVE_EN != i2c_drive_en) HSLDPF(E_ERROR_MESSAGE,"I2C_CNTL_0::I2C_DRIVE_EN data too large\n");
}
__inline void set_I2C_CNTL_0_i2c_drive_sel(regI2C_CNTL_0 *reg, unsigned int i2c_drive_sel)
{
  reg->bitfields.I2C_DRIVE_SEL = i2c_drive_sel;
  if (reg->bitfields.I2C_DRIVE_SEL != i2c_drive_sel) HSLDPF(E_ERROR_MESSAGE,"I2C_CNTL_0::I2C_DRIVE_SEL data too large\n");
}
__inline void set_I2C_CNTL_0_i2c_start(regI2C_CNTL_0 *reg, unsigned int i2c_start)
{
  reg->bitfields.I2C_START = i2c_start;
  if (reg->bitfields.I2C_START != i2c_start) HSLDPF(E_ERROR_MESSAGE,"I2C_CNTL_0::I2C_START data too large\n");
}
__inline void set_I2C_CNTL_0_i2c_stop(regI2C_CNTL_0 *reg, unsigned int i2c_stop)
{
  reg->bitfields.I2C_STOP = i2c_stop;
  if (reg->bitfields.I2C_STOP != i2c_stop) HSLDPF(E_ERROR_MESSAGE,"I2C_CNTL_0::I2C_STOP data too large\n");
}
__inline void set_I2C_CNTL_0_i2c_receive(regI2C_CNTL_0 *reg, unsigned int i2c_receive)
{
  reg->bitfields.I2C_RECEIVE = i2c_receive;
  if (reg->bitfields.I2C_RECEIVE != i2c_receive) HSLDPF(E_ERROR_MESSAGE,"I2C_CNTL_0::I2C_RECEIVE data too large\n");
}
__inline void set_I2C_CNTL_0_i2c_abort(regI2C_CNTL_0 *reg, unsigned int i2c_abort)
{
  reg->bitfields.I2C_ABORT = i2c_abort;
  if (reg->bitfields.I2C_ABORT != i2c_abort) HSLDPF(E_ERROR_MESSAGE,"I2C_CNTL_0::I2C_ABORT data too large\n");
}
__inline void set_I2C_CNTL_0_i2c_go(regI2C_CNTL_0 *reg, unsigned int i2c_go)
{
  reg->bitfields.I2C_GO = i2c_go;
  if (reg->bitfields.I2C_GO != i2c_go) HSLDPF(E_ERROR_MESSAGE,"I2C_CNTL_0::I2C_GO data too large\n");
}
__inline void set_I2C_CNTL_0_i2c_prescale(regI2C_CNTL_0 *reg, unsigned int i2c_prescale)
{
  reg->bitfields.I2C_PRESCALE = i2c_prescale;
  if (reg->bitfields.I2C_PRESCALE != i2c_prescale) HSLDPF(E_ERROR_MESSAGE,"I2C_CNTL_0::I2C_PRESCALE data too large\n");
}
#else
#define set_I2C_CNTL_0_i2c_done(reg, i2c_done) (reg)->bitfields.I2C_DONE = i2c_done
#define set_I2C_CNTL_0_i2c_nack(reg, i2c_nack) (reg)->bitfields.I2C_NACK = i2c_nack
#define set_I2C_CNTL_0_i2c_halt(reg, i2c_halt) (reg)->bitfields.I2C_HALT = i2c_halt
#define set_I2C_CNTL_0_i2c_soft_rst(reg, i2c_soft_rst) (reg)->bitfields.I2C_SOFT_RST = i2c_soft_rst
#define set_I2C_CNTL_0_i2c_drive_en(reg, i2c_drive_en) (reg)->bitfields.I2C_DRIVE_EN = i2c_drive_en
#define set_I2C_CNTL_0_i2c_drive_sel(reg, i2c_drive_sel) (reg)->bitfields.I2C_DRIVE_SEL = i2c_drive_sel
#define set_I2C_CNTL_0_i2c_start(reg, i2c_start) (reg)->bitfields.I2C_START = i2c_start
#define set_I2C_CNTL_0_i2c_stop(reg, i2c_stop) (reg)->bitfields.I2C_STOP = i2c_stop
#define set_I2C_CNTL_0_i2c_receive(reg, i2c_receive) (reg)->bitfields.I2C_RECEIVE = i2c_receive
#define set_I2C_CNTL_0_i2c_abort(reg, i2c_abort) (reg)->bitfields.I2C_ABORT = i2c_abort
#define set_I2C_CNTL_0_i2c_go(reg, i2c_go) (reg)->bitfields.I2C_GO = i2c_go
#define set_I2C_CNTL_0_i2c_prescale(reg, i2c_prescale) (reg)->bitfields.I2C_PRESCALE = i2c_prescale

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union I2C_CNTL_1 regI2C_CNTL_1;

#ifdef DEBUG
__inline void set_I2C_CNTL_1_i2c_data_count(regI2C_CNTL_1 *reg, unsigned int i2c_data_count)
{
  reg->bitfields.I2C_DATA_COUNT = i2c_data_count;
  if (reg->bitfields.I2C_DATA_COUNT != i2c_data_count) HSLDPF(E_ERROR_MESSAGE,"I2C_CNTL_1::I2C_DATA_COUNT data too large\n");
}
__inline void set_I2C_CNTL_1_i2c_addr_count(regI2C_CNTL_1 *reg, unsigned int i2c_addr_count)
{
  reg->bitfields.I2C_ADDR_COUNT = i2c_addr_count;
  if (reg->bitfields.I2C_ADDR_COUNT != i2c_addr_count) HSLDPF(E_ERROR_MESSAGE,"I2C_CNTL_1::I2C_ADDR_COUNT data too large\n");
}
__inline void set_I2C_CNTL_1_i2c_intra_byte_delay(regI2C_CNTL_1 *reg, unsigned int i2c_intra_byte_delay)
{
  reg->bitfields.I2C_INTRA_BYTE_DELAY = i2c_intra_byte_delay;
  if (reg->bitfields.I2C_INTRA_BYTE_DELAY != i2c_intra_byte_delay) HSLDPF(E_ERROR_MESSAGE,"I2C_CNTL_1::I2C_INTRA_BYTE_DELAY data too large\n");
}
__inline void set_I2C_CNTL_1_i2c_sel(regI2C_CNTL_1 *reg, unsigned int i2c_sel)
{
  reg->bitfields.I2C_SEL = i2c_sel;
  if (reg->bitfields.I2C_SEL != i2c_sel) HSLDPF(E_ERROR_MESSAGE,"I2C_CNTL_1::I2C_SEL data too large\n");
}
__inline void set_I2C_CNTL_1_i2c_en(regI2C_CNTL_1 *reg, unsigned int i2c_en)
{
  reg->bitfields.I2C_EN = i2c_en;
  if (reg->bitfields.I2C_EN != i2c_en) HSLDPF(E_ERROR_MESSAGE,"I2C_CNTL_1::I2C_EN data too large\n");
}
__inline void set_I2C_CNTL_1_i2c_time_limit(regI2C_CNTL_1 *reg, unsigned int i2c_time_limit)
{
  reg->bitfields.I2C_TIME_LIMIT = i2c_time_limit;
  if (reg->bitfields.I2C_TIME_LIMIT != i2c_time_limit) HSLDPF(E_ERROR_MESSAGE,"I2C_CNTL_1::I2C_TIME_LIMIT data too large\n");
}
#else
#define set_I2C_CNTL_1_i2c_data_count(reg, i2c_data_count) (reg)->bitfields.I2C_DATA_COUNT = i2c_data_count
#define set_I2C_CNTL_1_i2c_addr_count(reg, i2c_addr_count) (reg)->bitfields.I2C_ADDR_COUNT = i2c_addr_count
#define set_I2C_CNTL_1_i2c_intra_byte_delay(reg, i2c_intra_byte_delay) (reg)->bitfields.I2C_INTRA_BYTE_DELAY = i2c_intra_byte_delay
#define set_I2C_CNTL_1_i2c_sel(reg, i2c_sel) (reg)->bitfields.I2C_SEL = i2c_sel
#define set_I2C_CNTL_1_i2c_en(reg, i2c_en) (reg)->bitfields.I2C_EN = i2c_en
#define set_I2C_CNTL_1_i2c_time_limit(reg, i2c_time_limit) (reg)->bitfields.I2C_TIME_LIMIT = i2c_time_limit

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union I2C_DATA regI2C_DATA;

#ifdef DEBUG
__inline void set_I2C_DATA_i2c_data(regI2C_DATA *reg, unsigned int i2c_data)
{
  reg->bitfields.I2C_DATA = i2c_data;
  if (reg->bitfields.I2C_DATA != i2c_data) HSLDPF(E_ERROR_MESSAGE,"I2C_DATA::I2C_DATA data too large\n");
}
#else
#define set_I2C_DATA_i2c_data(reg, i2c_data) (reg)->bitfields.I2C_DATA = i2c_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250CONFIG_XSTRAP regrv250CONFIG_XSTRAP;

#ifdef DEBUG
__inline void set_rv250CONFIG_XSTRAP_vga_disable(regrv250CONFIG_XSTRAP *reg, unsigned int vga_disable)
{
  reg->bitfields.VGA_DISABLE = vga_disable;
  if (reg->bitfields.VGA_DISABLE != vga_disable) HSLDPF(E_ERROR_MESSAGE,"rv250CONFIG_XSTRAP::VGA_DISABLE data too large\n");
}
__inline void set_rv250CONFIG_XSTRAP_blank_rom(regrv250CONFIG_XSTRAP *reg, unsigned int blank_rom)
{
  reg->bitfields.BLANK_ROM = blank_rom;
  if (reg->bitfields.BLANK_ROM != blank_rom) HSLDPF(E_ERROR_MESSAGE,"rv250CONFIG_XSTRAP::BLANK_ROM data too large\n");
}
__inline void set_rv250CONFIG_XSTRAP_enintb(regrv250CONFIG_XSTRAP *reg, unsigned int enintb)
{
  reg->bitfields.ENINTB = enintb;
  if (reg->bitfields.ENINTB != enintb) HSLDPF(E_ERROR_MESSAGE,"rv250CONFIG_XSTRAP::ENINTB data too large\n");
}
__inline void set_rv250CONFIG_XSTRAP_multi_func(regrv250CONFIG_XSTRAP *reg, unsigned int multi_func)
{
  reg->bitfields.MULTI_FUNC = multi_func;
  if (reg->bitfields.MULTI_FUNC != multi_func) HSLDPF(E_ERROR_MESSAGE,"rv250CONFIG_XSTRAP::MULTI_FUNC data too large\n");
}
__inline void set_rv250CONFIG_XSTRAP_agpskew(regrv250CONFIG_XSTRAP *reg, unsigned int agpskew)
{
  reg->bitfields.AGPSKEW = agpskew;
  if (reg->bitfields.AGPSKEW != agpskew) HSLDPF(E_ERROR_MESSAGE,"rv250CONFIG_XSTRAP::AGPSKEW data too large\n");
}
__inline void set_rv250CONFIG_XSTRAP_x1clk_skew(regrv250CONFIG_XSTRAP *reg, unsigned int x1clk_skew)
{
  reg->bitfields.X1CLK_SKEW = x1clk_skew;
  if (reg->bitfields.X1CLK_SKEW != x1clk_skew) HSLDPF(E_ERROR_MESSAGE,"rv250CONFIG_XSTRAP::X1CLK_SKEW data too large\n");
}
__inline void set_rv250CONFIG_XSTRAP_vip_device(regrv250CONFIG_XSTRAP *reg, unsigned int vip_device)
{
  reg->bitfields.VIP_DEVICE = vip_device;
  if (reg->bitfields.VIP_DEVICE != vip_device) HSLDPF(E_ERROR_MESSAGE,"rv250CONFIG_XSTRAP::VIP_DEVICE data too large\n");
}
__inline void set_rv250CONFIG_XSTRAP_id_disable(regrv250CONFIG_XSTRAP *reg, unsigned int id_disable)
{
  reg->bitfields.ID_DISABLE = id_disable;
  if (reg->bitfields.ID_DISABLE != id_disable) HSLDPF(E_ERROR_MESSAGE,"rv250CONFIG_XSTRAP::ID_DISABLE data too large\n");
}
__inline void set_rv250CONFIG_XSTRAP_ap_size(regrv250CONFIG_XSTRAP *reg, unsigned int ap_size)
{
  reg->bitfields.AP_SIZE = ap_size;
  if (reg->bitfields.AP_SIZE != ap_size) HSLDPF(E_ERROR_MESSAGE,"rv250CONFIG_XSTRAP::AP_SIZE data too large\n");
}
__inline void set_rv250CONFIG_XSTRAP_romidcfg(regrv250CONFIG_XSTRAP *reg, unsigned int romidcfg)
{
  reg->bitfields.ROMIDCFG = romidcfg;
  if (reg->bitfields.ROMIDCFG != romidcfg) HSLDPF(E_ERROR_MESSAGE,"rv250CONFIG_XSTRAP::ROMIDCFG data too large\n");
}
__inline void set_rv250CONFIG_XSTRAP_buscfg(regrv250CONFIG_XSTRAP *reg, unsigned int buscfg)
{
  reg->bitfields.BUSCFG = buscfg;
  if (reg->bitfields.BUSCFG != buscfg) HSLDPF(E_ERROR_MESSAGE,"rv250CONFIG_XSTRAP::BUSCFG data too large\n");
}
#else
#define set_rv250CONFIG_XSTRAP_vga_disable(reg, vga_disable) (reg)->bitfields.VGA_DISABLE = vga_disable
#define set_rv250CONFIG_XSTRAP_blank_rom(reg, blank_rom) (reg)->bitfields.BLANK_ROM = blank_rom
#define set_rv250CONFIG_XSTRAP_enintb(reg, enintb) (reg)->bitfields.ENINTB = enintb
#define set_rv250CONFIG_XSTRAP_multi_func(reg, multi_func) (reg)->bitfields.MULTI_FUNC = multi_func
#define set_rv250CONFIG_XSTRAP_agpskew(reg, agpskew) (reg)->bitfields.AGPSKEW = agpskew
#define set_rv250CONFIG_XSTRAP_x1clk_skew(reg, x1clk_skew) (reg)->bitfields.X1CLK_SKEW = x1clk_skew
#define set_rv250CONFIG_XSTRAP_vip_device(reg, vip_device) (reg)->bitfields.VIP_DEVICE = vip_device
#define set_rv250CONFIG_XSTRAP_id_disable(reg, id_disable) (reg)->bitfields.ID_DISABLE = id_disable
#define set_rv250CONFIG_XSTRAP_ap_size(reg, ap_size) (reg)->bitfields.AP_SIZE = ap_size
#define set_rv250CONFIG_XSTRAP_romidcfg(reg, romidcfg) (reg)->bitfields.ROMIDCFG = romidcfg
#define set_rv250CONFIG_XSTRAP_buscfg(reg, buscfg) (reg)->bitfields.BUSCFG = buscfg

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TEST_DEBUG_CNTL regTEST_DEBUG_CNTL;

#ifdef DEBUG
__inline void set_TEST_DEBUG_CNTL_test_debug_out_en(regTEST_DEBUG_CNTL *reg, unsigned int test_debug_out_en)
{
  reg->bitfields.TEST_DEBUG_OUT_EN = test_debug_out_en;
  if (reg->bitfields.TEST_DEBUG_OUT_EN != test_debug_out_en) HSLDPF(E_ERROR_MESSAGE,"TEST_DEBUG_CNTL::TEST_DEBUG_OUT_EN data too large\n");
}
__inline void set_TEST_DEBUG_CNTL_test_debug_in_en(regTEST_DEBUG_CNTL *reg, unsigned int test_debug_in_en)
{
  reg->bitfields.TEST_DEBUG_IN_EN = test_debug_in_en;
  if (reg->bitfields.TEST_DEBUG_IN_EN != test_debug_in_en) HSLDPF(E_ERROR_MESSAGE,"TEST_DEBUG_CNTL::TEST_DEBUG_IN_EN data too large\n");
}
__inline void set_TEST_DEBUG_CNTL_test_iddq_en(regTEST_DEBUG_CNTL *reg, unsigned int test_iddq_en)
{
  reg->bitfields.TEST_IDDQ_EN = test_iddq_en;
  if (reg->bitfields.TEST_IDDQ_EN != test_iddq_en) HSLDPF(E_ERROR_MESSAGE,"TEST_DEBUG_CNTL::TEST_IDDQ_EN data too large\n");
}
__inline void set_TEST_DEBUG_CNTL_test_block_sel(regTEST_DEBUG_CNTL *reg, unsigned int test_block_sel)
{
  reg->bitfields.TEST_BLOCK_SEL = test_block_sel;
  if (reg->bitfields.TEST_BLOCK_SEL != test_block_sel) HSLDPF(E_ERROR_MESSAGE,"TEST_DEBUG_CNTL::TEST_BLOCK_SEL data too large\n");
}
__inline void set_TEST_DEBUG_CNTL_test_enable(regTEST_DEBUG_CNTL *reg, unsigned int test_enable)
{
  reg->bitfields.TEST_ENABLE = test_enable;
  if (reg->bitfields.TEST_ENABLE != test_enable) HSLDPF(E_ERROR_MESSAGE,"TEST_DEBUG_CNTL::TEST_ENABLE data too large\n");
}
__inline void set_TEST_DEBUG_CNTL_test_delay_in(regTEST_DEBUG_CNTL *reg, unsigned int test_delay_in)
{
  reg->bitfields.TEST_DELAY_IN = test_delay_in;
  if (reg->bitfields.TEST_DELAY_IN != test_delay_in) HSLDPF(E_ERROR_MESSAGE,"TEST_DEBUG_CNTL::TEST_DELAY_IN data too large\n");
}
#else
#define set_TEST_DEBUG_CNTL_test_debug_out_en(reg, test_debug_out_en) (reg)->bitfields.TEST_DEBUG_OUT_EN = test_debug_out_en
#define set_TEST_DEBUG_CNTL_test_debug_in_en(reg, test_debug_in_en) (reg)->bitfields.TEST_DEBUG_IN_EN = test_debug_in_en
#define set_TEST_DEBUG_CNTL_test_iddq_en(reg, test_iddq_en) (reg)->bitfields.TEST_IDDQ_EN = test_iddq_en
#define set_TEST_DEBUG_CNTL_test_block_sel(reg, test_block_sel) (reg)->bitfields.TEST_BLOCK_SEL = test_block_sel
#define set_TEST_DEBUG_CNTL_test_enable(reg, test_enable) (reg)->bitfields.TEST_ENABLE = test_enable
#define set_TEST_DEBUG_CNTL_test_delay_in(reg, test_delay_in) (reg)->bitfields.TEST_DELAY_IN = test_delay_in

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TEST_DEBUG_MUX regTEST_DEBUG_MUX;

#ifdef DEBUG
__inline void set_TEST_DEBUG_MUX_test_debug_sel(regTEST_DEBUG_MUX *reg, unsigned int test_debug_sel)
{
  reg->bitfields.TEST_DEBUG_SEL = test_debug_sel;
  if (reg->bitfields.TEST_DEBUG_SEL != test_debug_sel) HSLDPF(E_ERROR_MESSAGE,"TEST_DEBUG_MUX::TEST_DEBUG_SEL data too large\n");
}
__inline void set_TEST_DEBUG_MUX_test_clk0(regTEST_DEBUG_MUX *reg, unsigned int test_clk0)
{
  reg->bitfields.TEST_CLK0 = test_clk0;
  if (reg->bitfields.TEST_CLK0 != test_clk0) HSLDPF(E_ERROR_MESSAGE,"TEST_DEBUG_MUX::TEST_CLK0 data too large\n");
}
__inline void set_TEST_DEBUG_MUX_test_clk0_inv(regTEST_DEBUG_MUX *reg, unsigned int test_clk0_inv)
{
  reg->bitfields.TEST_CLK0_INV = test_clk0_inv;
  if (reg->bitfields.TEST_CLK0_INV != test_clk0_inv) HSLDPF(E_ERROR_MESSAGE,"TEST_DEBUG_MUX::TEST_CLK0_INV data too large\n");
}
__inline void set_TEST_DEBUG_MUX_test_clk1(regTEST_DEBUG_MUX *reg, unsigned int test_clk1)
{
  reg->bitfields.TEST_CLK1 = test_clk1;
  if (reg->bitfields.TEST_CLK1 != test_clk1) HSLDPF(E_ERROR_MESSAGE,"TEST_DEBUG_MUX::TEST_CLK1 data too large\n");
}
__inline void set_TEST_DEBUG_MUX_test_clk1_inv(regTEST_DEBUG_MUX *reg, unsigned int test_clk1_inv)
{
  reg->bitfields.TEST_CLK1_INV = test_clk1_inv;
  if (reg->bitfields.TEST_CLK1_INV != test_clk1_inv) HSLDPF(E_ERROR_MESSAGE,"TEST_DEBUG_MUX::TEST_CLK1_INV data too large\n");
}
#else
#define set_TEST_DEBUG_MUX_test_debug_sel(reg, test_debug_sel) (reg)->bitfields.TEST_DEBUG_SEL = test_debug_sel
#define set_TEST_DEBUG_MUX_test_clk0(reg, test_clk0) (reg)->bitfields.TEST_CLK0 = test_clk0
#define set_TEST_DEBUG_MUX_test_clk0_inv(reg, test_clk0_inv) (reg)->bitfields.TEST_CLK0_INV = test_clk0_inv
#define set_TEST_DEBUG_MUX_test_clk1(reg, test_clk1) (reg)->bitfields.TEST_CLK1 = test_clk1
#define set_TEST_DEBUG_MUX_test_clk1_inv(reg, test_clk1_inv) (reg)->bitfields.TEST_CLK1_INV = test_clk1_inv

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TEST_DEBUG_OUT regTEST_DEBUG_OUT;

#ifdef DEBUG
__inline void set_TEST_DEBUG_OUT_test_debug_outr(regTEST_DEBUG_OUT *reg, unsigned int test_debug_outr)
{
  reg->bitfields.TEST_DEBUG_OUTR = test_debug_outr;
  if (reg->bitfields.TEST_DEBUG_OUTR != test_debug_outr) HSLDPF(E_ERROR_MESSAGE,"TEST_DEBUG_OUT::TEST_DEBUG_OUTR data too large\n");
}
#else
#define set_TEST_DEBUG_OUT_test_debug_outr(reg, test_debug_outr) (reg)->bitfields.TEST_DEBUG_OUTR = test_debug_outr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIDEOMUX_CNTL regVIDEOMUX_CNTL;

#ifdef DEBUG
__inline void set_VIDEOMUX_CNTL_viph_int_sel(regVIDEOMUX_CNTL *reg, unsigned int viph_int_sel)
{
  reg->bitfields.VIPH_INT_SEL = viph_int_sel;
  if (reg->bitfields.VIPH_INT_SEL != viph_int_sel) HSLDPF(E_ERROR_MESSAGE,"VIDEOMUX_CNTL::VIPH_INT_SEL data too large\n");
}
__inline void set_VIDEOMUX_CNTL_rom_clk_divide(regVIDEOMUX_CNTL *reg, unsigned int rom_clk_divide)
{
  reg->bitfields.ROM_CLK_DIVIDE = rom_clk_divide;
  if (reg->bitfields.ROM_CLK_DIVIDE != rom_clk_divide) HSLDPF(E_ERROR_MESSAGE,"VIDEOMUX_CNTL::ROM_CLK_DIVIDE data too large\n");
}
__inline void set_VIDEOMUX_CNTL_str_romclk(regVIDEOMUX_CNTL *reg, unsigned int str_romclk)
{
  reg->bitfields.STR_ROMCLK = str_romclk;
  if (reg->bitfields.STR_ROMCLK != str_romclk) HSLDPF(E_ERROR_MESSAGE,"VIDEOMUX_CNTL::STR_ROMCLK data too large\n");
}
__inline void set_VIDEOMUX_CNTL_vip_internal_debug_sel(regVIDEOMUX_CNTL *reg, unsigned int vip_internal_debug_sel)
{
  reg->bitfields.VIP_INTERNAL_DEBUG_SEL = vip_internal_debug_sel;
  if (reg->bitfields.VIP_INTERNAL_DEBUG_SEL != vip_internal_debug_sel) HSLDPF(E_ERROR_MESSAGE,"VIDEOMUX_CNTL::VIP_INTERNAL_DEBUG_SEL data too large\n");
}
__inline void set_VIDEOMUX_CNTL_geyserville_sense(regVIDEOMUX_CNTL *reg, unsigned int geyserville_sense)
{
  reg->bitfields.GEYSERVILLE_SENSE = geyserville_sense;
  if (reg->bitfields.GEYSERVILLE_SENSE != geyserville_sense) HSLDPF(E_ERROR_MESSAGE,"VIDEOMUX_CNTL::GEYSERVILLE_SENSE data too large\n");
}
__inline void set_VIDEOMUX_CNTL_geyserville_int_pol(regVIDEOMUX_CNTL *reg, unsigned int geyserville_int_pol)
{
  reg->bitfields.GEYSERVILLE_INT_POL = geyserville_int_pol;
  if (reg->bitfields.GEYSERVILLE_INT_POL != geyserville_int_pol) HSLDPF(E_ERROR_MESSAGE,"VIDEOMUX_CNTL::GEYSERVILLE_INT_POL data too large\n");
}
#else
#define set_VIDEOMUX_CNTL_viph_int_sel(reg, viph_int_sel) (reg)->bitfields.VIPH_INT_SEL = viph_int_sel
#define set_VIDEOMUX_CNTL_rom_clk_divide(reg, rom_clk_divide) (reg)->bitfields.ROM_CLK_DIVIDE = rom_clk_divide
#define set_VIDEOMUX_CNTL_str_romclk(reg, str_romclk) (reg)->bitfields.STR_ROMCLK = str_romclk
#define set_VIDEOMUX_CNTL_vip_internal_debug_sel(reg, vip_internal_debug_sel) (reg)->bitfields.VIP_INTERNAL_DEBUG_SEL = vip_internal_debug_sel
#define set_VIDEOMUX_CNTL_geyserville_sense(reg, geyserville_sense) (reg)->bitfields.GEYSERVILLE_SENSE = geyserville_sense
#define set_VIDEOMUX_CNTL_geyserville_int_pol(reg, geyserville_int_pol) (reg)->bitfields.GEYSERVILLE_INT_POL = geyserville_int_pol

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPPAD_STRENGTH_M6 regVIPPAD_STRENGTH_M6;

#ifdef DEBUG
__inline void set_VIPPAD_STRENGTH_M6_zv_lcddata_strength(regVIPPAD_STRENGTH_M6 *reg, unsigned int zv_lcddata_strength)
{
  reg->bitfields.ZV_LCDDATA_STRENGTH = zv_lcddata_strength;
  if (reg->bitfields.ZV_LCDDATA_STRENGTH != zv_lcddata_strength) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_STRENGTH_M6::ZV_LCDDATA_STRENGTH data too large\n");
}
__inline void set_VIPPAD_STRENGTH_M6_zv_lcdcntl_strength(regVIPPAD_STRENGTH_M6 *reg, unsigned int zv_lcdcntl_strength)
{
  reg->bitfields.ZV_LCDCNTL_STRENGTH = zv_lcdcntl_strength;
  if (reg->bitfields.ZV_LCDCNTL_STRENGTH != zv_lcdcntl_strength) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_STRENGTH_M6::ZV_LCDCNTL_STRENGTH data too large\n");
}
__inline void set_VIPPAD_STRENGTH_M6_gpio_strength(regVIPPAD_STRENGTH_M6 *reg, unsigned int gpio_strength)
{
  reg->bitfields.GPIO_STRENGTH = gpio_strength;
  if (reg->bitfields.GPIO_STRENGTH != gpio_strength) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_STRENGTH_M6::GPIO_STRENGTH data too large\n");
}
#else
#define set_VIPPAD_STRENGTH_M6_zv_lcddata_strength(reg, zv_lcddata_strength) (reg)->bitfields.ZV_LCDDATA_STRENGTH = zv_lcddata_strength
#define set_VIPPAD_STRENGTH_M6_zv_lcdcntl_strength(reg, zv_lcdcntl_strength) (reg)->bitfields.ZV_LCDCNTL_STRENGTH = zv_lcdcntl_strength
#define set_VIPPAD_STRENGTH_M6_gpio_strength(reg, gpio_strength) (reg)->bitfields.GPIO_STRENGTH = gpio_strength

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GPIOPAD_MASK regGPIOPAD_MASK;

#ifdef DEBUG
__inline void set_GPIOPAD_MASK_gpio_mask(regGPIOPAD_MASK *reg, unsigned int gpio_mask)
{
  reg->bitfields.GPIO_MASK = gpio_mask;
  if (reg->bitfields.GPIO_MASK != gpio_mask) HSLDPF(E_ERROR_MESSAGE,"GPIOPAD_MASK::GPIO_MASK data too large\n");
}
#else
#define set_GPIOPAD_MASK_gpio_mask(reg, gpio_mask) (reg)->bitfields.GPIO_MASK = gpio_mask

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GPIOPAD_A regGPIOPAD_A;

#ifdef DEBUG
__inline void set_GPIOPAD_A_gpio_a(regGPIOPAD_A *reg, unsigned int gpio_a)
{
  reg->bitfields.GPIO_A = gpio_a;
  if (reg->bitfields.GPIO_A != gpio_a) HSLDPF(E_ERROR_MESSAGE,"GPIOPAD_A::GPIO_A data too large\n");
}
#else
#define set_GPIOPAD_A_gpio_a(reg, gpio_a) (reg)->bitfields.GPIO_A = gpio_a

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GPIOPAD_EN regGPIOPAD_EN;

#ifdef DEBUG
__inline void set_GPIOPAD_EN_gpio_en(regGPIOPAD_EN *reg, unsigned int gpio_en)
{
  reg->bitfields.GPIO_EN = gpio_en;
  if (reg->bitfields.GPIO_EN != gpio_en) HSLDPF(E_ERROR_MESSAGE,"GPIOPAD_EN::GPIO_EN data too large\n");
}
#else
#define set_GPIOPAD_EN_gpio_en(reg, gpio_en) (reg)->bitfields.GPIO_EN = gpio_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GPIOPAD_Y regGPIOPAD_Y;

#ifdef DEBUG
__inline void set_GPIOPAD_Y_gpio_y(regGPIOPAD_Y *reg, unsigned int gpio_y)
{
  reg->bitfields.GPIO_Y = gpio_y;
  if (reg->bitfields.GPIO_Y != gpio_y) HSLDPF(E_ERROR_MESSAGE,"GPIOPAD_Y::GPIO_Y data too large\n");
}
#else
#define set_GPIOPAD_Y_gpio_y(reg, gpio_y) (reg)->bitfields.GPIO_Y = gpio_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ZV_LCDPAD_MASK regZV_LCDPAD_MASK;

#ifdef DEBUG
__inline void set_ZV_LCDPAD_MASK_zv_lcddata_mask(regZV_LCDPAD_MASK *reg, unsigned int zv_lcddata_mask)
{
  reg->bitfields.ZV_LCDDATA_MASK = zv_lcddata_mask;
  if (reg->bitfields.ZV_LCDDATA_MASK != zv_lcddata_mask) HSLDPF(E_ERROR_MESSAGE,"ZV_LCDPAD_MASK::ZV_LCDDATA_MASK data too large\n");
}
__inline void set_ZV_LCDPAD_MASK_zv_lcdcntl_mask(regZV_LCDPAD_MASK *reg, unsigned int zv_lcdcntl_mask)
{
  reg->bitfields.ZV_LCDCNTL_MASK = zv_lcdcntl_mask;
  if (reg->bitfields.ZV_LCDCNTL_MASK != zv_lcdcntl_mask) HSLDPF(E_ERROR_MESSAGE,"ZV_LCDPAD_MASK::ZV_LCDCNTL_MASK data too large\n");
}
#else
#define set_ZV_LCDPAD_MASK_zv_lcddata_mask(reg, zv_lcddata_mask) (reg)->bitfields.ZV_LCDDATA_MASK = zv_lcddata_mask
#define set_ZV_LCDPAD_MASK_zv_lcdcntl_mask(reg, zv_lcdcntl_mask) (reg)->bitfields.ZV_LCDCNTL_MASK = zv_lcdcntl_mask

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ZV_LCDPAD_A regZV_LCDPAD_A;

#ifdef DEBUG
__inline void set_ZV_LCDPAD_A_zv_lcddata_a(regZV_LCDPAD_A *reg, unsigned int zv_lcddata_a)
{
  reg->bitfields.ZV_LCDDATA_A = zv_lcddata_a;
  if (reg->bitfields.ZV_LCDDATA_A != zv_lcddata_a) HSLDPF(E_ERROR_MESSAGE,"ZV_LCDPAD_A::ZV_LCDDATA_A data too large\n");
}
__inline void set_ZV_LCDPAD_A_zv_lcdcntl_a(regZV_LCDPAD_A *reg, unsigned int zv_lcdcntl_a)
{
  reg->bitfields.ZV_LCDCNTL_A = zv_lcdcntl_a;
  if (reg->bitfields.ZV_LCDCNTL_A != zv_lcdcntl_a) HSLDPF(E_ERROR_MESSAGE,"ZV_LCDPAD_A::ZV_LCDCNTL_A data too large\n");
}
#else
#define set_ZV_LCDPAD_A_zv_lcddata_a(reg, zv_lcddata_a) (reg)->bitfields.ZV_LCDDATA_A = zv_lcddata_a
#define set_ZV_LCDPAD_A_zv_lcdcntl_a(reg, zv_lcdcntl_a) (reg)->bitfields.ZV_LCDCNTL_A = zv_lcdcntl_a

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ZV_LCDPAD_EN regZV_LCDPAD_EN;

#ifdef DEBUG
__inline void set_ZV_LCDPAD_EN_zv_lcddata_en(regZV_LCDPAD_EN *reg, unsigned int zv_lcddata_en)
{
  reg->bitfields.ZV_LCDDATA_EN = zv_lcddata_en;
  if (reg->bitfields.ZV_LCDDATA_EN != zv_lcddata_en) HSLDPF(E_ERROR_MESSAGE,"ZV_LCDPAD_EN::ZV_LCDDATA_EN data too large\n");
}
__inline void set_ZV_LCDPAD_EN_zv_lcdcntl_en(regZV_LCDPAD_EN *reg, unsigned int zv_lcdcntl_en)
{
  reg->bitfields.ZV_LCDCNTL_EN = zv_lcdcntl_en;
  if (reg->bitfields.ZV_LCDCNTL_EN != zv_lcdcntl_en) HSLDPF(E_ERROR_MESSAGE,"ZV_LCDPAD_EN::ZV_LCDCNTL_EN data too large\n");
}
#else
#define set_ZV_LCDPAD_EN_zv_lcddata_en(reg, zv_lcddata_en) (reg)->bitfields.ZV_LCDDATA_EN = zv_lcddata_en
#define set_ZV_LCDPAD_EN_zv_lcdcntl_en(reg, zv_lcdcntl_en) (reg)->bitfields.ZV_LCDCNTL_EN = zv_lcdcntl_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ZV_LCDPAD_Y regZV_LCDPAD_Y;

#ifdef DEBUG
__inline void set_ZV_LCDPAD_Y_zv_lcddata_y(regZV_LCDPAD_Y *reg, unsigned int zv_lcddata_y)
{
  reg->bitfields.ZV_LCDDATA_Y = zv_lcddata_y;
  if (reg->bitfields.ZV_LCDDATA_Y != zv_lcddata_y) HSLDPF(E_ERROR_MESSAGE,"ZV_LCDPAD_Y::ZV_LCDDATA_Y data too large\n");
}
__inline void set_ZV_LCDPAD_Y_zv_lcdcntl_y(regZV_LCDPAD_Y *reg, unsigned int zv_lcdcntl_y)
{
  reg->bitfields.ZV_LCDCNTL_Y = zv_lcdcntl_y;
  if (reg->bitfields.ZV_LCDCNTL_Y != zv_lcdcntl_y) HSLDPF(E_ERROR_MESSAGE,"ZV_LCDPAD_Y::ZV_LCDCNTL_Y data too large\n");
}
#else
#define set_ZV_LCDPAD_Y_zv_lcddata_y(reg, zv_lcddata_y) (reg)->bitfields.ZV_LCDDATA_Y = zv_lcddata_y
#define set_ZV_LCDPAD_Y_zv_lcdcntl_y(reg, zv_lcdcntl_y) (reg)->bitfields.ZV_LCDCNTL_Y = zv_lcdcntl_y

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union EXTERN_TRIG_CNTL regEXTERN_TRIG_CNTL;

#ifdef DEBUG
__inline void set_EXTERN_TRIG_CNTL_extern_trig_clr(regEXTERN_TRIG_CNTL *reg, unsigned int extern_trig_clr)
{
  reg->bitfields.EXTERN_TRIG_CLR = extern_trig_clr;
  if (reg->bitfields.EXTERN_TRIG_CLR != extern_trig_clr) HSLDPF(E_ERROR_MESSAGE,"EXTERN_TRIG_CNTL::EXTERN_TRIG_CLR data too large\n");
}
__inline void set_EXTERN_TRIG_CNTL_extern_trig_read(regEXTERN_TRIG_CNTL *reg, unsigned int extern_trig_read)
{
  reg->bitfields.EXTERN_TRIG_READ = extern_trig_read;
  if (reg->bitfields.EXTERN_TRIG_READ != extern_trig_read) HSLDPF(E_ERROR_MESSAGE,"EXTERN_TRIG_CNTL::EXTERN_TRIG_READ data too large\n");
}
#else
#define set_EXTERN_TRIG_CNTL_extern_trig_clr(reg, extern_trig_clr) (reg)->bitfields.EXTERN_TRIG_CLR = extern_trig_clr
#define set_EXTERN_TRIG_CNTL_extern_trig_read(reg, extern_trig_read) (reg)->bitfields.EXTERN_TRIG_READ = extern_trig_read

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ROM_INDEX regROM_INDEX;

#ifdef DEBUG
__inline void set_ROM_INDEX_rom_index(regROM_INDEX *reg, unsigned int rom_index)
{
  reg->bitfields.ROM_INDEX = rom_index;
  if (reg->bitfields.ROM_INDEX != rom_index) HSLDPF(E_ERROR_MESSAGE,"ROM_INDEX::ROM_INDEX data too large\n");
}
#else
#define set_ROM_INDEX_rom_index(reg, rom_index) (reg)->bitfields.ROM_INDEX = rom_index

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union ROM_DATA regROM_DATA;

#ifdef DEBUG
__inline void set_ROM_DATA_rom_data(regROM_DATA *reg, unsigned int rom_data)
{
  reg->bitfields.ROM_DATA = rom_data;
  if (reg->bitfields.ROM_DATA != rom_data) HSLDPF(E_ERROR_MESSAGE,"ROM_DATA::ROM_DATA data too large\n");
}
#else
#define set_ROM_DATA_rom_data(reg, rom_data) (reg)->bitfields.ROM_DATA = rom_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SEPROM_CNTL1 regSEPROM_CNTL1;

#ifdef DEBUG
__inline void set_SEPROM_CNTL1_write_enable(regSEPROM_CNTL1 *reg, unsigned int write_enable)
{
  reg->bitfields.WRITE_ENABLE = write_enable;
  if (reg->bitfields.WRITE_ENABLE != write_enable) HSLDPF(E_ERROR_MESSAGE,"SEPROM_CNTL1::WRITE_ENABLE data too large\n");
}
__inline void set_SEPROM_CNTL1_write_disable(regSEPROM_CNTL1 *reg, unsigned int write_disable)
{
  reg->bitfields.WRITE_DISABLE = write_disable;
  if (reg->bitfields.WRITE_DISABLE != write_disable) HSLDPF(E_ERROR_MESSAGE,"SEPROM_CNTL1::WRITE_DISABLE data too large\n");
}
__inline void set_SEPROM_CNTL1_read_config(regSEPROM_CNTL1 *reg, unsigned int read_config)
{
  reg->bitfields.READ_CONFIG = read_config;
  if (reg->bitfields.READ_CONFIG != read_config) HSLDPF(E_ERROR_MESSAGE,"SEPROM_CNTL1::READ_CONFIG data too large\n");
}
__inline void set_SEPROM_CNTL1_write_config(regSEPROM_CNTL1 *reg, unsigned int write_config)
{
  reg->bitfields.WRITE_CONFIG = write_config;
  if (reg->bitfields.WRITE_CONFIG != write_config) HSLDPF(E_ERROR_MESSAGE,"SEPROM_CNTL1::WRITE_CONFIG data too large\n");
}
__inline void set_SEPROM_CNTL1_read_status(regSEPROM_CNTL1 *reg, unsigned int read_status)
{
  reg->bitfields.READ_STATUS = read_status;
  if (reg->bitfields.READ_STATUS != read_status) HSLDPF(E_ERROR_MESSAGE,"SEPROM_CNTL1::READ_STATUS data too large\n");
}
__inline void set_SEPROM_CNTL1_sect_to_sram(regSEPROM_CNTL1 *reg, unsigned int sect_to_sram)
{
  reg->bitfields.SECT_TO_SRAM = sect_to_sram;
  if (reg->bitfields.SECT_TO_SRAM != sect_to_sram) HSLDPF(E_ERROR_MESSAGE,"SEPROM_CNTL1::SECT_TO_SRAM data too large\n");
}
__inline void set_SEPROM_CNTL1_ready_busy(regSEPROM_CNTL1 *reg, unsigned int ready_busy)
{
  reg->bitfields.READY_BUSY = ready_busy;
  if (reg->bitfields.READY_BUSY != ready_busy) HSLDPF(E_ERROR_MESSAGE,"SEPROM_CNTL1::READY_BUSY data too large\n");
}
__inline void set_SEPROM_CNTL1_seprom_busy(regSEPROM_CNTL1 *reg, unsigned int seprom_busy)
{
  reg->bitfields.SEPROM_BUSY = seprom_busy;
  if (reg->bitfields.SEPROM_BUSY != seprom_busy) HSLDPF(E_ERROR_MESSAGE,"SEPROM_CNTL1::SEPROM_BUSY data too large\n");
}
__inline void set_SEPROM_CNTL1_bcnt_over_wte_en(regSEPROM_CNTL1 *reg, unsigned int bcnt_over_wte_en)
{
  reg->bitfields.BCNT_OVER_WTE_EN = bcnt_over_wte_en;
  if (reg->bitfields.BCNT_OVER_WTE_EN != bcnt_over_wte_en) HSLDPF(E_ERROR_MESSAGE,"SEPROM_CNTL1::BCNT_OVER_WTE_EN data too large\n");
}
__inline void set_SEPROM_CNTL1_rb_maskb(regSEPROM_CNTL1 *reg, unsigned int rb_maskb)
{
  reg->bitfields.RB_MASKB = rb_maskb;
  if (reg->bitfields.RB_MASKB != rb_maskb) HSLDPF(E_ERROR_MESSAGE,"SEPROM_CNTL1::RB_MASKB data too large\n");
}
__inline void set_SEPROM_CNTL1_soft_reset(regSEPROM_CNTL1 *reg, unsigned int soft_reset)
{
  reg->bitfields.SOFT_RESET = soft_reset;
  if (reg->bitfields.SOFT_RESET != soft_reset) HSLDPF(E_ERROR_MESSAGE,"SEPROM_CNTL1::SOFT_RESET data too large\n");
}
__inline void set_SEPROM_CNTL1_state_idleb(regSEPROM_CNTL1 *reg, unsigned int state_idleb)
{
  reg->bitfields.STATE_IDLEb = state_idleb;
  if (reg->bitfields.STATE_IDLEb != state_idleb) HSLDPF(E_ERROR_MESSAGE,"SEPROM_CNTL1::STATE_IDLEb data too large\n");
}
__inline void set_SEPROM_CNTL1_byte_cnt(regSEPROM_CNTL1 *reg, unsigned int byte_cnt)
{
  reg->bitfields.BYTE_CNT = byte_cnt;
  if (reg->bitfields.BYTE_CNT != byte_cnt) HSLDPF(E_ERROR_MESSAGE,"SEPROM_CNTL1::BYTE_CNT data too large\n");
}
__inline void set_SEPROM_CNTL1_sck_prescale(regSEPROM_CNTL1 *reg, unsigned int sck_prescale)
{
  reg->bitfields.SCK_PRESCALE = sck_prescale;
  if (reg->bitfields.SCK_PRESCALE != sck_prescale) HSLDPF(E_ERROR_MESSAGE,"SEPROM_CNTL1::SCK_PRESCALE data too large\n");
}
#else
#define set_SEPROM_CNTL1_write_enable(reg, write_enable) (reg)->bitfields.WRITE_ENABLE = write_enable
#define set_SEPROM_CNTL1_write_disable(reg, write_disable) (reg)->bitfields.WRITE_DISABLE = write_disable
#define set_SEPROM_CNTL1_read_config(reg, read_config) (reg)->bitfields.READ_CONFIG = read_config
#define set_SEPROM_CNTL1_write_config(reg, write_config) (reg)->bitfields.WRITE_CONFIG = write_config
#define set_SEPROM_CNTL1_read_status(reg, read_status) (reg)->bitfields.READ_STATUS = read_status
#define set_SEPROM_CNTL1_sect_to_sram(reg, sect_to_sram) (reg)->bitfields.SECT_TO_SRAM = sect_to_sram
#define set_SEPROM_CNTL1_ready_busy(reg, ready_busy) (reg)->bitfields.READY_BUSY = ready_busy
#define set_SEPROM_CNTL1_seprom_busy(reg, seprom_busy) (reg)->bitfields.SEPROM_BUSY = seprom_busy
#define set_SEPROM_CNTL1_bcnt_over_wte_en(reg, bcnt_over_wte_en) (reg)->bitfields.BCNT_OVER_WTE_EN = bcnt_over_wte_en
#define set_SEPROM_CNTL1_rb_maskb(reg, rb_maskb) (reg)->bitfields.RB_MASKB = rb_maskb
#define set_SEPROM_CNTL1_soft_reset(reg, soft_reset) (reg)->bitfields.SOFT_RESET = soft_reset
#define set_SEPROM_CNTL1_state_idleb(reg, state_idleb) (reg)->bitfields.STATE_IDLEb = state_idleb
#define set_SEPROM_CNTL1_byte_cnt(reg, byte_cnt) (reg)->bitfields.BYTE_CNT = byte_cnt
#define set_SEPROM_CNTL1_sck_prescale(reg, sck_prescale) (reg)->bitfields.SCK_PRESCALE = sck_prescale

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SEPROM_CNTL2 regSEPROM_CNTL2;

#ifdef DEBUG
__inline void set_SEPROM_CNTL2_wait_cycle(regSEPROM_CNTL2 *reg, unsigned int wait_cycle)
{
  reg->bitfields.WAIT_CYCLE = wait_cycle;
  if (reg->bitfields.WAIT_CYCLE != wait_cycle) HSLDPF(E_ERROR_MESSAGE,"SEPROM_CNTL2::WAIT_CYCLE data too large\n");
}
__inline void set_SEPROM_CNTL2_auto_addr_sample(regSEPROM_CNTL2 *reg, unsigned int auto_addr_sample)
{
  reg->bitfields.AUTO_ADDR_SAMPLE = auto_addr_sample;
  if (reg->bitfields.AUTO_ADDR_SAMPLE != auto_addr_sample) HSLDPF(E_ERROR_MESSAGE,"SEPROM_CNTL2::AUTO_ADDR_SAMPLE data too large\n");
}
__inline void set_SEPROM_CNTL2_sec_command(regSEPROM_CNTL2 *reg, unsigned int sec_command)
{
  reg->bitfields.SEC_COMMAND = sec_command;
  if (reg->bitfields.SEC_COMMAND != sec_command) HSLDPF(E_ERROR_MESSAGE,"SEPROM_CNTL2::SEC_COMMAND data too large\n");
}
#else
#define set_SEPROM_CNTL2_wait_cycle(reg, wait_cycle) (reg)->bitfields.WAIT_CYCLE = wait_cycle
#define set_SEPROM_CNTL2_auto_addr_sample(reg, auto_addr_sample) (reg)->bitfields.AUTO_ADDR_SAMPLE = auto_addr_sample
#define set_SEPROM_CNTL2_sec_command(reg, sec_command) (reg)->bitfields.SEC_COMMAND = sec_command

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIP_HW_DEBUG regVIP_HW_DEBUG;

#ifdef DEBUG
__inline void set_VIP_HW_DEBUG_vip_hw_0_debug(regVIP_HW_DEBUG *reg, unsigned int vip_hw_0_debug)
{
  reg->bitfields.VIP_HW_0_DEBUG = vip_hw_0_debug;
  if (reg->bitfields.VIP_HW_0_DEBUG != vip_hw_0_debug) HSLDPF(E_ERROR_MESSAGE,"VIP_HW_DEBUG::VIP_HW_0_DEBUG data too large\n");
}
__inline void set_VIP_HW_DEBUG_vip_hw_1_debug(regVIP_HW_DEBUG *reg, unsigned int vip_hw_1_debug)
{
  reg->bitfields.VIP_HW_1_DEBUG = vip_hw_1_debug;
  if (reg->bitfields.VIP_HW_1_DEBUG != vip_hw_1_debug) HSLDPF(E_ERROR_MESSAGE,"VIP_HW_DEBUG::VIP_HW_1_DEBUG data too large\n");
}
__inline void set_VIP_HW_DEBUG_vip_hw_2_debug(regVIP_HW_DEBUG *reg, unsigned int vip_hw_2_debug)
{
  reg->bitfields.VIP_HW_2_DEBUG = vip_hw_2_debug;
  if (reg->bitfields.VIP_HW_2_DEBUG != vip_hw_2_debug) HSLDPF(E_ERROR_MESSAGE,"VIP_HW_DEBUG::VIP_HW_2_DEBUG data too large\n");
}
__inline void set_VIP_HW_DEBUG_vip_hw_3_debug(regVIP_HW_DEBUG *reg, unsigned int vip_hw_3_debug)
{
  reg->bitfields.VIP_HW_3_DEBUG = vip_hw_3_debug;
  if (reg->bitfields.VIP_HW_3_DEBUG != vip_hw_3_debug) HSLDPF(E_ERROR_MESSAGE,"VIP_HW_DEBUG::VIP_HW_3_DEBUG data too large\n");
}
__inline void set_VIP_HW_DEBUG_vip_hw_4_debug(regVIP_HW_DEBUG *reg, unsigned int vip_hw_4_debug)
{
  reg->bitfields.VIP_HW_4_DEBUG = vip_hw_4_debug;
  if (reg->bitfields.VIP_HW_4_DEBUG != vip_hw_4_debug) HSLDPF(E_ERROR_MESSAGE,"VIP_HW_DEBUG::VIP_HW_4_DEBUG data too large\n");
}
__inline void set_VIP_HW_DEBUG_vip_hw_5_debug(regVIP_HW_DEBUG *reg, unsigned int vip_hw_5_debug)
{
  reg->bitfields.VIP_HW_5_DEBUG = vip_hw_5_debug;
  if (reg->bitfields.VIP_HW_5_DEBUG != vip_hw_5_debug) HSLDPF(E_ERROR_MESSAGE,"VIP_HW_DEBUG::VIP_HW_5_DEBUG data too large\n");
}
__inline void set_VIP_HW_DEBUG_vip_hw_6_debug(regVIP_HW_DEBUG *reg, unsigned int vip_hw_6_debug)
{
  reg->bitfields.VIP_HW_6_DEBUG = vip_hw_6_debug;
  if (reg->bitfields.VIP_HW_6_DEBUG != vip_hw_6_debug) HSLDPF(E_ERROR_MESSAGE,"VIP_HW_DEBUG::VIP_HW_6_DEBUG data too large\n");
}
__inline void set_VIP_HW_DEBUG_vip_hw_7_debug(regVIP_HW_DEBUG *reg, unsigned int vip_hw_7_debug)
{
  reg->bitfields.VIP_HW_7_DEBUG = vip_hw_7_debug;
  if (reg->bitfields.VIP_HW_7_DEBUG != vip_hw_7_debug) HSLDPF(E_ERROR_MESSAGE,"VIP_HW_DEBUG::VIP_HW_7_DEBUG data too large\n");
}
__inline void set_VIP_HW_DEBUG_vip_hw_8_debug(regVIP_HW_DEBUG *reg, unsigned int vip_hw_8_debug)
{
  reg->bitfields.VIP_HW_8_DEBUG = vip_hw_8_debug;
  if (reg->bitfields.VIP_HW_8_DEBUG != vip_hw_8_debug) HSLDPF(E_ERROR_MESSAGE,"VIP_HW_DEBUG::VIP_HW_8_DEBUG data too large\n");
}
__inline void set_VIP_HW_DEBUG_vip_hw_9_debug(regVIP_HW_DEBUG *reg, unsigned int vip_hw_9_debug)
{
  reg->bitfields.VIP_HW_9_DEBUG = vip_hw_9_debug;
  if (reg->bitfields.VIP_HW_9_DEBUG != vip_hw_9_debug) HSLDPF(E_ERROR_MESSAGE,"VIP_HW_DEBUG::VIP_HW_9_DEBUG data too large\n");
}
__inline void set_VIP_HW_DEBUG_vip_hw_a_debug(regVIP_HW_DEBUG *reg, unsigned int vip_hw_a_debug)
{
  reg->bitfields.VIP_HW_A_DEBUG = vip_hw_a_debug;
  if (reg->bitfields.VIP_HW_A_DEBUG != vip_hw_a_debug) HSLDPF(E_ERROR_MESSAGE,"VIP_HW_DEBUG::VIP_HW_A_DEBUG data too large\n");
}
__inline void set_VIP_HW_DEBUG_vip_hw_b_debug(regVIP_HW_DEBUG *reg, unsigned int vip_hw_b_debug)
{
  reg->bitfields.VIP_HW_B_DEBUG = vip_hw_b_debug;
  if (reg->bitfields.VIP_HW_B_DEBUG != vip_hw_b_debug) HSLDPF(E_ERROR_MESSAGE,"VIP_HW_DEBUG::VIP_HW_B_DEBUG data too large\n");
}
__inline void set_VIP_HW_DEBUG_vip_hw_c_debug(regVIP_HW_DEBUG *reg, unsigned int vip_hw_c_debug)
{
  reg->bitfields.VIP_HW_C_DEBUG = vip_hw_c_debug;
  if (reg->bitfields.VIP_HW_C_DEBUG != vip_hw_c_debug) HSLDPF(E_ERROR_MESSAGE,"VIP_HW_DEBUG::VIP_HW_C_DEBUG data too large\n");
}
__inline void set_VIP_HW_DEBUG_vip_hw_d_debug(regVIP_HW_DEBUG *reg, unsigned int vip_hw_d_debug)
{
  reg->bitfields.VIP_HW_D_DEBUG = vip_hw_d_debug;
  if (reg->bitfields.VIP_HW_D_DEBUG != vip_hw_d_debug) HSLDPF(E_ERROR_MESSAGE,"VIP_HW_DEBUG::VIP_HW_D_DEBUG data too large\n");
}
__inline void set_VIP_HW_DEBUG_vip_hw_e_debug(regVIP_HW_DEBUG *reg, unsigned int vip_hw_e_debug)
{
  reg->bitfields.VIP_HW_E_DEBUG = vip_hw_e_debug;
  if (reg->bitfields.VIP_HW_E_DEBUG != vip_hw_e_debug) HSLDPF(E_ERROR_MESSAGE,"VIP_HW_DEBUG::VIP_HW_E_DEBUG data too large\n");
}
__inline void set_VIP_HW_DEBUG_vip_hw_f_debug(regVIP_HW_DEBUG *reg, unsigned int vip_hw_f_debug)
{
  reg->bitfields.VIP_HW_F_DEBUG = vip_hw_f_debug;
  if (reg->bitfields.VIP_HW_F_DEBUG != vip_hw_f_debug) HSLDPF(E_ERROR_MESSAGE,"VIP_HW_DEBUG::VIP_HW_F_DEBUG data too large\n");
}
#else
#define set_VIP_HW_DEBUG_vip_hw_0_debug(reg, vip_hw_0_debug) (reg)->bitfields.VIP_HW_0_DEBUG = vip_hw_0_debug
#define set_VIP_HW_DEBUG_vip_hw_1_debug(reg, vip_hw_1_debug) (reg)->bitfields.VIP_HW_1_DEBUG = vip_hw_1_debug
#define set_VIP_HW_DEBUG_vip_hw_2_debug(reg, vip_hw_2_debug) (reg)->bitfields.VIP_HW_2_DEBUG = vip_hw_2_debug
#define set_VIP_HW_DEBUG_vip_hw_3_debug(reg, vip_hw_3_debug) (reg)->bitfields.VIP_HW_3_DEBUG = vip_hw_3_debug
#define set_VIP_HW_DEBUG_vip_hw_4_debug(reg, vip_hw_4_debug) (reg)->bitfields.VIP_HW_4_DEBUG = vip_hw_4_debug
#define set_VIP_HW_DEBUG_vip_hw_5_debug(reg, vip_hw_5_debug) (reg)->bitfields.VIP_HW_5_DEBUG = vip_hw_5_debug
#define set_VIP_HW_DEBUG_vip_hw_6_debug(reg, vip_hw_6_debug) (reg)->bitfields.VIP_HW_6_DEBUG = vip_hw_6_debug
#define set_VIP_HW_DEBUG_vip_hw_7_debug(reg, vip_hw_7_debug) (reg)->bitfields.VIP_HW_7_DEBUG = vip_hw_7_debug
#define set_VIP_HW_DEBUG_vip_hw_8_debug(reg, vip_hw_8_debug) (reg)->bitfields.VIP_HW_8_DEBUG = vip_hw_8_debug
#define set_VIP_HW_DEBUG_vip_hw_9_debug(reg, vip_hw_9_debug) (reg)->bitfields.VIP_HW_9_DEBUG = vip_hw_9_debug
#define set_VIP_HW_DEBUG_vip_hw_a_debug(reg, vip_hw_a_debug) (reg)->bitfields.VIP_HW_A_DEBUG = vip_hw_a_debug
#define set_VIP_HW_DEBUG_vip_hw_b_debug(reg, vip_hw_b_debug) (reg)->bitfields.VIP_HW_B_DEBUG = vip_hw_b_debug
#define set_VIP_HW_DEBUG_vip_hw_c_debug(reg, vip_hw_c_debug) (reg)->bitfields.VIP_HW_C_DEBUG = vip_hw_c_debug
#define set_VIP_HW_DEBUG_vip_hw_d_debug(reg, vip_hw_d_debug) (reg)->bitfields.VIP_HW_D_DEBUG = vip_hw_d_debug
#define set_VIP_HW_DEBUG_vip_hw_e_debug(reg, vip_hw_e_debug) (reg)->bitfields.VIP_HW_E_DEBUG = vip_hw_e_debug
#define set_VIP_HW_DEBUG_vip_hw_f_debug(reg, vip_hw_f_debug) (reg)->bitfields.VIP_HW_F_DEBUG = vip_hw_f_debug

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MEDIA_0_SCRATCH regMEDIA_0_SCRATCH;

#ifdef DEBUG
__inline void set_MEDIA_0_SCRATCH_media_0_scratch(regMEDIA_0_SCRATCH *reg, unsigned int media_0_scratch)
{
  reg->bitfields.MEDIA_0_SCRATCH = media_0_scratch;
  if (reg->bitfields.MEDIA_0_SCRATCH != media_0_scratch) HSLDPF(E_ERROR_MESSAGE,"MEDIA_0_SCRATCH::MEDIA_0_SCRATCH data too large\n");
}
#else
#define set_MEDIA_0_SCRATCH_media_0_scratch(reg, media_0_scratch) (reg)->bitfields.MEDIA_0_SCRATCH = media_0_scratch

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MEDIA_1_SCRATCH regMEDIA_1_SCRATCH;

#ifdef DEBUG
__inline void set_MEDIA_1_SCRATCH_media_1_scrach(regMEDIA_1_SCRATCH *reg, unsigned int media_1_scrach)
{
  reg->bitfields.MEDIA_1_SCRACH = media_1_scrach;
  if (reg->bitfields.MEDIA_1_SCRACH != media_1_scrach) HSLDPF(E_ERROR_MESSAGE,"MEDIA_1_SCRATCH::MEDIA_1_SCRACH data too large\n");
}
#else
#define set_MEDIA_1_SCRATCH_media_1_scrach(reg, media_1_scrach) (reg)->bitfields.MEDIA_1_SCRACH = media_1_scrach

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VID_BUFFER_CONTROL_M6 regVID_BUFFER_CONTROL_M6;

#ifdef DEBUG
__inline void set_VID_BUFFER_CONTROL_M6_cap0_buffer_water_mark(regVID_BUFFER_CONTROL_M6 *reg, unsigned int cap0_buffer_water_mark)
{
  reg->bitfields.CAP0_BUFFER_WATER_MARK = cap0_buffer_water_mark;
  if (reg->bitfields.CAP0_BUFFER_WATER_MARK != cap0_buffer_water_mark) HSLDPF(E_ERROR_MESSAGE,"VID_BUFFER_CONTROL_M6::CAP0_BUFFER_WATER_MARK data too large\n");
}
__inline void set_VID_BUFFER_CONTROL_M6_full_buffer_en(regVID_BUFFER_CONTROL_M6 *reg, unsigned int full_buffer_en)
{
  reg->bitfields.FULL_BUFFER_EN = full_buffer_en;
  if (reg->bitfields.FULL_BUFFER_EN != full_buffer_en) HSLDPF(E_ERROR_MESSAGE,"VID_BUFFER_CONTROL_M6::FULL_BUFFER_EN data too large\n");
}
__inline void set_VID_BUFFER_CONTROL_M6_cap0_anc_vbi_quad_buf(regVID_BUFFER_CONTROL_M6 *reg, unsigned int cap0_anc_vbi_quad_buf)
{
  reg->bitfields.CAP0_ANC_VBI_QUAD_BUF = cap0_anc_vbi_quad_buf;
  if (reg->bitfields.CAP0_ANC_VBI_QUAD_BUF != cap0_anc_vbi_quad_buf) HSLDPF(E_ERROR_MESSAGE,"VID_BUFFER_CONTROL_M6::CAP0_ANC_VBI_QUAD_BUF data too large\n");
}
__inline void set_VID_BUFFER_CONTROL_M6_vid_buffer_reset(regVID_BUFFER_CONTROL_M6 *reg, unsigned int vid_buffer_reset)
{
  reg->bitfields.VID_BUFFER_RESET = vid_buffer_reset;
  if (reg->bitfields.VID_BUFFER_RESET != vid_buffer_reset) HSLDPF(E_ERROR_MESSAGE,"VID_BUFFER_CONTROL_M6::VID_BUFFER_RESET data too large\n");
}
__inline void set_VID_BUFFER_CONTROL_M6_cap_swap(regVID_BUFFER_CONTROL_M6 *reg, unsigned int cap_swap)
{
  reg->bitfields.CAP_SWAP = cap_swap;
  if (reg->bitfields.CAP_SWAP != cap_swap) HSLDPF(E_ERROR_MESSAGE,"VID_BUFFER_CONTROL_M6::CAP_SWAP data too large\n");
}
__inline void set_VID_BUFFER_CONTROL_M6_cap0_buffer_empty(regVID_BUFFER_CONTROL_M6 *reg, unsigned int cap0_buffer_empty)
{
  reg->bitfields.CAP0_BUFFER_EMPTY = cap0_buffer_empty;
  if (reg->bitfields.CAP0_BUFFER_EMPTY != cap0_buffer_empty) HSLDPF(E_ERROR_MESSAGE,"VID_BUFFER_CONTROL_M6::CAP0_BUFFER_EMPTY data too large\n");
}
#else
#define set_VID_BUFFER_CONTROL_M6_cap0_buffer_water_mark(reg, cap0_buffer_water_mark) (reg)->bitfields.CAP0_BUFFER_WATER_MARK = cap0_buffer_water_mark
#define set_VID_BUFFER_CONTROL_M6_full_buffer_en(reg, full_buffer_en) (reg)->bitfields.FULL_BUFFER_EN = full_buffer_en
#define set_VID_BUFFER_CONTROL_M6_cap0_anc_vbi_quad_buf(reg, cap0_anc_vbi_quad_buf) (reg)->bitfields.CAP0_ANC_VBI_QUAD_BUF = cap0_anc_vbi_quad_buf
#define set_VID_BUFFER_CONTROL_M6_vid_buffer_reset(reg, vid_buffer_reset) (reg)->bitfields.VID_BUFFER_RESET = vid_buffer_reset
#define set_VID_BUFFER_CONTROL_M6_cap_swap(reg, cap_swap) (reg)->bitfields.CAP_SWAP = cap_swap
#define set_VID_BUFFER_CONTROL_M6_cap0_buffer_empty(reg, cap0_buffer_empty) (reg)->bitfields.CAP0_BUFFER_EMPTY = cap0_buffer_empty

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP_INT_CNTL regCAP_INT_CNTL;

#ifdef DEBUG
__inline void set_CAP_INT_CNTL_cap0_buf0_int_en(regCAP_INT_CNTL *reg, unsigned int cap0_buf0_int_en)
{
  reg->bitfields.CAP0_BUF0_INT_EN = cap0_buf0_int_en;
  if (reg->bitfields.CAP0_BUF0_INT_EN != cap0_buf0_int_en) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_CNTL::CAP0_BUF0_INT_EN data too large\n");
}
__inline void set_CAP_INT_CNTL_cap0_buf0_even_int_en(regCAP_INT_CNTL *reg, unsigned int cap0_buf0_even_int_en)
{
  reg->bitfields.CAP0_BUF0_EVEN_INT_EN = cap0_buf0_even_int_en;
  if (reg->bitfields.CAP0_BUF0_EVEN_INT_EN != cap0_buf0_even_int_en) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_CNTL::CAP0_BUF0_EVEN_INT_EN data too large\n");
}
__inline void set_CAP_INT_CNTL_cap0_buf1_int_en(regCAP_INT_CNTL *reg, unsigned int cap0_buf1_int_en)
{
  reg->bitfields.CAP0_BUF1_INT_EN = cap0_buf1_int_en;
  if (reg->bitfields.CAP0_BUF1_INT_EN != cap0_buf1_int_en) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_CNTL::CAP0_BUF1_INT_EN data too large\n");
}
__inline void set_CAP_INT_CNTL_cap0_buf1_even_int_en(regCAP_INT_CNTL *reg, unsigned int cap0_buf1_even_int_en)
{
  reg->bitfields.CAP0_BUF1_EVEN_INT_EN = cap0_buf1_even_int_en;
  if (reg->bitfields.CAP0_BUF1_EVEN_INT_EN != cap0_buf1_even_int_en) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_CNTL::CAP0_BUF1_EVEN_INT_EN data too large\n");
}
__inline void set_CAP_INT_CNTL_cap0_vbi0_int_en(regCAP_INT_CNTL *reg, unsigned int cap0_vbi0_int_en)
{
  reg->bitfields.CAP0_VBI0_INT_EN = cap0_vbi0_int_en;
  if (reg->bitfields.CAP0_VBI0_INT_EN != cap0_vbi0_int_en) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_CNTL::CAP0_VBI0_INT_EN data too large\n");
}
__inline void set_CAP_INT_CNTL_cap0_vbi1_int_en(regCAP_INT_CNTL *reg, unsigned int cap0_vbi1_int_en)
{
  reg->bitfields.CAP0_VBI1_INT_EN = cap0_vbi1_int_en;
  if (reg->bitfields.CAP0_VBI1_INT_EN != cap0_vbi1_int_en) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_CNTL::CAP0_VBI1_INT_EN data too large\n");
}
__inline void set_CAP_INT_CNTL_cap0_oneshot_int_en(regCAP_INT_CNTL *reg, unsigned int cap0_oneshot_int_en)
{
  reg->bitfields.CAP0_ONESHOT_INT_EN = cap0_oneshot_int_en;
  if (reg->bitfields.CAP0_ONESHOT_INT_EN != cap0_oneshot_int_en) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_CNTL::CAP0_ONESHOT_INT_EN data too large\n");
}
__inline void set_CAP_INT_CNTL_cap0_anc0_int_en(regCAP_INT_CNTL *reg, unsigned int cap0_anc0_int_en)
{
  reg->bitfields.CAP0_ANC0_INT_EN = cap0_anc0_int_en;
  if (reg->bitfields.CAP0_ANC0_INT_EN != cap0_anc0_int_en) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_CNTL::CAP0_ANC0_INT_EN data too large\n");
}
__inline void set_CAP_INT_CNTL_cap0_anc1_int_en(regCAP_INT_CNTL *reg, unsigned int cap0_anc1_int_en)
{
  reg->bitfields.CAP0_ANC1_INT_EN = cap0_anc1_int_en;
  if (reg->bitfields.CAP0_ANC1_INT_EN != cap0_anc1_int_en) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_CNTL::CAP0_ANC1_INT_EN data too large\n");
}
__inline void set_CAP_INT_CNTL_cap0_vbi2_int_en(regCAP_INT_CNTL *reg, unsigned int cap0_vbi2_int_en)
{
  reg->bitfields.CAP0_VBI2_INT_EN = cap0_vbi2_int_en;
  if (reg->bitfields.CAP0_VBI2_INT_EN != cap0_vbi2_int_en) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_CNTL::CAP0_VBI2_INT_EN data too large\n");
}
__inline void set_CAP_INT_CNTL_cap0_vbi3_int_en(regCAP_INT_CNTL *reg, unsigned int cap0_vbi3_int_en)
{
  reg->bitfields.CAP0_VBI3_INT_EN = cap0_vbi3_int_en;
  if (reg->bitfields.CAP0_VBI3_INT_EN != cap0_vbi3_int_en) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_CNTL::CAP0_VBI3_INT_EN data too large\n");
}
__inline void set_CAP_INT_CNTL_cap0_anc2_int_en(regCAP_INT_CNTL *reg, unsigned int cap0_anc2_int_en)
{
  reg->bitfields.CAP0_ANC2_INT_EN = cap0_anc2_int_en;
  if (reg->bitfields.CAP0_ANC2_INT_EN != cap0_anc2_int_en) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_CNTL::CAP0_ANC2_INT_EN data too large\n");
}
__inline void set_CAP_INT_CNTL_cap0_anc3_int_en(regCAP_INT_CNTL *reg, unsigned int cap0_anc3_int_en)
{
  reg->bitfields.CAP0_ANC3_INT_EN = cap0_anc3_int_en;
  if (reg->bitfields.CAP0_ANC3_INT_EN != cap0_anc3_int_en) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_CNTL::CAP0_ANC3_INT_EN data too large\n");
}
#else
#define set_CAP_INT_CNTL_cap0_buf0_int_en(reg, cap0_buf0_int_en) (reg)->bitfields.CAP0_BUF0_INT_EN = cap0_buf0_int_en
#define set_CAP_INT_CNTL_cap0_buf0_even_int_en(reg, cap0_buf0_even_int_en) (reg)->bitfields.CAP0_BUF0_EVEN_INT_EN = cap0_buf0_even_int_en
#define set_CAP_INT_CNTL_cap0_buf1_int_en(reg, cap0_buf1_int_en) (reg)->bitfields.CAP0_BUF1_INT_EN = cap0_buf1_int_en
#define set_CAP_INT_CNTL_cap0_buf1_even_int_en(reg, cap0_buf1_even_int_en) (reg)->bitfields.CAP0_BUF1_EVEN_INT_EN = cap0_buf1_even_int_en
#define set_CAP_INT_CNTL_cap0_vbi0_int_en(reg, cap0_vbi0_int_en) (reg)->bitfields.CAP0_VBI0_INT_EN = cap0_vbi0_int_en
#define set_CAP_INT_CNTL_cap0_vbi1_int_en(reg, cap0_vbi1_int_en) (reg)->bitfields.CAP0_VBI1_INT_EN = cap0_vbi1_int_en
#define set_CAP_INT_CNTL_cap0_oneshot_int_en(reg, cap0_oneshot_int_en) (reg)->bitfields.CAP0_ONESHOT_INT_EN = cap0_oneshot_int_en
#define set_CAP_INT_CNTL_cap0_anc0_int_en(reg, cap0_anc0_int_en) (reg)->bitfields.CAP0_ANC0_INT_EN = cap0_anc0_int_en
#define set_CAP_INT_CNTL_cap0_anc1_int_en(reg, cap0_anc1_int_en) (reg)->bitfields.CAP0_ANC1_INT_EN = cap0_anc1_int_en
#define set_CAP_INT_CNTL_cap0_vbi2_int_en(reg, cap0_vbi2_int_en) (reg)->bitfields.CAP0_VBI2_INT_EN = cap0_vbi2_int_en
#define set_CAP_INT_CNTL_cap0_vbi3_int_en(reg, cap0_vbi3_int_en) (reg)->bitfields.CAP0_VBI3_INT_EN = cap0_vbi3_int_en
#define set_CAP_INT_CNTL_cap0_anc2_int_en(reg, cap0_anc2_int_en) (reg)->bitfields.CAP0_ANC2_INT_EN = cap0_anc2_int_en
#define set_CAP_INT_CNTL_cap0_anc3_int_en(reg, cap0_anc3_int_en) (reg)->bitfields.CAP0_ANC3_INT_EN = cap0_anc3_int_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP_INT_STATUS regCAP_INT_STATUS;

#ifdef DEBUG
__inline void set_CAP_INT_STATUS_cap0_buf0_int(regCAP_INT_STATUS *reg, unsigned int cap0_buf0_int)
{
  reg->bitfields.CAP0_BUF0_INT = cap0_buf0_int;
  if (reg->bitfields.CAP0_BUF0_INT != cap0_buf0_int) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_STATUS::CAP0_BUF0_INT data too large\n");
}
__inline void set_CAP_INT_STATUS_cap0_buf0_even_int(regCAP_INT_STATUS *reg, unsigned int cap0_buf0_even_int)
{
  reg->bitfields.CAP0_BUF0_EVEN_INT = cap0_buf0_even_int;
  if (reg->bitfields.CAP0_BUF0_EVEN_INT != cap0_buf0_even_int) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_STATUS::CAP0_BUF0_EVEN_INT data too large\n");
}
__inline void set_CAP_INT_STATUS_cap0_buf1_int(regCAP_INT_STATUS *reg, unsigned int cap0_buf1_int)
{
  reg->bitfields.CAP0_BUF1_INT = cap0_buf1_int;
  if (reg->bitfields.CAP0_BUF1_INT != cap0_buf1_int) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_STATUS::CAP0_BUF1_INT data too large\n");
}
__inline void set_CAP_INT_STATUS_cap0_buf1_even_int(regCAP_INT_STATUS *reg, unsigned int cap0_buf1_even_int)
{
  reg->bitfields.CAP0_BUF1_EVEN_INT = cap0_buf1_even_int;
  if (reg->bitfields.CAP0_BUF1_EVEN_INT != cap0_buf1_even_int) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_STATUS::CAP0_BUF1_EVEN_INT data too large\n");
}
__inline void set_CAP_INT_STATUS_cap0_vbi0_int(regCAP_INT_STATUS *reg, unsigned int cap0_vbi0_int)
{
  reg->bitfields.CAP0_VBI0_INT = cap0_vbi0_int;
  if (reg->bitfields.CAP0_VBI0_INT != cap0_vbi0_int) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_STATUS::CAP0_VBI0_INT data too large\n");
}
__inline void set_CAP_INT_STATUS_cap0_vbi1_int(regCAP_INT_STATUS *reg, unsigned int cap0_vbi1_int)
{
  reg->bitfields.CAP0_VBI1_INT = cap0_vbi1_int;
  if (reg->bitfields.CAP0_VBI1_INT != cap0_vbi1_int) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_STATUS::CAP0_VBI1_INT data too large\n");
}
__inline void set_CAP_INT_STATUS_cap0_oneshot_int(regCAP_INT_STATUS *reg, unsigned int cap0_oneshot_int)
{
  reg->bitfields.CAP0_ONESHOT_INT = cap0_oneshot_int;
  if (reg->bitfields.CAP0_ONESHOT_INT != cap0_oneshot_int) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_STATUS::CAP0_ONESHOT_INT data too large\n");
}
__inline void set_CAP_INT_STATUS_cap0_anc0_int(regCAP_INT_STATUS *reg, unsigned int cap0_anc0_int)
{
  reg->bitfields.CAP0_ANC0_INT = cap0_anc0_int;
  if (reg->bitfields.CAP0_ANC0_INT != cap0_anc0_int) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_STATUS::CAP0_ANC0_INT data too large\n");
}
__inline void set_CAP_INT_STATUS_cap0_anc1_int(regCAP_INT_STATUS *reg, unsigned int cap0_anc1_int)
{
  reg->bitfields.CAP0_ANC1_INT = cap0_anc1_int;
  if (reg->bitfields.CAP0_ANC1_INT != cap0_anc1_int) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_STATUS::CAP0_ANC1_INT data too large\n");
}
__inline void set_CAP_INT_STATUS_cap0_vbi2_int(regCAP_INT_STATUS *reg, unsigned int cap0_vbi2_int)
{
  reg->bitfields.CAP0_VBI2_INT = cap0_vbi2_int;
  if (reg->bitfields.CAP0_VBI2_INT != cap0_vbi2_int) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_STATUS::CAP0_VBI2_INT data too large\n");
}
__inline void set_CAP_INT_STATUS_cap0_vbi3_int(regCAP_INT_STATUS *reg, unsigned int cap0_vbi3_int)
{
  reg->bitfields.CAP0_VBI3_INT = cap0_vbi3_int;
  if (reg->bitfields.CAP0_VBI3_INT != cap0_vbi3_int) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_STATUS::CAP0_VBI3_INT data too large\n");
}
__inline void set_CAP_INT_STATUS_cap0_anc2_int(regCAP_INT_STATUS *reg, unsigned int cap0_anc2_int)
{
  reg->bitfields.CAP0_ANC2_INT = cap0_anc2_int;
  if (reg->bitfields.CAP0_ANC2_INT != cap0_anc2_int) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_STATUS::CAP0_ANC2_INT data too large\n");
}
__inline void set_CAP_INT_STATUS_cap0_anc3_int(regCAP_INT_STATUS *reg, unsigned int cap0_anc3_int)
{
  reg->bitfields.CAP0_ANC3_INT = cap0_anc3_int;
  if (reg->bitfields.CAP0_ANC3_INT != cap0_anc3_int) HSLDPF(E_ERROR_MESSAGE,"CAP_INT_STATUS::CAP0_ANC3_INT data too large\n");
}
#else
#define set_CAP_INT_STATUS_cap0_buf0_int(reg, cap0_buf0_int) (reg)->bitfields.CAP0_BUF0_INT = cap0_buf0_int
#define set_CAP_INT_STATUS_cap0_buf0_even_int(reg, cap0_buf0_even_int) (reg)->bitfields.CAP0_BUF0_EVEN_INT = cap0_buf0_even_int
#define set_CAP_INT_STATUS_cap0_buf1_int(reg, cap0_buf1_int) (reg)->bitfields.CAP0_BUF1_INT = cap0_buf1_int
#define set_CAP_INT_STATUS_cap0_buf1_even_int(reg, cap0_buf1_even_int) (reg)->bitfields.CAP0_BUF1_EVEN_INT = cap0_buf1_even_int
#define set_CAP_INT_STATUS_cap0_vbi0_int(reg, cap0_vbi0_int) (reg)->bitfields.CAP0_VBI0_INT = cap0_vbi0_int
#define set_CAP_INT_STATUS_cap0_vbi1_int(reg, cap0_vbi1_int) (reg)->bitfields.CAP0_VBI1_INT = cap0_vbi1_int
#define set_CAP_INT_STATUS_cap0_oneshot_int(reg, cap0_oneshot_int) (reg)->bitfields.CAP0_ONESHOT_INT = cap0_oneshot_int
#define set_CAP_INT_STATUS_cap0_anc0_int(reg, cap0_anc0_int) (reg)->bitfields.CAP0_ANC0_INT = cap0_anc0_int
#define set_CAP_INT_STATUS_cap0_anc1_int(reg, cap0_anc1_int) (reg)->bitfields.CAP0_ANC1_INT = cap0_anc1_int
#define set_CAP_INT_STATUS_cap0_vbi2_int(reg, cap0_vbi2_int) (reg)->bitfields.CAP0_VBI2_INT = cap0_vbi2_int
#define set_CAP_INT_STATUS_cap0_vbi3_int(reg, cap0_vbi3_int) (reg)->bitfields.CAP0_VBI3_INT = cap0_vbi3_int
#define set_CAP_INT_STATUS_cap0_anc2_int(reg, cap0_anc2_int) (reg)->bitfields.CAP0_ANC2_INT = cap0_anc2_int
#define set_CAP_INT_STATUS_cap0_anc3_int(reg, cap0_anc3_int) (reg)->bitfields.CAP0_ANC3_INT = cap0_anc3_int

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union FCP_CNTL regFCP_CNTL;

#ifdef DEBUG
__inline void set_FCP_CNTL_fcp0_src_sel(regFCP_CNTL *reg, unsigned int fcp0_src_sel)
{
  reg->bitfields.FCP0_SRC_SEL = fcp0_src_sel;
  if (reg->bitfields.FCP0_SRC_SEL != fcp0_src_sel) HSLDPF(E_ERROR_MESSAGE,"FCP_CNTL::FCP0_SRC_SEL data too large\n");
}
#else
#define set_FCP_CNTL_fcp0_src_sel(reg, fcp0_src_sel) (reg)->bitfields.FCP0_SRC_SEL = fcp0_src_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_BUF0_OFFSET regCAP0_BUF0_OFFSET;

#ifdef DEBUG
__inline void set_CAP0_BUF0_OFFSET_cap_buf0_offset(regCAP0_BUF0_OFFSET *reg, unsigned int cap_buf0_offset)
{
  reg->bitfields.CAP_BUF0_OFFSET = cap_buf0_offset;
  if (reg->bitfields.CAP_BUF0_OFFSET != cap_buf0_offset) HSLDPF(E_ERROR_MESSAGE,"CAP0_BUF0_OFFSET::CAP_BUF0_OFFSET data too large\n");
}
#else
#define set_CAP0_BUF0_OFFSET_cap_buf0_offset(reg, cap_buf0_offset) (reg)->bitfields.CAP_BUF0_OFFSET = cap_buf0_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_BUF1_OFFSET regCAP0_BUF1_OFFSET;

#ifdef DEBUG
__inline void set_CAP0_BUF1_OFFSET_cap_buf1_offset(regCAP0_BUF1_OFFSET *reg, unsigned int cap_buf1_offset)
{
  reg->bitfields.CAP_BUF1_OFFSET = cap_buf1_offset;
  if (reg->bitfields.CAP_BUF1_OFFSET != cap_buf1_offset) HSLDPF(E_ERROR_MESSAGE,"CAP0_BUF1_OFFSET::CAP_BUF1_OFFSET data too large\n");
}
#else
#define set_CAP0_BUF1_OFFSET_cap_buf1_offset(reg, cap_buf1_offset) (reg)->bitfields.CAP_BUF1_OFFSET = cap_buf1_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_BUF0_EVEN_OFFSET regCAP0_BUF0_EVEN_OFFSET;

#ifdef DEBUG
__inline void set_CAP0_BUF0_EVEN_OFFSET_cap_buf0_even_offset(regCAP0_BUF0_EVEN_OFFSET *reg, unsigned int cap_buf0_even_offset)
{
  reg->bitfields.CAP_BUF0_EVEN_OFFSET = cap_buf0_even_offset;
  if (reg->bitfields.CAP_BUF0_EVEN_OFFSET != cap_buf0_even_offset) HSLDPF(E_ERROR_MESSAGE,"CAP0_BUF0_EVEN_OFFSET::CAP_BUF0_EVEN_OFFSET data too large\n");
}
#else
#define set_CAP0_BUF0_EVEN_OFFSET_cap_buf0_even_offset(reg, cap_buf0_even_offset) (reg)->bitfields.CAP_BUF0_EVEN_OFFSET = cap_buf0_even_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_BUF1_EVEN_OFFSET regCAP0_BUF1_EVEN_OFFSET;

#ifdef DEBUG
__inline void set_CAP0_BUF1_EVEN_OFFSET_cap_buf1_even_offset(regCAP0_BUF1_EVEN_OFFSET *reg, unsigned int cap_buf1_even_offset)
{
  reg->bitfields.CAP_BUF1_EVEN_OFFSET = cap_buf1_even_offset;
  if (reg->bitfields.CAP_BUF1_EVEN_OFFSET != cap_buf1_even_offset) HSLDPF(E_ERROR_MESSAGE,"CAP0_BUF1_EVEN_OFFSET::CAP_BUF1_EVEN_OFFSET data too large\n");
}
#else
#define set_CAP0_BUF1_EVEN_OFFSET_cap_buf1_even_offset(reg, cap_buf1_even_offset) (reg)->bitfields.CAP_BUF1_EVEN_OFFSET = cap_buf1_even_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_BUF_PITCH regCAP0_BUF_PITCH;

#ifdef DEBUG
__inline void set_CAP0_BUF_PITCH_cap_buf_pitch(regCAP0_BUF_PITCH *reg, unsigned int cap_buf_pitch)
{
  reg->bitfields.CAP_BUF_PITCH = cap_buf_pitch;
  if (reg->bitfields.CAP_BUF_PITCH != cap_buf_pitch) HSLDPF(E_ERROR_MESSAGE,"CAP0_BUF_PITCH::CAP_BUF_PITCH data too large\n");
}
#else
#define set_CAP0_BUF_PITCH_cap_buf_pitch(reg, cap_buf_pitch) (reg)->bitfields.CAP_BUF_PITCH = cap_buf_pitch

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_V_WINDOW regCAP0_V_WINDOW;

#ifdef DEBUG
__inline void set_CAP0_V_WINDOW_cap_v_start(regCAP0_V_WINDOW *reg, unsigned int cap_v_start)
{
  reg->bitfields.CAP_V_START = cap_v_start;
  if (reg->bitfields.CAP_V_START != cap_v_start) HSLDPF(E_ERROR_MESSAGE,"CAP0_V_WINDOW::CAP_V_START data too large\n");
}
__inline void set_CAP0_V_WINDOW_cap_v_end(regCAP0_V_WINDOW *reg, unsigned int cap_v_end)
{
  reg->bitfields.CAP_V_END = cap_v_end;
  if (reg->bitfields.CAP_V_END != cap_v_end) HSLDPF(E_ERROR_MESSAGE,"CAP0_V_WINDOW::CAP_V_END data too large\n");
}
#else
#define set_CAP0_V_WINDOW_cap_v_start(reg, cap_v_start) (reg)->bitfields.CAP_V_START = cap_v_start
#define set_CAP0_V_WINDOW_cap_v_end(reg, cap_v_end) (reg)->bitfields.CAP_V_END = cap_v_end

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_H_WINDOW regCAP0_H_WINDOW;

#ifdef DEBUG
__inline void set_CAP0_H_WINDOW_cap_h_start(regCAP0_H_WINDOW *reg, unsigned int cap_h_start)
{
  reg->bitfields.CAP_H_START = cap_h_start;
  if (reg->bitfields.CAP_H_START != cap_h_start) HSLDPF(E_ERROR_MESSAGE,"CAP0_H_WINDOW::CAP_H_START data too large\n");
}
__inline void set_CAP0_H_WINDOW_cap_h_width(regCAP0_H_WINDOW *reg, unsigned int cap_h_width)
{
  reg->bitfields.CAP_H_WIDTH = cap_h_width;
  if (reg->bitfields.CAP_H_WIDTH != cap_h_width) HSLDPF(E_ERROR_MESSAGE,"CAP0_H_WINDOW::CAP_H_WIDTH data too large\n");
}
#else
#define set_CAP0_H_WINDOW_cap_h_start(reg, cap_h_start) (reg)->bitfields.CAP_H_START = cap_h_start
#define set_CAP0_H_WINDOW_cap_h_width(reg, cap_h_width) (reg)->bitfields.CAP_H_WIDTH = cap_h_width

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_VBI0_OFFSET regCAP0_VBI0_OFFSET;

#ifdef DEBUG
__inline void set_CAP0_VBI0_OFFSET_cap_vbi0_offset(regCAP0_VBI0_OFFSET *reg, unsigned int cap_vbi0_offset)
{
  reg->bitfields.CAP_VBI0_OFFSET = cap_vbi0_offset;
  if (reg->bitfields.CAP_VBI0_OFFSET != cap_vbi0_offset) HSLDPF(E_ERROR_MESSAGE,"CAP0_VBI0_OFFSET::CAP_VBI0_OFFSET data too large\n");
}
#else
#define set_CAP0_VBI0_OFFSET_cap_vbi0_offset(reg, cap_vbi0_offset) (reg)->bitfields.CAP_VBI0_OFFSET = cap_vbi0_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_VBI1_OFFSET regCAP0_VBI1_OFFSET;

#ifdef DEBUG
__inline void set_CAP0_VBI1_OFFSET_cap_vbi1_offset(regCAP0_VBI1_OFFSET *reg, unsigned int cap_vbi1_offset)
{
  reg->bitfields.CAP_VBI1_OFFSET = cap_vbi1_offset;
  if (reg->bitfields.CAP_VBI1_OFFSET != cap_vbi1_offset) HSLDPF(E_ERROR_MESSAGE,"CAP0_VBI1_OFFSET::CAP_VBI1_OFFSET data too large\n");
}
#else
#define set_CAP0_VBI1_OFFSET_cap_vbi1_offset(reg, cap_vbi1_offset) (reg)->bitfields.CAP_VBI1_OFFSET = cap_vbi1_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_VBI_V_WINDOW regCAP0_VBI_V_WINDOW;

#ifdef DEBUG
__inline void set_CAP0_VBI_V_WINDOW_cap_vbi_v_start(regCAP0_VBI_V_WINDOW *reg, unsigned int cap_vbi_v_start)
{
  reg->bitfields.CAP_VBI_V_START = cap_vbi_v_start;
  if (reg->bitfields.CAP_VBI_V_START != cap_vbi_v_start) HSLDPF(E_ERROR_MESSAGE,"CAP0_VBI_V_WINDOW::CAP_VBI_V_START data too large\n");
}
__inline void set_CAP0_VBI_V_WINDOW_cap_vbi_v_end(regCAP0_VBI_V_WINDOW *reg, unsigned int cap_vbi_v_end)
{
  reg->bitfields.CAP_VBI_V_END = cap_vbi_v_end;
  if (reg->bitfields.CAP_VBI_V_END != cap_vbi_v_end) HSLDPF(E_ERROR_MESSAGE,"CAP0_VBI_V_WINDOW::CAP_VBI_V_END data too large\n");
}
#else
#define set_CAP0_VBI_V_WINDOW_cap_vbi_v_start(reg, cap_vbi_v_start) (reg)->bitfields.CAP_VBI_V_START = cap_vbi_v_start
#define set_CAP0_VBI_V_WINDOW_cap_vbi_v_end(reg, cap_vbi_v_end) (reg)->bitfields.CAP_VBI_V_END = cap_vbi_v_end

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_VBI_H_WINDOW regCAP0_VBI_H_WINDOW;

#ifdef DEBUG
__inline void set_CAP0_VBI_H_WINDOW_cap_vbi_h_start(regCAP0_VBI_H_WINDOW *reg, unsigned int cap_vbi_h_start)
{
  reg->bitfields.CAP_VBI_H_START = cap_vbi_h_start;
  if (reg->bitfields.CAP_VBI_H_START != cap_vbi_h_start) HSLDPF(E_ERROR_MESSAGE,"CAP0_VBI_H_WINDOW::CAP_VBI_H_START data too large\n");
}
__inline void set_CAP0_VBI_H_WINDOW_cap_vbi_h_width(regCAP0_VBI_H_WINDOW *reg, unsigned int cap_vbi_h_width)
{
  reg->bitfields.CAP_VBI_H_WIDTH = cap_vbi_h_width;
  if (reg->bitfields.CAP_VBI_H_WIDTH != cap_vbi_h_width) HSLDPF(E_ERROR_MESSAGE,"CAP0_VBI_H_WINDOW::CAP_VBI_H_WIDTH data too large\n");
}
#else
#define set_CAP0_VBI_H_WINDOW_cap_vbi_h_start(reg, cap_vbi_h_start) (reg)->bitfields.CAP_VBI_H_START = cap_vbi_h_start
#define set_CAP0_VBI_H_WINDOW_cap_vbi_h_width(reg, cap_vbi_h_width) (reg)->bitfields.CAP_VBI_H_WIDTH = cap_vbi_h_width

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_PORT_MODE_CNTL regCAP0_PORT_MODE_CNTL;

#ifdef DEBUG
__inline void set_CAP0_PORT_MODE_CNTL_cap_port_width(regCAP0_PORT_MODE_CNTL *reg, unsigned int cap_port_width)
{
  reg->bitfields.CAP_PORT_WIDTH = cap_port_width;
  if (reg->bitfields.CAP_PORT_WIDTH != cap_port_width) HSLDPF(E_ERROR_MESSAGE,"CAP0_PORT_MODE_CNTL::CAP_PORT_WIDTH data too large\n");
}
__inline void set_CAP0_PORT_MODE_CNTL_cap_port_byte_used(regCAP0_PORT_MODE_CNTL *reg, unsigned int cap_port_byte_used)
{
  reg->bitfields.CAP_PORT_BYTE_USED = cap_port_byte_used;
  if (reg->bitfields.CAP_PORT_BYTE_USED != cap_port_byte_used) HSLDPF(E_ERROR_MESSAGE,"CAP0_PORT_MODE_CNTL::CAP_PORT_BYTE_USED data too large\n");
}
#else
#define set_CAP0_PORT_MODE_CNTL_cap_port_width(reg, cap_port_width) (reg)->bitfields.CAP_PORT_WIDTH = cap_port_width
#define set_CAP0_PORT_MODE_CNTL_cap_port_byte_used(reg, cap_port_byte_used) (reg)->bitfields.CAP_PORT_BYTE_USED = cap_port_byte_used

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_TRIG_CNTL regCAP0_TRIG_CNTL;

#ifdef DEBUG
__inline void set_CAP0_TRIG_CNTL_cap_trigger_r(regCAP0_TRIG_CNTL *reg, unsigned int cap_trigger_r)
{
  reg->bitfields.CAP_TRIGGER_R = cap_trigger_r;
  if (reg->bitfields.CAP_TRIGGER_R != cap_trigger_r) HSLDPF(E_ERROR_MESSAGE,"CAP0_TRIG_CNTL::CAP_TRIGGER_R data too large\n");
}
__inline void set_CAP0_TRIG_CNTL_cap_en(regCAP0_TRIG_CNTL *reg, unsigned int cap_en)
{
  reg->bitfields.CAP_EN = cap_en;
  if (reg->bitfields.CAP_EN != cap_en) HSLDPF(E_ERROR_MESSAGE,"CAP0_TRIG_CNTL::CAP_EN data too large\n");
}
__inline void set_CAP0_TRIG_CNTL_cap_vsync_cnt(regCAP0_TRIG_CNTL *reg, unsigned int cap_vsync_cnt)
{
  reg->bitfields.CAP_VSYNC_CNT = cap_vsync_cnt;
  if (reg->bitfields.CAP_VSYNC_CNT != cap_vsync_cnt) HSLDPF(E_ERROR_MESSAGE,"CAP0_TRIG_CNTL::CAP_VSYNC_CNT data too large\n");
}
__inline void set_CAP0_TRIG_CNTL_cap_vsync_clr(regCAP0_TRIG_CNTL *reg, unsigned int cap_vsync_clr)
{
  reg->bitfields.CAP_VSYNC_CLR = cap_vsync_clr;
  if (reg->bitfields.CAP_VSYNC_CLR != cap_vsync_clr) HSLDPF(E_ERROR_MESSAGE,"CAP0_TRIG_CNTL::CAP_VSYNC_CLR data too large\n");
}
#else
#define set_CAP0_TRIG_CNTL_cap_trigger_r(reg, cap_trigger_r) (reg)->bitfields.CAP_TRIGGER_R = cap_trigger_r
#define set_CAP0_TRIG_CNTL_cap_en(reg, cap_en) (reg)->bitfields.CAP_EN = cap_en
#define set_CAP0_TRIG_CNTL_cap_vsync_cnt(reg, cap_vsync_cnt) (reg)->bitfields.CAP_VSYNC_CNT = cap_vsync_cnt
#define set_CAP0_TRIG_CNTL_cap_vsync_clr(reg, cap_vsync_clr) (reg)->bitfields.CAP_VSYNC_CLR = cap_vsync_clr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_DEBUG regCAP0_DEBUG;

#ifdef DEBUG
__inline void set_CAP0_DEBUG_cap_h_status(regCAP0_DEBUG *reg, unsigned int cap_h_status)
{
  reg->bitfields.CAP_H_STATUS = cap_h_status;
  if (reg->bitfields.CAP_H_STATUS != cap_h_status) HSLDPF(E_ERROR_MESSAGE,"CAP0_DEBUG::CAP_H_STATUS data too large\n");
}
__inline void set_CAP0_DEBUG_cap_v_status(regCAP0_DEBUG *reg, unsigned int cap_v_status)
{
  reg->bitfields.CAP_V_STATUS = cap_v_status;
  if (reg->bitfields.CAP_V_STATUS != cap_v_status) HSLDPF(E_ERROR_MESSAGE,"CAP0_DEBUG::CAP_V_STATUS data too large\n");
}
__inline void set_CAP0_DEBUG_cap_v_sync(regCAP0_DEBUG *reg, unsigned int cap_v_sync)
{
  reg->bitfields.CAP_V_SYNC = cap_v_sync;
  if (reg->bitfields.CAP_V_SYNC != cap_v_sync) HSLDPF(E_ERROR_MESSAGE,"CAP0_DEBUG::CAP_V_SYNC data too large\n");
}
__inline void set_CAP0_DEBUG_cap_buf_overflow_status(regCAP0_DEBUG *reg, unsigned int cap_buf_overflow_status)
{
  reg->bitfields.CAP_BUF_OVERFLOW_STATUS = cap_buf_overflow_status;
  if (reg->bitfields.CAP_BUF_OVERFLOW_STATUS != cap_buf_overflow_status) HSLDPF(E_ERROR_MESSAGE,"CAP0_DEBUG::CAP_BUF_OVERFLOW_STATUS data too large\n");
}
__inline void set_CAP0_DEBUG_cap_buf_overflow_clr(regCAP0_DEBUG *reg, unsigned int cap_buf_overflow_clr)
{
  reg->bitfields.CAP_BUF_OVERFLOW_CLR = cap_buf_overflow_clr;
  if (reg->bitfields.CAP_BUF_OVERFLOW_CLR != cap_buf_overflow_clr) HSLDPF(E_ERROR_MESSAGE,"CAP0_DEBUG::CAP_BUF_OVERFLOW_CLR data too large\n");
}
#else
#define set_CAP0_DEBUG_cap_h_status(reg, cap_h_status) (reg)->bitfields.CAP_H_STATUS = cap_h_status
#define set_CAP0_DEBUG_cap_v_status(reg, cap_v_status) (reg)->bitfields.CAP_V_STATUS = cap_v_status
#define set_CAP0_DEBUG_cap_v_sync(reg, cap_v_sync) (reg)->bitfields.CAP_V_SYNC = cap_v_sync
#define set_CAP0_DEBUG_cap_buf_overflow_status(reg, cap_buf_overflow_status) (reg)->bitfields.CAP_BUF_OVERFLOW_STATUS = cap_buf_overflow_status
#define set_CAP0_DEBUG_cap_buf_overflow_clr(reg, cap_buf_overflow_clr) (reg)->bitfields.CAP_BUF_OVERFLOW_CLR = cap_buf_overflow_clr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250CAP0_CONFIG regrv250CAP0_CONFIG;

#ifdef DEBUG
__inline void set_rv250CAP0_CONFIG_cap_input_mode(regrv250CAP0_CONFIG *reg, unsigned int cap_input_mode)
{
  reg->bitfields.CAP_INPUT_MODE = cap_input_mode;
  if (reg->bitfields.CAP_INPUT_MODE != cap_input_mode) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_INPUT_MODE data too large\n");
}
__inline void set_rv250CAP0_CONFIG_cap_start_field(regrv250CAP0_CONFIG *reg, unsigned int cap_start_field)
{
  reg->bitfields.CAP_START_FIELD = cap_start_field;
  if (reg->bitfields.CAP_START_FIELD != cap_start_field) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_START_FIELD data too large\n");
}
__inline void set_rv250CAP0_CONFIG_cap_start_buf_r(regrv250CAP0_CONFIG *reg, unsigned int cap_start_buf_r)
{
  reg->bitfields.CAP_START_BUF_R = cap_start_buf_r;
  if (reg->bitfields.CAP_START_BUF_R != cap_start_buf_r) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_START_BUF_R data too large\n");
}
__inline void set_rv250CAP0_CONFIG_cap_start_buf_w(regrv250CAP0_CONFIG *reg, unsigned int cap_start_buf_w)
{
  reg->bitfields.CAP_START_BUF_W = cap_start_buf_w;
  if (reg->bitfields.CAP_START_BUF_W != cap_start_buf_w) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_START_BUF_W data too large\n");
}
__inline void set_rv250CAP0_CONFIG_cap_buf_type(regrv250CAP0_CONFIG *reg, unsigned int cap_buf_type)
{
  reg->bitfields.CAP_BUF_TYPE = cap_buf_type;
  if (reg->bitfields.CAP_BUF_TYPE != cap_buf_type) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_BUF_TYPE data too large\n");
}
__inline void set_rv250CAP0_CONFIG_cap_oneshot_mode(regrv250CAP0_CONFIG *reg, unsigned int cap_oneshot_mode)
{
  reg->bitfields.CAP_ONESHOT_MODE = cap_oneshot_mode;
  if (reg->bitfields.CAP_ONESHOT_MODE != cap_oneshot_mode) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_ONESHOT_MODE data too large\n");
}
__inline void set_rv250CAP0_CONFIG_cap_buf_mode(regrv250CAP0_CONFIG *reg, unsigned int cap_buf_mode)
{
  reg->bitfields.CAP_BUF_MODE = cap_buf_mode;
  if (reg->bitfields.CAP_BUF_MODE != cap_buf_mode) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_BUF_MODE data too large\n");
}
__inline void set_rv250CAP0_CONFIG_cap_mirror_en(regrv250CAP0_CONFIG *reg, unsigned int cap_mirror_en)
{
  reg->bitfields.CAP_MIRROR_EN = cap_mirror_en;
  if (reg->bitfields.CAP_MIRROR_EN != cap_mirror_en) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_MIRROR_EN data too large\n");
}
__inline void set_rv250CAP0_CONFIG_cap_oneshot_mirror_en(regrv250CAP0_CONFIG *reg, unsigned int cap_oneshot_mirror_en)
{
  reg->bitfields.CAP_ONESHOT_MIRROR_EN = cap_oneshot_mirror_en;
  if (reg->bitfields.CAP_ONESHOT_MIRROR_EN != cap_oneshot_mirror_en) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_ONESHOT_MIRROR_EN data too large\n");
}
__inline void set_rv250CAP0_CONFIG_cap_video_signed_uv(regrv250CAP0_CONFIG *reg, unsigned int cap_video_signed_uv)
{
  reg->bitfields.CAP_VIDEO_SIGNED_UV = cap_video_signed_uv;
  if (reg->bitfields.CAP_VIDEO_SIGNED_UV != cap_video_signed_uv) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_VIDEO_SIGNED_UV data too large\n");
}
__inline void set_rv250CAP0_CONFIG_cap_anc_decode_en(regrv250CAP0_CONFIG *reg, unsigned int cap_anc_decode_en)
{
  reg->bitfields.CAP_ANC_DECODE_EN = cap_anc_decode_en;
  if (reg->bitfields.CAP_ANC_DECODE_EN != cap_anc_decode_en) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_ANC_DECODE_EN data too large\n");
}
__inline void set_rv250CAP0_CONFIG_cap_vbi_en(regrv250CAP0_CONFIG *reg, unsigned int cap_vbi_en)
{
  reg->bitfields.CAP_VBI_EN = cap_vbi_en;
  if (reg->bitfields.CAP_VBI_EN != cap_vbi_en) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_VBI_EN data too large\n");
}
__inline void set_rv250CAP0_CONFIG_cap_soft_pull_down_en(regrv250CAP0_CONFIG *reg, unsigned int cap_soft_pull_down_en)
{
  reg->bitfields.CAP_SOFT_PULL_DOWN_EN = cap_soft_pull_down_en;
  if (reg->bitfields.CAP_SOFT_PULL_DOWN_EN != cap_soft_pull_down_en) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_SOFT_PULL_DOWN_EN data too large\n");
}
__inline void set_rv250CAP0_CONFIG_cap_vip_extend_flag_en(regrv250CAP0_CONFIG *reg, unsigned int cap_vip_extend_flag_en)
{
  reg->bitfields.CAP_VIP_EXTEND_FLAG_EN = cap_vip_extend_flag_en;
  if (reg->bitfields.CAP_VIP_EXTEND_FLAG_EN != cap_vip_extend_flag_en) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_VIP_EXTEND_FLAG_EN data too large\n");
}
__inline void set_rv250CAP0_CONFIG_cap_fake_field_en(regrv250CAP0_CONFIG *reg, unsigned int cap_fake_field_en)
{
  reg->bitfields.CAP_FAKE_FIELD_EN = cap_fake_field_en;
  if (reg->bitfields.CAP_FAKE_FIELD_EN != cap_fake_field_en) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_FAKE_FIELD_EN data too large\n");
}
__inline void set_rv250CAP0_CONFIG_cap_field_start_line_diff(regrv250CAP0_CONFIG *reg, unsigned int cap_field_start_line_diff)
{
  reg->bitfields.CAP_FIELD_START_LINE_DIFF = cap_field_start_line_diff;
  if (reg->bitfields.CAP_FIELD_START_LINE_DIFF != cap_field_start_line_diff) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_FIELD_START_LINE_DIFF data too large\n");
}
__inline void set_rv250CAP0_CONFIG_cap_horz_down(regrv250CAP0_CONFIG *reg, unsigned int cap_horz_down)
{
  reg->bitfields.CAP_HORZ_DOWN = cap_horz_down;
  if (reg->bitfields.CAP_HORZ_DOWN != cap_horz_down) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_HORZ_DOWN data too large\n");
}
__inline void set_rv250CAP0_CONFIG_cap_vert_down(regrv250CAP0_CONFIG *reg, unsigned int cap_vert_down)
{
  reg->bitfields.CAP_VERT_DOWN = cap_vert_down;
  if (reg->bitfields.CAP_VERT_DOWN != cap_vert_down) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_VERT_DOWN data too large\n");
}
__inline void set_rv250CAP0_CONFIG_cap_stream_format(regrv250CAP0_CONFIG *reg, unsigned int cap_stream_format)
{
  reg->bitfields.CAP_STREAM_FORMAT = cap_stream_format;
  if (reg->bitfields.CAP_STREAM_FORMAT != cap_stream_format) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_STREAM_FORMAT data too large\n");
}
__inline void set_rv250CAP0_CONFIG_cap_hdwns_dec(regrv250CAP0_CONFIG *reg, unsigned int cap_hdwns_dec)
{
  reg->bitfields.CAP_HDWNS_DEC = cap_hdwns_dec;
  if (reg->bitfields.CAP_HDWNS_DEC != cap_hdwns_dec) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_HDWNS_DEC data too large\n");
}
__inline void set_rv250CAP0_CONFIG_cap_image_flip_en(regrv250CAP0_CONFIG *reg, unsigned int cap_image_flip_en)
{
  reg->bitfields.CAP_IMAGE_FLIP_EN = cap_image_flip_en;
  if (reg->bitfields.CAP_IMAGE_FLIP_EN != cap_image_flip_en) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_IMAGE_FLIP_EN data too large\n");
}
__inline void set_rv250CAP0_CONFIG_cap_oneshot_image_flip_en(regrv250CAP0_CONFIG *reg, unsigned int cap_oneshot_image_flip_en)
{
  reg->bitfields.CAP_ONESHOT_IMAGE_FLIP_EN = cap_oneshot_image_flip_en;
  if (reg->bitfields.CAP_ONESHOT_IMAGE_FLIP_EN != cap_oneshot_image_flip_en) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_ONESHOT_IMAGE_FLIP_EN data too large\n");
}
__inline void set_rv250CAP0_CONFIG_cap_video_in_format(regrv250CAP0_CONFIG *reg, unsigned int cap_video_in_format)
{
  reg->bitfields.CAP_VIDEO_IN_FORMAT = cap_video_in_format;
  if (reg->bitfields.CAP_VIDEO_IN_FORMAT != cap_video_in_format) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::CAP_VIDEO_IN_FORMAT data too large\n");
}
__inline void set_rv250CAP0_CONFIG_vbi_horz_down(regrv250CAP0_CONFIG *reg, unsigned int vbi_horz_down)
{
  reg->bitfields.VBI_HORZ_DOWN = vbi_horz_down;
  if (reg->bitfields.VBI_HORZ_DOWN != vbi_horz_down) HSLDPF(E_ERROR_MESSAGE,"rv250CAP0_CONFIG::VBI_HORZ_DOWN data too large\n");
}
#else
#define set_rv250CAP0_CONFIG_cap_input_mode(reg, cap_input_mode) (reg)->bitfields.CAP_INPUT_MODE = cap_input_mode
#define set_rv250CAP0_CONFIG_cap_start_field(reg, cap_start_field) (reg)->bitfields.CAP_START_FIELD = cap_start_field
#define set_rv250CAP0_CONFIG_cap_start_buf_r(reg, cap_start_buf_r) (reg)->bitfields.CAP_START_BUF_R = cap_start_buf_r
#define set_rv250CAP0_CONFIG_cap_start_buf_w(reg, cap_start_buf_w) (reg)->bitfields.CAP_START_BUF_W = cap_start_buf_w
#define set_rv250CAP0_CONFIG_cap_buf_type(reg, cap_buf_type) (reg)->bitfields.CAP_BUF_TYPE = cap_buf_type
#define set_rv250CAP0_CONFIG_cap_oneshot_mode(reg, cap_oneshot_mode) (reg)->bitfields.CAP_ONESHOT_MODE = cap_oneshot_mode
#define set_rv250CAP0_CONFIG_cap_buf_mode(reg, cap_buf_mode) (reg)->bitfields.CAP_BUF_MODE = cap_buf_mode
#define set_rv250CAP0_CONFIG_cap_mirror_en(reg, cap_mirror_en) (reg)->bitfields.CAP_MIRROR_EN = cap_mirror_en
#define set_rv250CAP0_CONFIG_cap_oneshot_mirror_en(reg, cap_oneshot_mirror_en) (reg)->bitfields.CAP_ONESHOT_MIRROR_EN = cap_oneshot_mirror_en
#define set_rv250CAP0_CONFIG_cap_video_signed_uv(reg, cap_video_signed_uv) (reg)->bitfields.CAP_VIDEO_SIGNED_UV = cap_video_signed_uv
#define set_rv250CAP0_CONFIG_cap_anc_decode_en(reg, cap_anc_decode_en) (reg)->bitfields.CAP_ANC_DECODE_EN = cap_anc_decode_en
#define set_rv250CAP0_CONFIG_cap_vbi_en(reg, cap_vbi_en) (reg)->bitfields.CAP_VBI_EN = cap_vbi_en
#define set_rv250CAP0_CONFIG_cap_soft_pull_down_en(reg, cap_soft_pull_down_en) (reg)->bitfields.CAP_SOFT_PULL_DOWN_EN = cap_soft_pull_down_en
#define set_rv250CAP0_CONFIG_cap_vip_extend_flag_en(reg, cap_vip_extend_flag_en) (reg)->bitfields.CAP_VIP_EXTEND_FLAG_EN = cap_vip_extend_flag_en
#define set_rv250CAP0_CONFIG_cap_fake_field_en(reg, cap_fake_field_en) (reg)->bitfields.CAP_FAKE_FIELD_EN = cap_fake_field_en
#define set_rv250CAP0_CONFIG_cap_field_start_line_diff(reg, cap_field_start_line_diff) (reg)->bitfields.CAP_FIELD_START_LINE_DIFF = cap_field_start_line_diff
#define set_rv250CAP0_CONFIG_cap_horz_down(reg, cap_horz_down) (reg)->bitfields.CAP_HORZ_DOWN = cap_horz_down
#define set_rv250CAP0_CONFIG_cap_vert_down(reg, cap_vert_down) (reg)->bitfields.CAP_VERT_DOWN = cap_vert_down
#define set_rv250CAP0_CONFIG_cap_stream_format(reg, cap_stream_format) (reg)->bitfields.CAP_STREAM_FORMAT = cap_stream_format
#define set_rv250CAP0_CONFIG_cap_hdwns_dec(reg, cap_hdwns_dec) (reg)->bitfields.CAP_HDWNS_DEC = cap_hdwns_dec
#define set_rv250CAP0_CONFIG_cap_image_flip_en(reg, cap_image_flip_en) (reg)->bitfields.CAP_IMAGE_FLIP_EN = cap_image_flip_en
#define set_rv250CAP0_CONFIG_cap_oneshot_image_flip_en(reg, cap_oneshot_image_flip_en) (reg)->bitfields.CAP_ONESHOT_IMAGE_FLIP_EN = cap_oneshot_image_flip_en
#define set_rv250CAP0_CONFIG_cap_video_in_format(reg, cap_video_in_format) (reg)->bitfields.CAP_VIDEO_IN_FORMAT = cap_video_in_format
#define set_rv250CAP0_CONFIG_vbi_horz_down(reg, vbi_horz_down) (reg)->bitfields.VBI_HORZ_DOWN = vbi_horz_down

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_ANC0_OFFSET regCAP0_ANC0_OFFSET;

#ifdef DEBUG
__inline void set_CAP0_ANC0_OFFSET_cap_anc0_offset(regCAP0_ANC0_OFFSET *reg, unsigned int cap_anc0_offset)
{
  reg->bitfields.CAP_ANC0_OFFSET = cap_anc0_offset;
  if (reg->bitfields.CAP_ANC0_OFFSET != cap_anc0_offset) HSLDPF(E_ERROR_MESSAGE,"CAP0_ANC0_OFFSET::CAP_ANC0_OFFSET data too large\n");
}
#else
#define set_CAP0_ANC0_OFFSET_cap_anc0_offset(reg, cap_anc0_offset) (reg)->bitfields.CAP_ANC0_OFFSET = cap_anc0_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_ANC1_OFFSET regCAP0_ANC1_OFFSET;

#ifdef DEBUG
__inline void set_CAP0_ANC1_OFFSET_cap_anc1_offset(regCAP0_ANC1_OFFSET *reg, unsigned int cap_anc1_offset)
{
  reg->bitfields.CAP_ANC1_OFFSET = cap_anc1_offset;
  if (reg->bitfields.CAP_ANC1_OFFSET != cap_anc1_offset) HSLDPF(E_ERROR_MESSAGE,"CAP0_ANC1_OFFSET::CAP_ANC1_OFFSET data too large\n");
}
#else
#define set_CAP0_ANC1_OFFSET_cap_anc1_offset(reg, cap_anc1_offset) (reg)->bitfields.CAP_ANC1_OFFSET = cap_anc1_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_ANC_H_WINDOW regCAP0_ANC_H_WINDOW;

#ifdef DEBUG
__inline void set_CAP0_ANC_H_WINDOW_cap_anc_width(regCAP0_ANC_H_WINDOW *reg, unsigned int cap_anc_width)
{
  reg->bitfields.CAP_ANC_WIDTH = cap_anc_width;
  if (reg->bitfields.CAP_ANC_WIDTH != cap_anc_width) HSLDPF(E_ERROR_MESSAGE,"CAP0_ANC_H_WINDOW::CAP_ANC_WIDTH data too large\n");
}
#else
#define set_CAP0_ANC_H_WINDOW_cap_anc_width(reg, cap_anc_width) (reg)->bitfields.CAP_ANC_WIDTH = cap_anc_width

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_VIDEO_SYNC_TEST regCAP0_VIDEO_SYNC_TEST;

#ifdef DEBUG
__inline void set_CAP0_VIDEO_SYNC_TEST_cap_test_vid_sof(regCAP0_VIDEO_SYNC_TEST *reg, unsigned int cap_test_vid_sof)
{
  reg->bitfields.CAP_TEST_VID_SOF = cap_test_vid_sof;
  if (reg->bitfields.CAP_TEST_VID_SOF != cap_test_vid_sof) HSLDPF(E_ERROR_MESSAGE,"CAP0_VIDEO_SYNC_TEST::CAP_TEST_VID_SOF data too large\n");
}
__inline void set_CAP0_VIDEO_SYNC_TEST_cap_test_vid_eof(regCAP0_VIDEO_SYNC_TEST *reg, unsigned int cap_test_vid_eof)
{
  reg->bitfields.CAP_TEST_VID_EOF = cap_test_vid_eof;
  if (reg->bitfields.CAP_TEST_VID_EOF != cap_test_vid_eof) HSLDPF(E_ERROR_MESSAGE,"CAP0_VIDEO_SYNC_TEST::CAP_TEST_VID_EOF data too large\n");
}
__inline void set_CAP0_VIDEO_SYNC_TEST_cap_test_vid_eol(regCAP0_VIDEO_SYNC_TEST *reg, unsigned int cap_test_vid_eol)
{
  reg->bitfields.CAP_TEST_VID_EOL = cap_test_vid_eol;
  if (reg->bitfields.CAP_TEST_VID_EOL != cap_test_vid_eol) HSLDPF(E_ERROR_MESSAGE,"CAP0_VIDEO_SYNC_TEST::CAP_TEST_VID_EOL data too large\n");
}
__inline void set_CAP0_VIDEO_SYNC_TEST_cap_test_vid_field(regCAP0_VIDEO_SYNC_TEST *reg, unsigned int cap_test_vid_field)
{
  reg->bitfields.CAP_TEST_VID_FIELD = cap_test_vid_field;
  if (reg->bitfields.CAP_TEST_VID_FIELD != cap_test_vid_field) HSLDPF(E_ERROR_MESSAGE,"CAP0_VIDEO_SYNC_TEST::CAP_TEST_VID_FIELD data too large\n");
}
__inline void set_CAP0_VIDEO_SYNC_TEST_cap_test_sync_en(regCAP0_VIDEO_SYNC_TEST *reg, unsigned int cap_test_sync_en)
{
  reg->bitfields.CAP_TEST_SYNC_EN = cap_test_sync_en;
  if (reg->bitfields.CAP_TEST_SYNC_EN != cap_test_sync_en) HSLDPF(E_ERROR_MESSAGE,"CAP0_VIDEO_SYNC_TEST::CAP_TEST_SYNC_EN data too large\n");
}
#else
#define set_CAP0_VIDEO_SYNC_TEST_cap_test_vid_sof(reg, cap_test_vid_sof) (reg)->bitfields.CAP_TEST_VID_SOF = cap_test_vid_sof
#define set_CAP0_VIDEO_SYNC_TEST_cap_test_vid_eof(reg, cap_test_vid_eof) (reg)->bitfields.CAP_TEST_VID_EOF = cap_test_vid_eof
#define set_CAP0_VIDEO_SYNC_TEST_cap_test_vid_eol(reg, cap_test_vid_eol) (reg)->bitfields.CAP_TEST_VID_EOL = cap_test_vid_eol
#define set_CAP0_VIDEO_SYNC_TEST_cap_test_vid_field(reg, cap_test_vid_field) (reg)->bitfields.CAP_TEST_VID_FIELD = cap_test_vid_field
#define set_CAP0_VIDEO_SYNC_TEST_cap_test_sync_en(reg, cap_test_sync_en) (reg)->bitfields.CAP_TEST_SYNC_EN = cap_test_sync_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_ONESHOT_BUF_OFFSET regCAP0_ONESHOT_BUF_OFFSET;

#ifdef DEBUG
__inline void set_CAP0_ONESHOT_BUF_OFFSET_cap_oneshot_buf_offset(regCAP0_ONESHOT_BUF_OFFSET *reg, unsigned int cap_oneshot_buf_offset)
{
  reg->bitfields.CAP_ONESHOT_BUF_OFFSET = cap_oneshot_buf_offset;
  if (reg->bitfields.CAP_ONESHOT_BUF_OFFSET != cap_oneshot_buf_offset) HSLDPF(E_ERROR_MESSAGE,"CAP0_ONESHOT_BUF_OFFSET::CAP_ONESHOT_BUF_OFFSET data too large\n");
}
#else
#define set_CAP0_ONESHOT_BUF_OFFSET_cap_oneshot_buf_offset(reg, cap_oneshot_buf_offset) (reg)->bitfields.CAP_ONESHOT_BUF_OFFSET = cap_oneshot_buf_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_BUF_STATUS regCAP0_BUF_STATUS;

#ifdef DEBUG
__inline void set_CAP0_BUF_STATUS_cap_pre_vid_buf(regCAP0_BUF_STATUS *reg, unsigned int cap_pre_vid_buf)
{
  reg->bitfields.CAP_PRE_VID_BUF = cap_pre_vid_buf;
  if (reg->bitfields.CAP_PRE_VID_BUF != cap_pre_vid_buf) HSLDPF(E_ERROR_MESSAGE,"CAP0_BUF_STATUS::CAP_PRE_VID_BUF data too large\n");
}
__inline void set_CAP0_BUF_STATUS_cap_cur_vid_buf(regCAP0_BUF_STATUS *reg, unsigned int cap_cur_vid_buf)
{
  reg->bitfields.CAP_CUR_VID_BUF = cap_cur_vid_buf;
  if (reg->bitfields.CAP_CUR_VID_BUF != cap_cur_vid_buf) HSLDPF(E_ERROR_MESSAGE,"CAP0_BUF_STATUS::CAP_CUR_VID_BUF data too large\n");
}
__inline void set_CAP0_BUF_STATUS_cap_pre_field(regCAP0_BUF_STATUS *reg, unsigned int cap_pre_field)
{
  reg->bitfields.CAP_PRE_FIELD = cap_pre_field;
  if (reg->bitfields.CAP_PRE_FIELD != cap_pre_field) HSLDPF(E_ERROR_MESSAGE,"CAP0_BUF_STATUS::CAP_PRE_FIELD data too large\n");
}
__inline void set_CAP0_BUF_STATUS_cap_cur_field(regCAP0_BUF_STATUS *reg, unsigned int cap_cur_field)
{
  reg->bitfields.CAP_CUR_FIELD = cap_cur_field;
  if (reg->bitfields.CAP_CUR_FIELD != cap_cur_field) HSLDPF(E_ERROR_MESSAGE,"CAP0_BUF_STATUS::CAP_CUR_FIELD data too large\n");
}
__inline void set_CAP0_BUF_STATUS_cap_pre_vbi_buf(regCAP0_BUF_STATUS *reg, unsigned int cap_pre_vbi_buf)
{
  reg->bitfields.CAP_PRE_VBI_BUF = cap_pre_vbi_buf;
  if (reg->bitfields.CAP_PRE_VBI_BUF != cap_pre_vbi_buf) HSLDPF(E_ERROR_MESSAGE,"CAP0_BUF_STATUS::CAP_PRE_VBI_BUF data too large\n");
}
__inline void set_CAP0_BUF_STATUS_cap_cur_vbi_buf(regCAP0_BUF_STATUS *reg, unsigned int cap_cur_vbi_buf)
{
  reg->bitfields.CAP_CUR_VBI_BUF = cap_cur_vbi_buf;
  if (reg->bitfields.CAP_CUR_VBI_BUF != cap_cur_vbi_buf) HSLDPF(E_ERROR_MESSAGE,"CAP0_BUF_STATUS::CAP_CUR_VBI_BUF data too large\n");
}
__inline void set_CAP0_BUF_STATUS_cap_vbi_buf_status(regCAP0_BUF_STATUS *reg, unsigned int cap_vbi_buf_status)
{
  reg->bitfields.CAP_VBI_BUF_STATUS = cap_vbi_buf_status;
  if (reg->bitfields.CAP_VBI_BUF_STATUS != cap_vbi_buf_status) HSLDPF(E_ERROR_MESSAGE,"CAP0_BUF_STATUS::CAP_VBI_BUF_STATUS data too large\n");
}
__inline void set_CAP0_BUF_STATUS_cap_pre_anc_buf(regCAP0_BUF_STATUS *reg, unsigned int cap_pre_anc_buf)
{
  reg->bitfields.CAP_PRE_ANC_BUF = cap_pre_anc_buf;
  if (reg->bitfields.CAP_PRE_ANC_BUF != cap_pre_anc_buf) HSLDPF(E_ERROR_MESSAGE,"CAP0_BUF_STATUS::CAP_PRE_ANC_BUF data too large\n");
}
__inline void set_CAP0_BUF_STATUS_cap_cur_anc_buf(regCAP0_BUF_STATUS *reg, unsigned int cap_cur_anc_buf)
{
  reg->bitfields.CAP_CUR_ANC_BUF = cap_cur_anc_buf;
  if (reg->bitfields.CAP_CUR_ANC_BUF != cap_cur_anc_buf) HSLDPF(E_ERROR_MESSAGE,"CAP0_BUF_STATUS::CAP_CUR_ANC_BUF data too large\n");
}
__inline void set_CAP0_BUF_STATUS_cap_anc_buf_status(regCAP0_BUF_STATUS *reg, unsigned int cap_anc_buf_status)
{
  reg->bitfields.CAP_ANC_BUF_STATUS = cap_anc_buf_status;
  if (reg->bitfields.CAP_ANC_BUF_STATUS != cap_anc_buf_status) HSLDPF(E_ERROR_MESSAGE,"CAP0_BUF_STATUS::CAP_ANC_BUF_STATUS data too large\n");
}
__inline void set_CAP0_BUF_STATUS_cap_anc_pre_buf_cnt(regCAP0_BUF_STATUS *reg, unsigned int cap_anc_pre_buf_cnt)
{
  reg->bitfields.CAP_ANC_PRE_BUF_CNT = cap_anc_pre_buf_cnt;
  if (reg->bitfields.CAP_ANC_PRE_BUF_CNT != cap_anc_pre_buf_cnt) HSLDPF(E_ERROR_MESSAGE,"CAP0_BUF_STATUS::CAP_ANC_PRE_BUF_CNT data too large\n");
}
__inline void set_CAP0_BUF_STATUS_cap_vip_inc(regCAP0_BUF_STATUS *reg, unsigned int cap_vip_inc)
{
  reg->bitfields.CAP_VIP_INC = cap_vip_inc;
  if (reg->bitfields.CAP_VIP_INC != cap_vip_inc) HSLDPF(E_ERROR_MESSAGE,"CAP0_BUF_STATUS::CAP_VIP_INC data too large\n");
}
__inline void set_CAP0_BUF_STATUS_cap_vip_pre_repeat_field(regCAP0_BUF_STATUS *reg, unsigned int cap_vip_pre_repeat_field)
{
  reg->bitfields.CAP_VIP_PRE_REPEAT_FIELD = cap_vip_pre_repeat_field;
  if (reg->bitfields.CAP_VIP_PRE_REPEAT_FIELD != cap_vip_pre_repeat_field) HSLDPF(E_ERROR_MESSAGE,"CAP0_BUF_STATUS::CAP_VIP_PRE_REPEAT_FIELD data too large\n");
}
__inline void set_CAP0_BUF_STATUS_cap_cap_buf_status(regCAP0_BUF_STATUS *reg, unsigned int cap_cap_buf_status)
{
  reg->bitfields.CAP_CAP_BUF_STATUS = cap_cap_buf_status;
  if (reg->bitfields.CAP_CAP_BUF_STATUS != cap_cap_buf_status) HSLDPF(E_ERROR_MESSAGE,"CAP0_BUF_STATUS::CAP_CAP_BUF_STATUS data too large\n");
}
#else
#define set_CAP0_BUF_STATUS_cap_pre_vid_buf(reg, cap_pre_vid_buf) (reg)->bitfields.CAP_PRE_VID_BUF = cap_pre_vid_buf
#define set_CAP0_BUF_STATUS_cap_cur_vid_buf(reg, cap_cur_vid_buf) (reg)->bitfields.CAP_CUR_VID_BUF = cap_cur_vid_buf
#define set_CAP0_BUF_STATUS_cap_pre_field(reg, cap_pre_field) (reg)->bitfields.CAP_PRE_FIELD = cap_pre_field
#define set_CAP0_BUF_STATUS_cap_cur_field(reg, cap_cur_field) (reg)->bitfields.CAP_CUR_FIELD = cap_cur_field
#define set_CAP0_BUF_STATUS_cap_pre_vbi_buf(reg, cap_pre_vbi_buf) (reg)->bitfields.CAP_PRE_VBI_BUF = cap_pre_vbi_buf
#define set_CAP0_BUF_STATUS_cap_cur_vbi_buf(reg, cap_cur_vbi_buf) (reg)->bitfields.CAP_CUR_VBI_BUF = cap_cur_vbi_buf
#define set_CAP0_BUF_STATUS_cap_vbi_buf_status(reg, cap_vbi_buf_status) (reg)->bitfields.CAP_VBI_BUF_STATUS = cap_vbi_buf_status
#define set_CAP0_BUF_STATUS_cap_pre_anc_buf(reg, cap_pre_anc_buf) (reg)->bitfields.CAP_PRE_ANC_BUF = cap_pre_anc_buf
#define set_CAP0_BUF_STATUS_cap_cur_anc_buf(reg, cap_cur_anc_buf) (reg)->bitfields.CAP_CUR_ANC_BUF = cap_cur_anc_buf
#define set_CAP0_BUF_STATUS_cap_anc_buf_status(reg, cap_anc_buf_status) (reg)->bitfields.CAP_ANC_BUF_STATUS = cap_anc_buf_status
#define set_CAP0_BUF_STATUS_cap_anc_pre_buf_cnt(reg, cap_anc_pre_buf_cnt) (reg)->bitfields.CAP_ANC_PRE_BUF_CNT = cap_anc_pre_buf_cnt
#define set_CAP0_BUF_STATUS_cap_vip_inc(reg, cap_vip_inc) (reg)->bitfields.CAP_VIP_INC = cap_vip_inc
#define set_CAP0_BUF_STATUS_cap_vip_pre_repeat_field(reg, cap_vip_pre_repeat_field) (reg)->bitfields.CAP_VIP_PRE_REPEAT_FIELD = cap_vip_pre_repeat_field
#define set_CAP0_BUF_STATUS_cap_cap_buf_status(reg, cap_cap_buf_status) (reg)->bitfields.CAP_CAP_BUF_STATUS = cap_cap_buf_status

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_ANC_BUF01_BLOCK_CNT regCAP0_ANC_BUF01_BLOCK_CNT;

#ifdef DEBUG
__inline void set_CAP0_ANC_BUF01_BLOCK_CNT_cap0_anc_buf0_block_cnt(regCAP0_ANC_BUF01_BLOCK_CNT *reg, unsigned int cap0_anc_buf0_block_cnt)
{
  reg->bitfields.CAP0_ANC_BUF0_BLOCK_CNT = cap0_anc_buf0_block_cnt;
  if (reg->bitfields.CAP0_ANC_BUF0_BLOCK_CNT != cap0_anc_buf0_block_cnt) HSLDPF(E_ERROR_MESSAGE,"CAP0_ANC_BUF01_BLOCK_CNT::CAP0_ANC_BUF0_BLOCK_CNT data too large\n");
}
__inline void set_CAP0_ANC_BUF01_BLOCK_CNT_cap0_anc_buf1_block_cnt(regCAP0_ANC_BUF01_BLOCK_CNT *reg, unsigned int cap0_anc_buf1_block_cnt)
{
  reg->bitfields.CAP0_ANC_BUF1_BLOCK_CNT = cap0_anc_buf1_block_cnt;
  if (reg->bitfields.CAP0_ANC_BUF1_BLOCK_CNT != cap0_anc_buf1_block_cnt) HSLDPF(E_ERROR_MESSAGE,"CAP0_ANC_BUF01_BLOCK_CNT::CAP0_ANC_BUF1_BLOCK_CNT data too large\n");
}
#else
#define set_CAP0_ANC_BUF01_BLOCK_CNT_cap0_anc_buf0_block_cnt(reg, cap0_anc_buf0_block_cnt) (reg)->bitfields.CAP0_ANC_BUF0_BLOCK_CNT = cap0_anc_buf0_block_cnt
#define set_CAP0_ANC_BUF01_BLOCK_CNT_cap0_anc_buf1_block_cnt(reg, cap0_anc_buf1_block_cnt) (reg)->bitfields.CAP0_ANC_BUF1_BLOCK_CNT = cap0_anc_buf1_block_cnt

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_ANC_BUF23_BLOCK_CNT regCAP0_ANC_BUF23_BLOCK_CNT;

#ifdef DEBUG
__inline void set_CAP0_ANC_BUF23_BLOCK_CNT_cap0_anc_buf2_block_cnt(regCAP0_ANC_BUF23_BLOCK_CNT *reg, unsigned int cap0_anc_buf2_block_cnt)
{
  reg->bitfields.CAP0_ANC_BUF2_BLOCK_CNT = cap0_anc_buf2_block_cnt;
  if (reg->bitfields.CAP0_ANC_BUF2_BLOCK_CNT != cap0_anc_buf2_block_cnt) HSLDPF(E_ERROR_MESSAGE,"CAP0_ANC_BUF23_BLOCK_CNT::CAP0_ANC_BUF2_BLOCK_CNT data too large\n");
}
__inline void set_CAP0_ANC_BUF23_BLOCK_CNT_cap0_anc_buf3_block_cnt(regCAP0_ANC_BUF23_BLOCK_CNT *reg, unsigned int cap0_anc_buf3_block_cnt)
{
  reg->bitfields.CAP0_ANC_BUF3_BLOCK_CNT = cap0_anc_buf3_block_cnt;
  if (reg->bitfields.CAP0_ANC_BUF3_BLOCK_CNT != cap0_anc_buf3_block_cnt) HSLDPF(E_ERROR_MESSAGE,"CAP0_ANC_BUF23_BLOCK_CNT::CAP0_ANC_BUF3_BLOCK_CNT data too large\n");
}
#else
#define set_CAP0_ANC_BUF23_BLOCK_CNT_cap0_anc_buf2_block_cnt(reg, cap0_anc_buf2_block_cnt) (reg)->bitfields.CAP0_ANC_BUF2_BLOCK_CNT = cap0_anc_buf2_block_cnt
#define set_CAP0_ANC_BUF23_BLOCK_CNT_cap0_anc_buf3_block_cnt(reg, cap0_anc_buf3_block_cnt) (reg)->bitfields.CAP0_ANC_BUF3_BLOCK_CNT = cap0_anc_buf3_block_cnt

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_VBI2_OFFSET regCAP0_VBI2_OFFSET;

#ifdef DEBUG
__inline void set_CAP0_VBI2_OFFSET_cap_vbi2_offset(regCAP0_VBI2_OFFSET *reg, unsigned int cap_vbi2_offset)
{
  reg->bitfields.CAP_VBI2_OFFSET = cap_vbi2_offset;
  if (reg->bitfields.CAP_VBI2_OFFSET != cap_vbi2_offset) HSLDPF(E_ERROR_MESSAGE,"CAP0_VBI2_OFFSET::CAP_VBI2_OFFSET data too large\n");
}
#else
#define set_CAP0_VBI2_OFFSET_cap_vbi2_offset(reg, cap_vbi2_offset) (reg)->bitfields.CAP_VBI2_OFFSET = cap_vbi2_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_VBI3_OFFSET regCAP0_VBI3_OFFSET;

#ifdef DEBUG
__inline void set_CAP0_VBI3_OFFSET_cap_vbi3_offset(regCAP0_VBI3_OFFSET *reg, unsigned int cap_vbi3_offset)
{
  reg->bitfields.CAP_VBI3_OFFSET = cap_vbi3_offset;
  if (reg->bitfields.CAP_VBI3_OFFSET != cap_vbi3_offset) HSLDPF(E_ERROR_MESSAGE,"CAP0_VBI3_OFFSET::CAP_VBI3_OFFSET data too large\n");
}
#else
#define set_CAP0_VBI3_OFFSET_cap_vbi3_offset(reg, cap_vbi3_offset) (reg)->bitfields.CAP_VBI3_OFFSET = cap_vbi3_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_ANC2_OFFSET regCAP0_ANC2_OFFSET;

#ifdef DEBUG
__inline void set_CAP0_ANC2_OFFSET_cap_anc2_offset(regCAP0_ANC2_OFFSET *reg, unsigned int cap_anc2_offset)
{
  reg->bitfields.CAP_ANC2_OFFSET = cap_anc2_offset;
  if (reg->bitfields.CAP_ANC2_OFFSET != cap_anc2_offset) HSLDPF(E_ERROR_MESSAGE,"CAP0_ANC2_OFFSET::CAP_ANC2_OFFSET data too large\n");
}
#else
#define set_CAP0_ANC2_OFFSET_cap_anc2_offset(reg, cap_anc2_offset) (reg)->bitfields.CAP_ANC2_OFFSET = cap_anc2_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_ANC3_OFFSET regCAP0_ANC3_OFFSET;

#ifdef DEBUG
__inline void set_CAP0_ANC3_OFFSET_cap_anc3_offset(regCAP0_ANC3_OFFSET *reg, unsigned int cap_anc3_offset)
{
  reg->bitfields.CAP_ANC3_OFFSET = cap_anc3_offset;
  if (reg->bitfields.CAP_ANC3_OFFSET != cap_anc3_offset) HSLDPF(E_ERROR_MESSAGE,"CAP0_ANC3_OFFSET::CAP_ANC3_OFFSET data too large\n");
}
#else
#define set_CAP0_ANC3_OFFSET_cap_anc3_offset(reg, cap_anc3_offset) (reg)->bitfields.CAP_ANC3_OFFSET = cap_anc3_offset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_VIPH0_COMMAND regDMA_VIPH0_COMMAND;

#ifdef DEBUG
__inline void set_DMA_VIPH0_COMMAND_byte_count(regDMA_VIPH0_COMMAND *reg, unsigned int byte_count)
{
  reg->bitfields.BYTE_COUNT = byte_count;
  if (reg->bitfields.BYTE_COUNT != byte_count) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH0_COMMAND::BYTE_COUNT data too large\n");
}
__inline void set_DMA_VIPH0_COMMAND_swap_control(regDMA_VIPH0_COMMAND *reg, unsigned int swap_control)
{
  reg->bitfields.SWAP_CONTROL = swap_control;
  if (reg->bitfields.SWAP_CONTROL != swap_control) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH0_COMMAND::SWAP_CONTROL data too large\n");
}
__inline void set_DMA_VIPH0_COMMAND_transfer_source(regDMA_VIPH0_COMMAND *reg, unsigned int transfer_source)
{
  reg->bitfields.TRANSFER_SOURCE = transfer_source;
  if (reg->bitfields.TRANSFER_SOURCE != transfer_source) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH0_COMMAND::TRANSFER_SOURCE data too large\n");
}
__inline void set_DMA_VIPH0_COMMAND_transfer_dest(regDMA_VIPH0_COMMAND *reg, unsigned int transfer_dest)
{
  reg->bitfields.TRANSFER_DEST = transfer_dest;
  if (reg->bitfields.TRANSFER_DEST != transfer_dest) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH0_COMMAND::TRANSFER_DEST data too large\n");
}
__inline void set_DMA_VIPH0_COMMAND_source_offset_hold(regDMA_VIPH0_COMMAND *reg, unsigned int source_offset_hold)
{
  reg->bitfields.SOURCE_OFFSET_HOLD = source_offset_hold;
  if (reg->bitfields.SOURCE_OFFSET_HOLD != source_offset_hold) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH0_COMMAND::SOURCE_OFFSET_HOLD data too large\n");
}
__inline void set_DMA_VIPH0_COMMAND_dest_offset_hold(regDMA_VIPH0_COMMAND *reg, unsigned int dest_offset_hold)
{
  reg->bitfields.DEST_OFFSET_HOLD = dest_offset_hold;
  if (reg->bitfields.DEST_OFFSET_HOLD != dest_offset_hold) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH0_COMMAND::DEST_OFFSET_HOLD data too large\n");
}
__inline void set_DMA_VIPH0_COMMAND_interrupt_dis(regDMA_VIPH0_COMMAND *reg, unsigned int interrupt_dis)
{
  reg->bitfields.INTERRUPT_DIS = interrupt_dis;
  if (reg->bitfields.INTERRUPT_DIS != interrupt_dis) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH0_COMMAND::INTERRUPT_DIS data too large\n");
}
__inline void set_DMA_VIPH0_COMMAND_end_of_list_status(regDMA_VIPH0_COMMAND *reg, unsigned int end_of_list_status)
{
  reg->bitfields.END_OF_LIST_STATUS = end_of_list_status;
  if (reg->bitfields.END_OF_LIST_STATUS != end_of_list_status) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH0_COMMAND::END_OF_LIST_STATUS data too large\n");
}
#else
#define set_DMA_VIPH0_COMMAND_byte_count(reg, byte_count) (reg)->bitfields.BYTE_COUNT = byte_count
#define set_DMA_VIPH0_COMMAND_swap_control(reg, swap_control) (reg)->bitfields.SWAP_CONTROL = swap_control
#define set_DMA_VIPH0_COMMAND_transfer_source(reg, transfer_source) (reg)->bitfields.TRANSFER_SOURCE = transfer_source
#define set_DMA_VIPH0_COMMAND_transfer_dest(reg, transfer_dest) (reg)->bitfields.TRANSFER_DEST = transfer_dest
#define set_DMA_VIPH0_COMMAND_source_offset_hold(reg, source_offset_hold) (reg)->bitfields.SOURCE_OFFSET_HOLD = source_offset_hold
#define set_DMA_VIPH0_COMMAND_dest_offset_hold(reg, dest_offset_hold) (reg)->bitfields.DEST_OFFSET_HOLD = dest_offset_hold
#define set_DMA_VIPH0_COMMAND_interrupt_dis(reg, interrupt_dis) (reg)->bitfields.INTERRUPT_DIS = interrupt_dis
#define set_DMA_VIPH0_COMMAND_end_of_list_status(reg, end_of_list_status) (reg)->bitfields.END_OF_LIST_STATUS = end_of_list_status

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_VIPH1_COMMAND regDMA_VIPH1_COMMAND;

#ifdef DEBUG
__inline void set_DMA_VIPH1_COMMAND_byte_count(regDMA_VIPH1_COMMAND *reg, unsigned int byte_count)
{
  reg->bitfields.BYTE_COUNT = byte_count;
  if (reg->bitfields.BYTE_COUNT != byte_count) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH1_COMMAND::BYTE_COUNT data too large\n");
}
__inline void set_DMA_VIPH1_COMMAND_swap_control(regDMA_VIPH1_COMMAND *reg, unsigned int swap_control)
{
  reg->bitfields.SWAP_CONTROL = swap_control;
  if (reg->bitfields.SWAP_CONTROL != swap_control) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH1_COMMAND::SWAP_CONTROL data too large\n");
}
__inline void set_DMA_VIPH1_COMMAND_transfer_source(regDMA_VIPH1_COMMAND *reg, unsigned int transfer_source)
{
  reg->bitfields.TRANSFER_SOURCE = transfer_source;
  if (reg->bitfields.TRANSFER_SOURCE != transfer_source) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH1_COMMAND::TRANSFER_SOURCE data too large\n");
}
__inline void set_DMA_VIPH1_COMMAND_transfer_dest(regDMA_VIPH1_COMMAND *reg, unsigned int transfer_dest)
{
  reg->bitfields.TRANSFER_DEST = transfer_dest;
  if (reg->bitfields.TRANSFER_DEST != transfer_dest) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH1_COMMAND::TRANSFER_DEST data too large\n");
}
__inline void set_DMA_VIPH1_COMMAND_source_offset_hold(regDMA_VIPH1_COMMAND *reg, unsigned int source_offset_hold)
{
  reg->bitfields.SOURCE_OFFSET_HOLD = source_offset_hold;
  if (reg->bitfields.SOURCE_OFFSET_HOLD != source_offset_hold) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH1_COMMAND::SOURCE_OFFSET_HOLD data too large\n");
}
__inline void set_DMA_VIPH1_COMMAND_dest_offset_hold(regDMA_VIPH1_COMMAND *reg, unsigned int dest_offset_hold)
{
  reg->bitfields.DEST_OFFSET_HOLD = dest_offset_hold;
  if (reg->bitfields.DEST_OFFSET_HOLD != dest_offset_hold) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH1_COMMAND::DEST_OFFSET_HOLD data too large\n");
}
__inline void set_DMA_VIPH1_COMMAND_interrupt_dis(regDMA_VIPH1_COMMAND *reg, unsigned int interrupt_dis)
{
  reg->bitfields.INTERRUPT_DIS = interrupt_dis;
  if (reg->bitfields.INTERRUPT_DIS != interrupt_dis) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH1_COMMAND::INTERRUPT_DIS data too large\n");
}
__inline void set_DMA_VIPH1_COMMAND_end_of_list_status(regDMA_VIPH1_COMMAND *reg, unsigned int end_of_list_status)
{
  reg->bitfields.END_OF_LIST_STATUS = end_of_list_status;
  if (reg->bitfields.END_OF_LIST_STATUS != end_of_list_status) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH1_COMMAND::END_OF_LIST_STATUS data too large\n");
}
#else
#define set_DMA_VIPH1_COMMAND_byte_count(reg, byte_count) (reg)->bitfields.BYTE_COUNT = byte_count
#define set_DMA_VIPH1_COMMAND_swap_control(reg, swap_control) (reg)->bitfields.SWAP_CONTROL = swap_control
#define set_DMA_VIPH1_COMMAND_transfer_source(reg, transfer_source) (reg)->bitfields.TRANSFER_SOURCE = transfer_source
#define set_DMA_VIPH1_COMMAND_transfer_dest(reg, transfer_dest) (reg)->bitfields.TRANSFER_DEST = transfer_dest
#define set_DMA_VIPH1_COMMAND_source_offset_hold(reg, source_offset_hold) (reg)->bitfields.SOURCE_OFFSET_HOLD = source_offset_hold
#define set_DMA_VIPH1_COMMAND_dest_offset_hold(reg, dest_offset_hold) (reg)->bitfields.DEST_OFFSET_HOLD = dest_offset_hold
#define set_DMA_VIPH1_COMMAND_interrupt_dis(reg, interrupt_dis) (reg)->bitfields.INTERRUPT_DIS = interrupt_dis
#define set_DMA_VIPH1_COMMAND_end_of_list_status(reg, end_of_list_status) (reg)->bitfields.END_OF_LIST_STATUS = end_of_list_status

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_VIPH2_COMMAND regDMA_VIPH2_COMMAND;

#ifdef DEBUG
__inline void set_DMA_VIPH2_COMMAND_byte_count(regDMA_VIPH2_COMMAND *reg, unsigned int byte_count)
{
  reg->bitfields.BYTE_COUNT = byte_count;
  if (reg->bitfields.BYTE_COUNT != byte_count) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH2_COMMAND::BYTE_COUNT data too large\n");
}
__inline void set_DMA_VIPH2_COMMAND_swap_control(regDMA_VIPH2_COMMAND *reg, unsigned int swap_control)
{
  reg->bitfields.SWAP_CONTROL = swap_control;
  if (reg->bitfields.SWAP_CONTROL != swap_control) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH2_COMMAND::SWAP_CONTROL data too large\n");
}
__inline void set_DMA_VIPH2_COMMAND_transfer_source(regDMA_VIPH2_COMMAND *reg, unsigned int transfer_source)
{
  reg->bitfields.TRANSFER_SOURCE = transfer_source;
  if (reg->bitfields.TRANSFER_SOURCE != transfer_source) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH2_COMMAND::TRANSFER_SOURCE data too large\n");
}
__inline void set_DMA_VIPH2_COMMAND_transfer_dest(regDMA_VIPH2_COMMAND *reg, unsigned int transfer_dest)
{
  reg->bitfields.TRANSFER_DEST = transfer_dest;
  if (reg->bitfields.TRANSFER_DEST != transfer_dest) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH2_COMMAND::TRANSFER_DEST data too large\n");
}
__inline void set_DMA_VIPH2_COMMAND_source_offset_hold(regDMA_VIPH2_COMMAND *reg, unsigned int source_offset_hold)
{
  reg->bitfields.SOURCE_OFFSET_HOLD = source_offset_hold;
  if (reg->bitfields.SOURCE_OFFSET_HOLD != source_offset_hold) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH2_COMMAND::SOURCE_OFFSET_HOLD data too large\n");
}
__inline void set_DMA_VIPH2_COMMAND_dest_offset_hold(regDMA_VIPH2_COMMAND *reg, unsigned int dest_offset_hold)
{
  reg->bitfields.DEST_OFFSET_HOLD = dest_offset_hold;
  if (reg->bitfields.DEST_OFFSET_HOLD != dest_offset_hold) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH2_COMMAND::DEST_OFFSET_HOLD data too large\n");
}
__inline void set_DMA_VIPH2_COMMAND_interrupt_dis(regDMA_VIPH2_COMMAND *reg, unsigned int interrupt_dis)
{
  reg->bitfields.INTERRUPT_DIS = interrupt_dis;
  if (reg->bitfields.INTERRUPT_DIS != interrupt_dis) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH2_COMMAND::INTERRUPT_DIS data too large\n");
}
__inline void set_DMA_VIPH2_COMMAND_end_of_list_status(regDMA_VIPH2_COMMAND *reg, unsigned int end_of_list_status)
{
  reg->bitfields.END_OF_LIST_STATUS = end_of_list_status;
  if (reg->bitfields.END_OF_LIST_STATUS != end_of_list_status) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH2_COMMAND::END_OF_LIST_STATUS data too large\n");
}
#else
#define set_DMA_VIPH2_COMMAND_byte_count(reg, byte_count) (reg)->bitfields.BYTE_COUNT = byte_count
#define set_DMA_VIPH2_COMMAND_swap_control(reg, swap_control) (reg)->bitfields.SWAP_CONTROL = swap_control
#define set_DMA_VIPH2_COMMAND_transfer_source(reg, transfer_source) (reg)->bitfields.TRANSFER_SOURCE = transfer_source
#define set_DMA_VIPH2_COMMAND_transfer_dest(reg, transfer_dest) (reg)->bitfields.TRANSFER_DEST = transfer_dest
#define set_DMA_VIPH2_COMMAND_source_offset_hold(reg, source_offset_hold) (reg)->bitfields.SOURCE_OFFSET_HOLD = source_offset_hold
#define set_DMA_VIPH2_COMMAND_dest_offset_hold(reg, dest_offset_hold) (reg)->bitfields.DEST_OFFSET_HOLD = dest_offset_hold
#define set_DMA_VIPH2_COMMAND_interrupt_dis(reg, interrupt_dis) (reg)->bitfields.INTERRUPT_DIS = interrupt_dis
#define set_DMA_VIPH2_COMMAND_end_of_list_status(reg, end_of_list_status) (reg)->bitfields.END_OF_LIST_STATUS = end_of_list_status

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_VIPH3_COMMAND regDMA_VIPH3_COMMAND;

#ifdef DEBUG
__inline void set_DMA_VIPH3_COMMAND_byte_count(regDMA_VIPH3_COMMAND *reg, unsigned int byte_count)
{
  reg->bitfields.BYTE_COUNT = byte_count;
  if (reg->bitfields.BYTE_COUNT != byte_count) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH3_COMMAND::BYTE_COUNT data too large\n");
}
__inline void set_DMA_VIPH3_COMMAND_swap_control(regDMA_VIPH3_COMMAND *reg, unsigned int swap_control)
{
  reg->bitfields.SWAP_CONTROL = swap_control;
  if (reg->bitfields.SWAP_CONTROL != swap_control) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH3_COMMAND::SWAP_CONTROL data too large\n");
}
__inline void set_DMA_VIPH3_COMMAND_transfer_source(regDMA_VIPH3_COMMAND *reg, unsigned int transfer_source)
{
  reg->bitfields.TRANSFER_SOURCE = transfer_source;
  if (reg->bitfields.TRANSFER_SOURCE != transfer_source) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH3_COMMAND::TRANSFER_SOURCE data too large\n");
}
__inline void set_DMA_VIPH3_COMMAND_transfer_dest(regDMA_VIPH3_COMMAND *reg, unsigned int transfer_dest)
{
  reg->bitfields.TRANSFER_DEST = transfer_dest;
  if (reg->bitfields.TRANSFER_DEST != transfer_dest) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH3_COMMAND::TRANSFER_DEST data too large\n");
}
__inline void set_DMA_VIPH3_COMMAND_source_offset_hold(regDMA_VIPH3_COMMAND *reg, unsigned int source_offset_hold)
{
  reg->bitfields.SOURCE_OFFSET_HOLD = source_offset_hold;
  if (reg->bitfields.SOURCE_OFFSET_HOLD != source_offset_hold) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH3_COMMAND::SOURCE_OFFSET_HOLD data too large\n");
}
__inline void set_DMA_VIPH3_COMMAND_dest_offset_hold(regDMA_VIPH3_COMMAND *reg, unsigned int dest_offset_hold)
{
  reg->bitfields.DEST_OFFSET_HOLD = dest_offset_hold;
  if (reg->bitfields.DEST_OFFSET_HOLD != dest_offset_hold) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH3_COMMAND::DEST_OFFSET_HOLD data too large\n");
}
__inline void set_DMA_VIPH3_COMMAND_interrupt_dis(regDMA_VIPH3_COMMAND *reg, unsigned int interrupt_dis)
{
  reg->bitfields.INTERRUPT_DIS = interrupt_dis;
  if (reg->bitfields.INTERRUPT_DIS != interrupt_dis) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH3_COMMAND::INTERRUPT_DIS data too large\n");
}
__inline void set_DMA_VIPH3_COMMAND_end_of_list_status(regDMA_VIPH3_COMMAND *reg, unsigned int end_of_list_status)
{
  reg->bitfields.END_OF_LIST_STATUS = end_of_list_status;
  if (reg->bitfields.END_OF_LIST_STATUS != end_of_list_status) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH3_COMMAND::END_OF_LIST_STATUS data too large\n");
}
#else
#define set_DMA_VIPH3_COMMAND_byte_count(reg, byte_count) (reg)->bitfields.BYTE_COUNT = byte_count
#define set_DMA_VIPH3_COMMAND_swap_control(reg, swap_control) (reg)->bitfields.SWAP_CONTROL = swap_control
#define set_DMA_VIPH3_COMMAND_transfer_source(reg, transfer_source) (reg)->bitfields.TRANSFER_SOURCE = transfer_source
#define set_DMA_VIPH3_COMMAND_transfer_dest(reg, transfer_dest) (reg)->bitfields.TRANSFER_DEST = transfer_dest
#define set_DMA_VIPH3_COMMAND_source_offset_hold(reg, source_offset_hold) (reg)->bitfields.SOURCE_OFFSET_HOLD = source_offset_hold
#define set_DMA_VIPH3_COMMAND_dest_offset_hold(reg, dest_offset_hold) (reg)->bitfields.DEST_OFFSET_HOLD = dest_offset_hold
#define set_DMA_VIPH3_COMMAND_interrupt_dis(reg, interrupt_dis) (reg)->bitfields.INTERRUPT_DIS = interrupt_dis
#define set_DMA_VIPH3_COMMAND_end_of_list_status(reg, end_of_list_status) (reg)->bitfields.END_OF_LIST_STATUS = end_of_list_status

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_VIPH_STATUS regDMA_VIPH_STATUS;

#ifdef DEBUG
__inline void set_DMA_VIPH_STATUS_dma_viph0_avail(regDMA_VIPH_STATUS *reg, unsigned int dma_viph0_avail)
{
  reg->bitfields.DMA_VIPH0_AVAIL = dma_viph0_avail;
  if (reg->bitfields.DMA_VIPH0_AVAIL != dma_viph0_avail) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_STATUS::DMA_VIPH0_AVAIL data too large\n");
}
__inline void set_DMA_VIPH_STATUS_dma_viph1_avail(regDMA_VIPH_STATUS *reg, unsigned int dma_viph1_avail)
{
  reg->bitfields.DMA_VIPH1_AVAIL = dma_viph1_avail;
  if (reg->bitfields.DMA_VIPH1_AVAIL != dma_viph1_avail) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_STATUS::DMA_VIPH1_AVAIL data too large\n");
}
__inline void set_DMA_VIPH_STATUS_dma_viph2_avail(regDMA_VIPH_STATUS *reg, unsigned int dma_viph2_avail)
{
  reg->bitfields.DMA_VIPH2_AVAIL = dma_viph2_avail;
  if (reg->bitfields.DMA_VIPH2_AVAIL != dma_viph2_avail) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_STATUS::DMA_VIPH2_AVAIL data too large\n");
}
__inline void set_DMA_VIPH_STATUS_dma_viph3_avail(regDMA_VIPH_STATUS *reg, unsigned int dma_viph3_avail)
{
  reg->bitfields.DMA_VIPH3_AVAIL = dma_viph3_avail;
  if (reg->bitfields.DMA_VIPH3_AVAIL != dma_viph3_avail) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_STATUS::DMA_VIPH3_AVAIL data too large\n");
}
__inline void set_DMA_VIPH_STATUS_dma_viph0_current(regDMA_VIPH_STATUS *reg, unsigned int dma_viph0_current)
{
  reg->bitfields.DMA_VIPH0_CURRENT = dma_viph0_current;
  if (reg->bitfields.DMA_VIPH0_CURRENT != dma_viph0_current) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_STATUS::DMA_VIPH0_CURRENT data too large\n");
}
__inline void set_DMA_VIPH_STATUS_dma_viph1_current(regDMA_VIPH_STATUS *reg, unsigned int dma_viph1_current)
{
  reg->bitfields.DMA_VIPH1_CURRENT = dma_viph1_current;
  if (reg->bitfields.DMA_VIPH1_CURRENT != dma_viph1_current) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_STATUS::DMA_VIPH1_CURRENT data too large\n");
}
__inline void set_DMA_VIPH_STATUS_dma_viph2_current(regDMA_VIPH_STATUS *reg, unsigned int dma_viph2_current)
{
  reg->bitfields.DMA_VIPH2_CURRENT = dma_viph2_current;
  if (reg->bitfields.DMA_VIPH2_CURRENT != dma_viph2_current) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_STATUS::DMA_VIPH2_CURRENT data too large\n");
}
__inline void set_DMA_VIPH_STATUS_dma_viph3_current(regDMA_VIPH_STATUS *reg, unsigned int dma_viph3_current)
{
  reg->bitfields.DMA_VIPH3_CURRENT = dma_viph3_current;
  if (reg->bitfields.DMA_VIPH3_CURRENT != dma_viph3_current) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_STATUS::DMA_VIPH3_CURRENT data too large\n");
}
__inline void set_DMA_VIPH_STATUS_dma_viph0_active(regDMA_VIPH_STATUS *reg, unsigned int dma_viph0_active)
{
  reg->bitfields.DMA_VIPH0_ACTIVE = dma_viph0_active;
  if (reg->bitfields.DMA_VIPH0_ACTIVE != dma_viph0_active) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_STATUS::DMA_VIPH0_ACTIVE data too large\n");
}
__inline void set_DMA_VIPH_STATUS_dma_viph1_active(regDMA_VIPH_STATUS *reg, unsigned int dma_viph1_active)
{
  reg->bitfields.DMA_VIPH1_ACTIVE = dma_viph1_active;
  if (reg->bitfields.DMA_VIPH1_ACTIVE != dma_viph1_active) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_STATUS::DMA_VIPH1_ACTIVE data too large\n");
}
__inline void set_DMA_VIPH_STATUS_dma_viph2_active(regDMA_VIPH_STATUS *reg, unsigned int dma_viph2_active)
{
  reg->bitfields.DMA_VIPH2_ACTIVE = dma_viph2_active;
  if (reg->bitfields.DMA_VIPH2_ACTIVE != dma_viph2_active) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_STATUS::DMA_VIPH2_ACTIVE data too large\n");
}
__inline void set_DMA_VIPH_STATUS_dma_viph3_active(regDMA_VIPH_STATUS *reg, unsigned int dma_viph3_active)
{
  reg->bitfields.DMA_VIPH3_ACTIVE = dma_viph3_active;
  if (reg->bitfields.DMA_VIPH3_ACTIVE != dma_viph3_active) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_STATUS::DMA_VIPH3_ACTIVE data too large\n");
}
#else
#define set_DMA_VIPH_STATUS_dma_viph0_avail(reg, dma_viph0_avail) (reg)->bitfields.DMA_VIPH0_AVAIL = dma_viph0_avail
#define set_DMA_VIPH_STATUS_dma_viph1_avail(reg, dma_viph1_avail) (reg)->bitfields.DMA_VIPH1_AVAIL = dma_viph1_avail
#define set_DMA_VIPH_STATUS_dma_viph2_avail(reg, dma_viph2_avail) (reg)->bitfields.DMA_VIPH2_AVAIL = dma_viph2_avail
#define set_DMA_VIPH_STATUS_dma_viph3_avail(reg, dma_viph3_avail) (reg)->bitfields.DMA_VIPH3_AVAIL = dma_viph3_avail
#define set_DMA_VIPH_STATUS_dma_viph0_current(reg, dma_viph0_current) (reg)->bitfields.DMA_VIPH0_CURRENT = dma_viph0_current
#define set_DMA_VIPH_STATUS_dma_viph1_current(reg, dma_viph1_current) (reg)->bitfields.DMA_VIPH1_CURRENT = dma_viph1_current
#define set_DMA_VIPH_STATUS_dma_viph2_current(reg, dma_viph2_current) (reg)->bitfields.DMA_VIPH2_CURRENT = dma_viph2_current
#define set_DMA_VIPH_STATUS_dma_viph3_current(reg, dma_viph3_current) (reg)->bitfields.DMA_VIPH3_CURRENT = dma_viph3_current
#define set_DMA_VIPH_STATUS_dma_viph0_active(reg, dma_viph0_active) (reg)->bitfields.DMA_VIPH0_ACTIVE = dma_viph0_active
#define set_DMA_VIPH_STATUS_dma_viph1_active(reg, dma_viph1_active) (reg)->bitfields.DMA_VIPH1_ACTIVE = dma_viph1_active
#define set_DMA_VIPH_STATUS_dma_viph2_active(reg, dma_viph2_active) (reg)->bitfields.DMA_VIPH2_ACTIVE = dma_viph2_active
#define set_DMA_VIPH_STATUS_dma_viph3_active(reg, dma_viph3_active) (reg)->bitfields.DMA_VIPH3_ACTIVE = dma_viph3_active

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_VIPH_CHUNK_0 regDMA_VIPH_CHUNK_0;

#ifdef DEBUG
__inline void set_DMA_VIPH_CHUNK_0_dma_viph3_table_swap(regDMA_VIPH_CHUNK_0 *reg, unsigned int dma_viph3_table_swap)
{
  reg->bitfields.DMA_VIPH3_TABLE_SWAP = dma_viph3_table_swap;
  if (reg->bitfields.DMA_VIPH3_TABLE_SWAP != dma_viph3_table_swap) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_CHUNK_0::DMA_VIPH3_TABLE_SWAP data too large\n");
}
__inline void set_DMA_VIPH_CHUNK_0_dma_viph2_table_swap(regDMA_VIPH_CHUNK_0 *reg, unsigned int dma_viph2_table_swap)
{
  reg->bitfields.DMA_VIPH2_TABLE_SWAP = dma_viph2_table_swap;
  if (reg->bitfields.DMA_VIPH2_TABLE_SWAP != dma_viph2_table_swap) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_CHUNK_0::DMA_VIPH2_TABLE_SWAP data too large\n");
}
__inline void set_DMA_VIPH_CHUNK_0_dma_viph1_table_swap(regDMA_VIPH_CHUNK_0 *reg, unsigned int dma_viph1_table_swap)
{
  reg->bitfields.DMA_VIPH1_TABLE_SWAP = dma_viph1_table_swap;
  if (reg->bitfields.DMA_VIPH1_TABLE_SWAP != dma_viph1_table_swap) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_CHUNK_0::DMA_VIPH1_TABLE_SWAP data too large\n");
}
__inline void set_DMA_VIPH_CHUNK_0_dma_viph0_table_swap(regDMA_VIPH_CHUNK_0 *reg, unsigned int dma_viph0_table_swap)
{
  reg->bitfields.DMA_VIPH0_TABLE_SWAP = dma_viph0_table_swap;
  if (reg->bitfields.DMA_VIPH0_TABLE_SWAP != dma_viph0_table_swap) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_CHUNK_0::DMA_VIPH0_TABLE_SWAP data too large\n");
}
__inline void set_DMA_VIPH_CHUNK_0_dma_viph3_nochunk(regDMA_VIPH_CHUNK_0 *reg, unsigned int dma_viph3_nochunk)
{
  reg->bitfields.DMA_VIPH3_NOCHUNK = dma_viph3_nochunk;
  if (reg->bitfields.DMA_VIPH3_NOCHUNK != dma_viph3_nochunk) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_CHUNK_0::DMA_VIPH3_NOCHUNK data too large\n");
}
__inline void set_DMA_VIPH_CHUNK_0_dma_viph2_nochunk(regDMA_VIPH_CHUNK_0 *reg, unsigned int dma_viph2_nochunk)
{
  reg->bitfields.DMA_VIPH2_NOCHUNK = dma_viph2_nochunk;
  if (reg->bitfields.DMA_VIPH2_NOCHUNK != dma_viph2_nochunk) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_CHUNK_0::DMA_VIPH2_NOCHUNK data too large\n");
}
__inline void set_DMA_VIPH_CHUNK_0_dma_viph1_nochunk(regDMA_VIPH_CHUNK_0 *reg, unsigned int dma_viph1_nochunk)
{
  reg->bitfields.DMA_VIPH1_NOCHUNK = dma_viph1_nochunk;
  if (reg->bitfields.DMA_VIPH1_NOCHUNK != dma_viph1_nochunk) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_CHUNK_0::DMA_VIPH1_NOCHUNK data too large\n");
}
__inline void set_DMA_VIPH_CHUNK_0_dma_viph0_nochunk(regDMA_VIPH_CHUNK_0 *reg, unsigned int dma_viph0_nochunk)
{
  reg->bitfields.DMA_VIPH0_NOCHUNK = dma_viph0_nochunk;
  if (reg->bitfields.DMA_VIPH0_NOCHUNK != dma_viph0_nochunk) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_CHUNK_0::DMA_VIPH0_NOCHUNK data too large\n");
}
#else
#define set_DMA_VIPH_CHUNK_0_dma_viph3_table_swap(reg, dma_viph3_table_swap) (reg)->bitfields.DMA_VIPH3_TABLE_SWAP = dma_viph3_table_swap
#define set_DMA_VIPH_CHUNK_0_dma_viph2_table_swap(reg, dma_viph2_table_swap) (reg)->bitfields.DMA_VIPH2_TABLE_SWAP = dma_viph2_table_swap
#define set_DMA_VIPH_CHUNK_0_dma_viph1_table_swap(reg, dma_viph1_table_swap) (reg)->bitfields.DMA_VIPH1_TABLE_SWAP = dma_viph1_table_swap
#define set_DMA_VIPH_CHUNK_0_dma_viph0_table_swap(reg, dma_viph0_table_swap) (reg)->bitfields.DMA_VIPH0_TABLE_SWAP = dma_viph0_table_swap
#define set_DMA_VIPH_CHUNK_0_dma_viph3_nochunk(reg, dma_viph3_nochunk) (reg)->bitfields.DMA_VIPH3_NOCHUNK = dma_viph3_nochunk
#define set_DMA_VIPH_CHUNK_0_dma_viph2_nochunk(reg, dma_viph2_nochunk) (reg)->bitfields.DMA_VIPH2_NOCHUNK = dma_viph2_nochunk
#define set_DMA_VIPH_CHUNK_0_dma_viph1_nochunk(reg, dma_viph1_nochunk) (reg)->bitfields.DMA_VIPH1_NOCHUNK = dma_viph1_nochunk
#define set_DMA_VIPH_CHUNK_0_dma_viph0_nochunk(reg, dma_viph0_nochunk) (reg)->bitfields.DMA_VIPH0_NOCHUNK = dma_viph0_nochunk

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_VIPH_CHUNK_1_VAL regDMA_VIPH_CHUNK_1_VAL;

#ifdef DEBUG
__inline void set_DMA_VIPH_CHUNK_1_VAL_dma_vip0_chunk(regDMA_VIPH_CHUNK_1_VAL *reg, unsigned int dma_vip0_chunk)
{
  reg->bitfields.DMA_VIP0_CHUNK = dma_vip0_chunk;
  if (reg->bitfields.DMA_VIP0_CHUNK != dma_vip0_chunk) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_CHUNK_1_VAL::DMA_VIP0_CHUNK data too large\n");
}
__inline void set_DMA_VIPH_CHUNK_1_VAL_dma_vip1_chunk(regDMA_VIPH_CHUNK_1_VAL *reg, unsigned int dma_vip1_chunk)
{
  reg->bitfields.DMA_VIP1_CHUNK = dma_vip1_chunk;
  if (reg->bitfields.DMA_VIP1_CHUNK != dma_vip1_chunk) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_CHUNK_1_VAL::DMA_VIP1_CHUNK data too large\n");
}
__inline void set_DMA_VIPH_CHUNK_1_VAL_dma_vip2_chunk(regDMA_VIPH_CHUNK_1_VAL *reg, unsigned int dma_vip2_chunk)
{
  reg->bitfields.DMA_VIP2_CHUNK = dma_vip2_chunk;
  if (reg->bitfields.DMA_VIP2_CHUNK != dma_vip2_chunk) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_CHUNK_1_VAL::DMA_VIP2_CHUNK data too large\n");
}
__inline void set_DMA_VIPH_CHUNK_1_VAL_dma_vip3_chunk(regDMA_VIPH_CHUNK_1_VAL *reg, unsigned int dma_vip3_chunk)
{
  reg->bitfields.DMA_VIP3_CHUNK = dma_vip3_chunk;
  if (reg->bitfields.DMA_VIP3_CHUNK != dma_vip3_chunk) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_CHUNK_1_VAL::DMA_VIP3_CHUNK data too large\n");
}
#else
#define set_DMA_VIPH_CHUNK_1_VAL_dma_vip0_chunk(reg, dma_vip0_chunk) (reg)->bitfields.DMA_VIP0_CHUNK = dma_vip0_chunk
#define set_DMA_VIPH_CHUNK_1_VAL_dma_vip1_chunk(reg, dma_vip1_chunk) (reg)->bitfields.DMA_VIP1_CHUNK = dma_vip1_chunk
#define set_DMA_VIPH_CHUNK_1_VAL_dma_vip2_chunk(reg, dma_vip2_chunk) (reg)->bitfields.DMA_VIP2_CHUNK = dma_vip2_chunk
#define set_DMA_VIPH_CHUNK_1_VAL_dma_vip3_chunk(reg, dma_vip3_chunk) (reg)->bitfields.DMA_VIP3_CHUNK = dma_vip3_chunk

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_VIP0_TABLE_ADDR regDMA_VIP0_TABLE_ADDR;

#ifdef DEBUG
__inline void set_DMA_VIP0_TABLE_ADDR_dma_viph_table_addr(regDMA_VIP0_TABLE_ADDR *reg, unsigned int dma_viph_table_addr)
{
  reg->bitfields.DMA_VIPH_TABLE_ADDR = dma_viph_table_addr;
  if (reg->bitfields.DMA_VIPH_TABLE_ADDR != dma_viph_table_addr) HSLDPF(E_ERROR_MESSAGE,"DMA_VIP0_TABLE_ADDR::DMA_VIPH_TABLE_ADDR data too large\n");
}
#else
#define set_DMA_VIP0_TABLE_ADDR_dma_viph_table_addr(reg, dma_viph_table_addr) (reg)->bitfields.DMA_VIPH_TABLE_ADDR = dma_viph_table_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_VIP1_TABLE_ADDR regDMA_VIP1_TABLE_ADDR;

#ifdef DEBUG
__inline void set_DMA_VIP1_TABLE_ADDR_dma_viph_table_addr(regDMA_VIP1_TABLE_ADDR *reg, unsigned int dma_viph_table_addr)
{
  reg->bitfields.DMA_VIPH_TABLE_ADDR = dma_viph_table_addr;
  if (reg->bitfields.DMA_VIPH_TABLE_ADDR != dma_viph_table_addr) HSLDPF(E_ERROR_MESSAGE,"DMA_VIP1_TABLE_ADDR::DMA_VIPH_TABLE_ADDR data too large\n");
}
#else
#define set_DMA_VIP1_TABLE_ADDR_dma_viph_table_addr(reg, dma_viph_table_addr) (reg)->bitfields.DMA_VIPH_TABLE_ADDR = dma_viph_table_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_VIP2_TABLE_ADDR regDMA_VIP2_TABLE_ADDR;

#ifdef DEBUG
__inline void set_DMA_VIP2_TABLE_ADDR_dma_viph_table_addr(regDMA_VIP2_TABLE_ADDR *reg, unsigned int dma_viph_table_addr)
{
  reg->bitfields.DMA_VIPH_TABLE_ADDR = dma_viph_table_addr;
  if (reg->bitfields.DMA_VIPH_TABLE_ADDR != dma_viph_table_addr) HSLDPF(E_ERROR_MESSAGE,"DMA_VIP2_TABLE_ADDR::DMA_VIPH_TABLE_ADDR data too large\n");
}
#else
#define set_DMA_VIP2_TABLE_ADDR_dma_viph_table_addr(reg, dma_viph_table_addr) (reg)->bitfields.DMA_VIPH_TABLE_ADDR = dma_viph_table_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_VIP3_TABLE_ADDR regDMA_VIP3_TABLE_ADDR;

#ifdef DEBUG
__inline void set_DMA_VIP3_TABLE_ADDR_dma_viph_table_addr(regDMA_VIP3_TABLE_ADDR *reg, unsigned int dma_viph_table_addr)
{
  reg->bitfields.DMA_VIPH_TABLE_ADDR = dma_viph_table_addr;
  if (reg->bitfields.DMA_VIPH_TABLE_ADDR != dma_viph_table_addr) HSLDPF(E_ERROR_MESSAGE,"DMA_VIP3_TABLE_ADDR::DMA_VIPH_TABLE_ADDR data too large\n");
}
#else
#define set_DMA_VIP3_TABLE_ADDR_dma_viph_table_addr(reg, dma_viph_table_addr) (reg)->bitfields.DMA_VIPH_TABLE_ADDR = dma_viph_table_addr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_VIPH0_ACTIVE regDMA_VIPH0_ACTIVE;

#ifdef DEBUG
__inline void set_DMA_VIPH0_ACTIVE_dma_viph_table_addr_act(regDMA_VIPH0_ACTIVE *reg, unsigned int dma_viph_table_addr_act)
{
  reg->bitfields.DMA_VIPH_TABLE_ADDR_ACT = dma_viph_table_addr_act;
  if (reg->bitfields.DMA_VIPH_TABLE_ADDR_ACT != dma_viph_table_addr_act) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH0_ACTIVE::DMA_VIPH_TABLE_ADDR_ACT data too large\n");
}
#else
#define set_DMA_VIPH0_ACTIVE_dma_viph_table_addr_act(reg, dma_viph_table_addr_act) (reg)->bitfields.DMA_VIPH_TABLE_ADDR_ACT = dma_viph_table_addr_act

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_VIPH1_ACTIVE regDMA_VIPH1_ACTIVE;

#ifdef DEBUG
__inline void set_DMA_VIPH1_ACTIVE_dma_viph_table_addr_act(regDMA_VIPH1_ACTIVE *reg, unsigned int dma_viph_table_addr_act)
{
  reg->bitfields.DMA_VIPH_TABLE_ADDR_ACT = dma_viph_table_addr_act;
  if (reg->bitfields.DMA_VIPH_TABLE_ADDR_ACT != dma_viph_table_addr_act) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH1_ACTIVE::DMA_VIPH_TABLE_ADDR_ACT data too large\n");
}
#else
#define set_DMA_VIPH1_ACTIVE_dma_viph_table_addr_act(reg, dma_viph_table_addr_act) (reg)->bitfields.DMA_VIPH_TABLE_ADDR_ACT = dma_viph_table_addr_act

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_VIPH2_ACTIVE regDMA_VIPH2_ACTIVE;

#ifdef DEBUG
__inline void set_DMA_VIPH2_ACTIVE_dma_viph_table_addr_act(regDMA_VIPH2_ACTIVE *reg, unsigned int dma_viph_table_addr_act)
{
  reg->bitfields.DMA_VIPH_TABLE_ADDR_ACT = dma_viph_table_addr_act;
  if (reg->bitfields.DMA_VIPH_TABLE_ADDR_ACT != dma_viph_table_addr_act) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH2_ACTIVE::DMA_VIPH_TABLE_ADDR_ACT data too large\n");
}
#else
#define set_DMA_VIPH2_ACTIVE_dma_viph_table_addr_act(reg, dma_viph_table_addr_act) (reg)->bitfields.DMA_VIPH_TABLE_ADDR_ACT = dma_viph_table_addr_act

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_VIPH3_ACTIVE regDMA_VIPH3_ACTIVE;

#ifdef DEBUG
__inline void set_DMA_VIPH3_ACTIVE_dma_viph_table_addr_act(regDMA_VIPH3_ACTIVE *reg, unsigned int dma_viph_table_addr_act)
{
  reg->bitfields.DMA_VIPH_TABLE_ADDR_ACT = dma_viph_table_addr_act;
  if (reg->bitfields.DMA_VIPH_TABLE_ADDR_ACT != dma_viph_table_addr_act) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH3_ACTIVE::DMA_VIPH_TABLE_ADDR_ACT data too large\n");
}
#else
#define set_DMA_VIPH3_ACTIVE_dma_viph_table_addr_act(reg, dma_viph_table_addr_act) (reg)->bitfields.DMA_VIPH_TABLE_ADDR_ACT = dma_viph_table_addr_act

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DMA_VIPH_ABORT regDMA_VIPH_ABORT;

#ifdef DEBUG
__inline void set_DMA_VIPH_ABORT_dma_viph0_abort_en(regDMA_VIPH_ABORT *reg, unsigned int dma_viph0_abort_en)
{
  reg->bitfields.DMA_VIPH0_ABORT_EN = dma_viph0_abort_en;
  if (reg->bitfields.DMA_VIPH0_ABORT_EN != dma_viph0_abort_en) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_ABORT::DMA_VIPH0_ABORT_EN data too large\n");
}
__inline void set_DMA_VIPH_ABORT_dma_viph1_abort_en(regDMA_VIPH_ABORT *reg, unsigned int dma_viph1_abort_en)
{
  reg->bitfields.DMA_VIPH1_ABORT_EN = dma_viph1_abort_en;
  if (reg->bitfields.DMA_VIPH1_ABORT_EN != dma_viph1_abort_en) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_ABORT::DMA_VIPH1_ABORT_EN data too large\n");
}
__inline void set_DMA_VIPH_ABORT_dma_viph2_abort_en(regDMA_VIPH_ABORT *reg, unsigned int dma_viph2_abort_en)
{
  reg->bitfields.DMA_VIPH2_ABORT_EN = dma_viph2_abort_en;
  if (reg->bitfields.DMA_VIPH2_ABORT_EN != dma_viph2_abort_en) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_ABORT::DMA_VIPH2_ABORT_EN data too large\n");
}
__inline void set_DMA_VIPH_ABORT_dma_viph3_abort_en(regDMA_VIPH_ABORT *reg, unsigned int dma_viph3_abort_en)
{
  reg->bitfields.DMA_VIPH3_ABORT_EN = dma_viph3_abort_en;
  if (reg->bitfields.DMA_VIPH3_ABORT_EN != dma_viph3_abort_en) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_ABORT::DMA_VIPH3_ABORT_EN data too large\n");
}
__inline void set_DMA_VIPH_ABORT_dma_viph0_reset(regDMA_VIPH_ABORT *reg, unsigned int dma_viph0_reset)
{
  reg->bitfields.DMA_VIPH0_RESET = dma_viph0_reset;
  if (reg->bitfields.DMA_VIPH0_RESET != dma_viph0_reset) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_ABORT::DMA_VIPH0_RESET data too large\n");
}
__inline void set_DMA_VIPH_ABORT_dma_viph1_reset(regDMA_VIPH_ABORT *reg, unsigned int dma_viph1_reset)
{
  reg->bitfields.DMA_VIPH1_RESET = dma_viph1_reset;
  if (reg->bitfields.DMA_VIPH1_RESET != dma_viph1_reset) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_ABORT::DMA_VIPH1_RESET data too large\n");
}
__inline void set_DMA_VIPH_ABORT_dma_viph2_reset(regDMA_VIPH_ABORT *reg, unsigned int dma_viph2_reset)
{
  reg->bitfields.DMA_VIPH2_RESET = dma_viph2_reset;
  if (reg->bitfields.DMA_VIPH2_RESET != dma_viph2_reset) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_ABORT::DMA_VIPH2_RESET data too large\n");
}
__inline void set_DMA_VIPH_ABORT_dma_viph3_reset(regDMA_VIPH_ABORT *reg, unsigned int dma_viph3_reset)
{
  reg->bitfields.DMA_VIPH3_RESET = dma_viph3_reset;
  if (reg->bitfields.DMA_VIPH3_RESET != dma_viph3_reset) HSLDPF(E_ERROR_MESSAGE,"DMA_VIPH_ABORT::DMA_VIPH3_RESET data too large\n");
}
#else
#define set_DMA_VIPH_ABORT_dma_viph0_abort_en(reg, dma_viph0_abort_en) (reg)->bitfields.DMA_VIPH0_ABORT_EN = dma_viph0_abort_en
#define set_DMA_VIPH_ABORT_dma_viph1_abort_en(reg, dma_viph1_abort_en) (reg)->bitfields.DMA_VIPH1_ABORT_EN = dma_viph1_abort_en
#define set_DMA_VIPH_ABORT_dma_viph2_abort_en(reg, dma_viph2_abort_en) (reg)->bitfields.DMA_VIPH2_ABORT_EN = dma_viph2_abort_en
#define set_DMA_VIPH_ABORT_dma_viph3_abort_en(reg, dma_viph3_abort_en) (reg)->bitfields.DMA_VIPH3_ABORT_EN = dma_viph3_abort_en
#define set_DMA_VIPH_ABORT_dma_viph0_reset(reg, dma_viph0_reset) (reg)->bitfields.DMA_VIPH0_RESET = dma_viph0_reset
#define set_DMA_VIPH_ABORT_dma_viph1_reset(reg, dma_viph1_reset) (reg)->bitfields.DMA_VIPH1_RESET = dma_viph1_reset
#define set_DMA_VIPH_ABORT_dma_viph2_reset(reg, dma_viph2_reset) (reg)->bitfields.DMA_VIPH2_RESET = dma_viph2_reset
#define set_DMA_VIPH_ABORT_dma_viph3_reset(reg, dma_viph3_reset) (reg)->bitfields.DMA_VIPH3_RESET = dma_viph3_reset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_REG_ADDR regVIPH_REG_ADDR;

#ifdef DEBUG
__inline void set_VIPH_REG_ADDR_viph_reg_ad(regVIPH_REG_ADDR *reg, unsigned int viph_reg_ad)
{
  reg->bitfields.VIPH_REG_AD = viph_reg_ad;
  if (reg->bitfields.VIPH_REG_AD != viph_reg_ad) HSLDPF(E_ERROR_MESSAGE,"VIPH_REG_ADDR::VIPH_REG_AD data too large\n");
}
#else
#define set_VIPH_REG_ADDR_viph_reg_ad(reg, viph_reg_ad) (reg)->bitfields.VIPH_REG_AD = viph_reg_ad

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_REG_DATA regVIPH_REG_DATA;

#ifdef DEBUG
__inline void set_VIPH_REG_DATA_viph_reg_dt_r(regVIPH_REG_DATA *reg, unsigned int viph_reg_dt_r)
{
  reg->bitfields.VIPH_REG_DT_R = viph_reg_dt_r;
  if (reg->bitfields.VIPH_REG_DT_R != viph_reg_dt_r) HSLDPF(E_ERROR_MESSAGE,"VIPH_REG_DATA::VIPH_REG_DT_R data too large\n");
}
#else
#define set_VIPH_REG_DATA_viph_reg_dt_r(reg, viph_reg_dt_r) (reg)->bitfields.VIPH_REG_DT_R = viph_reg_dt_r

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_CH0_DATA regVIPH_CH0_DATA;

#ifdef DEBUG
__inline void set_VIPH_CH0_DATA_viph_ch0_dt(regVIPH_CH0_DATA *reg, unsigned int viph_ch0_dt)
{
  reg->bitfields.VIPH_CH0_DT = viph_ch0_dt;
  if (reg->bitfields.VIPH_CH0_DT != viph_ch0_dt) HSLDPF(E_ERROR_MESSAGE,"VIPH_CH0_DATA::VIPH_CH0_DT data too large\n");
}
#else
#define set_VIPH_CH0_DATA_viph_ch0_dt(reg, viph_ch0_dt) (reg)->bitfields.VIPH_CH0_DT = viph_ch0_dt

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_CH1_DATA regVIPH_CH1_DATA;

#ifdef DEBUG
__inline void set_VIPH_CH1_DATA_viph_ch1_dt(regVIPH_CH1_DATA *reg, unsigned int viph_ch1_dt)
{
  reg->bitfields.VIPH_CH1_DT = viph_ch1_dt;
  if (reg->bitfields.VIPH_CH1_DT != viph_ch1_dt) HSLDPF(E_ERROR_MESSAGE,"VIPH_CH1_DATA::VIPH_CH1_DT data too large\n");
}
#else
#define set_VIPH_CH1_DATA_viph_ch1_dt(reg, viph_ch1_dt) (reg)->bitfields.VIPH_CH1_DT = viph_ch1_dt

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_CH2_DATA regVIPH_CH2_DATA;

#ifdef DEBUG
__inline void set_VIPH_CH2_DATA_viph_ch2_dt(regVIPH_CH2_DATA *reg, unsigned int viph_ch2_dt)
{
  reg->bitfields.VIPH_CH2_DT = viph_ch2_dt;
  if (reg->bitfields.VIPH_CH2_DT != viph_ch2_dt) HSLDPF(E_ERROR_MESSAGE,"VIPH_CH2_DATA::VIPH_CH2_DT data too large\n");
}
#else
#define set_VIPH_CH2_DATA_viph_ch2_dt(reg, viph_ch2_dt) (reg)->bitfields.VIPH_CH2_DT = viph_ch2_dt

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_CH3_DATA regVIPH_CH3_DATA;

#ifdef DEBUG
__inline void set_VIPH_CH3_DATA_viph_ch3_dt(regVIPH_CH3_DATA *reg, unsigned int viph_ch3_dt)
{
  reg->bitfields.VIPH_CH3_DT = viph_ch3_dt;
  if (reg->bitfields.VIPH_CH3_DT != viph_ch3_dt) HSLDPF(E_ERROR_MESSAGE,"VIPH_CH3_DATA::VIPH_CH3_DT data too large\n");
}
#else
#define set_VIPH_CH3_DATA_viph_ch3_dt(reg, viph_ch3_dt) (reg)->bitfields.VIPH_CH3_DT = viph_ch3_dt

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_CH0_ADDR regVIPH_CH0_ADDR;

#ifdef DEBUG
__inline void set_VIPH_CH0_ADDR_viph_ch0_ad(regVIPH_CH0_ADDR *reg, unsigned int viph_ch0_ad)
{
  reg->bitfields.VIPH_CH0_AD = viph_ch0_ad;
  if (reg->bitfields.VIPH_CH0_AD != viph_ch0_ad) HSLDPF(E_ERROR_MESSAGE,"VIPH_CH0_ADDR::VIPH_CH0_AD data too large\n");
}
#else
#define set_VIPH_CH0_ADDR_viph_ch0_ad(reg, viph_ch0_ad) (reg)->bitfields.VIPH_CH0_AD = viph_ch0_ad

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_CH1_ADDR regVIPH_CH1_ADDR;

#ifdef DEBUG
__inline void set_VIPH_CH1_ADDR_viph_ch1_ad(regVIPH_CH1_ADDR *reg, unsigned int viph_ch1_ad)
{
  reg->bitfields.VIPH_CH1_AD = viph_ch1_ad;
  if (reg->bitfields.VIPH_CH1_AD != viph_ch1_ad) HSLDPF(E_ERROR_MESSAGE,"VIPH_CH1_ADDR::VIPH_CH1_AD data too large\n");
}
#else
#define set_VIPH_CH1_ADDR_viph_ch1_ad(reg, viph_ch1_ad) (reg)->bitfields.VIPH_CH1_AD = viph_ch1_ad

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_CH2_ADDR regVIPH_CH2_ADDR;

#ifdef DEBUG
__inline void set_VIPH_CH2_ADDR_viph_ch2_ad(regVIPH_CH2_ADDR *reg, unsigned int viph_ch2_ad)
{
  reg->bitfields.VIPH_CH2_AD = viph_ch2_ad;
  if (reg->bitfields.VIPH_CH2_AD != viph_ch2_ad) HSLDPF(E_ERROR_MESSAGE,"VIPH_CH2_ADDR::VIPH_CH2_AD data too large\n");
}
#else
#define set_VIPH_CH2_ADDR_viph_ch2_ad(reg, viph_ch2_ad) (reg)->bitfields.VIPH_CH2_AD = viph_ch2_ad

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_CH3_ADDR regVIPH_CH3_ADDR;

#ifdef DEBUG
__inline void set_VIPH_CH3_ADDR_viph_ch3_ad(regVIPH_CH3_ADDR *reg, unsigned int viph_ch3_ad)
{
  reg->bitfields.VIPH_CH3_AD = viph_ch3_ad;
  if (reg->bitfields.VIPH_CH3_AD != viph_ch3_ad) HSLDPF(E_ERROR_MESSAGE,"VIPH_CH3_ADDR::VIPH_CH3_AD data too large\n");
}
#else
#define set_VIPH_CH3_ADDR_viph_ch3_ad(reg, viph_ch3_ad) (reg)->bitfields.VIPH_CH3_AD = viph_ch3_ad

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_CH0_SBCNT regVIPH_CH0_SBCNT;

#ifdef DEBUG
__inline void set_VIPH_CH0_SBCNT_viph_ch0_scnt(regVIPH_CH0_SBCNT *reg, unsigned int viph_ch0_scnt)
{
  reg->bitfields.VIPH_CH0_SCNT = viph_ch0_scnt;
  if (reg->bitfields.VIPH_CH0_SCNT != viph_ch0_scnt) HSLDPF(E_ERROR_MESSAGE,"VIPH_CH0_SBCNT::VIPH_CH0_SCNT data too large\n");
}
#else
#define set_VIPH_CH0_SBCNT_viph_ch0_scnt(reg, viph_ch0_scnt) (reg)->bitfields.VIPH_CH0_SCNT = viph_ch0_scnt

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_CH1_SBCNT regVIPH_CH1_SBCNT;

#ifdef DEBUG
__inline void set_VIPH_CH1_SBCNT_viph_ch1_scnt(regVIPH_CH1_SBCNT *reg, unsigned int viph_ch1_scnt)
{
  reg->bitfields.VIPH_CH1_SCNT = viph_ch1_scnt;
  if (reg->bitfields.VIPH_CH1_SCNT != viph_ch1_scnt) HSLDPF(E_ERROR_MESSAGE,"VIPH_CH1_SBCNT::VIPH_CH1_SCNT data too large\n");
}
#else
#define set_VIPH_CH1_SBCNT_viph_ch1_scnt(reg, viph_ch1_scnt) (reg)->bitfields.VIPH_CH1_SCNT = viph_ch1_scnt

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_CH2_SBCNT regVIPH_CH2_SBCNT;

#ifdef DEBUG
__inline void set_VIPH_CH2_SBCNT_viph_ch2_scnt(regVIPH_CH2_SBCNT *reg, unsigned int viph_ch2_scnt)
{
  reg->bitfields.VIPH_CH2_SCNT = viph_ch2_scnt;
  if (reg->bitfields.VIPH_CH2_SCNT != viph_ch2_scnt) HSLDPF(E_ERROR_MESSAGE,"VIPH_CH2_SBCNT::VIPH_CH2_SCNT data too large\n");
}
#else
#define set_VIPH_CH2_SBCNT_viph_ch2_scnt(reg, viph_ch2_scnt) (reg)->bitfields.VIPH_CH2_SCNT = viph_ch2_scnt

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_CH3_SBCNT regVIPH_CH3_SBCNT;

#ifdef DEBUG
__inline void set_VIPH_CH3_SBCNT_viph_ch3_scnt(regVIPH_CH3_SBCNT *reg, unsigned int viph_ch3_scnt)
{
  reg->bitfields.VIPH_CH3_SCNT = viph_ch3_scnt;
  if (reg->bitfields.VIPH_CH3_SCNT != viph_ch3_scnt) HSLDPF(E_ERROR_MESSAGE,"VIPH_CH3_SBCNT::VIPH_CH3_SCNT data too large\n");
}
#else
#define set_VIPH_CH3_SBCNT_viph_ch3_scnt(reg, viph_ch3_scnt) (reg)->bitfields.VIPH_CH3_SCNT = viph_ch3_scnt

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_CH0_ABCNT regVIPH_CH0_ABCNT;

#ifdef DEBUG
__inline void set_VIPH_CH0_ABCNT_viph_ch0_acnt(regVIPH_CH0_ABCNT *reg, unsigned int viph_ch0_acnt)
{
  reg->bitfields.VIPH_CH0_ACNT = viph_ch0_acnt;
  if (reg->bitfields.VIPH_CH0_ACNT != viph_ch0_acnt) HSLDPF(E_ERROR_MESSAGE,"VIPH_CH0_ABCNT::VIPH_CH0_ACNT data too large\n");
}
#else
#define set_VIPH_CH0_ABCNT_viph_ch0_acnt(reg, viph_ch0_acnt) (reg)->bitfields.VIPH_CH0_ACNT = viph_ch0_acnt

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_CH1_ABCNT regVIPH_CH1_ABCNT;

#ifdef DEBUG
__inline void set_VIPH_CH1_ABCNT_viph_ch1_acnt(regVIPH_CH1_ABCNT *reg, unsigned int viph_ch1_acnt)
{
  reg->bitfields.VIPH_CH1_ACNT = viph_ch1_acnt;
  if (reg->bitfields.VIPH_CH1_ACNT != viph_ch1_acnt) HSLDPF(E_ERROR_MESSAGE,"VIPH_CH1_ABCNT::VIPH_CH1_ACNT data too large\n");
}
#else
#define set_VIPH_CH1_ABCNT_viph_ch1_acnt(reg, viph_ch1_acnt) (reg)->bitfields.VIPH_CH1_ACNT = viph_ch1_acnt

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_CH2_ABCNT regVIPH_CH2_ABCNT;

#ifdef DEBUG
__inline void set_VIPH_CH2_ABCNT_viph_ch2_acnt(regVIPH_CH2_ABCNT *reg, unsigned int viph_ch2_acnt)
{
  reg->bitfields.VIPH_CH2_ACNT = viph_ch2_acnt;
  if (reg->bitfields.VIPH_CH2_ACNT != viph_ch2_acnt) HSLDPF(E_ERROR_MESSAGE,"VIPH_CH2_ABCNT::VIPH_CH2_ACNT data too large\n");
}
#else
#define set_VIPH_CH2_ABCNT_viph_ch2_acnt(reg, viph_ch2_acnt) (reg)->bitfields.VIPH_CH2_ACNT = viph_ch2_acnt

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_CH3_ABCNT regVIPH_CH3_ABCNT;

#ifdef DEBUG
__inline void set_VIPH_CH3_ABCNT_viph_ch3_acnt(regVIPH_CH3_ABCNT *reg, unsigned int viph_ch3_acnt)
{
  reg->bitfields.VIPH_CH3_ACNT = viph_ch3_acnt;
  if (reg->bitfields.VIPH_CH3_ACNT != viph_ch3_acnt) HSLDPF(E_ERROR_MESSAGE,"VIPH_CH3_ABCNT::VIPH_CH3_ACNT data too large\n");
}
#else
#define set_VIPH_CH3_ABCNT_viph_ch3_acnt(reg, viph_ch3_acnt) (reg)->bitfields.VIPH_CH3_ACNT = viph_ch3_acnt

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_CONTROL regVIPH_CONTROL;

#ifdef DEBUG
__inline void set_VIPH_CONTROL_viph_clk_sel(regVIPH_CONTROL *reg, unsigned int viph_clk_sel)
{
  reg->bitfields.VIPH_CLK_SEL = viph_clk_sel;
  if (reg->bitfields.VIPH_CLK_SEL != viph_clk_sel) HSLDPF(E_ERROR_MESSAGE,"VIPH_CONTROL::VIPH_CLK_SEL data too large\n");
}
__inline void set_VIPH_CONTROL_viph_reg_rdy(regVIPH_CONTROL *reg, unsigned int viph_reg_rdy)
{
  reg->bitfields.VIPH_REG_RDY = viph_reg_rdy;
  if (reg->bitfields.VIPH_REG_RDY != viph_reg_rdy) HSLDPF(E_ERROR_MESSAGE,"VIPH_CONTROL::VIPH_REG_RDY data too large\n");
}
__inline void set_VIPH_CONTROL_viph_max_wait(regVIPH_CONTROL *reg, unsigned int viph_max_wait)
{
  reg->bitfields.VIPH_MAX_WAIT = viph_max_wait;
  if (reg->bitfields.VIPH_MAX_WAIT != viph_max_wait) HSLDPF(E_ERROR_MESSAGE,"VIPH_CONTROL::VIPH_MAX_WAIT data too large\n");
}
__inline void set_VIPH_CONTROL_viph_dma_mode(regVIPH_CONTROL *reg, unsigned int viph_dma_mode)
{
  reg->bitfields.VIPH_DMA_MODE = viph_dma_mode;
  if (reg->bitfields.VIPH_DMA_MODE != viph_dma_mode) HSLDPF(E_ERROR_MESSAGE,"VIPH_CONTROL::VIPH_DMA_MODE data too large\n");
}
__inline void set_VIPH_CONTROL_viph_en(regVIPH_CONTROL *reg, unsigned int viph_en)
{
  reg->bitfields.VIPH_EN = viph_en;
  if (reg->bitfields.VIPH_EN != viph_en) HSLDPF(E_ERROR_MESSAGE,"VIPH_CONTROL::VIPH_EN data too large\n");
}
__inline void set_VIPH_CONTROL_viph_dv0_wid(regVIPH_CONTROL *reg, unsigned int viph_dv0_wid)
{
  reg->bitfields.VIPH_DV0_WID = viph_dv0_wid;
  if (reg->bitfields.VIPH_DV0_WID != viph_dv0_wid) HSLDPF(E_ERROR_MESSAGE,"VIPH_CONTROL::VIPH_DV0_WID data too large\n");
}
__inline void set_VIPH_CONTROL_viph_dv1_wid(regVIPH_CONTROL *reg, unsigned int viph_dv1_wid)
{
  reg->bitfields.VIPH_DV1_WID = viph_dv1_wid;
  if (reg->bitfields.VIPH_DV1_WID != viph_dv1_wid) HSLDPF(E_ERROR_MESSAGE,"VIPH_CONTROL::VIPH_DV1_WID data too large\n");
}
__inline void set_VIPH_CONTROL_viph_dv2_wid(regVIPH_CONTROL *reg, unsigned int viph_dv2_wid)
{
  reg->bitfields.VIPH_DV2_WID = viph_dv2_wid;
  if (reg->bitfields.VIPH_DV2_WID != viph_dv2_wid) HSLDPF(E_ERROR_MESSAGE,"VIPH_CONTROL::VIPH_DV2_WID data too large\n");
}
__inline void set_VIPH_CONTROL_viph_dv3_wid(regVIPH_CONTROL *reg, unsigned int viph_dv3_wid)
{
  reg->bitfields.VIPH_DV3_WID = viph_dv3_wid;
  if (reg->bitfields.VIPH_DV3_WID != viph_dv3_wid) HSLDPF(E_ERROR_MESSAGE,"VIPH_CONTROL::VIPH_DV3_WID data too large\n");
}
__inline void set_VIPH_CONTROL_viph_pwr_down(regVIPH_CONTROL *reg, unsigned int viph_pwr_down)
{
  reg->bitfields.VIPH_PWR_DOWN = viph_pwr_down;
  if (reg->bitfields.VIPH_PWR_DOWN != viph_pwr_down) HSLDPF(E_ERROR_MESSAGE,"VIPH_CONTROL::VIPH_PWR_DOWN data too large\n");
}
__inline void set_VIPH_CONTROL_viph_vipclk_dis(regVIPH_CONTROL *reg, unsigned int viph_vipclk_dis)
{
  reg->bitfields.VIPH_VIPCLK_DIS = viph_vipclk_dis;
  if (reg->bitfields.VIPH_VIPCLK_DIS != viph_vipclk_dis) HSLDPF(E_ERROR_MESSAGE,"VIPH_CONTROL::VIPH_VIPCLK_DIS data too large\n");
}
#else
#define set_VIPH_CONTROL_viph_clk_sel(reg, viph_clk_sel) (reg)->bitfields.VIPH_CLK_SEL = viph_clk_sel
#define set_VIPH_CONTROL_viph_reg_rdy(reg, viph_reg_rdy) (reg)->bitfields.VIPH_REG_RDY = viph_reg_rdy
#define set_VIPH_CONTROL_viph_max_wait(reg, viph_max_wait) (reg)->bitfields.VIPH_MAX_WAIT = viph_max_wait
#define set_VIPH_CONTROL_viph_dma_mode(reg, viph_dma_mode) (reg)->bitfields.VIPH_DMA_MODE = viph_dma_mode
#define set_VIPH_CONTROL_viph_en(reg, viph_en) (reg)->bitfields.VIPH_EN = viph_en
#define set_VIPH_CONTROL_viph_dv0_wid(reg, viph_dv0_wid) (reg)->bitfields.VIPH_DV0_WID = viph_dv0_wid
#define set_VIPH_CONTROL_viph_dv1_wid(reg, viph_dv1_wid) (reg)->bitfields.VIPH_DV1_WID = viph_dv1_wid
#define set_VIPH_CONTROL_viph_dv2_wid(reg, viph_dv2_wid) (reg)->bitfields.VIPH_DV2_WID = viph_dv2_wid
#define set_VIPH_CONTROL_viph_dv3_wid(reg, viph_dv3_wid) (reg)->bitfields.VIPH_DV3_WID = viph_dv3_wid
#define set_VIPH_CONTROL_viph_pwr_down(reg, viph_pwr_down) (reg)->bitfields.VIPH_PWR_DOWN = viph_pwr_down
#define set_VIPH_CONTROL_viph_vipclk_dis(reg, viph_vipclk_dis) (reg)->bitfields.VIPH_VIPCLK_DIS = viph_vipclk_dis

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_DV_LAT regVIPH_DV_LAT;

#ifdef DEBUG
__inline void set_VIPH_DV_LAT_viph_time_unit(regVIPH_DV_LAT *reg, unsigned int viph_time_unit)
{
  reg->bitfields.VIPH_TIME_UNIT = viph_time_unit;
  if (reg->bitfields.VIPH_TIME_UNIT != viph_time_unit) HSLDPF(E_ERROR_MESSAGE,"VIPH_DV_LAT::VIPH_TIME_UNIT data too large\n");
}
__inline void set_VIPH_DV_LAT_viph_dv0_lat(regVIPH_DV_LAT *reg, unsigned int viph_dv0_lat)
{
  reg->bitfields.VIPH_DV0_LAT = viph_dv0_lat;
  if (reg->bitfields.VIPH_DV0_LAT != viph_dv0_lat) HSLDPF(E_ERROR_MESSAGE,"VIPH_DV_LAT::VIPH_DV0_LAT data too large\n");
}
__inline void set_VIPH_DV_LAT_viph_dv1_lat(regVIPH_DV_LAT *reg, unsigned int viph_dv1_lat)
{
  reg->bitfields.VIPH_DV1_LAT = viph_dv1_lat;
  if (reg->bitfields.VIPH_DV1_LAT != viph_dv1_lat) HSLDPF(E_ERROR_MESSAGE,"VIPH_DV_LAT::VIPH_DV1_LAT data too large\n");
}
__inline void set_VIPH_DV_LAT_viph_dv2_lat(regVIPH_DV_LAT *reg, unsigned int viph_dv2_lat)
{
  reg->bitfields.VIPH_DV2_LAT = viph_dv2_lat;
  if (reg->bitfields.VIPH_DV2_LAT != viph_dv2_lat) HSLDPF(E_ERROR_MESSAGE,"VIPH_DV_LAT::VIPH_DV2_LAT data too large\n");
}
__inline void set_VIPH_DV_LAT_viph_dv3_lat(regVIPH_DV_LAT *reg, unsigned int viph_dv3_lat)
{
  reg->bitfields.VIPH_DV3_LAT = viph_dv3_lat;
  if (reg->bitfields.VIPH_DV3_LAT != viph_dv3_lat) HSLDPF(E_ERROR_MESSAGE,"VIPH_DV_LAT::VIPH_DV3_LAT data too large\n");
}
#else
#define set_VIPH_DV_LAT_viph_time_unit(reg, viph_time_unit) (reg)->bitfields.VIPH_TIME_UNIT = viph_time_unit
#define set_VIPH_DV_LAT_viph_dv0_lat(reg, viph_dv0_lat) (reg)->bitfields.VIPH_DV0_LAT = viph_dv0_lat
#define set_VIPH_DV_LAT_viph_dv1_lat(reg, viph_dv1_lat) (reg)->bitfields.VIPH_DV1_LAT = viph_dv1_lat
#define set_VIPH_DV_LAT_viph_dv2_lat(reg, viph_dv2_lat) (reg)->bitfields.VIPH_DV2_LAT = viph_dv2_lat
#define set_VIPH_DV_LAT_viph_dv3_lat(reg, viph_dv3_lat) (reg)->bitfields.VIPH_DV3_LAT = viph_dv3_lat

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_DMA_CHUNK regVIPH_DMA_CHUNK;

#ifdef DEBUG
__inline void set_VIPH_DMA_CHUNK_viph_ch0_chunk(regVIPH_DMA_CHUNK *reg, unsigned int viph_ch0_chunk)
{
  reg->bitfields.VIPH_CH0_CHUNK = viph_ch0_chunk;
  if (reg->bitfields.VIPH_CH0_CHUNK != viph_ch0_chunk) HSLDPF(E_ERROR_MESSAGE,"VIPH_DMA_CHUNK::VIPH_CH0_CHUNK data too large\n");
}
__inline void set_VIPH_DMA_CHUNK_viph_ch1_chunk(regVIPH_DMA_CHUNK *reg, unsigned int viph_ch1_chunk)
{
  reg->bitfields.VIPH_CH1_CHUNK = viph_ch1_chunk;
  if (reg->bitfields.VIPH_CH1_CHUNK != viph_ch1_chunk) HSLDPF(E_ERROR_MESSAGE,"VIPH_DMA_CHUNK::VIPH_CH1_CHUNK data too large\n");
}
__inline void set_VIPH_DMA_CHUNK_viph_ch2_chunk(regVIPH_DMA_CHUNK *reg, unsigned int viph_ch2_chunk)
{
  reg->bitfields.VIPH_CH2_CHUNK = viph_ch2_chunk;
  if (reg->bitfields.VIPH_CH2_CHUNK != viph_ch2_chunk) HSLDPF(E_ERROR_MESSAGE,"VIPH_DMA_CHUNK::VIPH_CH2_CHUNK data too large\n");
}
__inline void set_VIPH_DMA_CHUNK_viph_ch3_chunk(regVIPH_DMA_CHUNK *reg, unsigned int viph_ch3_chunk)
{
  reg->bitfields.VIPH_CH3_CHUNK = viph_ch3_chunk;
  if (reg->bitfields.VIPH_CH3_CHUNK != viph_ch3_chunk) HSLDPF(E_ERROR_MESSAGE,"VIPH_DMA_CHUNK::VIPH_CH3_CHUNK data too large\n");
}
__inline void set_VIPH_DMA_CHUNK_viph_ch0_abort(regVIPH_DMA_CHUNK *reg, unsigned int viph_ch0_abort)
{
  reg->bitfields.VIPH_CH0_ABORT = viph_ch0_abort;
  if (reg->bitfields.VIPH_CH0_ABORT != viph_ch0_abort) HSLDPF(E_ERROR_MESSAGE,"VIPH_DMA_CHUNK::VIPH_CH0_ABORT data too large\n");
}
__inline void set_VIPH_DMA_CHUNK_viph_ch1_abort(regVIPH_DMA_CHUNK *reg, unsigned int viph_ch1_abort)
{
  reg->bitfields.VIPH_CH1_ABORT = viph_ch1_abort;
  if (reg->bitfields.VIPH_CH1_ABORT != viph_ch1_abort) HSLDPF(E_ERROR_MESSAGE,"VIPH_DMA_CHUNK::VIPH_CH1_ABORT data too large\n");
}
__inline void set_VIPH_DMA_CHUNK_viph_ch2_abort(regVIPH_DMA_CHUNK *reg, unsigned int viph_ch2_abort)
{
  reg->bitfields.VIPH_CH2_ABORT = viph_ch2_abort;
  if (reg->bitfields.VIPH_CH2_ABORT != viph_ch2_abort) HSLDPF(E_ERROR_MESSAGE,"VIPH_DMA_CHUNK::VIPH_CH2_ABORT data too large\n");
}
__inline void set_VIPH_DMA_CHUNK_viph_ch3_abort(regVIPH_DMA_CHUNK *reg, unsigned int viph_ch3_abort)
{
  reg->bitfields.VIPH_CH3_ABORT = viph_ch3_abort;
  if (reg->bitfields.VIPH_CH3_ABORT != viph_ch3_abort) HSLDPF(E_ERROR_MESSAGE,"VIPH_DMA_CHUNK::VIPH_CH3_ABORT data too large\n");
}
#else
#define set_VIPH_DMA_CHUNK_viph_ch0_chunk(reg, viph_ch0_chunk) (reg)->bitfields.VIPH_CH0_CHUNK = viph_ch0_chunk
#define set_VIPH_DMA_CHUNK_viph_ch1_chunk(reg, viph_ch1_chunk) (reg)->bitfields.VIPH_CH1_CHUNK = viph_ch1_chunk
#define set_VIPH_DMA_CHUNK_viph_ch2_chunk(reg, viph_ch2_chunk) (reg)->bitfields.VIPH_CH2_CHUNK = viph_ch2_chunk
#define set_VIPH_DMA_CHUNK_viph_ch3_chunk(reg, viph_ch3_chunk) (reg)->bitfields.VIPH_CH3_CHUNK = viph_ch3_chunk
#define set_VIPH_DMA_CHUNK_viph_ch0_abort(reg, viph_ch0_abort) (reg)->bitfields.VIPH_CH0_ABORT = viph_ch0_abort
#define set_VIPH_DMA_CHUNK_viph_ch1_abort(reg, viph_ch1_abort) (reg)->bitfields.VIPH_CH1_ABORT = viph_ch1_abort
#define set_VIPH_DMA_CHUNK_viph_ch2_abort(reg, viph_ch2_abort) (reg)->bitfields.VIPH_CH2_ABORT = viph_ch2_abort
#define set_VIPH_DMA_CHUNK_viph_ch3_abort(reg, viph_ch3_abort) (reg)->bitfields.VIPH_CH3_ABORT = viph_ch3_abort

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_DV_INT regVIPH_DV_INT;

#ifdef DEBUG
__inline void set_VIPH_DV_INT_viph_dv0_int_en(regVIPH_DV_INT *reg, unsigned int viph_dv0_int_en)
{
  reg->bitfields.VIPH_DV0_INT_EN = viph_dv0_int_en;
  if (reg->bitfields.VIPH_DV0_INT_EN != viph_dv0_int_en) HSLDPF(E_ERROR_MESSAGE,"VIPH_DV_INT::VIPH_DV0_INT_EN data too large\n");
}
__inline void set_VIPH_DV_INT_viph_dv1_int_en(regVIPH_DV_INT *reg, unsigned int viph_dv1_int_en)
{
  reg->bitfields.VIPH_DV1_INT_EN = viph_dv1_int_en;
  if (reg->bitfields.VIPH_DV1_INT_EN != viph_dv1_int_en) HSLDPF(E_ERROR_MESSAGE,"VIPH_DV_INT::VIPH_DV1_INT_EN data too large\n");
}
__inline void set_VIPH_DV_INT_viph_dv2_int_en(regVIPH_DV_INT *reg, unsigned int viph_dv2_int_en)
{
  reg->bitfields.VIPH_DV2_INT_EN = viph_dv2_int_en;
  if (reg->bitfields.VIPH_DV2_INT_EN != viph_dv2_int_en) HSLDPF(E_ERROR_MESSAGE,"VIPH_DV_INT::VIPH_DV2_INT_EN data too large\n");
}
__inline void set_VIPH_DV_INT_viph_dv3_int_en(regVIPH_DV_INT *reg, unsigned int viph_dv3_int_en)
{
  reg->bitfields.VIPH_DV3_INT_EN = viph_dv3_int_en;
  if (reg->bitfields.VIPH_DV3_INT_EN != viph_dv3_int_en) HSLDPF(E_ERROR_MESSAGE,"VIPH_DV_INT::VIPH_DV3_INT_EN data too large\n");
}
__inline void set_VIPH_DV_INT_viph_dv0_int(regVIPH_DV_INT *reg, unsigned int viph_dv0_int)
{
  reg->bitfields.VIPH_DV0_INT = viph_dv0_int;
  if (reg->bitfields.VIPH_DV0_INT != viph_dv0_int) HSLDPF(E_ERROR_MESSAGE,"VIPH_DV_INT::VIPH_DV0_INT data too large\n");
}
__inline void set_VIPH_DV_INT_viph_dv1_int(regVIPH_DV_INT *reg, unsigned int viph_dv1_int)
{
  reg->bitfields.VIPH_DV1_INT = viph_dv1_int;
  if (reg->bitfields.VIPH_DV1_INT != viph_dv1_int) HSLDPF(E_ERROR_MESSAGE,"VIPH_DV_INT::VIPH_DV1_INT data too large\n");
}
__inline void set_VIPH_DV_INT_viph_dv2_int(regVIPH_DV_INT *reg, unsigned int viph_dv2_int)
{
  reg->bitfields.VIPH_DV2_INT = viph_dv2_int;
  if (reg->bitfields.VIPH_DV2_INT != viph_dv2_int) HSLDPF(E_ERROR_MESSAGE,"VIPH_DV_INT::VIPH_DV2_INT data too large\n");
}
__inline void set_VIPH_DV_INT_viph_dv3_int(regVIPH_DV_INT *reg, unsigned int viph_dv3_int)
{
  reg->bitfields.VIPH_DV3_INT = viph_dv3_int;
  if (reg->bitfields.VIPH_DV3_INT != viph_dv3_int) HSLDPF(E_ERROR_MESSAGE,"VIPH_DV_INT::VIPH_DV3_INT data too large\n");
}
#else
#define set_VIPH_DV_INT_viph_dv0_int_en(reg, viph_dv0_int_en) (reg)->bitfields.VIPH_DV0_INT_EN = viph_dv0_int_en
#define set_VIPH_DV_INT_viph_dv1_int_en(reg, viph_dv1_int_en) (reg)->bitfields.VIPH_DV1_INT_EN = viph_dv1_int_en
#define set_VIPH_DV_INT_viph_dv2_int_en(reg, viph_dv2_int_en) (reg)->bitfields.VIPH_DV2_INT_EN = viph_dv2_int_en
#define set_VIPH_DV_INT_viph_dv3_int_en(reg, viph_dv3_int_en) (reg)->bitfields.VIPH_DV3_INT_EN = viph_dv3_int_en
#define set_VIPH_DV_INT_viph_dv0_int(reg, viph_dv0_int) (reg)->bitfields.VIPH_DV0_INT = viph_dv0_int
#define set_VIPH_DV_INT_viph_dv1_int(reg, viph_dv1_int) (reg)->bitfields.VIPH_DV1_INT = viph_dv1_int
#define set_VIPH_DV_INT_viph_dv2_int(reg, viph_dv2_int) (reg)->bitfields.VIPH_DV2_INT = viph_dv2_int
#define set_VIPH_DV_INT_viph_dv3_int(reg, viph_dv3_int) (reg)->bitfields.VIPH_DV3_INT = viph_dv3_int

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPH_TIMEOUT_STAT regVIPH_TIMEOUT_STAT;

#ifdef DEBUG
__inline void set_VIPH_TIMEOUT_STAT_viph_fifo0_stat(regVIPH_TIMEOUT_STAT *reg, unsigned int viph_fifo0_stat)
{
  reg->bitfields.VIPH_FIFO0_STAT = viph_fifo0_stat;
  if (reg->bitfields.VIPH_FIFO0_STAT != viph_fifo0_stat) HSLDPF(E_ERROR_MESSAGE,"VIPH_TIMEOUT_STAT::VIPH_FIFO0_STAT data too large\n");
}
__inline void set_VIPH_TIMEOUT_STAT_viph_fifo1_stat(regVIPH_TIMEOUT_STAT *reg, unsigned int viph_fifo1_stat)
{
  reg->bitfields.VIPH_FIFO1_STAT = viph_fifo1_stat;
  if (reg->bitfields.VIPH_FIFO1_STAT != viph_fifo1_stat) HSLDPF(E_ERROR_MESSAGE,"VIPH_TIMEOUT_STAT::VIPH_FIFO1_STAT data too large\n");
}
__inline void set_VIPH_TIMEOUT_STAT_viph_fifo2_stat(regVIPH_TIMEOUT_STAT *reg, unsigned int viph_fifo2_stat)
{
  reg->bitfields.VIPH_FIFO2_STAT = viph_fifo2_stat;
  if (reg->bitfields.VIPH_FIFO2_STAT != viph_fifo2_stat) HSLDPF(E_ERROR_MESSAGE,"VIPH_TIMEOUT_STAT::VIPH_FIFO2_STAT data too large\n");
}
__inline void set_VIPH_TIMEOUT_STAT_viph_fifo3_stat(regVIPH_TIMEOUT_STAT *reg, unsigned int viph_fifo3_stat)
{
  reg->bitfields.VIPH_FIFO3_STAT = viph_fifo3_stat;
  if (reg->bitfields.VIPH_FIFO3_STAT != viph_fifo3_stat) HSLDPF(E_ERROR_MESSAGE,"VIPH_TIMEOUT_STAT::VIPH_FIFO3_STAT data too large\n");
}
__inline void set_VIPH_TIMEOUT_STAT_viph_reg_stat(regVIPH_TIMEOUT_STAT *reg, unsigned int viph_reg_stat)
{
  reg->bitfields.VIPH_REG_STAT = viph_reg_stat;
  if (reg->bitfields.VIPH_REG_STAT != viph_reg_stat) HSLDPF(E_ERROR_MESSAGE,"VIPH_TIMEOUT_STAT::VIPH_REG_STAT data too large\n");
}
__inline void set_VIPH_TIMEOUT_STAT_viph_auto_int_stat(regVIPH_TIMEOUT_STAT *reg, unsigned int viph_auto_int_stat)
{
  reg->bitfields.VIPH_AUTO_INT_STAT = viph_auto_int_stat;
  if (reg->bitfields.VIPH_AUTO_INT_STAT != viph_auto_int_stat) HSLDPF(E_ERROR_MESSAGE,"VIPH_TIMEOUT_STAT::VIPH_AUTO_INT_STAT data too large\n");
}
__inline void set_VIPH_TIMEOUT_STAT_viph_fifo0_mask(regVIPH_TIMEOUT_STAT *reg, unsigned int viph_fifo0_mask)
{
  reg->bitfields.VIPH_FIFO0_MASK = viph_fifo0_mask;
  if (reg->bitfields.VIPH_FIFO0_MASK != viph_fifo0_mask) HSLDPF(E_ERROR_MESSAGE,"VIPH_TIMEOUT_STAT::VIPH_FIFO0_MASK data too large\n");
}
__inline void set_VIPH_TIMEOUT_STAT_viph_fifo1_mask(regVIPH_TIMEOUT_STAT *reg, unsigned int viph_fifo1_mask)
{
  reg->bitfields.VIPH_FIFO1_MASK = viph_fifo1_mask;
  if (reg->bitfields.VIPH_FIFO1_MASK != viph_fifo1_mask) HSLDPF(E_ERROR_MESSAGE,"VIPH_TIMEOUT_STAT::VIPH_FIFO1_MASK data too large\n");
}
__inline void set_VIPH_TIMEOUT_STAT_viph_fifo2_mask(regVIPH_TIMEOUT_STAT *reg, unsigned int viph_fifo2_mask)
{
  reg->bitfields.VIPH_FIFO2_MASK = viph_fifo2_mask;
  if (reg->bitfields.VIPH_FIFO2_MASK != viph_fifo2_mask) HSLDPF(E_ERROR_MESSAGE,"VIPH_TIMEOUT_STAT::VIPH_FIFO2_MASK data too large\n");
}
__inline void set_VIPH_TIMEOUT_STAT_viph_fifo3_mask(regVIPH_TIMEOUT_STAT *reg, unsigned int viph_fifo3_mask)
{
  reg->bitfields.VIPH_FIFO3_MASK = viph_fifo3_mask;
  if (reg->bitfields.VIPH_FIFO3_MASK != viph_fifo3_mask) HSLDPF(E_ERROR_MESSAGE,"VIPH_TIMEOUT_STAT::VIPH_FIFO3_MASK data too large\n");
}
__inline void set_VIPH_TIMEOUT_STAT_viph_reg_mask(regVIPH_TIMEOUT_STAT *reg, unsigned int viph_reg_mask)
{
  reg->bitfields.VIPH_REG_MASK = viph_reg_mask;
  if (reg->bitfields.VIPH_REG_MASK != viph_reg_mask) HSLDPF(E_ERROR_MESSAGE,"VIPH_TIMEOUT_STAT::VIPH_REG_MASK data too large\n");
}
__inline void set_VIPH_TIMEOUT_STAT_viph_auto_int_mask(regVIPH_TIMEOUT_STAT *reg, unsigned int viph_auto_int_mask)
{
  reg->bitfields.VIPH_AUTO_INT_MASK = viph_auto_int_mask;
  if (reg->bitfields.VIPH_AUTO_INT_MASK != viph_auto_int_mask) HSLDPF(E_ERROR_MESSAGE,"VIPH_TIMEOUT_STAT::VIPH_AUTO_INT_MASK data too large\n");
}
__inline void set_VIPH_TIMEOUT_STAT_viph_dv0_int_mask(regVIPH_TIMEOUT_STAT *reg, unsigned int viph_dv0_int_mask)
{
  reg->bitfields.VIPH_DV0_INT_MASK = viph_dv0_int_mask;
  if (reg->bitfields.VIPH_DV0_INT_MASK != viph_dv0_int_mask) HSLDPF(E_ERROR_MESSAGE,"VIPH_TIMEOUT_STAT::VIPH_DV0_INT_MASK data too large\n");
}
__inline void set_VIPH_TIMEOUT_STAT_viph_dv1_int_mask(regVIPH_TIMEOUT_STAT *reg, unsigned int viph_dv1_int_mask)
{
  reg->bitfields.VIPH_DV1_INT_MASK = viph_dv1_int_mask;
  if (reg->bitfields.VIPH_DV1_INT_MASK != viph_dv1_int_mask) HSLDPF(E_ERROR_MESSAGE,"VIPH_TIMEOUT_STAT::VIPH_DV1_INT_MASK data too large\n");
}
__inline void set_VIPH_TIMEOUT_STAT_viph_dv2_int_mask(regVIPH_TIMEOUT_STAT *reg, unsigned int viph_dv2_int_mask)
{
  reg->bitfields.VIPH_DV2_INT_MASK = viph_dv2_int_mask;
  if (reg->bitfields.VIPH_DV2_INT_MASK != viph_dv2_int_mask) HSLDPF(E_ERROR_MESSAGE,"VIPH_TIMEOUT_STAT::VIPH_DV2_INT_MASK data too large\n");
}
__inline void set_VIPH_TIMEOUT_STAT_viph_dv3_int_mask(regVIPH_TIMEOUT_STAT *reg, unsigned int viph_dv3_int_mask)
{
  reg->bitfields.VIPH_DV3_INT_MASK = viph_dv3_int_mask;
  if (reg->bitfields.VIPH_DV3_INT_MASK != viph_dv3_int_mask) HSLDPF(E_ERROR_MESSAGE,"VIPH_TIMEOUT_STAT::VIPH_DV3_INT_MASK data too large\n");
}
__inline void set_VIPH_TIMEOUT_STAT_viph_intpin_en(regVIPH_TIMEOUT_STAT *reg, unsigned int viph_intpin_en)
{
  reg->bitfields.VIPH_INTPIN_EN = viph_intpin_en;
  if (reg->bitfields.VIPH_INTPIN_EN != viph_intpin_en) HSLDPF(E_ERROR_MESSAGE,"VIPH_TIMEOUT_STAT::VIPH_INTPIN_EN data too large\n");
}
__inline void set_VIPH_TIMEOUT_STAT_viph_intpin_int(regVIPH_TIMEOUT_STAT *reg, unsigned int viph_intpin_int)
{
  reg->bitfields.VIPH_INTPIN_INT = viph_intpin_int;
  if (reg->bitfields.VIPH_INTPIN_INT != viph_intpin_int) HSLDPF(E_ERROR_MESSAGE,"VIPH_TIMEOUT_STAT::VIPH_INTPIN_INT data too large\n");
}
__inline void set_VIPH_TIMEOUT_STAT_viph_regr_dis(regVIPH_TIMEOUT_STAT *reg, unsigned int viph_regr_dis)
{
  reg->bitfields.VIPH_REGR_DIS = viph_regr_dis;
  if (reg->bitfields.VIPH_REGR_DIS != viph_regr_dis) HSLDPF(E_ERROR_MESSAGE,"VIPH_TIMEOUT_STAT::VIPH_REGR_DIS data too large\n");
}
#else
#define set_VIPH_TIMEOUT_STAT_viph_fifo0_stat(reg, viph_fifo0_stat) (reg)->bitfields.VIPH_FIFO0_STAT = viph_fifo0_stat
#define set_VIPH_TIMEOUT_STAT_viph_fifo1_stat(reg, viph_fifo1_stat) (reg)->bitfields.VIPH_FIFO1_STAT = viph_fifo1_stat
#define set_VIPH_TIMEOUT_STAT_viph_fifo2_stat(reg, viph_fifo2_stat) (reg)->bitfields.VIPH_FIFO2_STAT = viph_fifo2_stat
#define set_VIPH_TIMEOUT_STAT_viph_fifo3_stat(reg, viph_fifo3_stat) (reg)->bitfields.VIPH_FIFO3_STAT = viph_fifo3_stat
#define set_VIPH_TIMEOUT_STAT_viph_reg_stat(reg, viph_reg_stat) (reg)->bitfields.VIPH_REG_STAT = viph_reg_stat
#define set_VIPH_TIMEOUT_STAT_viph_auto_int_stat(reg, viph_auto_int_stat) (reg)->bitfields.VIPH_AUTO_INT_STAT = viph_auto_int_stat
#define set_VIPH_TIMEOUT_STAT_viph_fifo0_mask(reg, viph_fifo0_mask) (reg)->bitfields.VIPH_FIFO0_MASK = viph_fifo0_mask
#define set_VIPH_TIMEOUT_STAT_viph_fifo1_mask(reg, viph_fifo1_mask) (reg)->bitfields.VIPH_FIFO1_MASK = viph_fifo1_mask
#define set_VIPH_TIMEOUT_STAT_viph_fifo2_mask(reg, viph_fifo2_mask) (reg)->bitfields.VIPH_FIFO2_MASK = viph_fifo2_mask
#define set_VIPH_TIMEOUT_STAT_viph_fifo3_mask(reg, viph_fifo3_mask) (reg)->bitfields.VIPH_FIFO3_MASK = viph_fifo3_mask
#define set_VIPH_TIMEOUT_STAT_viph_reg_mask(reg, viph_reg_mask) (reg)->bitfields.VIPH_REG_MASK = viph_reg_mask
#define set_VIPH_TIMEOUT_STAT_viph_auto_int_mask(reg, viph_auto_int_mask) (reg)->bitfields.VIPH_AUTO_INT_MASK = viph_auto_int_mask
#define set_VIPH_TIMEOUT_STAT_viph_dv0_int_mask(reg, viph_dv0_int_mask) (reg)->bitfields.VIPH_DV0_INT_MASK = viph_dv0_int_mask
#define set_VIPH_TIMEOUT_STAT_viph_dv1_int_mask(reg, viph_dv1_int_mask) (reg)->bitfields.VIPH_DV1_INT_MASK = viph_dv1_int_mask
#define set_VIPH_TIMEOUT_STAT_viph_dv2_int_mask(reg, viph_dv2_int_mask) (reg)->bitfields.VIPH_DV2_INT_MASK = viph_dv2_int_mask
#define set_VIPH_TIMEOUT_STAT_viph_dv3_int_mask(reg, viph_dv3_int_mask) (reg)->bitfields.VIPH_DV3_INT_MASK = viph_dv3_int_mask
#define set_VIPH_TIMEOUT_STAT_viph_intpin_en(reg, viph_intpin_en) (reg)->bitfields.VIPH_INTPIN_EN = viph_intpin_en
#define set_VIPH_TIMEOUT_STAT_viph_intpin_int(reg, viph_intpin_int) (reg)->bitfields.VIPH_INTPIN_INT = viph_intpin_int
#define set_VIPH_TIMEOUT_STAT_viph_regr_dis(reg, viph_regr_dis) (reg)->bitfields.VIPH_REGR_DIS = viph_regr_dis

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CLK_PIN_CNTL regCLK_PIN_CNTL;

#ifdef DEBUG
__inline void set_CLK_PIN_CNTL_osc_en(regCLK_PIN_CNTL *reg, unsigned int osc_en)
{
  reg->bitfields.OSC_EN = osc_en;
  if (reg->bitfields.OSC_EN != osc_en) HSLDPF(E_ERROR_MESSAGE,"CLK_PIN_CNTL::OSC_EN data too large\n");
}
__inline void set_CLK_PIN_CNTL_xtl_low_gain(regCLK_PIN_CNTL *reg, unsigned int xtl_low_gain)
{
  reg->bitfields.XTL_LOW_GAIN = xtl_low_gain;
  if (reg->bitfields.XTL_LOW_GAIN != xtl_low_gain) HSLDPF(E_ERROR_MESSAGE,"CLK_PIN_CNTL::XTL_LOW_GAIN data too large\n");
}
__inline void set_CLK_PIN_CNTL_dont_use_xtalin(regCLK_PIN_CNTL *reg, unsigned int dont_use_xtalin)
{
  reg->bitfields.DONT_USE_XTALIN = dont_use_xtalin;
  if (reg->bitfields.DONT_USE_XTALIN != dont_use_xtalin) HSLDPF(E_ERROR_MESSAGE,"CLK_PIN_CNTL::DONT_USE_XTALIN data too large\n");
}
__inline void set_CLK_PIN_CNTL_slow_clock_source(regCLK_PIN_CNTL *reg, unsigned int slow_clock_source)
{
  reg->bitfields.SLOW_CLOCK_SOURCE = slow_clock_source;
  if (reg->bitfields.SLOW_CLOCK_SOURCE != slow_clock_source) HSLDPF(E_ERROR_MESSAGE,"CLK_PIN_CNTL::SLOW_CLOCK_SOURCE data too large\n");
}
__inline void set_CLK_PIN_CNTL_cg_clk_to_outpin(regCLK_PIN_CNTL *reg, unsigned int cg_clk_to_outpin)
{
  reg->bitfields.CG_CLK_TO_OUTPIN = cg_clk_to_outpin;
  if (reg->bitfields.CG_CLK_TO_OUTPIN != cg_clk_to_outpin) HSLDPF(E_ERROR_MESSAGE,"CLK_PIN_CNTL::CG_CLK_TO_OUTPIN data too large\n");
}
__inline void set_CLK_PIN_CNTL_cg_count_up_to_outpin(regCLK_PIN_CNTL *reg, unsigned int cg_count_up_to_outpin)
{
  reg->bitfields.CG_COUNT_UP_TO_OUTPIN = cg_count_up_to_outpin;
  if (reg->bitfields.CG_COUNT_UP_TO_OUTPIN != cg_count_up_to_outpin) HSLDPF(E_ERROR_MESSAGE,"CLK_PIN_CNTL::CG_COUNT_UP_TO_OUTPIN data too large\n");
}
__inline void set_CLK_PIN_CNTL_access_regs_in_suspend(regCLK_PIN_CNTL *reg, unsigned int access_regs_in_suspend)
{
  reg->bitfields.ACCESS_REGS_IN_SUSPEND = access_regs_in_suspend;
  if (reg->bitfields.ACCESS_REGS_IN_SUSPEND != access_regs_in_suspend) HSLDPF(E_ERROR_MESSAGE,"CLK_PIN_CNTL::ACCESS_REGS_IN_SUSPEND data too large\n");
}
__inline void set_CLK_PIN_CNTL_cg_spare(regCLK_PIN_CNTL *reg, unsigned int cg_spare)
{
  reg->bitfields.CG_SPARE = cg_spare;
  if (reg->bitfields.CG_SPARE != cg_spare) HSLDPF(E_ERROR_MESSAGE,"CLK_PIN_CNTL::CG_SPARE data too large\n");
}
__inline void set_CLK_PIN_CNTL_sclk_dyn_start_cntl(regCLK_PIN_CNTL *reg, unsigned int sclk_dyn_start_cntl)
{
  reg->bitfields.SCLK_DYN_START_CNTL = sclk_dyn_start_cntl;
  if (reg->bitfields.SCLK_DYN_START_CNTL != sclk_dyn_start_cntl) HSLDPF(E_ERROR_MESSAGE,"CLK_PIN_CNTL::SCLK_DYN_START_CNTL data too large\n");
}
__inline void set_CLK_PIN_CNTL_cp_clk_running(regCLK_PIN_CNTL *reg, unsigned int cp_clk_running)
{
  reg->bitfields.CP_CLK_RUNNING = cp_clk_running;
  if (reg->bitfields.CP_CLK_RUNNING != cp_clk_running) HSLDPF(E_ERROR_MESSAGE,"CLK_PIN_CNTL::CP_CLK_RUNNING data too large\n");
}
__inline void set_CLK_PIN_CNTL_cg_spare_rd(regCLK_PIN_CNTL *reg, unsigned int cg_spare_rd)
{
  reg->bitfields.CG_SPARE_RD = cg_spare_rd;
  if (reg->bitfields.CG_SPARE_RD != cg_spare_rd) HSLDPF(E_ERROR_MESSAGE,"CLK_PIN_CNTL::CG_SPARE_RD data too large\n");
}
__inline void set_CLK_PIN_CNTL_xtalin_always_onb(regCLK_PIN_CNTL *reg, unsigned int xtalin_always_onb)
{
  reg->bitfields.XTALIN_ALWAYS_ONb = xtalin_always_onb;
  if (reg->bitfields.XTALIN_ALWAYS_ONb != xtalin_always_onb) HSLDPF(E_ERROR_MESSAGE,"CLK_PIN_CNTL::XTALIN_ALWAYS_ONb data too large\n");
}
__inline void set_CLK_PIN_CNTL_pwrseq_delay(regCLK_PIN_CNTL *reg, unsigned int pwrseq_delay)
{
  reg->bitfields.PWRSEQ_DELAY = pwrseq_delay;
  if (reg->bitfields.PWRSEQ_DELAY != pwrseq_delay) HSLDPF(E_ERROR_MESSAGE,"CLK_PIN_CNTL::PWRSEQ_DELAY data too large\n");
}
#else
#define set_CLK_PIN_CNTL_osc_en(reg, osc_en) (reg)->bitfields.OSC_EN = osc_en
#define set_CLK_PIN_CNTL_xtl_low_gain(reg, xtl_low_gain) (reg)->bitfields.XTL_LOW_GAIN = xtl_low_gain
#define set_CLK_PIN_CNTL_dont_use_xtalin(reg, dont_use_xtalin) (reg)->bitfields.DONT_USE_XTALIN = dont_use_xtalin
#define set_CLK_PIN_CNTL_slow_clock_source(reg, slow_clock_source) (reg)->bitfields.SLOW_CLOCK_SOURCE = slow_clock_source
#define set_CLK_PIN_CNTL_cg_clk_to_outpin(reg, cg_clk_to_outpin) (reg)->bitfields.CG_CLK_TO_OUTPIN = cg_clk_to_outpin
#define set_CLK_PIN_CNTL_cg_count_up_to_outpin(reg, cg_count_up_to_outpin) (reg)->bitfields.CG_COUNT_UP_TO_OUTPIN = cg_count_up_to_outpin
#define set_CLK_PIN_CNTL_access_regs_in_suspend(reg, access_regs_in_suspend) (reg)->bitfields.ACCESS_REGS_IN_SUSPEND = access_regs_in_suspend
#define set_CLK_PIN_CNTL_cg_spare(reg, cg_spare) (reg)->bitfields.CG_SPARE = cg_spare
#define set_CLK_PIN_CNTL_sclk_dyn_start_cntl(reg, sclk_dyn_start_cntl) (reg)->bitfields.SCLK_DYN_START_CNTL = sclk_dyn_start_cntl
#define set_CLK_PIN_CNTL_cp_clk_running(reg, cp_clk_running) (reg)->bitfields.CP_CLK_RUNNING = cp_clk_running
#define set_CLK_PIN_CNTL_cg_spare_rd(reg, cg_spare_rd) (reg)->bitfields.CG_SPARE_RD = cg_spare_rd
#define set_CLK_PIN_CNTL_xtalin_always_onb(reg, xtalin_always_onb) (reg)->bitfields.XTALIN_ALWAYS_ONb = xtalin_always_onb
#define set_CLK_PIN_CNTL_pwrseq_delay(reg, pwrseq_delay) (reg)->bitfields.PWRSEQ_DELAY = pwrseq_delay

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PPLL_CNTL regPPLL_CNTL;

#ifdef DEBUG
__inline void set_PPLL_CNTL_ppll_reset(regPPLL_CNTL *reg, unsigned int ppll_reset)
{
  reg->bitfields.PPLL_RESET = ppll_reset;
  if (reg->bitfields.PPLL_RESET != ppll_reset) HSLDPF(E_ERROR_MESSAGE,"PPLL_CNTL::PPLL_RESET data too large\n");
}
__inline void set_PPLL_CNTL_ppll_sleep(regPPLL_CNTL *reg, unsigned int ppll_sleep)
{
  reg->bitfields.PPLL_SLEEP = ppll_sleep;
  if (reg->bitfields.PPLL_SLEEP != ppll_sleep) HSLDPF(E_ERROR_MESSAGE,"PPLL_CNTL::PPLL_SLEEP data too large\n");
}
__inline void set_PPLL_CNTL_ppll_tst_en(regPPLL_CNTL *reg, unsigned int ppll_tst_en)
{
  reg->bitfields.PPLL_TST_EN = ppll_tst_en;
  if (reg->bitfields.PPLL_TST_EN != ppll_tst_en) HSLDPF(E_ERROR_MESSAGE,"PPLL_CNTL::PPLL_TST_EN data too large\n");
}
__inline void set_PPLL_CNTL_ppll_refclk_sel(regPPLL_CNTL *reg, unsigned int ppll_refclk_sel)
{
  reg->bitfields.PPLL_REFCLK_SEL = ppll_refclk_sel;
  if (reg->bitfields.PPLL_REFCLK_SEL != ppll_refclk_sel) HSLDPF(E_ERROR_MESSAGE,"PPLL_CNTL::PPLL_REFCLK_SEL data too large\n");
}
__inline void set_PPLL_CNTL_ppll_fbclk_sel(regPPLL_CNTL *reg, unsigned int ppll_fbclk_sel)
{
  reg->bitfields.PPLL_FBCLK_SEL = ppll_fbclk_sel;
  if (reg->bitfields.PPLL_FBCLK_SEL != ppll_fbclk_sel) HSLDPF(E_ERROR_MESSAGE,"PPLL_CNTL::PPLL_FBCLK_SEL data too large\n");
}
__inline void set_PPLL_CNTL_ppll_tcpoff(regPPLL_CNTL *reg, unsigned int ppll_tcpoff)
{
  reg->bitfields.PPLL_TCPOFF = ppll_tcpoff;
  if (reg->bitfields.PPLL_TCPOFF != ppll_tcpoff) HSLDPF(E_ERROR_MESSAGE,"PPLL_CNTL::PPLL_TCPOFF data too large\n");
}
__inline void set_PPLL_CNTL_ppll_tvcomax(regPPLL_CNTL *reg, unsigned int ppll_tvcomax)
{
  reg->bitfields.PPLL_TVCOMAX = ppll_tvcomax;
  if (reg->bitfields.PPLL_TVCOMAX != ppll_tvcomax) HSLDPF(E_ERROR_MESSAGE,"PPLL_CNTL::PPLL_TVCOMAX data too large\n");
}
__inline void set_PPLL_CNTL_ppll_pcp(regPPLL_CNTL *reg, unsigned int ppll_pcp)
{
  reg->bitfields.PPLL_PCP = ppll_pcp;
  if (reg->bitfields.PPLL_PCP != ppll_pcp) HSLDPF(E_ERROR_MESSAGE,"PPLL_CNTL::PPLL_PCP data too large\n");
}
__inline void set_PPLL_CNTL_ppll_pvg(regPPLL_CNTL *reg, unsigned int ppll_pvg)
{
  reg->bitfields.PPLL_PVG = ppll_pvg;
  if (reg->bitfields.PPLL_PVG != ppll_pvg) HSLDPF(E_ERROR_MESSAGE,"PPLL_CNTL::PPLL_PVG data too large\n");
}
__inline void set_PPLL_CNTL_ppll_pdc(regPPLL_CNTL *reg, unsigned int ppll_pdc)
{
  reg->bitfields.PPLL_PDC = ppll_pdc;
  if (reg->bitfields.PPLL_PDC != ppll_pdc) HSLDPF(E_ERROR_MESSAGE,"PPLL_CNTL::PPLL_PDC data too large\n");
}
__inline void set_PPLL_CNTL_ppll_atomic_update_en(regPPLL_CNTL *reg, unsigned int ppll_atomic_update_en)
{
  reg->bitfields.PPLL_ATOMIC_UPDATE_EN = ppll_atomic_update_en;
  if (reg->bitfields.PPLL_ATOMIC_UPDATE_EN != ppll_atomic_update_en) HSLDPF(E_ERROR_MESSAGE,"PPLL_CNTL::PPLL_ATOMIC_UPDATE_EN data too large\n");
}
__inline void set_PPLL_CNTL_ppll_vga_atomic_update_en(regPPLL_CNTL *reg, unsigned int ppll_vga_atomic_update_en)
{
  reg->bitfields.PPLL_VGA_ATOMIC_UPDATE_EN = ppll_vga_atomic_update_en;
  if (reg->bitfields.PPLL_VGA_ATOMIC_UPDATE_EN != ppll_vga_atomic_update_en) HSLDPF(E_ERROR_MESSAGE,"PPLL_CNTL::PPLL_VGA_ATOMIC_UPDATE_EN data too large\n");
}
__inline void set_PPLL_CNTL_ppll_atomic_update_sync(regPPLL_CNTL *reg, unsigned int ppll_atomic_update_sync)
{
  reg->bitfields.PPLL_ATOMIC_UPDATE_SYNC = ppll_atomic_update_sync;
  if (reg->bitfields.PPLL_ATOMIC_UPDATE_SYNC != ppll_atomic_update_sync) HSLDPF(E_ERROR_MESSAGE,"PPLL_CNTL::PPLL_ATOMIC_UPDATE_SYNC data too large\n");
}
__inline void set_PPLL_CNTL_ppll_disable_auto_reset(regPPLL_CNTL *reg, unsigned int ppll_disable_auto_reset)
{
  reg->bitfields.PPLL_DISABLE_AUTO_RESET = ppll_disable_auto_reset;
  if (reg->bitfields.PPLL_DISABLE_AUTO_RESET != ppll_disable_auto_reset) HSLDPF(E_ERROR_MESSAGE,"PPLL_CNTL::PPLL_DISABLE_AUTO_RESET data too large\n");
}
#else
#define set_PPLL_CNTL_ppll_reset(reg, ppll_reset) (reg)->bitfields.PPLL_RESET = ppll_reset
#define set_PPLL_CNTL_ppll_sleep(reg, ppll_sleep) (reg)->bitfields.PPLL_SLEEP = ppll_sleep
#define set_PPLL_CNTL_ppll_tst_en(reg, ppll_tst_en) (reg)->bitfields.PPLL_TST_EN = ppll_tst_en
#define set_PPLL_CNTL_ppll_refclk_sel(reg, ppll_refclk_sel) (reg)->bitfields.PPLL_REFCLK_SEL = ppll_refclk_sel
#define set_PPLL_CNTL_ppll_fbclk_sel(reg, ppll_fbclk_sel) (reg)->bitfields.PPLL_FBCLK_SEL = ppll_fbclk_sel
#define set_PPLL_CNTL_ppll_tcpoff(reg, ppll_tcpoff) (reg)->bitfields.PPLL_TCPOFF = ppll_tcpoff
#define set_PPLL_CNTL_ppll_tvcomax(reg, ppll_tvcomax) (reg)->bitfields.PPLL_TVCOMAX = ppll_tvcomax
#define set_PPLL_CNTL_ppll_pcp(reg, ppll_pcp) (reg)->bitfields.PPLL_PCP = ppll_pcp
#define set_PPLL_CNTL_ppll_pvg(reg, ppll_pvg) (reg)->bitfields.PPLL_PVG = ppll_pvg
#define set_PPLL_CNTL_ppll_pdc(reg, ppll_pdc) (reg)->bitfields.PPLL_PDC = ppll_pdc
#define set_PPLL_CNTL_ppll_atomic_update_en(reg, ppll_atomic_update_en) (reg)->bitfields.PPLL_ATOMIC_UPDATE_EN = ppll_atomic_update_en
#define set_PPLL_CNTL_ppll_vga_atomic_update_en(reg, ppll_vga_atomic_update_en) (reg)->bitfields.PPLL_VGA_ATOMIC_UPDATE_EN = ppll_vga_atomic_update_en
#define set_PPLL_CNTL_ppll_atomic_update_sync(reg, ppll_atomic_update_sync) (reg)->bitfields.PPLL_ATOMIC_UPDATE_SYNC = ppll_atomic_update_sync
#define set_PPLL_CNTL_ppll_disable_auto_reset(reg, ppll_disable_auto_reset) (reg)->bitfields.PPLL_DISABLE_AUTO_RESET = ppll_disable_auto_reset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PPLL_REF_DIV regPPLL_REF_DIV;

#ifdef DEBUG
__inline void set_PPLL_REF_DIV_ppll_ref_div(regPPLL_REF_DIV *reg, unsigned int ppll_ref_div)
{
  reg->bitfields.PPLL_REF_DIV = ppll_ref_div;
  if (reg->bitfields.PPLL_REF_DIV != ppll_ref_div) HSLDPF(E_ERROR_MESSAGE,"PPLL_REF_DIV::PPLL_REF_DIV data too large\n");
}
__inline void set_PPLL_REF_DIV_ppll_atomic_update_w(regPPLL_REF_DIV *reg, unsigned int ppll_atomic_update_w)
{
  reg->bitfields.PPLL_ATOMIC_UPDATE_W = ppll_atomic_update_w;
  if (reg->bitfields.PPLL_ATOMIC_UPDATE_W != ppll_atomic_update_w) HSLDPF(E_ERROR_MESSAGE,"PPLL_REF_DIV::PPLL_ATOMIC_UPDATE_W data too large\n");
}
__inline void set_PPLL_REF_DIV_ppll_ref_div_src(regPPLL_REF_DIV *reg, unsigned int ppll_ref_div_src)
{
  reg->bitfields.PPLL_REF_DIV_SRC = ppll_ref_div_src;
  if (reg->bitfields.PPLL_REF_DIV_SRC != ppll_ref_div_src) HSLDPF(E_ERROR_MESSAGE,"PPLL_REF_DIV::PPLL_REF_DIV_SRC data too large\n");
}
#else
#define set_PPLL_REF_DIV_ppll_ref_div(reg, ppll_ref_div) (reg)->bitfields.PPLL_REF_DIV = ppll_ref_div
#define set_PPLL_REF_DIV_ppll_atomic_update_w(reg, ppll_atomic_update_w) (reg)->bitfields.PPLL_ATOMIC_UPDATE_W = ppll_atomic_update_w
#define set_PPLL_REF_DIV_ppll_ref_div_src(reg, ppll_ref_div_src) (reg)->bitfields.PPLL_REF_DIV_SRC = ppll_ref_div_src

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SPLL_CNTL regSPLL_CNTL;

#ifdef DEBUG
__inline void set_SPLL_CNTL_spll_sleep(regSPLL_CNTL *reg, unsigned int spll_sleep)
{
  reg->bitfields.SPLL_SLEEP = spll_sleep;
  if (reg->bitfields.SPLL_SLEEP != spll_sleep) HSLDPF(E_ERROR_MESSAGE,"SPLL_CNTL::SPLL_SLEEP data too large\n");
}
__inline void set_SPLL_CNTL_spll_reset(regSPLL_CNTL *reg, unsigned int spll_reset)
{
  reg->bitfields.SPLL_RESET = spll_reset;
  if (reg->bitfields.SPLL_RESET != spll_reset) HSLDPF(E_ERROR_MESSAGE,"SPLL_CNTL::SPLL_RESET data too large\n");
}
__inline void set_SPLL_CNTL_spll_tst_en(regSPLL_CNTL *reg, unsigned int spll_tst_en)
{
  reg->bitfields.SPLL_TST_EN = spll_tst_en;
  if (reg->bitfields.SPLL_TST_EN != spll_tst_en) HSLDPF(E_ERROR_MESSAGE,"SPLL_CNTL::SPLL_TST_EN data too large\n");
}
__inline void set_SPLL_CNTL_spll_refclk_sel(regSPLL_CNTL *reg, unsigned int spll_refclk_sel)
{
  reg->bitfields.SPLL_REFCLK_SEL = spll_refclk_sel;
  if (reg->bitfields.SPLL_REFCLK_SEL != spll_refclk_sel) HSLDPF(E_ERROR_MESSAGE,"SPLL_CNTL::SPLL_REFCLK_SEL data too large\n");
}
__inline void set_SPLL_CNTL_spll_fbclk_sel(regSPLL_CNTL *reg, unsigned int spll_fbclk_sel)
{
  reg->bitfields.SPLL_FBCLK_SEL = spll_fbclk_sel;
  if (reg->bitfields.SPLL_FBCLK_SEL != spll_fbclk_sel) HSLDPF(E_ERROR_MESSAGE,"SPLL_CNTL::SPLL_FBCLK_SEL data too large\n");
}
__inline void set_SPLL_CNTL_spll_tcpoff(regSPLL_CNTL *reg, unsigned int spll_tcpoff)
{
  reg->bitfields.SPLL_TCPOFF = spll_tcpoff;
  if (reg->bitfields.SPLL_TCPOFF != spll_tcpoff) HSLDPF(E_ERROR_MESSAGE,"SPLL_CNTL::SPLL_TCPOFF data too large\n");
}
__inline void set_SPLL_CNTL_spll_tvcomax(regSPLL_CNTL *reg, unsigned int spll_tvcomax)
{
  reg->bitfields.SPLL_TVCOMAX = spll_tvcomax;
  if (reg->bitfields.SPLL_TVCOMAX != spll_tvcomax) HSLDPF(E_ERROR_MESSAGE,"SPLL_CNTL::SPLL_TVCOMAX data too large\n");
}
__inline void set_SPLL_CNTL_spll_pcp(regSPLL_CNTL *reg, unsigned int spll_pcp)
{
  reg->bitfields.SPLL_PCP = spll_pcp;
  if (reg->bitfields.SPLL_PCP != spll_pcp) HSLDPF(E_ERROR_MESSAGE,"SPLL_CNTL::SPLL_PCP data too large\n");
}
__inline void set_SPLL_CNTL_spll_pvg(regSPLL_CNTL *reg, unsigned int spll_pvg)
{
  reg->bitfields.SPLL_PVG = spll_pvg;
  if (reg->bitfields.SPLL_PVG != spll_pvg) HSLDPF(E_ERROR_MESSAGE,"SPLL_CNTL::SPLL_PVG data too large\n");
}
__inline void set_SPLL_CNTL_spll_pdc(regSPLL_CNTL *reg, unsigned int spll_pdc)
{
  reg->bitfields.SPLL_PDC = spll_pdc;
  if (reg->bitfields.SPLL_PDC != spll_pdc) HSLDPF(E_ERROR_MESSAGE,"SPLL_CNTL::SPLL_PDC data too large\n");
}
__inline void set_SPLL_CNTL_spll_x1_clk_skew(regSPLL_CNTL *reg, unsigned int spll_x1_clk_skew)
{
  reg->bitfields.SPLL_X1_CLK_SKEW = spll_x1_clk_skew;
  if (reg->bitfields.SPLL_X1_CLK_SKEW != spll_x1_clk_skew) HSLDPF(E_ERROR_MESSAGE,"SPLL_CNTL::SPLL_X1_CLK_SKEW data too large\n");
}
__inline void set_SPLL_CNTL_spll_x2_clk_skew(regSPLL_CNTL *reg, unsigned int spll_x2_clk_skew)
{
  reg->bitfields.SPLL_X2_CLK_SKEW = spll_x2_clk_skew;
  if (reg->bitfields.SPLL_X2_CLK_SKEW != spll_x2_clk_skew) HSLDPF(E_ERROR_MESSAGE,"SPLL_CNTL::SPLL_X2_CLK_SKEW data too large\n");
}
__inline void set_SPLL_CNTL_spll_mode(regSPLL_CNTL *reg, unsigned int spll_mode)
{
  reg->bitfields.SPLL_MODE = spll_mode;
  if (reg->bitfields.SPLL_MODE != spll_mode) HSLDPF(E_ERROR_MESSAGE,"SPLL_CNTL::SPLL_MODE data too large\n");
}
__inline void set_SPLL_CNTL_myclk_sourced_from_spll_sel(regSPLL_CNTL *reg, unsigned int myclk_sourced_from_spll_sel)
{
  reg->bitfields.MYCLK_SOURCED_FROM_SPLL_SEL = myclk_sourced_from_spll_sel;
  if (reg->bitfields.MYCLK_SOURCED_FROM_SPLL_SEL != myclk_sourced_from_spll_sel) HSLDPF(E_ERROR_MESSAGE,"SPLL_CNTL::MYCLK_SOURCED_FROM_SPLL_SEL data too large\n");
}
__inline void set_SPLL_CNTL_enable_myclk_from_spll(regSPLL_CNTL *reg, unsigned int enable_myclk_from_spll)
{
  reg->bitfields.ENABLE_MYCLK_FROM_SPLL = enable_myclk_from_spll;
  if (reg->bitfields.ENABLE_MYCLK_FROM_SPLL != enable_myclk_from_spll) HSLDPF(E_ERROR_MESSAGE,"SPLL_CNTL::ENABLE_MYCLK_FROM_SPLL data too large\n");
}
#else
#define set_SPLL_CNTL_spll_sleep(reg, spll_sleep) (reg)->bitfields.SPLL_SLEEP = spll_sleep
#define set_SPLL_CNTL_spll_reset(reg, spll_reset) (reg)->bitfields.SPLL_RESET = spll_reset
#define set_SPLL_CNTL_spll_tst_en(reg, spll_tst_en) (reg)->bitfields.SPLL_TST_EN = spll_tst_en
#define set_SPLL_CNTL_spll_refclk_sel(reg, spll_refclk_sel) (reg)->bitfields.SPLL_REFCLK_SEL = spll_refclk_sel
#define set_SPLL_CNTL_spll_fbclk_sel(reg, spll_fbclk_sel) (reg)->bitfields.SPLL_FBCLK_SEL = spll_fbclk_sel
#define set_SPLL_CNTL_spll_tcpoff(reg, spll_tcpoff) (reg)->bitfields.SPLL_TCPOFF = spll_tcpoff
#define set_SPLL_CNTL_spll_tvcomax(reg, spll_tvcomax) (reg)->bitfields.SPLL_TVCOMAX = spll_tvcomax
#define set_SPLL_CNTL_spll_pcp(reg, spll_pcp) (reg)->bitfields.SPLL_PCP = spll_pcp
#define set_SPLL_CNTL_spll_pvg(reg, spll_pvg) (reg)->bitfields.SPLL_PVG = spll_pvg
#define set_SPLL_CNTL_spll_pdc(reg, spll_pdc) (reg)->bitfields.SPLL_PDC = spll_pdc
#define set_SPLL_CNTL_spll_x1_clk_skew(reg, spll_x1_clk_skew) (reg)->bitfields.SPLL_X1_CLK_SKEW = spll_x1_clk_skew
#define set_SPLL_CNTL_spll_x2_clk_skew(reg, spll_x2_clk_skew) (reg)->bitfields.SPLL_X2_CLK_SKEW = spll_x2_clk_skew
#define set_SPLL_CNTL_spll_mode(reg, spll_mode) (reg)->bitfields.SPLL_MODE = spll_mode
#define set_SPLL_CNTL_myclk_sourced_from_spll_sel(reg, myclk_sourced_from_spll_sel) (reg)->bitfields.MYCLK_SOURCED_FROM_SPLL_SEL = myclk_sourced_from_spll_sel
#define set_SPLL_CNTL_enable_myclk_from_spll(reg, enable_myclk_from_spll) (reg)->bitfields.ENABLE_MYCLK_FROM_SPLL = enable_myclk_from_spll

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250SPLL_AUX_CNTL regrv250SPLL_AUX_CNTL;

#ifdef DEBUG
__inline void set_rv250SPLL_AUX_CNTL_spll_pdc_c(regrv250SPLL_AUX_CNTL *reg, unsigned int spll_pdc_c)
{
  reg->bitfields.SPLL_PDC_C = spll_pdc_c;
  if (reg->bitfields.SPLL_PDC_C != spll_pdc_c) HSLDPF(E_ERROR_MESSAGE,"rv250SPLL_AUX_CNTL::SPLL_PDC_C data too large\n");
}
__inline void set_rv250SPLL_AUX_CNTL_spll_ckinva(regrv250SPLL_AUX_CNTL *reg, unsigned int spll_ckinva)
{
  reg->bitfields.SPLL_CKINVA = spll_ckinva;
  if (reg->bitfields.SPLL_CKINVA != spll_ckinva) HSLDPF(E_ERROR_MESSAGE,"rv250SPLL_AUX_CNTL::SPLL_CKINVA data too large\n");
}
__inline void set_rv250SPLL_AUX_CNTL_spll_ckinvc(regrv250SPLL_AUX_CNTL *reg, unsigned int spll_ckinvc)
{
  reg->bitfields.SPLL_CKINVC = spll_ckinvc;
  if (reg->bitfields.SPLL_CKINVC != spll_ckinvc) HSLDPF(E_ERROR_MESSAGE,"rv250SPLL_AUX_CNTL::SPLL_CKINVC data too large\n");
}
__inline void set_rv250SPLL_AUX_CNTL_spll_x3_clk_skew(regrv250SPLL_AUX_CNTL *reg, unsigned int spll_x3_clk_skew)
{
  reg->bitfields.SPLL_X3_CLK_SKEW = spll_x3_clk_skew;
  if (reg->bitfields.SPLL_X3_CLK_SKEW != spll_x3_clk_skew) HSLDPF(E_ERROR_MESSAGE,"rv250SPLL_AUX_CNTL::SPLL_X3_CLK_SKEW data too large\n");
}
__inline void set_rv250SPLL_AUX_CNTL_spll_modec(regrv250SPLL_AUX_CNTL *reg, unsigned int spll_modec)
{
  reg->bitfields.SPLL_MODEC = spll_modec;
  if (reg->bitfields.SPLL_MODEC != spll_modec) HSLDPF(E_ERROR_MESSAGE,"rv250SPLL_AUX_CNTL::SPLL_MODEC data too large\n");
}
__inline void set_rv250SPLL_AUX_CNTL_transit_done_length(regrv250SPLL_AUX_CNTL *reg, unsigned int transit_done_length)
{
  reg->bitfields.TRANSIT_DONE_LENGTH = transit_done_length;
  if (reg->bitfields.TRANSIT_DONE_LENGTH != transit_done_length) HSLDPF(E_ERROR_MESSAGE,"rv250SPLL_AUX_CNTL::TRANSIT_DONE_LENGTH data too large\n");
}
__inline void set_rv250SPLL_AUX_CNTL_spll_refclk_src_sel(regrv250SPLL_AUX_CNTL *reg, unsigned int spll_refclk_src_sel)
{
  reg->bitfields.SPLL_REFCLK_SRC_SEL = spll_refclk_src_sel;
  if (reg->bitfields.SPLL_REFCLK_SRC_SEL != spll_refclk_src_sel) HSLDPF(E_ERROR_MESSAGE,"rv250SPLL_AUX_CNTL::SPLL_REFCLK_SRC_SEL data too large\n");
}
#else
#define set_rv250SPLL_AUX_CNTL_spll_pdc_c(reg, spll_pdc_c) (reg)->bitfields.SPLL_PDC_C = spll_pdc_c
#define set_rv250SPLL_AUX_CNTL_spll_ckinva(reg, spll_ckinva) (reg)->bitfields.SPLL_CKINVA = spll_ckinva
#define set_rv250SPLL_AUX_CNTL_spll_ckinvc(reg, spll_ckinvc) (reg)->bitfields.SPLL_CKINVC = spll_ckinvc
#define set_rv250SPLL_AUX_CNTL_spll_x3_clk_skew(reg, spll_x3_clk_skew) (reg)->bitfields.SPLL_X3_CLK_SKEW = spll_x3_clk_skew
#define set_rv250SPLL_AUX_CNTL_spll_modec(reg, spll_modec) (reg)->bitfields.SPLL_MODEC = spll_modec
#define set_rv250SPLL_AUX_CNTL_transit_done_length(reg, transit_done_length) (reg)->bitfields.TRANSIT_DONE_LENGTH = transit_done_length
#define set_rv250SPLL_AUX_CNTL_spll_refclk_src_sel(reg, spll_refclk_src_sel) (reg)->bitfields.SPLL_REFCLK_SRC_SEL = spll_refclk_src_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SCLK_CNTL_M6 regSCLK_CNTL_M6;

#ifdef DEBUG
__inline void set_SCLK_CNTL_M6_sclk_src_sel(regSCLK_CNTL_M6 *reg, unsigned int sclk_src_sel)
{
  reg->bitfields.SCLK_SRC_SEL = sclk_src_sel;
  if (reg->bitfields.SCLK_SRC_SEL != sclk_src_sel) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::SCLK_SRC_SEL data too large\n");
}
__inline void set_SCLK_CNTL_M6_cp_max_dyn_stop_lat(regSCLK_CNTL_M6 *reg, unsigned int cp_max_dyn_stop_lat)
{
  reg->bitfields.CP_MAX_DYN_STOP_LAT = cp_max_dyn_stop_lat;
  if (reg->bitfields.CP_MAX_DYN_STOP_LAT != cp_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::CP_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_M6_hdp_max_dyn_stop_lat(regSCLK_CNTL_M6 *reg, unsigned int hdp_max_dyn_stop_lat)
{
  reg->bitfields.HDP_MAX_DYN_STOP_LAT = hdp_max_dyn_stop_lat;
  if (reg->bitfields.HDP_MAX_DYN_STOP_LAT != hdp_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::HDP_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_M6_tv_max_dyn_stop_lat(regSCLK_CNTL_M6 *reg, unsigned int tv_max_dyn_stop_lat)
{
  reg->bitfields.TV_MAX_DYN_STOP_LAT = tv_max_dyn_stop_lat;
  if (reg->bitfields.TV_MAX_DYN_STOP_LAT != tv_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::TV_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_M6_e2_max_dyn_stop_lat(regSCLK_CNTL_M6 *reg, unsigned int e2_max_dyn_stop_lat)
{
  reg->bitfields.E2_MAX_DYN_STOP_LAT = e2_max_dyn_stop_lat;
  if (reg->bitfields.E2_MAX_DYN_STOP_LAT != e2_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::E2_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_M6_se_max_dyn_stop_lat(regSCLK_CNTL_M6 *reg, unsigned int se_max_dyn_stop_lat)
{
  reg->bitfields.SE_MAX_DYN_STOP_LAT = se_max_dyn_stop_lat;
  if (reg->bitfields.SE_MAX_DYN_STOP_LAT != se_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::SE_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_M6_idct_max_dyn_stop_lat(regSCLK_CNTL_M6 *reg, unsigned int idct_max_dyn_stop_lat)
{
  reg->bitfields.IDCT_MAX_DYN_STOP_LAT = idct_max_dyn_stop_lat;
  if (reg->bitfields.IDCT_MAX_DYN_STOP_LAT != idct_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::IDCT_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_M6_vip_max_dyn_stop_lat(regSCLK_CNTL_M6 *reg, unsigned int vip_max_dyn_stop_lat)
{
  reg->bitfields.VIP_MAX_DYN_STOP_LAT = vip_max_dyn_stop_lat;
  if (reg->bitfields.VIP_MAX_DYN_STOP_LAT != vip_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::VIP_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_M6_re_max_dyn_stop_lat(regSCLK_CNTL_M6 *reg, unsigned int re_max_dyn_stop_lat)
{
  reg->bitfields.RE_MAX_DYN_STOP_LAT = re_max_dyn_stop_lat;
  if (reg->bitfields.RE_MAX_DYN_STOP_LAT != re_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::RE_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_M6_pb_max_dyn_stop_lat(regSCLK_CNTL_M6 *reg, unsigned int pb_max_dyn_stop_lat)
{
  reg->bitfields.PB_MAX_DYN_STOP_LAT = pb_max_dyn_stop_lat;
  if (reg->bitfields.PB_MAX_DYN_STOP_LAT != pb_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::PB_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_M6_tam_max_dyn_stop_lat(regSCLK_CNTL_M6 *reg, unsigned int tam_max_dyn_stop_lat)
{
  reg->bitfields.TAM_MAX_DYN_STOP_LAT = tam_max_dyn_stop_lat;
  if (reg->bitfields.TAM_MAX_DYN_STOP_LAT != tam_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::TAM_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_M6_tdm_max_dyn_stop_lat(regSCLK_CNTL_M6 *reg, unsigned int tdm_max_dyn_stop_lat)
{
  reg->bitfields.TDM_MAX_DYN_STOP_LAT = tdm_max_dyn_stop_lat;
  if (reg->bitfields.TDM_MAX_DYN_STOP_LAT != tdm_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::TDM_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_M6_rb_max_dyn_stop_lat(regSCLK_CNTL_M6 *reg, unsigned int rb_max_dyn_stop_lat)
{
  reg->bitfields.RB_MAX_DYN_STOP_LAT = rb_max_dyn_stop_lat;
  if (reg->bitfields.RB_MAX_DYN_STOP_LAT != rb_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::RB_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_M6_force_disp2(regSCLK_CNTL_M6 *reg, unsigned int force_disp2)
{
  reg->bitfields.FORCE_DISP2 = force_disp2;
  if (reg->bitfields.FORCE_DISP2 != force_disp2) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::FORCE_DISP2 data too large\n");
}
__inline void set_SCLK_CNTL_M6_force_cp(regSCLK_CNTL_M6 *reg, unsigned int force_cp)
{
  reg->bitfields.FORCE_CP = force_cp;
  if (reg->bitfields.FORCE_CP != force_cp) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::FORCE_CP data too large\n");
}
__inline void set_SCLK_CNTL_M6_force_hdp(regSCLK_CNTL_M6 *reg, unsigned int force_hdp)
{
  reg->bitfields.FORCE_HDP = force_hdp;
  if (reg->bitfields.FORCE_HDP != force_hdp) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::FORCE_HDP data too large\n");
}
__inline void set_SCLK_CNTL_M6_force_disp1(regSCLK_CNTL_M6 *reg, unsigned int force_disp1)
{
  reg->bitfields.FORCE_DISP1 = force_disp1;
  if (reg->bitfields.FORCE_DISP1 != force_disp1) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::FORCE_DISP1 data too large\n");
}
__inline void set_SCLK_CNTL_M6_force_top(regSCLK_CNTL_M6 *reg, unsigned int force_top)
{
  reg->bitfields.FORCE_TOP = force_top;
  if (reg->bitfields.FORCE_TOP != force_top) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::FORCE_TOP data too large\n");
}
__inline void set_SCLK_CNTL_M6_force_e2(regSCLK_CNTL_M6 *reg, unsigned int force_e2)
{
  reg->bitfields.FORCE_E2 = force_e2;
  if (reg->bitfields.FORCE_E2 != force_e2) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::FORCE_E2 data too large\n");
}
__inline void set_SCLK_CNTL_M6_force_se(regSCLK_CNTL_M6 *reg, unsigned int force_se)
{
  reg->bitfields.FORCE_SE = force_se;
  if (reg->bitfields.FORCE_SE != force_se) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::FORCE_SE data too large\n");
}
__inline void set_SCLK_CNTL_M6_force_idct(regSCLK_CNTL_M6 *reg, unsigned int force_idct)
{
  reg->bitfields.FORCE_IDCT = force_idct;
  if (reg->bitfields.FORCE_IDCT != force_idct) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::FORCE_IDCT data too large\n");
}
__inline void set_SCLK_CNTL_M6_force_vip(regSCLK_CNTL_M6 *reg, unsigned int force_vip)
{
  reg->bitfields.FORCE_VIP = force_vip;
  if (reg->bitfields.FORCE_VIP != force_vip) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::FORCE_VIP data too large\n");
}
__inline void set_SCLK_CNTL_M6_force_re(regSCLK_CNTL_M6 *reg, unsigned int force_re)
{
  reg->bitfields.FORCE_RE = force_re;
  if (reg->bitfields.FORCE_RE != force_re) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::FORCE_RE data too large\n");
}
__inline void set_SCLK_CNTL_M6_force_pb(regSCLK_CNTL_M6 *reg, unsigned int force_pb)
{
  reg->bitfields.FORCE_PB = force_pb;
  if (reg->bitfields.FORCE_PB != force_pb) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::FORCE_PB data too large\n");
}
__inline void set_SCLK_CNTL_M6_force_tam(regSCLK_CNTL_M6 *reg, unsigned int force_tam)
{
  reg->bitfields.FORCE_TAM = force_tam;
  if (reg->bitfields.FORCE_TAM != force_tam) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::FORCE_TAM data too large\n");
}
__inline void set_SCLK_CNTL_M6_force_tdm(regSCLK_CNTL_M6 *reg, unsigned int force_tdm)
{
  reg->bitfields.FORCE_TDM = force_tdm;
  if (reg->bitfields.FORCE_TDM != force_tdm) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::FORCE_TDM data too large\n");
}
__inline void set_SCLK_CNTL_M6_force_rb(regSCLK_CNTL_M6 *reg, unsigned int force_rb)
{
  reg->bitfields.FORCE_RB = force_rb;
  if (reg->bitfields.FORCE_RB != force_rb) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::FORCE_RB data too large\n");
}
__inline void set_SCLK_CNTL_M6_force_tv_sclk(regSCLK_CNTL_M6 *reg, unsigned int force_tv_sclk)
{
  reg->bitfields.FORCE_TV_SCLK = force_tv_sclk;
  if (reg->bitfields.FORCE_TV_SCLK != force_tv_sclk) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::FORCE_TV_SCLK data too large\n");
}
__inline void set_SCLK_CNTL_M6_force_subpic(regSCLK_CNTL_M6 *reg, unsigned int force_subpic)
{
  reg->bitfields.FORCE_SUBPIC = force_subpic;
  if (reg->bitfields.FORCE_SUBPIC != force_subpic) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::FORCE_SUBPIC data too large\n");
}
__inline void set_SCLK_CNTL_M6_force_ov0(regSCLK_CNTL_M6 *reg, unsigned int force_ov0)
{
  reg->bitfields.FORCE_OV0 = force_ov0;
  if (reg->bitfields.FORCE_OV0 != force_ov0) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL_M6::FORCE_OV0 data too large\n");
}
#else
#define set_SCLK_CNTL_M6_sclk_src_sel(reg, sclk_src_sel) (reg)->bitfields.SCLK_SRC_SEL = sclk_src_sel
#define set_SCLK_CNTL_M6_cp_max_dyn_stop_lat(reg, cp_max_dyn_stop_lat) (reg)->bitfields.CP_MAX_DYN_STOP_LAT = cp_max_dyn_stop_lat
#define set_SCLK_CNTL_M6_hdp_max_dyn_stop_lat(reg, hdp_max_dyn_stop_lat) (reg)->bitfields.HDP_MAX_DYN_STOP_LAT = hdp_max_dyn_stop_lat
#define set_SCLK_CNTL_M6_tv_max_dyn_stop_lat(reg, tv_max_dyn_stop_lat) (reg)->bitfields.TV_MAX_DYN_STOP_LAT = tv_max_dyn_stop_lat
#define set_SCLK_CNTL_M6_e2_max_dyn_stop_lat(reg, e2_max_dyn_stop_lat) (reg)->bitfields.E2_MAX_DYN_STOP_LAT = e2_max_dyn_stop_lat
#define set_SCLK_CNTL_M6_se_max_dyn_stop_lat(reg, se_max_dyn_stop_lat) (reg)->bitfields.SE_MAX_DYN_STOP_LAT = se_max_dyn_stop_lat
#define set_SCLK_CNTL_M6_idct_max_dyn_stop_lat(reg, idct_max_dyn_stop_lat) (reg)->bitfields.IDCT_MAX_DYN_STOP_LAT = idct_max_dyn_stop_lat
#define set_SCLK_CNTL_M6_vip_max_dyn_stop_lat(reg, vip_max_dyn_stop_lat) (reg)->bitfields.VIP_MAX_DYN_STOP_LAT = vip_max_dyn_stop_lat
#define set_SCLK_CNTL_M6_re_max_dyn_stop_lat(reg, re_max_dyn_stop_lat) (reg)->bitfields.RE_MAX_DYN_STOP_LAT = re_max_dyn_stop_lat
#define set_SCLK_CNTL_M6_pb_max_dyn_stop_lat(reg, pb_max_dyn_stop_lat) (reg)->bitfields.PB_MAX_DYN_STOP_LAT = pb_max_dyn_stop_lat
#define set_SCLK_CNTL_M6_tam_max_dyn_stop_lat(reg, tam_max_dyn_stop_lat) (reg)->bitfields.TAM_MAX_DYN_STOP_LAT = tam_max_dyn_stop_lat
#define set_SCLK_CNTL_M6_tdm_max_dyn_stop_lat(reg, tdm_max_dyn_stop_lat) (reg)->bitfields.TDM_MAX_DYN_STOP_LAT = tdm_max_dyn_stop_lat
#define set_SCLK_CNTL_M6_rb_max_dyn_stop_lat(reg, rb_max_dyn_stop_lat) (reg)->bitfields.RB_MAX_DYN_STOP_LAT = rb_max_dyn_stop_lat
#define set_SCLK_CNTL_M6_force_disp2(reg, force_disp2) (reg)->bitfields.FORCE_DISP2 = force_disp2
#define set_SCLK_CNTL_M6_force_cp(reg, force_cp) (reg)->bitfields.FORCE_CP = force_cp
#define set_SCLK_CNTL_M6_force_hdp(reg, force_hdp) (reg)->bitfields.FORCE_HDP = force_hdp
#define set_SCLK_CNTL_M6_force_disp1(reg, force_disp1) (reg)->bitfields.FORCE_DISP1 = force_disp1
#define set_SCLK_CNTL_M6_force_top(reg, force_top) (reg)->bitfields.FORCE_TOP = force_top
#define set_SCLK_CNTL_M6_force_e2(reg, force_e2) (reg)->bitfields.FORCE_E2 = force_e2
#define set_SCLK_CNTL_M6_force_se(reg, force_se) (reg)->bitfields.FORCE_SE = force_se
#define set_SCLK_CNTL_M6_force_idct(reg, force_idct) (reg)->bitfields.FORCE_IDCT = force_idct
#define set_SCLK_CNTL_M6_force_vip(reg, force_vip) (reg)->bitfields.FORCE_VIP = force_vip
#define set_SCLK_CNTL_M6_force_re(reg, force_re) (reg)->bitfields.FORCE_RE = force_re
#define set_SCLK_CNTL_M6_force_pb(reg, force_pb) (reg)->bitfields.FORCE_PB = force_pb
#define set_SCLK_CNTL_M6_force_tam(reg, force_tam) (reg)->bitfields.FORCE_TAM = force_tam
#define set_SCLK_CNTL_M6_force_tdm(reg, force_tdm) (reg)->bitfields.FORCE_TDM = force_tdm
#define set_SCLK_CNTL_M6_force_rb(reg, force_rb) (reg)->bitfields.FORCE_RB = force_rb
#define set_SCLK_CNTL_M6_force_tv_sclk(reg, force_tv_sclk) (reg)->bitfields.FORCE_TV_SCLK = force_tv_sclk
#define set_SCLK_CNTL_M6_force_subpic(reg, force_subpic) (reg)->bitfields.FORCE_SUBPIC = force_subpic
#define set_SCLK_CNTL_M6_force_ov0(reg, force_ov0) (reg)->bitfields.FORCE_OV0 = force_ov0

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union AGP_PLL_CNTL regAGP_PLL_CNTL;

#ifdef DEBUG
__inline void set_AGP_PLL_CNTL_apll_sleep(regAGP_PLL_CNTL *reg, unsigned int apll_sleep)
{
  reg->bitfields.APLL_SLEEP = apll_sleep;
  if (reg->bitfields.APLL_SLEEP != apll_sleep) HSLDPF(E_ERROR_MESSAGE,"AGP_PLL_CNTL::APLL_SLEEP data too large\n");
}
__inline void set_AGP_PLL_CNTL_apll_reset(regAGP_PLL_CNTL *reg, unsigned int apll_reset)
{
  reg->bitfields.APLL_RESET = apll_reset;
  if (reg->bitfields.APLL_RESET != apll_reset) HSLDPF(E_ERROR_MESSAGE,"AGP_PLL_CNTL::APLL_RESET data too large\n");
}
__inline void set_AGP_PLL_CNTL_apll_xsel(regAGP_PLL_CNTL *reg, unsigned int apll_xsel)
{
  reg->bitfields.APLL_XSEL = apll_xsel;
  if (reg->bitfields.APLL_XSEL != apll_xsel) HSLDPF(E_ERROR_MESSAGE,"AGP_PLL_CNTL::APLL_XSEL data too large\n");
}
__inline void set_AGP_PLL_CNTL_apll_tst_en(regAGP_PLL_CNTL *reg, unsigned int apll_tst_en)
{
  reg->bitfields.APLL_TST_EN = apll_tst_en;
  if (reg->bitfields.APLL_TST_EN != apll_tst_en) HSLDPF(E_ERROR_MESSAGE,"AGP_PLL_CNTL::APLL_TST_EN data too large\n");
}
__inline void set_AGP_PLL_CNTL_apll_tcpoff(regAGP_PLL_CNTL *reg, unsigned int apll_tcpoff)
{
  reg->bitfields.APLL_TCPOFF = apll_tcpoff;
  if (reg->bitfields.APLL_TCPOFF != apll_tcpoff) HSLDPF(E_ERROR_MESSAGE,"AGP_PLL_CNTL::APLL_TCPOFF data too large\n");
}
__inline void set_AGP_PLL_CNTL_apll_tvcomax(regAGP_PLL_CNTL *reg, unsigned int apll_tvcomax)
{
  reg->bitfields.APLL_TVCOMAX = apll_tvcomax;
  if (reg->bitfields.APLL_TVCOMAX != apll_tvcomax) HSLDPF(E_ERROR_MESSAGE,"AGP_PLL_CNTL::APLL_TVCOMAX data too large\n");
}
__inline void set_AGP_PLL_CNTL_apll_ref_skew(regAGP_PLL_CNTL *reg, unsigned int apll_ref_skew)
{
  reg->bitfields.APLL_REF_SKEW = apll_ref_skew;
  if (reg->bitfields.APLL_REF_SKEW != apll_ref_skew) HSLDPF(E_ERROR_MESSAGE,"AGP_PLL_CNTL::APLL_REF_SKEW data too large\n");
}
__inline void set_AGP_PLL_CNTL_apll_fb_skew(regAGP_PLL_CNTL *reg, unsigned int apll_fb_skew)
{
  reg->bitfields.APLL_FB_SKEW = apll_fb_skew;
  if (reg->bitfields.APLL_FB_SKEW != apll_fb_skew) HSLDPF(E_ERROR_MESSAGE,"AGP_PLL_CNTL::APLL_FB_SKEW data too large\n");
}
__inline void set_AGP_PLL_CNTL_apll_x0_clk_skew(regAGP_PLL_CNTL *reg, unsigned int apll_x0_clk_skew)
{
  reg->bitfields.APLL_X0_CLK_SKEW = apll_x0_clk_skew;
  if (reg->bitfields.APLL_X0_CLK_SKEW != apll_x0_clk_skew) HSLDPF(E_ERROR_MESSAGE,"AGP_PLL_CNTL::APLL_X0_CLK_SKEW data too large\n");
}
__inline void set_AGP_PLL_CNTL_apll_x1_clk_skew(regAGP_PLL_CNTL *reg, unsigned int apll_x1_clk_skew)
{
  reg->bitfields.APLL_X1_CLK_SKEW = apll_x1_clk_skew;
  if (reg->bitfields.APLL_X1_CLK_SKEW != apll_x1_clk_skew) HSLDPF(E_ERROR_MESSAGE,"AGP_PLL_CNTL::APLL_X1_CLK_SKEW data too large\n");
}
__inline void set_AGP_PLL_CNTL_apll_pump_gain(regAGP_PLL_CNTL *reg, unsigned int apll_pump_gain)
{
  reg->bitfields.APLL_PUMP_GAIN = apll_pump_gain;
  if (reg->bitfields.APLL_PUMP_GAIN != apll_pump_gain) HSLDPF(E_ERROR_MESSAGE,"AGP_PLL_CNTL::APLL_PUMP_GAIN data too large\n");
}
__inline void set_AGP_PLL_CNTL_apll_vco_gain(regAGP_PLL_CNTL *reg, unsigned int apll_vco_gain)
{
  reg->bitfields.APLL_VCO_GAIN = apll_vco_gain;
  if (reg->bitfields.APLL_VCO_GAIN != apll_vco_gain) HSLDPF(E_ERROR_MESSAGE,"AGP_PLL_CNTL::APLL_VCO_GAIN data too large\n");
}
__inline void set_AGP_PLL_CNTL_apll_sel_skwadj_pciclk(regAGP_PLL_CNTL *reg, unsigned int apll_sel_skwadj_pciclk)
{
  reg->bitfields.APLL_SEL_SKWADJ_PCICLK = apll_sel_skwadj_pciclk;
  if (reg->bitfields.APLL_SEL_SKWADJ_PCICLK != apll_sel_skwadj_pciclk) HSLDPF(E_ERROR_MESSAGE,"AGP_PLL_CNTL::APLL_SEL_SKWADJ_PCICLK data too large\n");
}
#else
#define set_AGP_PLL_CNTL_apll_sleep(reg, apll_sleep) (reg)->bitfields.APLL_SLEEP = apll_sleep
#define set_AGP_PLL_CNTL_apll_reset(reg, apll_reset) (reg)->bitfields.APLL_RESET = apll_reset
#define set_AGP_PLL_CNTL_apll_xsel(reg, apll_xsel) (reg)->bitfields.APLL_XSEL = apll_xsel
#define set_AGP_PLL_CNTL_apll_tst_en(reg, apll_tst_en) (reg)->bitfields.APLL_TST_EN = apll_tst_en
#define set_AGP_PLL_CNTL_apll_tcpoff(reg, apll_tcpoff) (reg)->bitfields.APLL_TCPOFF = apll_tcpoff
#define set_AGP_PLL_CNTL_apll_tvcomax(reg, apll_tvcomax) (reg)->bitfields.APLL_TVCOMAX = apll_tvcomax
#define set_AGP_PLL_CNTL_apll_ref_skew(reg, apll_ref_skew) (reg)->bitfields.APLL_REF_SKEW = apll_ref_skew
#define set_AGP_PLL_CNTL_apll_fb_skew(reg, apll_fb_skew) (reg)->bitfields.APLL_FB_SKEW = apll_fb_skew
#define set_AGP_PLL_CNTL_apll_x0_clk_skew(reg, apll_x0_clk_skew) (reg)->bitfields.APLL_X0_CLK_SKEW = apll_x0_clk_skew
#define set_AGP_PLL_CNTL_apll_x1_clk_skew(reg, apll_x1_clk_skew) (reg)->bitfields.APLL_X1_CLK_SKEW = apll_x1_clk_skew
#define set_AGP_PLL_CNTL_apll_pump_gain(reg, apll_pump_gain) (reg)->bitfields.APLL_PUMP_GAIN = apll_pump_gain
#define set_AGP_PLL_CNTL_apll_vco_gain(reg, apll_vco_gain) (reg)->bitfields.APLL_VCO_GAIN = apll_vco_gain
#define set_AGP_PLL_CNTL_apll_sel_skwadj_pciclk(reg, apll_sel_skwadj_pciclk) (reg)->bitfields.APLL_SEL_SKWADJ_PCICLK = apll_sel_skwadj_pciclk

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_PLL_FINE_CNTL regTV_PLL_FINE_CNTL;

#ifdef DEBUG
__inline void set_TV_PLL_FINE_CNTL_tv_m1(regTV_PLL_FINE_CNTL *reg, unsigned int tv_m1)
{
  reg->bitfields.TV_M1 = tv_m1;
  if (reg->bitfields.TV_M1 != tv_m1) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_FINE_CNTL::TV_M1 data too large\n");
}
__inline void set_TV_PLL_FINE_CNTL_tv_n1(regTV_PLL_FINE_CNTL *reg, unsigned int tv_n1)
{
  reg->bitfields.TV_N1 = tv_n1;
  if (reg->bitfields.TV_N1 != tv_n1) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_FINE_CNTL::TV_N1 data too large\n");
}
__inline void set_TV_PLL_FINE_CNTL_tv_divider_sel(regTV_PLL_FINE_CNTL *reg, unsigned int tv_divider_sel)
{
  reg->bitfields.TV_DIVIDER_SEL = tv_divider_sel;
  if (reg->bitfields.TV_DIVIDER_SEL != tv_divider_sel) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_FINE_CNTL::TV_DIVIDER_SEL data too large\n");
}
__inline void set_TV_PLL_FINE_CNTL_tv_mnflip_req(regTV_PLL_FINE_CNTL *reg, unsigned int tv_mnflip_req)
{
  reg->bitfields.TV_MNFLIP_REQ = tv_mnflip_req;
  if (reg->bitfields.TV_MNFLIP_REQ != tv_mnflip_req) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_FINE_CNTL::TV_MNFLIP_REQ data too large\n");
}
__inline void set_TV_PLL_FINE_CNTL_tv_mnflip_done(regTV_PLL_FINE_CNTL *reg, unsigned int tv_mnflip_done)
{
  reg->bitfields.TV_MNFLIP_DONE = tv_mnflip_done;
  if (reg->bitfields.TV_MNFLIP_DONE != tv_mnflip_done) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_FINE_CNTL::TV_MNFLIP_DONE data too large\n");
}
__inline void set_TV_PLL_FINE_CNTL_tv_slip_req(regTV_PLL_FINE_CNTL *reg, unsigned int tv_slip_req)
{
  reg->bitfields.TV_SLIP_REQ = tv_slip_req;
  if (reg->bitfields.TV_SLIP_REQ != tv_slip_req) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_FINE_CNTL::TV_SLIP_REQ data too large\n");
}
__inline void set_TV_PLL_FINE_CNTL_tv_slip_done(regTV_PLL_FINE_CNTL *reg, unsigned int tv_slip_done)
{
  reg->bitfields.TV_SLIP_DONE = tv_slip_done;
  if (reg->bitfields.TV_SLIP_DONE != tv_slip_done) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_FINE_CNTL::TV_SLIP_DONE data too large\n");
}
__inline void set_TV_PLL_FINE_CNTL_tv_mnflip_en(regTV_PLL_FINE_CNTL *reg, unsigned int tv_mnflip_en)
{
  reg->bitfields.TV_MNFLIP_EN = tv_mnflip_en;
  if (reg->bitfields.TV_MNFLIP_EN != tv_mnflip_en) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_FINE_CNTL::TV_MNFLIP_EN data too large\n");
}
__inline void set_TV_PLL_FINE_CNTL_tv_slip_count(regTV_PLL_FINE_CNTL *reg, unsigned int tv_slip_count)
{
  reg->bitfields.TV_SLIP_COUNT = tv_slip_count;
  if (reg->bitfields.TV_SLIP_COUNT != tv_slip_count) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_FINE_CNTL::TV_SLIP_COUNT data too large\n");
}
#else
#define set_TV_PLL_FINE_CNTL_tv_m1(reg, tv_m1) (reg)->bitfields.TV_M1 = tv_m1
#define set_TV_PLL_FINE_CNTL_tv_n1(reg, tv_n1) (reg)->bitfields.TV_N1 = tv_n1
#define set_TV_PLL_FINE_CNTL_tv_divider_sel(reg, tv_divider_sel) (reg)->bitfields.TV_DIVIDER_SEL = tv_divider_sel
#define set_TV_PLL_FINE_CNTL_tv_mnflip_req(reg, tv_mnflip_req) (reg)->bitfields.TV_MNFLIP_REQ = tv_mnflip_req
#define set_TV_PLL_FINE_CNTL_tv_mnflip_done(reg, tv_mnflip_done) (reg)->bitfields.TV_MNFLIP_DONE = tv_mnflip_done
#define set_TV_PLL_FINE_CNTL_tv_slip_req(reg, tv_slip_req) (reg)->bitfields.TV_SLIP_REQ = tv_slip_req
#define set_TV_PLL_FINE_CNTL_tv_slip_done(reg, tv_slip_done) (reg)->bitfields.TV_SLIP_DONE = tv_slip_done
#define set_TV_PLL_FINE_CNTL_tv_mnflip_en(reg, tv_mnflip_en) (reg)->bitfields.TV_MNFLIP_EN = tv_mnflip_en
#define set_TV_PLL_FINE_CNTL_tv_slip_count(reg, tv_slip_count) (reg)->bitfields.TV_SLIP_COUNT = tv_slip_count

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_PLL_CNTL regTV_PLL_CNTL;

#ifdef DEBUG
__inline void set_TV_PLL_CNTL_tv_m0_lo(regTV_PLL_CNTL *reg, unsigned int tv_m0_lo)
{
  reg->bitfields.TV_M0_LO = tv_m0_lo;
  if (reg->bitfields.TV_M0_LO != tv_m0_lo) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_CNTL::TV_M0_LO data too large\n");
}
__inline void set_TV_PLL_CNTL_tv_n0_lo(regTV_PLL_CNTL *reg, unsigned int tv_n0_lo)
{
  reg->bitfields.TV_N0_LO = tv_n0_lo;
  if (reg->bitfields.TV_N0_LO != tv_n0_lo) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_CNTL::TV_N0_LO data too large\n");
}
__inline void set_TV_PLL_CNTL_tv_m0_hi(regTV_PLL_CNTL *reg, unsigned int tv_m0_hi)
{
  reg->bitfields.TV_M0_HI = tv_m0_hi;
  if (reg->bitfields.TV_M0_HI != tv_m0_hi) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_CNTL::TV_M0_HI data too large\n");
}
__inline void set_TV_PLL_CNTL_tv_n0_hi(regTV_PLL_CNTL *reg, unsigned int tv_n0_hi)
{
  reg->bitfields.TV_N0_HI = tv_n0_hi;
  if (reg->bitfields.TV_N0_HI != tv_n0_hi) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_CNTL::TV_N0_HI data too large\n");
}
__inline void set_TV_PLL_CNTL_tv_slip_en(regTV_PLL_CNTL *reg, unsigned int tv_slip_en)
{
  reg->bitfields.TV_SLIP_EN = tv_slip_en;
  if (reg->bitfields.TV_SLIP_EN != tv_slip_en) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_CNTL::TV_SLIP_EN data too large\n");
}
__inline void set_TV_PLL_CNTL_tv_p(regTV_PLL_CNTL *reg, unsigned int tv_p)
{
  reg->bitfields.TV_P = tv_p;
  if (reg->bitfields.TV_P != tv_p) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_CNTL::TV_P data too large\n");
}
__inline void set_TV_PLL_CNTL_tv_dto_en(regTV_PLL_CNTL *reg, unsigned int tv_dto_en)
{
  reg->bitfields.TV_DTO_EN = tv_dto_en;
  if (reg->bitfields.TV_DTO_EN != tv_dto_en) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_CNTL::TV_DTO_EN data too large\n");
}
__inline void set_TV_PLL_CNTL_tv_dto_type(regTV_PLL_CNTL *reg, unsigned int tv_dto_type)
{
  reg->bitfields.TV_DTO_TYPE = tv_dto_type;
  if (reg->bitfields.TV_DTO_TYPE != tv_dto_type) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_CNTL::TV_DTO_TYPE data too large\n");
}
__inline void set_TV_PLL_CNTL_tv_ref_clk_sel(regTV_PLL_CNTL *reg, unsigned int tv_ref_clk_sel)
{
  reg->bitfields.TV_REF_CLK_SEL = tv_ref_clk_sel;
  if (reg->bitfields.TV_REF_CLK_SEL != tv_ref_clk_sel) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_CNTL::TV_REF_CLK_SEL data too large\n");
}
#else
#define set_TV_PLL_CNTL_tv_m0_lo(reg, tv_m0_lo) (reg)->bitfields.TV_M0_LO = tv_m0_lo
#define set_TV_PLL_CNTL_tv_n0_lo(reg, tv_n0_lo) (reg)->bitfields.TV_N0_LO = tv_n0_lo
#define set_TV_PLL_CNTL_tv_m0_hi(reg, tv_m0_hi) (reg)->bitfields.TV_M0_HI = tv_m0_hi
#define set_TV_PLL_CNTL_tv_n0_hi(reg, tv_n0_hi) (reg)->bitfields.TV_N0_HI = tv_n0_hi
#define set_TV_PLL_CNTL_tv_slip_en(reg, tv_slip_en) (reg)->bitfields.TV_SLIP_EN = tv_slip_en
#define set_TV_PLL_CNTL_tv_p(reg, tv_p) (reg)->bitfields.TV_P = tv_p
#define set_TV_PLL_CNTL_tv_dto_en(reg, tv_dto_en) (reg)->bitfields.TV_DTO_EN = tv_dto_en
#define set_TV_PLL_CNTL_tv_dto_type(reg, tv_dto_type) (reg)->bitfields.TV_DTO_TYPE = tv_dto_type
#define set_TV_PLL_CNTL_tv_ref_clk_sel(reg, tv_ref_clk_sel) (reg)->bitfields.TV_REF_CLK_SEL = tv_ref_clk_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_PLL_CNTL1 regTV_PLL_CNTL1;

#ifdef DEBUG
__inline void set_TV_PLL_CNTL1_tvpll_reset(regTV_PLL_CNTL1 *reg, unsigned int tvpll_reset)
{
  reg->bitfields.TVPLL_RESET = tvpll_reset;
  if (reg->bitfields.TVPLL_RESET != tvpll_reset) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_CNTL1::TVPLL_RESET data too large\n");
}
__inline void set_TV_PLL_CNTL1_tvpll_sleep(regTV_PLL_CNTL1 *reg, unsigned int tvpll_sleep)
{
  reg->bitfields.TVPLL_SLEEP = tvpll_sleep;
  if (reg->bitfields.TVPLL_SLEEP != tvpll_sleep) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_CNTL1::TVPLL_SLEEP data too large\n");
}
__inline void set_TV_PLL_CNTL1_tvpll_refclk_sel(regTV_PLL_CNTL1 *reg, unsigned int tvpll_refclk_sel)
{
  reg->bitfields.TVPLL_REFCLK_SEL = tvpll_refclk_sel;
  if (reg->bitfields.TVPLL_REFCLK_SEL != tvpll_refclk_sel) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_CNTL1::TVPLL_REFCLK_SEL data too large\n");
}
__inline void set_TV_PLL_CNTL1_tvpll_fbclk_sel(regTV_PLL_CNTL1 *reg, unsigned int tvpll_fbclk_sel)
{
  reg->bitfields.TVPLL_FBCLK_SEL = tvpll_fbclk_sel;
  if (reg->bitfields.TVPLL_FBCLK_SEL != tvpll_fbclk_sel) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_CNTL1::TVPLL_FBCLK_SEL data too large\n");
}
__inline void set_TV_PLL_CNTL1_tvpll_tcpoff(regTV_PLL_CNTL1 *reg, unsigned int tvpll_tcpoff)
{
  reg->bitfields.TVPLL_TCPOFF = tvpll_tcpoff;
  if (reg->bitfields.TVPLL_TCPOFF != tvpll_tcpoff) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_CNTL1::TVPLL_TCPOFF data too large\n");
}
__inline void set_TV_PLL_CNTL1_tvpll_tvcomax(regTV_PLL_CNTL1 *reg, unsigned int tvpll_tvcomax)
{
  reg->bitfields.TVPLL_TVCOMAX = tvpll_tvcomax;
  if (reg->bitfields.TVPLL_TVCOMAX != tvpll_tvcomax) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_CNTL1::TVPLL_TVCOMAX data too large\n");
}
__inline void set_TV_PLL_CNTL1_tvpcp(regTV_PLL_CNTL1 *reg, unsigned int tvpcp)
{
  reg->bitfields.TVPCP = tvpcp;
  if (reg->bitfields.TVPCP != tvpcp) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_CNTL1::TVPCP data too large\n");
}
__inline void set_TV_PLL_CNTL1_tvpvg(regTV_PLL_CNTL1 *reg, unsigned int tvpvg)
{
  reg->bitfields.TVPVG = tvpvg;
  if (reg->bitfields.TVPVG != tvpvg) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_CNTL1::TVPVG data too large\n");
}
__inline void set_TV_PLL_CNTL1_tvpdc(regTV_PLL_CNTL1 *reg, unsigned int tvpdc)
{
  reg->bitfields.TVPDC = tvpdc;
  if (reg->bitfields.TVPDC != tvpdc) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_CNTL1::TVPDC data too large\n");
}
__inline void set_TV_PLL_CNTL1_tvclk_src_sel(regTV_PLL_CNTL1 *reg, unsigned int tvclk_src_sel)
{
  reg->bitfields.TVCLK_SRC_SEL = tvclk_src_sel;
  if (reg->bitfields.TVCLK_SRC_SEL != tvclk_src_sel) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_CNTL1::TVCLK_SRC_SEL data too large\n");
}
__inline void set_TV_PLL_CNTL1_tvpll_test(regTV_PLL_CNTL1 *reg, unsigned int tvpll_test)
{
  reg->bitfields.TVPLL_TEST = tvpll_test;
  if (reg->bitfields.TVPLL_TEST != tvpll_test) HSLDPF(E_ERROR_MESSAGE,"TV_PLL_CNTL1::TVPLL_TEST data too large\n");
}
#else
#define set_TV_PLL_CNTL1_tvpll_reset(reg, tvpll_reset) (reg)->bitfields.TVPLL_RESET = tvpll_reset
#define set_TV_PLL_CNTL1_tvpll_sleep(reg, tvpll_sleep) (reg)->bitfields.TVPLL_SLEEP = tvpll_sleep
#define set_TV_PLL_CNTL1_tvpll_refclk_sel(reg, tvpll_refclk_sel) (reg)->bitfields.TVPLL_REFCLK_SEL = tvpll_refclk_sel
#define set_TV_PLL_CNTL1_tvpll_fbclk_sel(reg, tvpll_fbclk_sel) (reg)->bitfields.TVPLL_FBCLK_SEL = tvpll_fbclk_sel
#define set_TV_PLL_CNTL1_tvpll_tcpoff(reg, tvpll_tcpoff) (reg)->bitfields.TVPLL_TCPOFF = tvpll_tcpoff
#define set_TV_PLL_CNTL1_tvpll_tvcomax(reg, tvpll_tvcomax) (reg)->bitfields.TVPLL_TVCOMAX = tvpll_tvcomax
#define set_TV_PLL_CNTL1_tvpcp(reg, tvpcp) (reg)->bitfields.TVPCP = tvpcp
#define set_TV_PLL_CNTL1_tvpvg(reg, tvpvg) (reg)->bitfields.TVPVG = tvpvg
#define set_TV_PLL_CNTL1_tvpdc(reg, tvpdc) (reg)->bitfields.TVPDC = tvpdc
#define set_TV_PLL_CNTL1_tvclk_src_sel(reg, tvclk_src_sel) (reg)->bitfields.TVCLK_SRC_SEL = tvclk_src_sel
#define set_TV_PLL_CNTL1_tvpll_test(reg, tvpll_test) (reg)->bitfields.TVPLL_TEST = tvpll_test

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TV_DTO_INCREMENTS regTV_DTO_INCREMENTS;

#ifdef DEBUG
__inline void set_TV_DTO_INCREMENTS_tv_dto_inc0(regTV_DTO_INCREMENTS *reg, unsigned int tv_dto_inc0)
{
  reg->bitfields.TV_DTO_INC0 = tv_dto_inc0;
  if (reg->bitfields.TV_DTO_INC0 != tv_dto_inc0) HSLDPF(E_ERROR_MESSAGE,"TV_DTO_INCREMENTS::TV_DTO_INC0 data too large\n");
}
__inline void set_TV_DTO_INCREMENTS_tv_dto_inc1(regTV_DTO_INCREMENTS *reg, unsigned int tv_dto_inc1)
{
  reg->bitfields.TV_DTO_INC1 = tv_dto_inc1;
  if (reg->bitfields.TV_DTO_INC1 != tv_dto_inc1) HSLDPF(E_ERROR_MESSAGE,"TV_DTO_INCREMENTS::TV_DTO_INC1 data too large\n");
}
#else
#define set_TV_DTO_INCREMENTS_tv_dto_inc0(reg, tv_dto_inc0) (reg)->bitfields.TV_DTO_INC0 = tv_dto_inc0
#define set_TV_DTO_INCREMENTS_tv_dto_inc1(reg, tv_dto_inc1) (reg)->bitfields.TV_DTO_INC1 = tv_dto_inc1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union P2PLL_CNTL regP2PLL_CNTL;

#ifdef DEBUG
__inline void set_P2PLL_CNTL_p2pll_reset(regP2PLL_CNTL *reg, unsigned int p2pll_reset)
{
  reg->bitfields.P2PLL_RESET = p2pll_reset;
  if (reg->bitfields.P2PLL_RESET != p2pll_reset) HSLDPF(E_ERROR_MESSAGE,"P2PLL_CNTL::P2PLL_RESET data too large\n");
}
__inline void set_P2PLL_CNTL_p2pll_sleep(regP2PLL_CNTL *reg, unsigned int p2pll_sleep)
{
  reg->bitfields.P2PLL_SLEEP = p2pll_sleep;
  if (reg->bitfields.P2PLL_SLEEP != p2pll_sleep) HSLDPF(E_ERROR_MESSAGE,"P2PLL_CNTL::P2PLL_SLEEP data too large\n");
}
__inline void set_P2PLL_CNTL_p2pll_tst_en(regP2PLL_CNTL *reg, unsigned int p2pll_tst_en)
{
  reg->bitfields.P2PLL_TST_EN = p2pll_tst_en;
  if (reg->bitfields.P2PLL_TST_EN != p2pll_tst_en) HSLDPF(E_ERROR_MESSAGE,"P2PLL_CNTL::P2PLL_TST_EN data too large\n");
}
__inline void set_P2PLL_CNTL_p2pll_refclk_sel(regP2PLL_CNTL *reg, unsigned int p2pll_refclk_sel)
{
  reg->bitfields.P2PLL_REFCLK_SEL = p2pll_refclk_sel;
  if (reg->bitfields.P2PLL_REFCLK_SEL != p2pll_refclk_sel) HSLDPF(E_ERROR_MESSAGE,"P2PLL_CNTL::P2PLL_REFCLK_SEL data too large\n");
}
__inline void set_P2PLL_CNTL_p2pll_fbclk_sel(regP2PLL_CNTL *reg, unsigned int p2pll_fbclk_sel)
{
  reg->bitfields.P2PLL_FBCLK_SEL = p2pll_fbclk_sel;
  if (reg->bitfields.P2PLL_FBCLK_SEL != p2pll_fbclk_sel) HSLDPF(E_ERROR_MESSAGE,"P2PLL_CNTL::P2PLL_FBCLK_SEL data too large\n");
}
__inline void set_P2PLL_CNTL_p2pll_tcpoff(regP2PLL_CNTL *reg, unsigned int p2pll_tcpoff)
{
  reg->bitfields.P2PLL_TCPOFF = p2pll_tcpoff;
  if (reg->bitfields.P2PLL_TCPOFF != p2pll_tcpoff) HSLDPF(E_ERROR_MESSAGE,"P2PLL_CNTL::P2PLL_TCPOFF data too large\n");
}
__inline void set_P2PLL_CNTL_p2pll_tvcomax(regP2PLL_CNTL *reg, unsigned int p2pll_tvcomax)
{
  reg->bitfields.P2PLL_TVCOMAX = p2pll_tvcomax;
  if (reg->bitfields.P2PLL_TVCOMAX != p2pll_tvcomax) HSLDPF(E_ERROR_MESSAGE,"P2PLL_CNTL::P2PLL_TVCOMAX data too large\n");
}
__inline void set_P2PLL_CNTL_p2pll_pcp(regP2PLL_CNTL *reg, unsigned int p2pll_pcp)
{
  reg->bitfields.P2PLL_PCP = p2pll_pcp;
  if (reg->bitfields.P2PLL_PCP != p2pll_pcp) HSLDPF(E_ERROR_MESSAGE,"P2PLL_CNTL::P2PLL_PCP data too large\n");
}
__inline void set_P2PLL_CNTL_p2pll_pvg(regP2PLL_CNTL *reg, unsigned int p2pll_pvg)
{
  reg->bitfields.P2PLL_PVG = p2pll_pvg;
  if (reg->bitfields.P2PLL_PVG != p2pll_pvg) HSLDPF(E_ERROR_MESSAGE,"P2PLL_CNTL::P2PLL_PVG data too large\n");
}
__inline void set_P2PLL_CNTL_p2pll_pdc(regP2PLL_CNTL *reg, unsigned int p2pll_pdc)
{
  reg->bitfields.P2PLL_PDC = p2pll_pdc;
  if (reg->bitfields.P2PLL_PDC != p2pll_pdc) HSLDPF(E_ERROR_MESSAGE,"P2PLL_CNTL::P2PLL_PDC data too large\n");
}
__inline void set_P2PLL_CNTL_p2pll_atomic_update_en(regP2PLL_CNTL *reg, unsigned int p2pll_atomic_update_en)
{
  reg->bitfields.P2PLL_ATOMIC_UPDATE_EN = p2pll_atomic_update_en;
  if (reg->bitfields.P2PLL_ATOMIC_UPDATE_EN != p2pll_atomic_update_en) HSLDPF(E_ERROR_MESSAGE,"P2PLL_CNTL::P2PLL_ATOMIC_UPDATE_EN data too large\n");
}
__inline void set_P2PLL_CNTL_p2pll_atomic_update_sync(regP2PLL_CNTL *reg, unsigned int p2pll_atomic_update_sync)
{
  reg->bitfields.P2PLL_ATOMIC_UPDATE_SYNC = p2pll_atomic_update_sync;
  if (reg->bitfields.P2PLL_ATOMIC_UPDATE_SYNC != p2pll_atomic_update_sync) HSLDPF(E_ERROR_MESSAGE,"P2PLL_CNTL::P2PLL_ATOMIC_UPDATE_SYNC data too large\n");
}
__inline void set_P2PLL_CNTL_p2pll_disable_auto_reset(regP2PLL_CNTL *reg, unsigned int p2pll_disable_auto_reset)
{
  reg->bitfields.P2PLL_DISABLE_AUTO_RESET = p2pll_disable_auto_reset;
  if (reg->bitfields.P2PLL_DISABLE_AUTO_RESET != p2pll_disable_auto_reset) HSLDPF(E_ERROR_MESSAGE,"P2PLL_CNTL::P2PLL_DISABLE_AUTO_RESET data too large\n");
}
#else
#define set_P2PLL_CNTL_p2pll_reset(reg, p2pll_reset) (reg)->bitfields.P2PLL_RESET = p2pll_reset
#define set_P2PLL_CNTL_p2pll_sleep(reg, p2pll_sleep) (reg)->bitfields.P2PLL_SLEEP = p2pll_sleep
#define set_P2PLL_CNTL_p2pll_tst_en(reg, p2pll_tst_en) (reg)->bitfields.P2PLL_TST_EN = p2pll_tst_en
#define set_P2PLL_CNTL_p2pll_refclk_sel(reg, p2pll_refclk_sel) (reg)->bitfields.P2PLL_REFCLK_SEL = p2pll_refclk_sel
#define set_P2PLL_CNTL_p2pll_fbclk_sel(reg, p2pll_fbclk_sel) (reg)->bitfields.P2PLL_FBCLK_SEL = p2pll_fbclk_sel
#define set_P2PLL_CNTL_p2pll_tcpoff(reg, p2pll_tcpoff) (reg)->bitfields.P2PLL_TCPOFF = p2pll_tcpoff
#define set_P2PLL_CNTL_p2pll_tvcomax(reg, p2pll_tvcomax) (reg)->bitfields.P2PLL_TVCOMAX = p2pll_tvcomax
#define set_P2PLL_CNTL_p2pll_pcp(reg, p2pll_pcp) (reg)->bitfields.P2PLL_PCP = p2pll_pcp
#define set_P2PLL_CNTL_p2pll_pvg(reg, p2pll_pvg) (reg)->bitfields.P2PLL_PVG = p2pll_pvg
#define set_P2PLL_CNTL_p2pll_pdc(reg, p2pll_pdc) (reg)->bitfields.P2PLL_PDC = p2pll_pdc
#define set_P2PLL_CNTL_p2pll_atomic_update_en(reg, p2pll_atomic_update_en) (reg)->bitfields.P2PLL_ATOMIC_UPDATE_EN = p2pll_atomic_update_en
#define set_P2PLL_CNTL_p2pll_atomic_update_sync(reg, p2pll_atomic_update_sync) (reg)->bitfields.P2PLL_ATOMIC_UPDATE_SYNC = p2pll_atomic_update_sync
#define set_P2PLL_CNTL_p2pll_disable_auto_reset(reg, p2pll_disable_auto_reset) (reg)->bitfields.P2PLL_DISABLE_AUTO_RESET = p2pll_disable_auto_reset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union P2PLL_REF_DIV regP2PLL_REF_DIV;

#ifdef DEBUG
__inline void set_P2PLL_REF_DIV_p2pll_ref_div(regP2PLL_REF_DIV *reg, unsigned int p2pll_ref_div)
{
  reg->bitfields.P2PLL_REF_DIV = p2pll_ref_div;
  if (reg->bitfields.P2PLL_REF_DIV != p2pll_ref_div) HSLDPF(E_ERROR_MESSAGE,"P2PLL_REF_DIV::P2PLL_REF_DIV data too large\n");
}
__inline void set_P2PLL_REF_DIV_p2pll_atomic_update_w(regP2PLL_REF_DIV *reg, unsigned int p2pll_atomic_update_w)
{
  reg->bitfields.P2PLL_ATOMIC_UPDATE_W = p2pll_atomic_update_w;
  if (reg->bitfields.P2PLL_ATOMIC_UPDATE_W != p2pll_atomic_update_w) HSLDPF(E_ERROR_MESSAGE,"P2PLL_REF_DIV::P2PLL_ATOMIC_UPDATE_W data too large\n");
}
__inline void set_P2PLL_REF_DIV_p2pll_ref_div_src(regP2PLL_REF_DIV *reg, unsigned int p2pll_ref_div_src)
{
  reg->bitfields.P2PLL_REF_DIV_SRC = p2pll_ref_div_src;
  if (reg->bitfields.P2PLL_REF_DIV_SRC != p2pll_ref_div_src) HSLDPF(E_ERROR_MESSAGE,"P2PLL_REF_DIV::P2PLL_REF_DIV_SRC data too large\n");
}
#else
#define set_P2PLL_REF_DIV_p2pll_ref_div(reg, p2pll_ref_div) (reg)->bitfields.P2PLL_REF_DIV = p2pll_ref_div
#define set_P2PLL_REF_DIV_p2pll_atomic_update_w(reg, p2pll_atomic_update_w) (reg)->bitfields.P2PLL_ATOMIC_UPDATE_W = p2pll_atomic_update_w
#define set_P2PLL_REF_DIV_p2pll_ref_div_src(reg, p2pll_ref_div_src) (reg)->bitfields.P2PLL_REF_DIV_SRC = p2pll_ref_div_src

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SSPLL_CNTL regSSPLL_CNTL;

#ifdef DEBUG
__inline void set_SSPLL_CNTL_sspll_reset(regSSPLL_CNTL *reg, unsigned int sspll_reset)
{
  reg->bitfields.SSPLL_RESET = sspll_reset;
  if (reg->bitfields.SSPLL_RESET != sspll_reset) HSLDPF(E_ERROR_MESSAGE,"SSPLL_CNTL::SSPLL_RESET data too large\n");
}
__inline void set_SSPLL_CNTL_sspll_sleep(regSSPLL_CNTL *reg, unsigned int sspll_sleep)
{
  reg->bitfields.SSPLL_SLEEP = sspll_sleep;
  if (reg->bitfields.SSPLL_SLEEP != sspll_sleep) HSLDPF(E_ERROR_MESSAGE,"SSPLL_CNTL::SSPLL_SLEEP data too large\n");
}
__inline void set_SSPLL_CNTL_sspll_tst_en(regSSPLL_CNTL *reg, unsigned int sspll_tst_en)
{
  reg->bitfields.SSPLL_TST_EN = sspll_tst_en;
  if (reg->bitfields.SSPLL_TST_EN != sspll_tst_en) HSLDPF(E_ERROR_MESSAGE,"SSPLL_CNTL::SSPLL_TST_EN data too large\n");
}
__inline void set_SSPLL_CNTL_sspll_refclk_sel(regSSPLL_CNTL *reg, unsigned int sspll_refclk_sel)
{
  reg->bitfields.SSPLL_REFCLK_SEL = sspll_refclk_sel;
  if (reg->bitfields.SSPLL_REFCLK_SEL != sspll_refclk_sel) HSLDPF(E_ERROR_MESSAGE,"SSPLL_CNTL::SSPLL_REFCLK_SEL data too large\n");
}
__inline void set_SSPLL_CNTL_sspll_fbclk_sel(regSSPLL_CNTL *reg, unsigned int sspll_fbclk_sel)
{
  reg->bitfields.SSPLL_FBCLK_SEL = sspll_fbclk_sel;
  if (reg->bitfields.SSPLL_FBCLK_SEL != sspll_fbclk_sel) HSLDPF(E_ERROR_MESSAGE,"SSPLL_CNTL::SSPLL_FBCLK_SEL data too large\n");
}
__inline void set_SSPLL_CNTL_sspll_tcpoff(regSSPLL_CNTL *reg, unsigned int sspll_tcpoff)
{
  reg->bitfields.SSPLL_TCPOFF = sspll_tcpoff;
  if (reg->bitfields.SSPLL_TCPOFF != sspll_tcpoff) HSLDPF(E_ERROR_MESSAGE,"SSPLL_CNTL::SSPLL_TCPOFF data too large\n");
}
__inline void set_SSPLL_CNTL_sspll_tvcomax(regSSPLL_CNTL *reg, unsigned int sspll_tvcomax)
{
  reg->bitfields.SSPLL_TVCOMAX = sspll_tvcomax;
  if (reg->bitfields.SSPLL_TVCOMAX != sspll_tvcomax) HSLDPF(E_ERROR_MESSAGE,"SSPLL_CNTL::SSPLL_TVCOMAX data too large\n");
}
__inline void set_SSPLL_CNTL_sspll_pcp(regSSPLL_CNTL *reg, unsigned int sspll_pcp)
{
  reg->bitfields.SSPLL_PCP = sspll_pcp;
  if (reg->bitfields.SSPLL_PCP != sspll_pcp) HSLDPF(E_ERROR_MESSAGE,"SSPLL_CNTL::SSPLL_PCP data too large\n");
}
__inline void set_SSPLL_CNTL_sspll_pvg(regSSPLL_CNTL *reg, unsigned int sspll_pvg)
{
  reg->bitfields.SSPLL_PVG = sspll_pvg;
  if (reg->bitfields.SSPLL_PVG != sspll_pvg) HSLDPF(E_ERROR_MESSAGE,"SSPLL_CNTL::SSPLL_PVG data too large\n");
}
__inline void set_SSPLL_CNTL_sspll_pdc(regSSPLL_CNTL *reg, unsigned int sspll_pdc)
{
  reg->bitfields.SSPLL_PDC = sspll_pdc;
  if (reg->bitfields.SSPLL_PDC != sspll_pdc) HSLDPF(E_ERROR_MESSAGE,"SSPLL_CNTL::SSPLL_PDC data too large\n");
}
__inline void set_SSPLL_CNTL_sspll_atomic_update_en(regSSPLL_CNTL *reg, unsigned int sspll_atomic_update_en)
{
  reg->bitfields.SSPLL_ATOMIC_UPDATE_EN = sspll_atomic_update_en;
  if (reg->bitfields.SSPLL_ATOMIC_UPDATE_EN != sspll_atomic_update_en) HSLDPF(E_ERROR_MESSAGE,"SSPLL_CNTL::SSPLL_ATOMIC_UPDATE_EN data too large\n");
}
__inline void set_SSPLL_CNTL_sspll_atomic_update_sync(regSSPLL_CNTL *reg, unsigned int sspll_atomic_update_sync)
{
  reg->bitfields.SSPLL_ATOMIC_UPDATE_SYNC = sspll_atomic_update_sync;
  if (reg->bitfields.SSPLL_ATOMIC_UPDATE_SYNC != sspll_atomic_update_sync) HSLDPF(E_ERROR_MESSAGE,"SSPLL_CNTL::SSPLL_ATOMIC_UPDATE_SYNC data too large\n");
}
#else
#define set_SSPLL_CNTL_sspll_reset(reg, sspll_reset) (reg)->bitfields.SSPLL_RESET = sspll_reset
#define set_SSPLL_CNTL_sspll_sleep(reg, sspll_sleep) (reg)->bitfields.SSPLL_SLEEP = sspll_sleep
#define set_SSPLL_CNTL_sspll_tst_en(reg, sspll_tst_en) (reg)->bitfields.SSPLL_TST_EN = sspll_tst_en
#define set_SSPLL_CNTL_sspll_refclk_sel(reg, sspll_refclk_sel) (reg)->bitfields.SSPLL_REFCLK_SEL = sspll_refclk_sel
#define set_SSPLL_CNTL_sspll_fbclk_sel(reg, sspll_fbclk_sel) (reg)->bitfields.SSPLL_FBCLK_SEL = sspll_fbclk_sel
#define set_SSPLL_CNTL_sspll_tcpoff(reg, sspll_tcpoff) (reg)->bitfields.SSPLL_TCPOFF = sspll_tcpoff
#define set_SSPLL_CNTL_sspll_tvcomax(reg, sspll_tvcomax) (reg)->bitfields.SSPLL_TVCOMAX = sspll_tvcomax
#define set_SSPLL_CNTL_sspll_pcp(reg, sspll_pcp) (reg)->bitfields.SSPLL_PCP = sspll_pcp
#define set_SSPLL_CNTL_sspll_pvg(reg, sspll_pvg) (reg)->bitfields.SSPLL_PVG = sspll_pvg
#define set_SSPLL_CNTL_sspll_pdc(reg, sspll_pdc) (reg)->bitfields.SSPLL_PDC = sspll_pdc
#define set_SSPLL_CNTL_sspll_atomic_update_en(reg, sspll_atomic_update_en) (reg)->bitfields.SSPLL_ATOMIC_UPDATE_EN = sspll_atomic_update_en
#define set_SSPLL_CNTL_sspll_atomic_update_sync(reg, sspll_atomic_update_sync) (reg)->bitfields.SSPLL_ATOMIC_UPDATE_SYNC = sspll_atomic_update_sync

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SSPLL_REF_DIV regSSPLL_REF_DIV;

#ifdef DEBUG
__inline void set_SSPLL_REF_DIV_sspll_ref_div(regSSPLL_REF_DIV *reg, unsigned int sspll_ref_div)
{
  reg->bitfields.SSPLL_REF_DIV = sspll_ref_div;
  if (reg->bitfields.SSPLL_REF_DIV != sspll_ref_div) HSLDPF(E_ERROR_MESSAGE,"SSPLL_REF_DIV::SSPLL_REF_DIV data too large\n");
}
__inline void set_SSPLL_REF_DIV_sspll_atomic_update_w(regSSPLL_REF_DIV *reg, unsigned int sspll_atomic_update_w)
{
  reg->bitfields.SSPLL_ATOMIC_UPDATE_W = sspll_atomic_update_w;
  if (reg->bitfields.SSPLL_ATOMIC_UPDATE_W != sspll_atomic_update_w) HSLDPF(E_ERROR_MESSAGE,"SSPLL_REF_DIV::SSPLL_ATOMIC_UPDATE_W data too large\n");
}
__inline void set_SSPLL_REF_DIV_sspll_ref_div_src(regSSPLL_REF_DIV *reg, unsigned int sspll_ref_div_src)
{
  reg->bitfields.SSPLL_REF_DIV_SRC = sspll_ref_div_src;
  if (reg->bitfields.SSPLL_REF_DIV_SRC != sspll_ref_div_src) HSLDPF(E_ERROR_MESSAGE,"SSPLL_REF_DIV::SSPLL_REF_DIV_SRC data too large\n");
}
#else
#define set_SSPLL_REF_DIV_sspll_ref_div(reg, sspll_ref_div) (reg)->bitfields.SSPLL_REF_DIV = sspll_ref_div
#define set_SSPLL_REF_DIV_sspll_atomic_update_w(reg, sspll_atomic_update_w) (reg)->bitfields.SSPLL_ATOMIC_UPDATE_W = sspll_atomic_update_w
#define set_SSPLL_REF_DIV_sspll_ref_div_src(reg, sspll_ref_div_src) (reg)->bitfields.SSPLL_REF_DIV_SRC = sspll_ref_div_src

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SSPLL_DIV_0 regSSPLL_DIV_0;

#ifdef DEBUG
__inline void set_SSPLL_DIV_0_sspll_fb_div(regSSPLL_DIV_0 *reg, unsigned int sspll_fb_div)
{
  reg->bitfields.SSPLL_FB_DIV = sspll_fb_div;
  if (reg->bitfields.SSPLL_FB_DIV != sspll_fb_div) HSLDPF(E_ERROR_MESSAGE,"SSPLL_DIV_0::SSPLL_FB_DIV data too large\n");
}
__inline void set_SSPLL_DIV_0_sspll_fb_div_fraction(regSSPLL_DIV_0 *reg, unsigned int sspll_fb_div_fraction)
{
  reg->bitfields.SSPLL_FB_DIV_FRACTION = sspll_fb_div_fraction;
  if (reg->bitfields.SSPLL_FB_DIV_FRACTION != sspll_fb_div_fraction) HSLDPF(E_ERROR_MESSAGE,"SSPLL_DIV_0::SSPLL_FB_DIV_FRACTION data too large\n");
}
__inline void set_SSPLL_DIV_0_sspll_atomic_update_w(regSSPLL_DIV_0 *reg, unsigned int sspll_atomic_update_w)
{
  reg->bitfields.SSPLL_ATOMIC_UPDATE_W = sspll_atomic_update_w;
  if (reg->bitfields.SSPLL_ATOMIC_UPDATE_W != sspll_atomic_update_w) HSLDPF(E_ERROR_MESSAGE,"SSPLL_DIV_0::SSPLL_ATOMIC_UPDATE_W data too large\n");
}
__inline void set_SSPLL_DIV_0_sspll_post_div(regSSPLL_DIV_0 *reg, unsigned int sspll_post_div)
{
  reg->bitfields.SSPLL_POST_DIV = sspll_post_div;
  if (reg->bitfields.SSPLL_POST_DIV != sspll_post_div) HSLDPF(E_ERROR_MESSAGE,"SSPLL_DIV_0::SSPLL_POST_DIV data too large\n");
}
__inline void set_SSPLL_DIV_0_sspll_fb_div_fraction_update(regSSPLL_DIV_0 *reg, unsigned int sspll_fb_div_fraction_update)
{
  reg->bitfields.SSPLL_FB_DIV_FRACTION_UPDATE = sspll_fb_div_fraction_update;
  if (reg->bitfields.SSPLL_FB_DIV_FRACTION_UPDATE != sspll_fb_div_fraction_update) HSLDPF(E_ERROR_MESSAGE,"SSPLL_DIV_0::SSPLL_FB_DIV_FRACTION_UPDATE data too large\n");
}
#else
#define set_SSPLL_DIV_0_sspll_fb_div(reg, sspll_fb_div) (reg)->bitfields.SSPLL_FB_DIV = sspll_fb_div
#define set_SSPLL_DIV_0_sspll_fb_div_fraction(reg, sspll_fb_div_fraction) (reg)->bitfields.SSPLL_FB_DIV_FRACTION = sspll_fb_div_fraction
#define set_SSPLL_DIV_0_sspll_atomic_update_w(reg, sspll_atomic_update_w) (reg)->bitfields.SSPLL_ATOMIC_UPDATE_W = sspll_atomic_update_w
#define set_SSPLL_DIV_0_sspll_post_div(reg, sspll_post_div) (reg)->bitfields.SSPLL_POST_DIV = sspll_post_div
#define set_SSPLL_DIV_0_sspll_fb_div_fraction_update(reg, sspll_fb_div_fraction_update) (reg)->bitfields.SSPLL_FB_DIV_FRACTION_UPDATE = sspll_fb_div_fraction_update

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SS_INT_CNTL regSS_INT_CNTL;

#ifdef DEBUG
__inline void set_SS_INT_CNTL_ss_int_en(regSS_INT_CNTL *reg, unsigned int ss_int_en)
{
  reg->bitfields.SS_INT_EN = ss_int_en;
  if (reg->bitfields.SS_INT_EN != ss_int_en) HSLDPF(E_ERROR_MESSAGE,"SS_INT_CNTL::SS_INT_EN data too large\n");
}
__inline void set_SS_INT_CNTL_ss_int_sel(regSS_INT_CNTL *reg, unsigned int ss_int_sel)
{
  reg->bitfields.SS_INT_SEL = ss_int_sel;
  if (reg->bitfields.SS_INT_SEL != ss_int_sel) HSLDPF(E_ERROR_MESSAGE,"SS_INT_CNTL::SS_INT_SEL data too large\n");
}
__inline void set_SS_INT_CNTL_ss_step_size(regSS_INT_CNTL *reg, unsigned int ss_step_size)
{
  reg->bitfields.SS_STEP_SIZE = ss_step_size;
  if (reg->bitfields.SS_STEP_SIZE != ss_step_size) HSLDPF(E_ERROR_MESSAGE,"SS_INT_CNTL::SS_STEP_SIZE data too large\n");
}
__inline void set_SS_INT_CNTL_ss_delay(regSS_INT_CNTL *reg, unsigned int ss_delay)
{
  reg->bitfields.SS_DELAY = ss_delay;
  if (reg->bitfields.SS_DELAY != ss_delay) HSLDPF(E_ERROR_MESSAGE,"SS_INT_CNTL::SS_DELAY data too large\n");
}
__inline void set_SS_INT_CNTL_ss_delta_fraction(regSS_INT_CNTL *reg, unsigned int ss_delta_fraction)
{
  reg->bitfields.SS_DELTA_FRACTION = ss_delta_fraction;
  if (reg->bitfields.SS_DELTA_FRACTION != ss_delta_fraction) HSLDPF(E_ERROR_MESSAGE,"SS_INT_CNTL::SS_DELTA_FRACTION data too large\n");
}
__inline void set_SS_INT_CNTL_ss_delta_integer(regSS_INT_CNTL *reg, unsigned int ss_delta_integer)
{
  reg->bitfields.SS_DELTA_INTEGER = ss_delta_integer;
  if (reg->bitfields.SS_DELTA_INTEGER != ss_delta_integer) HSLDPF(E_ERROR_MESSAGE,"SS_INT_CNTL::SS_DELTA_INTEGER data too large\n");
}
__inline void set_SS_INT_CNTL_ss_pll_display_src(regSS_INT_CNTL *reg, unsigned int ss_pll_display_src)
{
  reg->bitfields.SS_PLL_DISPLAY_SRC = ss_pll_display_src;
  if (reg->bitfields.SS_PLL_DISPLAY_SRC != ss_pll_display_src) HSLDPF(E_ERROR_MESSAGE,"SS_INT_CNTL::SS_PLL_DISPLAY_SRC data too large\n");
}
__inline void set_SS_INT_CNTL_ss_pll_display_en(regSS_INT_CNTL *reg, unsigned int ss_pll_display_en)
{
  reg->bitfields.SS_PLL_DISPLAY_EN = ss_pll_display_en;
  if (reg->bitfields.SS_PLL_DISPLAY_EN != ss_pll_display_en) HSLDPF(E_ERROR_MESSAGE,"SS_INT_CNTL::SS_PLL_DISPLAY_EN data too large\n");
}
__inline void set_SS_INT_CNTL_ss_buf_genlock_en(regSS_INT_CNTL *reg, unsigned int ss_buf_genlock_en)
{
  reg->bitfields.SS_BUF_GENLOCK_EN = ss_buf_genlock_en;
  if (reg->bitfields.SS_BUF_GENLOCK_EN != ss_buf_genlock_en) HSLDPF(E_ERROR_MESSAGE,"SS_INT_CNTL::SS_BUF_GENLOCK_EN data too large\n");
}
__inline void set_SS_INT_CNTL_ss_buf_genlock_threshold(regSS_INT_CNTL *reg, unsigned int ss_buf_genlock_threshold)
{
  reg->bitfields.SS_BUF_GENLOCK_THRESHOLD = ss_buf_genlock_threshold;
  if (reg->bitfields.SS_BUF_GENLOCK_THRESHOLD != ss_buf_genlock_threshold) HSLDPF(E_ERROR_MESSAGE,"SS_INT_CNTL::SS_BUF_GENLOCK_THRESHOLD data too large\n");
}
__inline void set_SS_INT_CNTL_ss_buf_genlock_duration(regSS_INT_CNTL *reg, unsigned int ss_buf_genlock_duration)
{
  reg->bitfields.SS_BUF_GENLOCK_DURATION = ss_buf_genlock_duration;
  if (reg->bitfields.SS_BUF_GENLOCK_DURATION != ss_buf_genlock_duration) HSLDPF(E_ERROR_MESSAGE,"SS_INT_CNTL::SS_BUF_GENLOCK_DURATION data too large\n");
}
__inline void set_SS_INT_CNTL_ss_buf_genlock_height(regSS_INT_CNTL *reg, unsigned int ss_buf_genlock_height)
{
  reg->bitfields.SS_BUF_GENLOCK_HEIGHT = ss_buf_genlock_height;
  if (reg->bitfields.SS_BUF_GENLOCK_HEIGHT != ss_buf_genlock_height) HSLDPF(E_ERROR_MESSAGE,"SS_INT_CNTL::SS_BUF_GENLOCK_HEIGHT data too large\n");
}
#else
#define set_SS_INT_CNTL_ss_int_en(reg, ss_int_en) (reg)->bitfields.SS_INT_EN = ss_int_en
#define set_SS_INT_CNTL_ss_int_sel(reg, ss_int_sel) (reg)->bitfields.SS_INT_SEL = ss_int_sel
#define set_SS_INT_CNTL_ss_step_size(reg, ss_step_size) (reg)->bitfields.SS_STEP_SIZE = ss_step_size
#define set_SS_INT_CNTL_ss_delay(reg, ss_delay) (reg)->bitfields.SS_DELAY = ss_delay
#define set_SS_INT_CNTL_ss_delta_fraction(reg, ss_delta_fraction) (reg)->bitfields.SS_DELTA_FRACTION = ss_delta_fraction
#define set_SS_INT_CNTL_ss_delta_integer(reg, ss_delta_integer) (reg)->bitfields.SS_DELTA_INTEGER = ss_delta_integer
#define set_SS_INT_CNTL_ss_pll_display_src(reg, ss_pll_display_src) (reg)->bitfields.SS_PLL_DISPLAY_SRC = ss_pll_display_src
#define set_SS_INT_CNTL_ss_pll_display_en(reg, ss_pll_display_en) (reg)->bitfields.SS_PLL_DISPLAY_EN = ss_pll_display_en
#define set_SS_INT_CNTL_ss_buf_genlock_en(reg, ss_buf_genlock_en) (reg)->bitfields.SS_BUF_GENLOCK_EN = ss_buf_genlock_en
#define set_SS_INT_CNTL_ss_buf_genlock_threshold(reg, ss_buf_genlock_threshold) (reg)->bitfields.SS_BUF_GENLOCK_THRESHOLD = ss_buf_genlock_threshold
#define set_SS_INT_CNTL_ss_buf_genlock_duration(reg, ss_buf_genlock_duration) (reg)->bitfields.SS_BUF_GENLOCK_DURATION = ss_buf_genlock_duration
#define set_SS_INT_CNTL_ss_buf_genlock_height(reg, ss_buf_genlock_height) (reg)->bitfields.SS_BUF_GENLOCK_HEIGHT = ss_buf_genlock_height

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SS_TST_CNTL regSS_TST_CNTL;

#ifdef DEBUG
__inline void set_SS_TST_CNTL_ss_tst_cnt(regSS_TST_CNTL *reg, unsigned int ss_tst_cnt)
{
  reg->bitfields.SS_TST_CNT = ss_tst_cnt;
  if (reg->bitfields.SS_TST_CNT != ss_tst_cnt) HSLDPF(E_ERROR_MESSAGE,"SS_TST_CNTL::SS_TST_CNT data too large\n");
}
__inline void set_SS_TST_CNTL_ss_tst_cnt_sel(regSS_TST_CNTL *reg, unsigned int ss_tst_cnt_sel)
{
  reg->bitfields.SS_TST_CNT_SEL = ss_tst_cnt_sel;
  if (reg->bitfields.SS_TST_CNT_SEL != ss_tst_cnt_sel) HSLDPF(E_ERROR_MESSAGE,"SS_TST_CNTL::SS_TST_CNT_SEL data too large\n");
}
__inline void set_SS_TST_CNTL_ss_tst_ge(regSS_TST_CNTL *reg, unsigned int ss_tst_ge)
{
  reg->bitfields.SS_TST_GE = ss_tst_ge;
  if (reg->bitfields.SS_TST_GE != ss_tst_ge) HSLDPF(E_ERROR_MESSAGE,"SS_TST_CNTL::SS_TST_GE data too large\n");
}
__inline void set_SS_TST_CNTL_ss_tst_le(regSS_TST_CNTL *reg, unsigned int ss_tst_le)
{
  reg->bitfields.SS_TST_LE = ss_tst_le;
  if (reg->bitfields.SS_TST_LE != ss_tst_le) HSLDPF(E_ERROR_MESSAGE,"SS_TST_CNTL::SS_TST_LE data too large\n");
}
__inline void set_SS_TST_CNTL_ss_tst_dec(regSS_TST_CNTL *reg, unsigned int ss_tst_dec)
{
  reg->bitfields.SS_TST_DEC = ss_tst_dec;
  if (reg->bitfields.SS_TST_DEC != ss_tst_dec) HSLDPF(E_ERROR_MESSAGE,"SS_TST_CNTL::SS_TST_DEC data too large\n");
}
__inline void set_SS_TST_CNTL_analog_mon_ss(regSS_TST_CNTL *reg, unsigned int analog_mon_ss)
{
  reg->bitfields.ANALOG_MON_SS = analog_mon_ss;
  if (reg->bitfields.ANALOG_MON_SS != analog_mon_ss) HSLDPF(E_ERROR_MESSAGE,"SS_TST_CNTL::ANALOG_MON_SS data too large\n");
}
__inline void set_SS_TST_CNTL_exp_implementation_en(regSS_TST_CNTL *reg, unsigned int exp_implementation_en)
{
  reg->bitfields.EXP_IMPLEMENTATION_EN = exp_implementation_en;
  if (reg->bitfields.EXP_IMPLEMENTATION_EN != exp_implementation_en) HSLDPF(E_ERROR_MESSAGE,"SS_TST_CNTL::EXP_IMPLEMENTATION_EN data too large\n");
}
__inline void set_SS_TST_CNTL_ss_antiglitch_en(regSS_TST_CNTL *reg, unsigned int ss_antiglitch_en)
{
  reg->bitfields.SS_ANTIGLITCH_EN = ss_antiglitch_en;
  if (reg->bitfields.SS_ANTIGLITCH_EN != ss_antiglitch_en) HSLDPF(E_ERROR_MESSAGE,"SS_TST_CNTL::SS_ANTIGLITCH_EN data too large\n");
}
__inline void set_SS_TST_CNTL_hdp_busy_half_sclk(regSS_TST_CNTL *reg, unsigned int hdp_busy_half_sclk)
{
  reg->bitfields.HDP_BUSY_HALF_SCLK = hdp_busy_half_sclk;
  if (reg->bitfields.HDP_BUSY_HALF_SCLK != hdp_busy_half_sclk) HSLDPF(E_ERROR_MESSAGE,"SS_TST_CNTL::HDP_BUSY_HALF_SCLK data too large\n");
}
__inline void set_SS_TST_CNTL_en_div2_half_sclk(regSS_TST_CNTL *reg, unsigned int en_div2_half_sclk)
{
  reg->bitfields.EN_DIV2_HALF_SCLK = en_div2_half_sclk;
  if (reg->bitfields.EN_DIV2_HALF_SCLK != en_div2_half_sclk) HSLDPF(E_ERROR_MESSAGE,"SS_TST_CNTL::EN_DIV2_HALF_SCLK data too large\n");
}
__inline void set_SS_TST_CNTL_ss_tst_mode(regSS_TST_CNTL *reg, unsigned int ss_tst_mode)
{
  reg->bitfields.SS_TST_MODE = ss_tst_mode;
  if (reg->bitfields.SS_TST_MODE != ss_tst_mode) HSLDPF(E_ERROR_MESSAGE,"SS_TST_CNTL::SS_TST_MODE data too large\n");
}
#else
#define set_SS_TST_CNTL_ss_tst_cnt(reg, ss_tst_cnt) (reg)->bitfields.SS_TST_CNT = ss_tst_cnt
#define set_SS_TST_CNTL_ss_tst_cnt_sel(reg, ss_tst_cnt_sel) (reg)->bitfields.SS_TST_CNT_SEL = ss_tst_cnt_sel
#define set_SS_TST_CNTL_ss_tst_ge(reg, ss_tst_ge) (reg)->bitfields.SS_TST_GE = ss_tst_ge
#define set_SS_TST_CNTL_ss_tst_le(reg, ss_tst_le) (reg)->bitfields.SS_TST_LE = ss_tst_le
#define set_SS_TST_CNTL_ss_tst_dec(reg, ss_tst_dec) (reg)->bitfields.SS_TST_DEC = ss_tst_dec
#define set_SS_TST_CNTL_analog_mon_ss(reg, analog_mon_ss) (reg)->bitfields.ANALOG_MON_SS = analog_mon_ss
#define set_SS_TST_CNTL_exp_implementation_en(reg, exp_implementation_en) (reg)->bitfields.EXP_IMPLEMENTATION_EN = exp_implementation_en
#define set_SS_TST_CNTL_ss_antiglitch_en(reg, ss_antiglitch_en) (reg)->bitfields.SS_ANTIGLITCH_EN = ss_antiglitch_en
#define set_SS_TST_CNTL_hdp_busy_half_sclk(reg, hdp_busy_half_sclk) (reg)->bitfields.HDP_BUSY_HALF_SCLK = hdp_busy_half_sclk
#define set_SS_TST_CNTL_en_div2_half_sclk(reg, en_div2_half_sclk) (reg)->bitfields.EN_DIV2_HALF_SCLK = en_div2_half_sclk
#define set_SS_TST_CNTL_ss_tst_mode(reg, ss_tst_mode) (reg)->bitfields.SS_TST_MODE = ss_tst_mode

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SCLK_MORE_CNTL regSCLK_MORE_CNTL;

#ifdef DEBUG
__inline void set_SCLK_MORE_CNTL_dispregs_max_dyn_stop_lat(regSCLK_MORE_CNTL *reg, unsigned int dispregs_max_dyn_stop_lat)
{
  reg->bitfields.DISPREGS_MAX_DYN_STOP_LAT = dispregs_max_dyn_stop_lat;
  if (reg->bitfields.DISPREGS_MAX_DYN_STOP_LAT != dispregs_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_MORE_CNTL::DISPREGS_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_MORE_CNTL_mc_gui_max_dyn_stop_lat(regSCLK_MORE_CNTL *reg, unsigned int mc_gui_max_dyn_stop_lat)
{
  reg->bitfields.MC_GUI_MAX_DYN_STOP_LAT = mc_gui_max_dyn_stop_lat;
  if (reg->bitfields.MC_GUI_MAX_DYN_STOP_LAT != mc_gui_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_MORE_CNTL::MC_GUI_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_MORE_CNTL_mc_host_max_dyn_stop_lat(regSCLK_MORE_CNTL *reg, unsigned int mc_host_max_dyn_stop_lat)
{
  reg->bitfields.MC_HOST_MAX_DYN_STOP_LAT = mc_host_max_dyn_stop_lat;
  if (reg->bitfields.MC_HOST_MAX_DYN_STOP_LAT != mc_host_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_MORE_CNTL::MC_HOST_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_MORE_CNTL_force_dispregs(regSCLK_MORE_CNTL *reg, unsigned int force_dispregs)
{
  reg->bitfields.FORCE_DISPREGS = force_dispregs;
  if (reg->bitfields.FORCE_DISPREGS != force_dispregs) HSLDPF(E_ERROR_MESSAGE,"SCLK_MORE_CNTL::FORCE_DISPREGS data too large\n");
}
__inline void set_SCLK_MORE_CNTL_force_mc_gui(regSCLK_MORE_CNTL *reg, unsigned int force_mc_gui)
{
  reg->bitfields.FORCE_MC_GUI = force_mc_gui;
  if (reg->bitfields.FORCE_MC_GUI != force_mc_gui) HSLDPF(E_ERROR_MESSAGE,"SCLK_MORE_CNTL::FORCE_MC_GUI data too large\n");
}
__inline void set_SCLK_MORE_CNTL_force_mc_host(regSCLK_MORE_CNTL *reg, unsigned int force_mc_host)
{
  reg->bitfields.FORCE_MC_HOST = force_mc_host;
  if (reg->bitfields.FORCE_MC_HOST != force_mc_host) HSLDPF(E_ERROR_MESSAGE,"SCLK_MORE_CNTL::FORCE_MC_HOST data too large\n");
}
__inline void set_SCLK_MORE_CNTL_stop_sclk_en(regSCLK_MORE_CNTL *reg, unsigned int stop_sclk_en)
{
  reg->bitfields.STOP_SCLK_EN = stop_sclk_en;
  if (reg->bitfields.STOP_SCLK_EN != stop_sclk_en) HSLDPF(E_ERROR_MESSAGE,"SCLK_MORE_CNTL::STOP_SCLK_EN data too large\n");
}
__inline void set_SCLK_MORE_CNTL_stop_sclk_a(regSCLK_MORE_CNTL *reg, unsigned int stop_sclk_a)
{
  reg->bitfields.STOP_SCLK_A = stop_sclk_a;
  if (reg->bitfields.STOP_SCLK_A != stop_sclk_a) HSLDPF(E_ERROR_MESSAGE,"SCLK_MORE_CNTL::STOP_SCLK_A data too large\n");
}
__inline void set_SCLK_MORE_CNTL_stop_sclk_b(regSCLK_MORE_CNTL *reg, unsigned int stop_sclk_b)
{
  reg->bitfields.STOP_SCLK_B = stop_sclk_b;
  if (reg->bitfields.STOP_SCLK_B != stop_sclk_b) HSLDPF(E_ERROR_MESSAGE,"SCLK_MORE_CNTL::STOP_SCLK_B data too large\n");
}
__inline void set_SCLK_MORE_CNTL_stop_sclk_c(regSCLK_MORE_CNTL *reg, unsigned int stop_sclk_c)
{
  reg->bitfields.STOP_SCLK_C = stop_sclk_c;
  if (reg->bitfields.STOP_SCLK_C != stop_sclk_c) HSLDPF(E_ERROR_MESSAGE,"SCLK_MORE_CNTL::STOP_SCLK_C data too large\n");
}
__inline void set_SCLK_MORE_CNTL_half_speed_sclk(regSCLK_MORE_CNTL *reg, unsigned int half_speed_sclk)
{
  reg->bitfields.HALF_SPEED_SCLK = half_speed_sclk;
  if (reg->bitfields.HALF_SPEED_SCLK != half_speed_sclk) HSLDPF(E_ERROR_MESSAGE,"SCLK_MORE_CNTL::HALF_SPEED_SCLK data too large\n");
}
__inline void set_SCLK_MORE_CNTL_io_cg_voltage_drop(regSCLK_MORE_CNTL *reg, unsigned int io_cg_voltage_drop)
{
  reg->bitfields.IO_CG_VOLTAGE_DROP = io_cg_voltage_drop;
  if (reg->bitfields.IO_CG_VOLTAGE_DROP != io_cg_voltage_drop) HSLDPF(E_ERROR_MESSAGE,"SCLK_MORE_CNTL::IO_CG_VOLTAGE_DROP data too large\n");
}
__inline void set_SCLK_MORE_CNTL_tvfb_soft_reset(regSCLK_MORE_CNTL *reg, unsigned int tvfb_soft_reset)
{
  reg->bitfields.TVFB_SOFT_RESET = tvfb_soft_reset;
  if (reg->bitfields.TVFB_SOFT_RESET != tvfb_soft_reset) HSLDPF(E_ERROR_MESSAGE,"SCLK_MORE_CNTL::TVFB_SOFT_RESET data too large\n");
}
__inline void set_SCLK_MORE_CNTL_voltage_drop_sync(regSCLK_MORE_CNTL *reg, unsigned int voltage_drop_sync)
{
  reg->bitfields.VOLTAGE_DROP_SYNC = voltage_drop_sync;
  if (reg->bitfields.VOLTAGE_DROP_SYNC != voltage_drop_sync) HSLDPF(E_ERROR_MESSAGE,"SCLK_MORE_CNTL::VOLTAGE_DROP_SYNC data too large\n");
}
__inline void set_SCLK_MORE_CNTL_voltage_delay_sel(regSCLK_MORE_CNTL *reg, unsigned int voltage_delay_sel)
{
  reg->bitfields.VOLTAGE_DELAY_SEL = voltage_delay_sel;
  if (reg->bitfields.VOLTAGE_DELAY_SEL != voltage_delay_sel) HSLDPF(E_ERROR_MESSAGE,"SCLK_MORE_CNTL::VOLTAGE_DELAY_SEL data too large\n");
}
__inline void set_SCLK_MORE_CNTL_idle_delay_half_sclk(regSCLK_MORE_CNTL *reg, unsigned int idle_delay_half_sclk)
{
  reg->bitfields.IDLE_DELAY_HALF_SCLK = idle_delay_half_sclk;
  if (reg->bitfields.IDLE_DELAY_HALF_SCLK != idle_delay_half_sclk) HSLDPF(E_ERROR_MESSAGE,"SCLK_MORE_CNTL::IDLE_DELAY_HALF_SCLK data too large\n");
}
__inline void set_SCLK_MORE_CNTL_agp_busy_half_sclk(regSCLK_MORE_CNTL *reg, unsigned int agp_busy_half_sclk)
{
  reg->bitfields.AGP_BUSY_HALF_SCLK = agp_busy_half_sclk;
  if (reg->bitfields.AGP_BUSY_HALF_SCLK != agp_busy_half_sclk) HSLDPF(E_ERROR_MESSAGE,"SCLK_MORE_CNTL::AGP_BUSY_HALF_SCLK data too large\n");
}
__inline void set_SCLK_MORE_CNTL_cg_spare_rd_c(regSCLK_MORE_CNTL *reg, unsigned int cg_spare_rd_c)
{
  reg->bitfields.CG_SPARE_RD_C = cg_spare_rd_c;
  if (reg->bitfields.CG_SPARE_RD_C != cg_spare_rd_c) HSLDPF(E_ERROR_MESSAGE,"SCLK_MORE_CNTL::CG_SPARE_RD_C data too large\n");
}
#else
#define set_SCLK_MORE_CNTL_dispregs_max_dyn_stop_lat(reg, dispregs_max_dyn_stop_lat) (reg)->bitfields.DISPREGS_MAX_DYN_STOP_LAT = dispregs_max_dyn_stop_lat
#define set_SCLK_MORE_CNTL_mc_gui_max_dyn_stop_lat(reg, mc_gui_max_dyn_stop_lat) (reg)->bitfields.MC_GUI_MAX_DYN_STOP_LAT = mc_gui_max_dyn_stop_lat
#define set_SCLK_MORE_CNTL_mc_host_max_dyn_stop_lat(reg, mc_host_max_dyn_stop_lat) (reg)->bitfields.MC_HOST_MAX_DYN_STOP_LAT = mc_host_max_dyn_stop_lat
#define set_SCLK_MORE_CNTL_force_dispregs(reg, force_dispregs) (reg)->bitfields.FORCE_DISPREGS = force_dispregs
#define set_SCLK_MORE_CNTL_force_mc_gui(reg, force_mc_gui) (reg)->bitfields.FORCE_MC_GUI = force_mc_gui
#define set_SCLK_MORE_CNTL_force_mc_host(reg, force_mc_host) (reg)->bitfields.FORCE_MC_HOST = force_mc_host
#define set_SCLK_MORE_CNTL_stop_sclk_en(reg, stop_sclk_en) (reg)->bitfields.STOP_SCLK_EN = stop_sclk_en
#define set_SCLK_MORE_CNTL_stop_sclk_a(reg, stop_sclk_a) (reg)->bitfields.STOP_SCLK_A = stop_sclk_a
#define set_SCLK_MORE_CNTL_stop_sclk_b(reg, stop_sclk_b) (reg)->bitfields.STOP_SCLK_B = stop_sclk_b
#define set_SCLK_MORE_CNTL_stop_sclk_c(reg, stop_sclk_c) (reg)->bitfields.STOP_SCLK_C = stop_sclk_c
#define set_SCLK_MORE_CNTL_half_speed_sclk(reg, half_speed_sclk) (reg)->bitfields.HALF_SPEED_SCLK = half_speed_sclk
#define set_SCLK_MORE_CNTL_io_cg_voltage_drop(reg, io_cg_voltage_drop) (reg)->bitfields.IO_CG_VOLTAGE_DROP = io_cg_voltage_drop
#define set_SCLK_MORE_CNTL_tvfb_soft_reset(reg, tvfb_soft_reset) (reg)->bitfields.TVFB_SOFT_RESET = tvfb_soft_reset
#define set_SCLK_MORE_CNTL_voltage_drop_sync(reg, voltage_drop_sync) (reg)->bitfields.VOLTAGE_DROP_SYNC = voltage_drop_sync
#define set_SCLK_MORE_CNTL_voltage_delay_sel(reg, voltage_delay_sel) (reg)->bitfields.VOLTAGE_DELAY_SEL = voltage_delay_sel
#define set_SCLK_MORE_CNTL_idle_delay_half_sclk(reg, idle_delay_half_sclk) (reg)->bitfields.IDLE_DELAY_HALF_SCLK = idle_delay_half_sclk
#define set_SCLK_MORE_CNTL_agp_busy_half_sclk(reg, agp_busy_half_sclk) (reg)->bitfields.AGP_BUSY_HALF_SCLK = agp_busy_half_sclk
#define set_SCLK_MORE_CNTL_cg_spare_rd_c(reg, cg_spare_rd_c) (reg)->bitfields.CG_SPARE_RD_C = cg_spare_rd_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CLK_PWRMGT_CNTL_M6 regCLK_PWRMGT_CNTL_M6;

#ifdef DEBUG
__inline void set_CLK_PWRMGT_CNTL_M6_mpll_pwrmgt_off(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int mpll_pwrmgt_off)
{
  reg->bitfields.MPLL_PWRMGT_OFF = mpll_pwrmgt_off;
  if (reg->bitfields.MPLL_PWRMGT_OFF != mpll_pwrmgt_off) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::MPLL_PWRMGT_OFF data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_M6_spll_pwrmgt_off(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int spll_pwrmgt_off)
{
  reg->bitfields.SPLL_PWRMGT_OFF = spll_pwrmgt_off;
  if (reg->bitfields.SPLL_PWRMGT_OFF != spll_pwrmgt_off) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::SPLL_PWRMGT_OFF data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_M6_ppll_pwrmgt_off(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int ppll_pwrmgt_off)
{
  reg->bitfields.PPLL_PWRMGT_OFF = ppll_pwrmgt_off;
  if (reg->bitfields.PPLL_PWRMGT_OFF != ppll_pwrmgt_off) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::PPLL_PWRMGT_OFF data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_M6_p2pll_pwrmgt_off(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int p2pll_pwrmgt_off)
{
  reg->bitfields.P2PLL_PWRMGT_OFF = p2pll_pwrmgt_off;
  if (reg->bitfields.P2PLL_PWRMGT_OFF != p2pll_pwrmgt_off) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::P2PLL_PWRMGT_OFF data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_M6_mclk_turnoff(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int mclk_turnoff)
{
  reg->bitfields.MCLK_TURNOFF = mclk_turnoff;
  if (reg->bitfields.MCLK_TURNOFF != mclk_turnoff) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::MCLK_TURNOFF data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_M6_sclk_turnoff(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int sclk_turnoff)
{
  reg->bitfields.SCLK_TURNOFF = sclk_turnoff;
  if (reg->bitfields.SCLK_TURNOFF != sclk_turnoff) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::SCLK_TURNOFF data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_M6_pclk_turnoff(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int pclk_turnoff)
{
  reg->bitfields.PCLK_TURNOFF = pclk_turnoff;
  if (reg->bitfields.PCLK_TURNOFF != pclk_turnoff) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::PCLK_TURNOFF data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_M6_p2clk_turnoff(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int p2clk_turnoff)
{
  reg->bitfields.P2CLK_TURNOFF = p2clk_turnoff;
  if (reg->bitfields.P2CLK_TURNOFF != p2clk_turnoff) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::P2CLK_TURNOFF data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_M6_mc_ch_mode(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int mc_ch_mode)
{
  reg->bitfields.MC_CH_MODE = mc_ch_mode;
  if (reg->bitfields.MC_CH_MODE != mc_ch_mode) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::MC_CH_MODE data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_M6_test_mode(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int test_mode)
{
  reg->bitfields.TEST_MODE = test_mode;
  if (reg->bitfields.TEST_MODE != test_mode) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::TEST_MODE data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_M6_global_pman_en(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int global_pman_en)
{
  reg->bitfields.GLOBAL_PMAN_EN = global_pman_en;
  if (reg->bitfields.GLOBAL_PMAN_EN != global_pman_en) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::GLOBAL_PMAN_EN data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_M6_engine_dynclk_mode(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int engine_dynclk_mode)
{
  reg->bitfields.ENGINE_DYNCLK_MODE = engine_dynclk_mode;
  if (reg->bitfields.ENGINE_DYNCLK_MODE != engine_dynclk_mode) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::ENGINE_DYNCLK_MODE data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_M6_active_hilo_lat(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int active_hilo_lat)
{
  reg->bitfields.ACTIVE_HILO_LAT = active_hilo_lat;
  if (reg->bitfields.ACTIVE_HILO_LAT != active_hilo_lat) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::ACTIVE_HILO_LAT data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_M6_disp_dyn_stop_lat(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int disp_dyn_stop_lat)
{
  reg->bitfields.DISP_DYN_STOP_LAT = disp_dyn_stop_lat;
  if (reg->bitfields.DISP_DYN_STOP_LAT != disp_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::DISP_DYN_STOP_LAT data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_M6_mc_busy(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int mc_busy)
{
  reg->bitfields.MC_BUSY = mc_busy;
  if (reg->bitfields.MC_BUSY != mc_busy) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::MC_BUSY data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_M6_mc_int_cntl(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int mc_int_cntl)
{
  reg->bitfields.MC_INT_CNTL = mc_int_cntl;
  if (reg->bitfields.MC_INT_CNTL != mc_int_cntl) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::MC_INT_CNTL data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_M6_mc_switch(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int mc_switch)
{
  reg->bitfields.MC_SWITCH = mc_switch;
  if (reg->bitfields.MC_SWITCH != mc_switch) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::MC_SWITCH data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_M6_dll_ready(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int dll_ready)
{
  reg->bitfields.DLL_READY = dll_ready;
  if (reg->bitfields.DLL_READY != dll_ready) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::DLL_READY data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_M6_disp_pm(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int disp_pm)
{
  reg->bitfields.DISP_PM = disp_pm;
  if (reg->bitfields.DISP_PM != disp_pm) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::DISP_PM data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_M6_dyn_stop_mode(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int dyn_stop_mode)
{
  reg->bitfields.DYN_STOP_MODE = dyn_stop_mode;
  if (reg->bitfields.DYN_STOP_MODE != dyn_stop_mode) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::DYN_STOP_MODE data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_M6_cg_no1_debug(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int cg_no1_debug)
{
  reg->bitfields.CG_NO1_DEBUG = cg_no1_debug;
  if (reg->bitfields.CG_NO1_DEBUG != cg_no1_debug) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::CG_NO1_DEBUG data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_M6_tvpll_pwrmgt_off(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int tvpll_pwrmgt_off)
{
  reg->bitfields.TVPLL_PWRMGT_OFF = tvpll_pwrmgt_off;
  if (reg->bitfields.TVPLL_PWRMGT_OFF != tvpll_pwrmgt_off) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::TVPLL_PWRMGT_OFF data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_M6_tvclk_turnoff(regCLK_PWRMGT_CNTL_M6 *reg, unsigned int tvclk_turnoff)
{
  reg->bitfields.TVCLK_TURNOFF = tvclk_turnoff;
  if (reg->bitfields.TVCLK_TURNOFF != tvclk_turnoff) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL_M6::TVCLK_TURNOFF data too large\n");
}
#else
#define set_CLK_PWRMGT_CNTL_M6_mpll_pwrmgt_off(reg, mpll_pwrmgt_off) (reg)->bitfields.MPLL_PWRMGT_OFF = mpll_pwrmgt_off
#define set_CLK_PWRMGT_CNTL_M6_spll_pwrmgt_off(reg, spll_pwrmgt_off) (reg)->bitfields.SPLL_PWRMGT_OFF = spll_pwrmgt_off
#define set_CLK_PWRMGT_CNTL_M6_ppll_pwrmgt_off(reg, ppll_pwrmgt_off) (reg)->bitfields.PPLL_PWRMGT_OFF = ppll_pwrmgt_off
#define set_CLK_PWRMGT_CNTL_M6_p2pll_pwrmgt_off(reg, p2pll_pwrmgt_off) (reg)->bitfields.P2PLL_PWRMGT_OFF = p2pll_pwrmgt_off
#define set_CLK_PWRMGT_CNTL_M6_mclk_turnoff(reg, mclk_turnoff) (reg)->bitfields.MCLK_TURNOFF = mclk_turnoff
#define set_CLK_PWRMGT_CNTL_M6_sclk_turnoff(reg, sclk_turnoff) (reg)->bitfields.SCLK_TURNOFF = sclk_turnoff
#define set_CLK_PWRMGT_CNTL_M6_pclk_turnoff(reg, pclk_turnoff) (reg)->bitfields.PCLK_TURNOFF = pclk_turnoff
#define set_CLK_PWRMGT_CNTL_M6_p2clk_turnoff(reg, p2clk_turnoff) (reg)->bitfields.P2CLK_TURNOFF = p2clk_turnoff
#define set_CLK_PWRMGT_CNTL_M6_mc_ch_mode(reg, mc_ch_mode) (reg)->bitfields.MC_CH_MODE = mc_ch_mode
#define set_CLK_PWRMGT_CNTL_M6_test_mode(reg, test_mode) (reg)->bitfields.TEST_MODE = test_mode
#define set_CLK_PWRMGT_CNTL_M6_global_pman_en(reg, global_pman_en) (reg)->bitfields.GLOBAL_PMAN_EN = global_pman_en
#define set_CLK_PWRMGT_CNTL_M6_engine_dynclk_mode(reg, engine_dynclk_mode) (reg)->bitfields.ENGINE_DYNCLK_MODE = engine_dynclk_mode
#define set_CLK_PWRMGT_CNTL_M6_active_hilo_lat(reg, active_hilo_lat) (reg)->bitfields.ACTIVE_HILO_LAT = active_hilo_lat
#define set_CLK_PWRMGT_CNTL_M6_disp_dyn_stop_lat(reg, disp_dyn_stop_lat) (reg)->bitfields.DISP_DYN_STOP_LAT = disp_dyn_stop_lat
#define set_CLK_PWRMGT_CNTL_M6_mc_busy(reg, mc_busy) (reg)->bitfields.MC_BUSY = mc_busy
#define set_CLK_PWRMGT_CNTL_M6_mc_int_cntl(reg, mc_int_cntl) (reg)->bitfields.MC_INT_CNTL = mc_int_cntl
#define set_CLK_PWRMGT_CNTL_M6_mc_switch(reg, mc_switch) (reg)->bitfields.MC_SWITCH = mc_switch
#define set_CLK_PWRMGT_CNTL_M6_dll_ready(reg, dll_ready) (reg)->bitfields.DLL_READY = dll_ready
#define set_CLK_PWRMGT_CNTL_M6_disp_pm(reg, disp_pm) (reg)->bitfields.DISP_PM = disp_pm
#define set_CLK_PWRMGT_CNTL_M6_dyn_stop_mode(reg, dyn_stop_mode) (reg)->bitfields.DYN_STOP_MODE = dyn_stop_mode
#define set_CLK_PWRMGT_CNTL_M6_cg_no1_debug(reg, cg_no1_debug) (reg)->bitfields.CG_NO1_DEBUG = cg_no1_debug
#define set_CLK_PWRMGT_CNTL_M6_tvpll_pwrmgt_off(reg, tvpll_pwrmgt_off) (reg)->bitfields.TVPLL_PWRMGT_OFF = tvpll_pwrmgt_off
#define set_CLK_PWRMGT_CNTL_M6_tvclk_turnoff(reg, tvclk_turnoff) (reg)->bitfields.TVCLK_TURNOFF = tvclk_turnoff

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250PLL_PWRMGT_CNTL regrv250PLL_PWRMGT_CNTL;

#ifdef DEBUG
__inline void set_rv250PLL_PWRMGT_CNTL_mpll_turnoff(regrv250PLL_PWRMGT_CNTL *reg, unsigned int mpll_turnoff)
{
  reg->bitfields.MPLL_TURNOFF = mpll_turnoff;
  if (reg->bitfields.MPLL_TURNOFF != mpll_turnoff) HSLDPF(E_ERROR_MESSAGE,"rv250PLL_PWRMGT_CNTL::MPLL_TURNOFF data too large\n");
}
__inline void set_rv250PLL_PWRMGT_CNTL_spll_turnoff(regrv250PLL_PWRMGT_CNTL *reg, unsigned int spll_turnoff)
{
  reg->bitfields.SPLL_TURNOFF = spll_turnoff;
  if (reg->bitfields.SPLL_TURNOFF != spll_turnoff) HSLDPF(E_ERROR_MESSAGE,"rv250PLL_PWRMGT_CNTL::SPLL_TURNOFF data too large\n");
}
__inline void set_rv250PLL_PWRMGT_CNTL_ppll_turnoff(regrv250PLL_PWRMGT_CNTL *reg, unsigned int ppll_turnoff)
{
  reg->bitfields.PPLL_TURNOFF = ppll_turnoff;
  if (reg->bitfields.PPLL_TURNOFF != ppll_turnoff) HSLDPF(E_ERROR_MESSAGE,"rv250PLL_PWRMGT_CNTL::PPLL_TURNOFF data too large\n");
}
__inline void set_rv250PLL_PWRMGT_CNTL_p2pll_turnoff(regrv250PLL_PWRMGT_CNTL *reg, unsigned int p2pll_turnoff)
{
  reg->bitfields.P2PLL_TURNOFF = p2pll_turnoff;
  if (reg->bitfields.P2PLL_TURNOFF != p2pll_turnoff) HSLDPF(E_ERROR_MESSAGE,"rv250PLL_PWRMGT_CNTL::P2PLL_TURNOFF data too large\n");
}
__inline void set_rv250PLL_PWRMGT_CNTL_tvpll_turnoff(regrv250PLL_PWRMGT_CNTL *reg, unsigned int tvpll_turnoff)
{
  reg->bitfields.TVPLL_TURNOFF = tvpll_turnoff;
  if (reg->bitfields.TVPLL_TURNOFF != tvpll_turnoff) HSLDPF(E_ERROR_MESSAGE,"rv250PLL_PWRMGT_CNTL::TVPLL_TURNOFF data too large\n");
}
__inline void set_rv250PLL_PWRMGT_CNTL_agpclk_dyn_stop_lat(regrv250PLL_PWRMGT_CNTL *reg, unsigned int agpclk_dyn_stop_lat)
{
  reg->bitfields.AGPCLK_DYN_STOP_LAT = agpclk_dyn_stop_lat;
  if (reg->bitfields.AGPCLK_DYN_STOP_LAT != agpclk_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"rv250PLL_PWRMGT_CNTL::AGPCLK_DYN_STOP_LAT data too large\n");
}
__inline void set_rv250PLL_PWRMGT_CNTL_apm_power_state(regrv250PLL_PWRMGT_CNTL *reg, unsigned int apm_power_state)
{
  reg->bitfields.APM_POWER_STATE = apm_power_state;
  if (reg->bitfields.APM_POWER_STATE != apm_power_state) HSLDPF(E_ERROR_MESSAGE,"rv250PLL_PWRMGT_CNTL::APM_POWER_STATE data too large\n");
}
__inline void set_rv250PLL_PWRMGT_CNTL_apm_pwrstate_rd(regrv250PLL_PWRMGT_CNTL *reg, unsigned int apm_pwrstate_rd)
{
  reg->bitfields.APM_PWRSTATE_RD = apm_pwrstate_rd;
  if (reg->bitfields.APM_PWRSTATE_RD != apm_pwrstate_rd) HSLDPF(E_ERROR_MESSAGE,"rv250PLL_PWRMGT_CNTL::APM_PWRSTATE_RD data too large\n");
}
__inline void set_rv250PLL_PWRMGT_CNTL_pm_mode_sel(regrv250PLL_PWRMGT_CNTL *reg, unsigned int pm_mode_sel)
{
  reg->bitfields.PM_MODE_SEL = pm_mode_sel;
  if (reg->bitfields.PM_MODE_SEL != pm_mode_sel) HSLDPF(E_ERROR_MESSAGE,"rv250PLL_PWRMGT_CNTL::PM_MODE_SEL data too large\n");
}
__inline void set_rv250PLL_PWRMGT_CNTL_en_pwrseq_done_cond(regrv250PLL_PWRMGT_CNTL *reg, unsigned int en_pwrseq_done_cond)
{
  reg->bitfields.EN_PWRSEQ_DONE_COND = en_pwrseq_done_cond;
  if (reg->bitfields.EN_PWRSEQ_DONE_COND != en_pwrseq_done_cond) HSLDPF(E_ERROR_MESSAGE,"rv250PLL_PWRMGT_CNTL::EN_PWRSEQ_DONE_COND data too large\n");
}
__inline void set_rv250PLL_PWRMGT_CNTL_en_disp_parked_cond(regrv250PLL_PWRMGT_CNTL *reg, unsigned int en_disp_parked_cond)
{
  reg->bitfields.EN_DISP_PARKED_COND = en_disp_parked_cond;
  if (reg->bitfields.EN_DISP_PARKED_COND != en_disp_parked_cond) HSLDPF(E_ERROR_MESSAGE,"rv250PLL_PWRMGT_CNTL::EN_DISP_PARKED_COND data too large\n");
}
__inline void set_rv250PLL_PWRMGT_CNTL_mobile_su(regrv250PLL_PWRMGT_CNTL *reg, unsigned int mobile_su)
{
  reg->bitfields.MOBILE_SU = mobile_su;
  if (reg->bitfields.MOBILE_SU != mobile_su) HSLDPF(E_ERROR_MESSAGE,"rv250PLL_PWRMGT_CNTL::MOBILE_SU data too large\n");
}
__inline void set_rv250PLL_PWRMGT_CNTL_su_sclk_use_bclk(regrv250PLL_PWRMGT_CNTL *reg, unsigned int su_sclk_use_bclk)
{
  reg->bitfields.SU_SCLK_USE_BCLK = su_sclk_use_bclk;
  if (reg->bitfields.SU_SCLK_USE_BCLK != su_sclk_use_bclk) HSLDPF(E_ERROR_MESSAGE,"rv250PLL_PWRMGT_CNTL::SU_SCLK_USE_BCLK data too large\n");
}
__inline void set_rv250PLL_PWRMGT_CNTL_su_mclk_use_bclk(regrv250PLL_PWRMGT_CNTL *reg, unsigned int su_mclk_use_bclk)
{
  reg->bitfields.SU_MCLK_USE_BCLK = su_mclk_use_bclk;
  if (reg->bitfields.SU_MCLK_USE_BCLK != su_mclk_use_bclk) HSLDPF(E_ERROR_MESSAGE,"rv250PLL_PWRMGT_CNTL::SU_MCLK_USE_BCLK data too large\n");
}
__inline void set_rv250PLL_PWRMGT_CNTL_su_sustain_disable(regrv250PLL_PWRMGT_CNTL *reg, unsigned int su_sustain_disable)
{
  reg->bitfields.SU_SUSTAIN_DISABLE = su_sustain_disable;
  if (reg->bitfields.SU_SUSTAIN_DISABLE != su_sustain_disable) HSLDPF(E_ERROR_MESSAGE,"rv250PLL_PWRMGT_CNTL::SU_SUSTAIN_DISABLE data too large\n");
}
__inline void set_rv250PLL_PWRMGT_CNTL_tcl_bypass_disable(regrv250PLL_PWRMGT_CNTL *reg, unsigned int tcl_bypass_disable)
{
  reg->bitfields.TCL_BYPASS_DISABLE = tcl_bypass_disable;
  if (reg->bitfields.TCL_BYPASS_DISABLE != tcl_bypass_disable) HSLDPF(E_ERROR_MESSAGE,"rv250PLL_PWRMGT_CNTL::TCL_BYPASS_DISABLE data too large\n");
}
__inline void set_rv250PLL_PWRMGT_CNTL_tcl_clock_active_rd(regrv250PLL_PWRMGT_CNTL *reg, unsigned int tcl_clock_active_rd)
{
  reg->bitfields.TCL_CLOCK_ACTIVE_RD = tcl_clock_active_rd;
  if (reg->bitfields.TCL_CLOCK_ACTIVE_RD != tcl_clock_active_rd) HSLDPF(E_ERROR_MESSAGE,"rv250PLL_PWRMGT_CNTL::TCL_CLOCK_ACTIVE_RD data too large\n");
}
__inline void set_rv250PLL_PWRMGT_CNTL_cg_no2_debug(regrv250PLL_PWRMGT_CNTL *reg, unsigned int cg_no2_debug)
{
  reg->bitfields.CG_NO2_DEBUG = cg_no2_debug;
  if (reg->bitfields.CG_NO2_DEBUG != cg_no2_debug) HSLDPF(E_ERROR_MESSAGE,"rv250PLL_PWRMGT_CNTL::CG_NO2_DEBUG data too large\n");
}
#else
#define set_rv250PLL_PWRMGT_CNTL_mpll_turnoff(reg, mpll_turnoff) (reg)->bitfields.MPLL_TURNOFF = mpll_turnoff
#define set_rv250PLL_PWRMGT_CNTL_spll_turnoff(reg, spll_turnoff) (reg)->bitfields.SPLL_TURNOFF = spll_turnoff
#define set_rv250PLL_PWRMGT_CNTL_ppll_turnoff(reg, ppll_turnoff) (reg)->bitfields.PPLL_TURNOFF = ppll_turnoff
#define set_rv250PLL_PWRMGT_CNTL_p2pll_turnoff(reg, p2pll_turnoff) (reg)->bitfields.P2PLL_TURNOFF = p2pll_turnoff
#define set_rv250PLL_PWRMGT_CNTL_tvpll_turnoff(reg, tvpll_turnoff) (reg)->bitfields.TVPLL_TURNOFF = tvpll_turnoff
#define set_rv250PLL_PWRMGT_CNTL_agpclk_dyn_stop_lat(reg, agpclk_dyn_stop_lat) (reg)->bitfields.AGPCLK_DYN_STOP_LAT = agpclk_dyn_stop_lat
#define set_rv250PLL_PWRMGT_CNTL_apm_power_state(reg, apm_power_state) (reg)->bitfields.APM_POWER_STATE = apm_power_state
#define set_rv250PLL_PWRMGT_CNTL_apm_pwrstate_rd(reg, apm_pwrstate_rd) (reg)->bitfields.APM_PWRSTATE_RD = apm_pwrstate_rd
#define set_rv250PLL_PWRMGT_CNTL_pm_mode_sel(reg, pm_mode_sel) (reg)->bitfields.PM_MODE_SEL = pm_mode_sel
#define set_rv250PLL_PWRMGT_CNTL_en_pwrseq_done_cond(reg, en_pwrseq_done_cond) (reg)->bitfields.EN_PWRSEQ_DONE_COND = en_pwrseq_done_cond
#define set_rv250PLL_PWRMGT_CNTL_en_disp_parked_cond(reg, en_disp_parked_cond) (reg)->bitfields.EN_DISP_PARKED_COND = en_disp_parked_cond
#define set_rv250PLL_PWRMGT_CNTL_mobile_su(reg, mobile_su) (reg)->bitfields.MOBILE_SU = mobile_su
#define set_rv250PLL_PWRMGT_CNTL_su_sclk_use_bclk(reg, su_sclk_use_bclk) (reg)->bitfields.SU_SCLK_USE_BCLK = su_sclk_use_bclk
#define set_rv250PLL_PWRMGT_CNTL_su_mclk_use_bclk(reg, su_mclk_use_bclk) (reg)->bitfields.SU_MCLK_USE_BCLK = su_mclk_use_bclk
#define set_rv250PLL_PWRMGT_CNTL_su_sustain_disable(reg, su_sustain_disable) (reg)->bitfields.SU_SUSTAIN_DISABLE = su_sustain_disable
#define set_rv250PLL_PWRMGT_CNTL_tcl_bypass_disable(reg, tcl_bypass_disable) (reg)->bitfields.TCL_BYPASS_DISABLE = tcl_bypass_disable
#define set_rv250PLL_PWRMGT_CNTL_tcl_clock_active_rd(reg, tcl_clock_active_rd) (reg)->bitfields.TCL_CLOCK_ACTIVE_RD = tcl_clock_active_rd
#define set_rv250PLL_PWRMGT_CNTL_cg_no2_debug(reg, cg_no2_debug) (reg)->bitfields.CG_NO2_DEBUG = cg_no2_debug

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250M_SPLL_REF_FB_DIV regrv250M_SPLL_REF_FB_DIV;

#ifdef DEBUG
__inline void set_rv250M_SPLL_REF_FB_DIV_m_spll_ref_div(regrv250M_SPLL_REF_FB_DIV *reg, unsigned int m_spll_ref_div)
{
  reg->bitfields.M_SPLL_REF_DIV = m_spll_ref_div;
  if (reg->bitfields.M_SPLL_REF_DIV != m_spll_ref_div) HSLDPF(E_ERROR_MESSAGE,"rv250M_SPLL_REF_FB_DIV::M_SPLL_REF_DIV data too large\n");
}
__inline void set_rv250M_SPLL_REF_FB_DIV_mpll_fb_div(regrv250M_SPLL_REF_FB_DIV *reg, unsigned int mpll_fb_div)
{
  reg->bitfields.MPLL_FB_DIV = mpll_fb_div;
  if (reg->bitfields.MPLL_FB_DIV != mpll_fb_div) HSLDPF(E_ERROR_MESSAGE,"rv250M_SPLL_REF_FB_DIV::MPLL_FB_DIV data too large\n");
}
__inline void set_rv250M_SPLL_REF_FB_DIV_spll_fb_div(regrv250M_SPLL_REF_FB_DIV *reg, unsigned int spll_fb_div)
{
  reg->bitfields.SPLL_FB_DIV = spll_fb_div;
  if (reg->bitfields.SPLL_FB_DIV != spll_fb_div) HSLDPF(E_ERROR_MESSAGE,"rv250M_SPLL_REF_FB_DIV::SPLL_FB_DIV data too large\n");
}
__inline void set_rv250M_SPLL_REF_FB_DIV_mpll_ref_src_sel(regrv250M_SPLL_REF_FB_DIV *reg, unsigned int mpll_ref_src_sel)
{
  reg->bitfields.MPLL_REF_SRC_SEL = mpll_ref_src_sel;
  if (reg->bitfields.MPLL_REF_SRC_SEL != mpll_ref_src_sel) HSLDPF(E_ERROR_MESSAGE,"rv250M_SPLL_REF_FB_DIV::MPLL_REF_SRC_SEL data too large\n");
}
#else
#define set_rv250M_SPLL_REF_FB_DIV_m_spll_ref_div(reg, m_spll_ref_div) (reg)->bitfields.M_SPLL_REF_DIV = m_spll_ref_div
#define set_rv250M_SPLL_REF_FB_DIV_mpll_fb_div(reg, mpll_fb_div) (reg)->bitfields.MPLL_FB_DIV = mpll_fb_div
#define set_rv250M_SPLL_REF_FB_DIV_spll_fb_div(reg, spll_fb_div) (reg)->bitfields.SPLL_FB_DIV = spll_fb_div
#define set_rv250M_SPLL_REF_FB_DIV_mpll_ref_src_sel(reg, mpll_ref_src_sel) (reg)->bitfields.MPLL_REF_SRC_SEL = mpll_ref_src_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MPLL_CNTL regMPLL_CNTL;

#ifdef DEBUG
__inline void set_MPLL_CNTL_mpll_reset(regMPLL_CNTL *reg, unsigned int mpll_reset)
{
  reg->bitfields.MPLL_RESET = mpll_reset;
  if (reg->bitfields.MPLL_RESET != mpll_reset) HSLDPF(E_ERROR_MESSAGE,"MPLL_CNTL::MPLL_RESET data too large\n");
}
__inline void set_MPLL_CNTL_mpll_sleep(regMPLL_CNTL *reg, unsigned int mpll_sleep)
{
  reg->bitfields.MPLL_SLEEP = mpll_sleep;
  if (reg->bitfields.MPLL_SLEEP != mpll_sleep) HSLDPF(E_ERROR_MESSAGE,"MPLL_CNTL::MPLL_SLEEP data too large\n");
}
__inline void set_MPLL_CNTL_mpll_tst_en(regMPLL_CNTL *reg, unsigned int mpll_tst_en)
{
  reg->bitfields.MPLL_TST_EN = mpll_tst_en;
  if (reg->bitfields.MPLL_TST_EN != mpll_tst_en) HSLDPF(E_ERROR_MESSAGE,"MPLL_CNTL::MPLL_TST_EN data too large\n");
}
__inline void set_MPLL_CNTL_mpll_refclk_sel(regMPLL_CNTL *reg, unsigned int mpll_refclk_sel)
{
  reg->bitfields.MPLL_REFCLK_SEL = mpll_refclk_sel;
  if (reg->bitfields.MPLL_REFCLK_SEL != mpll_refclk_sel) HSLDPF(E_ERROR_MESSAGE,"MPLL_CNTL::MPLL_REFCLK_SEL data too large\n");
}
__inline void set_MPLL_CNTL_mpll_fbclk_sel(regMPLL_CNTL *reg, unsigned int mpll_fbclk_sel)
{
  reg->bitfields.MPLL_FBCLK_SEL = mpll_fbclk_sel;
  if (reg->bitfields.MPLL_FBCLK_SEL != mpll_fbclk_sel) HSLDPF(E_ERROR_MESSAGE,"MPLL_CNTL::MPLL_FBCLK_SEL data too large\n");
}
__inline void set_MPLL_CNTL_mpll_tcpoff(regMPLL_CNTL *reg, unsigned int mpll_tcpoff)
{
  reg->bitfields.MPLL_TCPOFF = mpll_tcpoff;
  if (reg->bitfields.MPLL_TCPOFF != mpll_tcpoff) HSLDPF(E_ERROR_MESSAGE,"MPLL_CNTL::MPLL_TCPOFF data too large\n");
}
__inline void set_MPLL_CNTL_mpll_tvcomax(regMPLL_CNTL *reg, unsigned int mpll_tvcomax)
{
  reg->bitfields.MPLL_TVCOMAX = mpll_tvcomax;
  if (reg->bitfields.MPLL_TVCOMAX != mpll_tvcomax) HSLDPF(E_ERROR_MESSAGE,"MPLL_CNTL::MPLL_TVCOMAX data too large\n");
}
__inline void set_MPLL_CNTL_mpll_pcp(regMPLL_CNTL *reg, unsigned int mpll_pcp)
{
  reg->bitfields.MPLL_PCP = mpll_pcp;
  if (reg->bitfields.MPLL_PCP != mpll_pcp) HSLDPF(E_ERROR_MESSAGE,"MPLL_CNTL::MPLL_PCP data too large\n");
}
__inline void set_MPLL_CNTL_mpll_pvg(regMPLL_CNTL *reg, unsigned int mpll_pvg)
{
  reg->bitfields.MPLL_PVG = mpll_pvg;
  if (reg->bitfields.MPLL_PVG != mpll_pvg) HSLDPF(E_ERROR_MESSAGE,"MPLL_CNTL::MPLL_PVG data too large\n");
}
__inline void set_MPLL_CNTL_mpll_pdc(regMPLL_CNTL *reg, unsigned int mpll_pdc)
{
  reg->bitfields.MPLL_PDC = mpll_pdc;
  if (reg->bitfields.MPLL_PDC != mpll_pdc) HSLDPF(E_ERROR_MESSAGE,"MPLL_CNTL::MPLL_PDC data too large\n");
}
__inline void set_MPLL_CNTL_mpll_x1_clk_skew(regMPLL_CNTL *reg, unsigned int mpll_x1_clk_skew)
{
  reg->bitfields.MPLL_X1_CLK_SKEW = mpll_x1_clk_skew;
  if (reg->bitfields.MPLL_X1_CLK_SKEW != mpll_x1_clk_skew) HSLDPF(E_ERROR_MESSAGE,"MPLL_CNTL::MPLL_X1_CLK_SKEW data too large\n");
}
__inline void set_MPLL_CNTL_mpll_x2_clk_skew(regMPLL_CNTL *reg, unsigned int mpll_x2_clk_skew)
{
  reg->bitfields.MPLL_X2_CLK_SKEW = mpll_x2_clk_skew;
  if (reg->bitfields.MPLL_X2_CLK_SKEW != mpll_x2_clk_skew) HSLDPF(E_ERROR_MESSAGE,"MPLL_CNTL::MPLL_X2_CLK_SKEW data too large\n");
}
__inline void set_MPLL_CNTL_mpll_mode(regMPLL_CNTL *reg, unsigned int mpll_mode)
{
  reg->bitfields.MPLL_MODE = mpll_mode;
  if (reg->bitfields.MPLL_MODE != mpll_mode) HSLDPF(E_ERROR_MESSAGE,"MPLL_CNTL::MPLL_MODE data too large\n");
}
#else
#define set_MPLL_CNTL_mpll_reset(reg, mpll_reset) (reg)->bitfields.MPLL_RESET = mpll_reset
#define set_MPLL_CNTL_mpll_sleep(reg, mpll_sleep) (reg)->bitfields.MPLL_SLEEP = mpll_sleep
#define set_MPLL_CNTL_mpll_tst_en(reg, mpll_tst_en) (reg)->bitfields.MPLL_TST_EN = mpll_tst_en
#define set_MPLL_CNTL_mpll_refclk_sel(reg, mpll_refclk_sel) (reg)->bitfields.MPLL_REFCLK_SEL = mpll_refclk_sel
#define set_MPLL_CNTL_mpll_fbclk_sel(reg, mpll_fbclk_sel) (reg)->bitfields.MPLL_FBCLK_SEL = mpll_fbclk_sel
#define set_MPLL_CNTL_mpll_tcpoff(reg, mpll_tcpoff) (reg)->bitfields.MPLL_TCPOFF = mpll_tcpoff
#define set_MPLL_CNTL_mpll_tvcomax(reg, mpll_tvcomax) (reg)->bitfields.MPLL_TVCOMAX = mpll_tvcomax
#define set_MPLL_CNTL_mpll_pcp(reg, mpll_pcp) (reg)->bitfields.MPLL_PCP = mpll_pcp
#define set_MPLL_CNTL_mpll_pvg(reg, mpll_pvg) (reg)->bitfields.MPLL_PVG = mpll_pvg
#define set_MPLL_CNTL_mpll_pdc(reg, mpll_pdc) (reg)->bitfields.MPLL_PDC = mpll_pdc
#define set_MPLL_CNTL_mpll_x1_clk_skew(reg, mpll_x1_clk_skew) (reg)->bitfields.MPLL_X1_CLK_SKEW = mpll_x1_clk_skew
#define set_MPLL_CNTL_mpll_x2_clk_skew(reg, mpll_x2_clk_skew) (reg)->bitfields.MPLL_X2_CLK_SKEW = mpll_x2_clk_skew
#define set_MPLL_CNTL_mpll_mode(reg, mpll_mode) (reg)->bitfields.MPLL_MODE = mpll_mode

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250MPLL_AUX_CNTL regrv250MPLL_AUX_CNTL;

#ifdef DEBUG
__inline void set_rv250MPLL_AUX_CNTL_mpll_pdc_c(regrv250MPLL_AUX_CNTL *reg, unsigned int mpll_pdc_c)
{
  reg->bitfields.MPLL_PDC_C = mpll_pdc_c;
  if (reg->bitfields.MPLL_PDC_C != mpll_pdc_c) HSLDPF(E_ERROR_MESSAGE,"rv250MPLL_AUX_CNTL::MPLL_PDC_C data too large\n");
}
__inline void set_rv250MPLL_AUX_CNTL_mpll_ckinva(regrv250MPLL_AUX_CNTL *reg, unsigned int mpll_ckinva)
{
  reg->bitfields.MPLL_CKINVA = mpll_ckinva;
  if (reg->bitfields.MPLL_CKINVA != mpll_ckinva) HSLDPF(E_ERROR_MESSAGE,"rv250MPLL_AUX_CNTL::MPLL_CKINVA data too large\n");
}
__inline void set_rv250MPLL_AUX_CNTL_mpll_ckinvc(regrv250MPLL_AUX_CNTL *reg, unsigned int mpll_ckinvc)
{
  reg->bitfields.MPLL_CKINVC = mpll_ckinvc;
  if (reg->bitfields.MPLL_CKINVC != mpll_ckinvc) HSLDPF(E_ERROR_MESSAGE,"rv250MPLL_AUX_CNTL::MPLL_CKINVC data too large\n");
}
__inline void set_rv250MPLL_AUX_CNTL_mpll_x3_clk_skew(regrv250MPLL_AUX_CNTL *reg, unsigned int mpll_x3_clk_skew)
{
  reg->bitfields.MPLL_X3_CLK_SKEW = mpll_x3_clk_skew;
  if (reg->bitfields.MPLL_X3_CLK_SKEW != mpll_x3_clk_skew) HSLDPF(E_ERROR_MESSAGE,"rv250MPLL_AUX_CNTL::MPLL_X3_CLK_SKEW data too large\n");
}
__inline void set_rv250MPLL_AUX_CNTL_mpll_modec(regrv250MPLL_AUX_CNTL *reg, unsigned int mpll_modec)
{
  reg->bitfields.MPLL_MODEC = mpll_modec;
  if (reg->bitfields.MPLL_MODEC != mpll_modec) HSLDPF(E_ERROR_MESSAGE,"rv250MPLL_AUX_CNTL::MPLL_MODEC data too large\n");
}
__inline void set_rv250MPLL_AUX_CNTL_mpll_test_count(regrv250MPLL_AUX_CNTL *reg, unsigned int mpll_test_count)
{
  reg->bitfields.MPLL_TEST_COUNT = mpll_test_count;
  if (reg->bitfields.MPLL_TEST_COUNT != mpll_test_count) HSLDPF(E_ERROR_MESSAGE,"rv250MPLL_AUX_CNTL::MPLL_TEST_COUNT data too large\n");
}
#else
#define set_rv250MPLL_AUX_CNTL_mpll_pdc_c(reg, mpll_pdc_c) (reg)->bitfields.MPLL_PDC_C = mpll_pdc_c
#define set_rv250MPLL_AUX_CNTL_mpll_ckinva(reg, mpll_ckinva) (reg)->bitfields.MPLL_CKINVA = mpll_ckinva
#define set_rv250MPLL_AUX_CNTL_mpll_ckinvc(reg, mpll_ckinvc) (reg)->bitfields.MPLL_CKINVC = mpll_ckinvc
#define set_rv250MPLL_AUX_CNTL_mpll_x3_clk_skew(reg, mpll_x3_clk_skew) (reg)->bitfields.MPLL_X3_CLK_SKEW = mpll_x3_clk_skew
#define set_rv250MPLL_AUX_CNTL_mpll_modec(reg, mpll_modec) (reg)->bitfields.MPLL_MODEC = mpll_modec
#define set_rv250MPLL_AUX_CNTL_mpll_test_count(reg, mpll_test_count) (reg)->bitfields.MPLL_TEST_COUNT = mpll_test_count

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MDLL_CKO regMDLL_CKO;

#ifdef DEBUG
__inline void set_MDLL_CKO_mckoa_sleep(regMDLL_CKO *reg, unsigned int mckoa_sleep)
{
  reg->bitfields.MCKOA_SLEEP = mckoa_sleep;
  if (reg->bitfields.MCKOA_SLEEP != mckoa_sleep) HSLDPF(E_ERROR_MESSAGE,"MDLL_CKO::MCKOA_SLEEP data too large\n");
}
__inline void set_MDLL_CKO_mckoa_reset(regMDLL_CKO *reg, unsigned int mckoa_reset)
{
  reg->bitfields.MCKOA_RESET = mckoa_reset;
  if (reg->bitfields.MCKOA_RESET != mckoa_reset) HSLDPF(E_ERROR_MESSAGE,"MDLL_CKO::MCKOA_RESET data too large\n");
}
__inline void set_MDLL_CKO_mckoa_range(regMDLL_CKO *reg, unsigned int mckoa_range)
{
  reg->bitfields.MCKOA_RANGE = mckoa_range;
  if (reg->bitfields.MCKOA_RANGE != mckoa_range) HSLDPF(E_ERROR_MESSAGE,"MDLL_CKO::MCKOA_RANGE data too large\n");
}
__inline void set_MDLL_CKO_ersta_soutsel(regMDLL_CKO *reg, unsigned int ersta_soutsel)
{
  reg->bitfields.ERSTA_SOUTSEL = ersta_soutsel;
  if (reg->bitfields.ERSTA_SOUTSEL != ersta_soutsel) HSLDPF(E_ERROR_MESSAGE,"MDLL_CKO::ERSTA_SOUTSEL data too large\n");
}
__inline void set_MDLL_CKO_mckoa_fb_sel(regMDLL_CKO *reg, unsigned int mckoa_fb_sel)
{
  reg->bitfields.MCKOA_FB_SEL = mckoa_fb_sel;
  if (reg->bitfields.MCKOA_FB_SEL != mckoa_fb_sel) HSLDPF(E_ERROR_MESSAGE,"MDLL_CKO::MCKOA_FB_SEL data too large\n");
}
__inline void set_MDLL_CKO_mckoa_ref_skew(regMDLL_CKO *reg, unsigned int mckoa_ref_skew)
{
  reg->bitfields.MCKOA_REF_SKEW = mckoa_ref_skew;
  if (reg->bitfields.MCKOA_REF_SKEW != mckoa_ref_skew) HSLDPF(E_ERROR_MESSAGE,"MDLL_CKO::MCKOA_REF_SKEW data too large\n");
}
__inline void set_MDLL_CKO_mckoa_fb_skew(regMDLL_CKO *reg, unsigned int mckoa_fb_skew)
{
  reg->bitfields.MCKOA_FB_SKEW = mckoa_fb_skew;
  if (reg->bitfields.MCKOA_FB_SKEW != mckoa_fb_skew) HSLDPF(E_ERROR_MESSAGE,"MDLL_CKO::MCKOA_FB_SKEW data too large\n");
}
__inline void set_MDLL_CKO_mckoa_bp_sel(regMDLL_CKO *reg, unsigned int mckoa_bp_sel)
{
  reg->bitfields.MCKOA_BP_SEL = mckoa_bp_sel;
  if (reg->bitfields.MCKOA_BP_SEL != mckoa_bp_sel) HSLDPF(E_ERROR_MESSAGE,"MDLL_CKO::MCKOA_BP_SEL data too large\n");
}
__inline void set_MDLL_CKO_mckob_sleep(regMDLL_CKO *reg, unsigned int mckob_sleep)
{
  reg->bitfields.MCKOB_SLEEP = mckob_sleep;
  if (reg->bitfields.MCKOB_SLEEP != mckob_sleep) HSLDPF(E_ERROR_MESSAGE,"MDLL_CKO::MCKOB_SLEEP data too large\n");
}
__inline void set_MDLL_CKO_mckob_reset(regMDLL_CKO *reg, unsigned int mckob_reset)
{
  reg->bitfields.MCKOB_RESET = mckob_reset;
  if (reg->bitfields.MCKOB_RESET != mckob_reset) HSLDPF(E_ERROR_MESSAGE,"MDLL_CKO::MCKOB_RESET data too large\n");
}
__inline void set_MDLL_CKO_mckob_range(regMDLL_CKO *reg, unsigned int mckob_range)
{
  reg->bitfields.MCKOB_RANGE = mckob_range;
  if (reg->bitfields.MCKOB_RANGE != mckob_range) HSLDPF(E_ERROR_MESSAGE,"MDLL_CKO::MCKOB_RANGE data too large\n");
}
__inline void set_MDLL_CKO_erstb_soutsel(regMDLL_CKO *reg, unsigned int erstb_soutsel)
{
  reg->bitfields.ERSTB_SOUTSEL = erstb_soutsel;
  if (reg->bitfields.ERSTB_SOUTSEL != erstb_soutsel) HSLDPF(E_ERROR_MESSAGE,"MDLL_CKO::ERSTB_SOUTSEL data too large\n");
}
__inline void set_MDLL_CKO_mckob_fb_sel(regMDLL_CKO *reg, unsigned int mckob_fb_sel)
{
  reg->bitfields.MCKOB_FB_SEL = mckob_fb_sel;
  if (reg->bitfields.MCKOB_FB_SEL != mckob_fb_sel) HSLDPF(E_ERROR_MESSAGE,"MDLL_CKO::MCKOB_FB_SEL data too large\n");
}
__inline void set_MDLL_CKO_mckob_ref_skew(regMDLL_CKO *reg, unsigned int mckob_ref_skew)
{
  reg->bitfields.MCKOB_REF_SKEW = mckob_ref_skew;
  if (reg->bitfields.MCKOB_REF_SKEW != mckob_ref_skew) HSLDPF(E_ERROR_MESSAGE,"MDLL_CKO::MCKOB_REF_SKEW data too large\n");
}
__inline void set_MDLL_CKO_mckob_fb_skew(regMDLL_CKO *reg, unsigned int mckob_fb_skew)
{
  reg->bitfields.MCKOB_FB_SKEW = mckob_fb_skew;
  if (reg->bitfields.MCKOB_FB_SKEW != mckob_fb_skew) HSLDPF(E_ERROR_MESSAGE,"MDLL_CKO::MCKOB_FB_SKEW data too large\n");
}
__inline void set_MDLL_CKO_mckob_bp_sel(regMDLL_CKO *reg, unsigned int mckob_bp_sel)
{
  reg->bitfields.MCKOB_BP_SEL = mckob_bp_sel;
  if (reg->bitfields.MCKOB_BP_SEL != mckob_bp_sel) HSLDPF(E_ERROR_MESSAGE,"MDLL_CKO::MCKOB_BP_SEL data too large\n");
}
#else
#define set_MDLL_CKO_mckoa_sleep(reg, mckoa_sleep) (reg)->bitfields.MCKOA_SLEEP = mckoa_sleep
#define set_MDLL_CKO_mckoa_reset(reg, mckoa_reset) (reg)->bitfields.MCKOA_RESET = mckoa_reset
#define set_MDLL_CKO_mckoa_range(reg, mckoa_range) (reg)->bitfields.MCKOA_RANGE = mckoa_range
#define set_MDLL_CKO_ersta_soutsel(reg, ersta_soutsel) (reg)->bitfields.ERSTA_SOUTSEL = ersta_soutsel
#define set_MDLL_CKO_mckoa_fb_sel(reg, mckoa_fb_sel) (reg)->bitfields.MCKOA_FB_SEL = mckoa_fb_sel
#define set_MDLL_CKO_mckoa_ref_skew(reg, mckoa_ref_skew) (reg)->bitfields.MCKOA_REF_SKEW = mckoa_ref_skew
#define set_MDLL_CKO_mckoa_fb_skew(reg, mckoa_fb_skew) (reg)->bitfields.MCKOA_FB_SKEW = mckoa_fb_skew
#define set_MDLL_CKO_mckoa_bp_sel(reg, mckoa_bp_sel) (reg)->bitfields.MCKOA_BP_SEL = mckoa_bp_sel
#define set_MDLL_CKO_mckob_sleep(reg, mckob_sleep) (reg)->bitfields.MCKOB_SLEEP = mckob_sleep
#define set_MDLL_CKO_mckob_reset(reg, mckob_reset) (reg)->bitfields.MCKOB_RESET = mckob_reset
#define set_MDLL_CKO_mckob_range(reg, mckob_range) (reg)->bitfields.MCKOB_RANGE = mckob_range
#define set_MDLL_CKO_erstb_soutsel(reg, erstb_soutsel) (reg)->bitfields.ERSTB_SOUTSEL = erstb_soutsel
#define set_MDLL_CKO_mckob_fb_sel(reg, mckob_fb_sel) (reg)->bitfields.MCKOB_FB_SEL = mckob_fb_sel
#define set_MDLL_CKO_mckob_ref_skew(reg, mckob_ref_skew) (reg)->bitfields.MCKOB_REF_SKEW = mckob_ref_skew
#define set_MDLL_CKO_mckob_fb_skew(reg, mckob_fb_skew) (reg)->bitfields.MCKOB_FB_SKEW = mckob_fb_skew
#define set_MDLL_CKO_mckob_bp_sel(reg, mckob_bp_sel) (reg)->bitfields.MCKOB_BP_SEL = mckob_bp_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MDLL_RDCKA regMDLL_RDCKA;

#ifdef DEBUG
__inline void set_MDLL_RDCKA_mrdcka0_sleep(regMDLL_RDCKA *reg, unsigned int mrdcka0_sleep)
{
  reg->bitfields.MRDCKA0_SLEEP = mrdcka0_sleep;
  if (reg->bitfields.MRDCKA0_SLEEP != mrdcka0_sleep) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKA::MRDCKA0_SLEEP data too large\n");
}
__inline void set_MDLL_RDCKA_mrdcka0_reset(regMDLL_RDCKA *reg, unsigned int mrdcka0_reset)
{
  reg->bitfields.MRDCKA0_RESET = mrdcka0_reset;
  if (reg->bitfields.MRDCKA0_RESET != mrdcka0_reset) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKA::MRDCKA0_RESET data too large\n");
}
__inline void set_MDLL_RDCKA_mrdcka0_range(regMDLL_RDCKA *reg, unsigned int mrdcka0_range)
{
  reg->bitfields.MRDCKA0_RANGE = mrdcka0_range;
  if (reg->bitfields.MRDCKA0_RANGE != mrdcka0_range) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKA::MRDCKA0_RANGE data too large\n");
}
__inline void set_MDLL_RDCKA_mrdcka0_ref_sel(regMDLL_RDCKA *reg, unsigned int mrdcka0_ref_sel)
{
  reg->bitfields.MRDCKA0_REF_SEL = mrdcka0_ref_sel;
  if (reg->bitfields.MRDCKA0_REF_SEL != mrdcka0_ref_sel) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKA::MRDCKA0_REF_SEL data too large\n");
}
__inline void set_MDLL_RDCKA_mrdcka0_fb_sel(regMDLL_RDCKA *reg, unsigned int mrdcka0_fb_sel)
{
  reg->bitfields.MRDCKA0_FB_SEL = mrdcka0_fb_sel;
  if (reg->bitfields.MRDCKA0_FB_SEL != mrdcka0_fb_sel) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKA::MRDCKA0_FB_SEL data too large\n");
}
__inline void set_MDLL_RDCKA_mrdcka0_ref_skew(regMDLL_RDCKA *reg, unsigned int mrdcka0_ref_skew)
{
  reg->bitfields.MRDCKA0_REF_SKEW = mrdcka0_ref_skew;
  if (reg->bitfields.MRDCKA0_REF_SKEW != mrdcka0_ref_skew) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKA::MRDCKA0_REF_SKEW data too large\n");
}
__inline void set_MDLL_RDCKA_mrdcka0_sinsel(regMDLL_RDCKA *reg, unsigned int mrdcka0_sinsel)
{
  reg->bitfields.MRDCKA0_SINSEL = mrdcka0_sinsel;
  if (reg->bitfields.MRDCKA0_SINSEL != mrdcka0_sinsel) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKA::MRDCKA0_SINSEL data too large\n");
}
__inline void set_MDLL_RDCKA_mrdcka0_fb_skew(regMDLL_RDCKA *reg, unsigned int mrdcka0_fb_skew)
{
  reg->bitfields.MRDCKA0_FB_SKEW = mrdcka0_fb_skew;
  if (reg->bitfields.MRDCKA0_FB_SKEW != mrdcka0_fb_skew) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKA::MRDCKA0_FB_SKEW data too large\n");
}
__inline void set_MDLL_RDCKA_mrdcka0_bp_sel(regMDLL_RDCKA *reg, unsigned int mrdcka0_bp_sel)
{
  reg->bitfields.MRDCKA0_BP_SEL = mrdcka0_bp_sel;
  if (reg->bitfields.MRDCKA0_BP_SEL != mrdcka0_bp_sel) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKA::MRDCKA0_BP_SEL data too large\n");
}
__inline void set_MDLL_RDCKA_mrdcka1_sleep(regMDLL_RDCKA *reg, unsigned int mrdcka1_sleep)
{
  reg->bitfields.MRDCKA1_SLEEP = mrdcka1_sleep;
  if (reg->bitfields.MRDCKA1_SLEEP != mrdcka1_sleep) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKA::MRDCKA1_SLEEP data too large\n");
}
__inline void set_MDLL_RDCKA_mrdcka1_reset(regMDLL_RDCKA *reg, unsigned int mrdcka1_reset)
{
  reg->bitfields.MRDCKA1_RESET = mrdcka1_reset;
  if (reg->bitfields.MRDCKA1_RESET != mrdcka1_reset) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKA::MRDCKA1_RESET data too large\n");
}
__inline void set_MDLL_RDCKA_mrdcka1_range(regMDLL_RDCKA *reg, unsigned int mrdcka1_range)
{
  reg->bitfields.MRDCKA1_RANGE = mrdcka1_range;
  if (reg->bitfields.MRDCKA1_RANGE != mrdcka1_range) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKA::MRDCKA1_RANGE data too large\n");
}
__inline void set_MDLL_RDCKA_mrdcka1_ref_sel(regMDLL_RDCKA *reg, unsigned int mrdcka1_ref_sel)
{
  reg->bitfields.MRDCKA1_REF_SEL = mrdcka1_ref_sel;
  if (reg->bitfields.MRDCKA1_REF_SEL != mrdcka1_ref_sel) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKA::MRDCKA1_REF_SEL data too large\n");
}
__inline void set_MDLL_RDCKA_mrdcka1_fb_sel(regMDLL_RDCKA *reg, unsigned int mrdcka1_fb_sel)
{
  reg->bitfields.MRDCKA1_FB_SEL = mrdcka1_fb_sel;
  if (reg->bitfields.MRDCKA1_FB_SEL != mrdcka1_fb_sel) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKA::MRDCKA1_FB_SEL data too large\n");
}
__inline void set_MDLL_RDCKA_mrdcka1_ref_skew(regMDLL_RDCKA *reg, unsigned int mrdcka1_ref_skew)
{
  reg->bitfields.MRDCKA1_REF_SKEW = mrdcka1_ref_skew;
  if (reg->bitfields.MRDCKA1_REF_SKEW != mrdcka1_ref_skew) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKA::MRDCKA1_REF_SKEW data too large\n");
}
__inline void set_MDLL_RDCKA_mrdcka1_sinsel(regMDLL_RDCKA *reg, unsigned int mrdcka1_sinsel)
{
  reg->bitfields.MRDCKA1_SINSEL = mrdcka1_sinsel;
  if (reg->bitfields.MRDCKA1_SINSEL != mrdcka1_sinsel) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKA::MRDCKA1_SINSEL data too large\n");
}
__inline void set_MDLL_RDCKA_mrdcka1_fb_skew(regMDLL_RDCKA *reg, unsigned int mrdcka1_fb_skew)
{
  reg->bitfields.MRDCKA1_FB_SKEW = mrdcka1_fb_skew;
  if (reg->bitfields.MRDCKA1_FB_SKEW != mrdcka1_fb_skew) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKA::MRDCKA1_FB_SKEW data too large\n");
}
__inline void set_MDLL_RDCKA_mrdcka1_bp_sel(regMDLL_RDCKA *reg, unsigned int mrdcka1_bp_sel)
{
  reg->bitfields.MRDCKA1_BP_SEL = mrdcka1_bp_sel;
  if (reg->bitfields.MRDCKA1_BP_SEL != mrdcka1_bp_sel) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKA::MRDCKA1_BP_SEL data too large\n");
}
#else
#define set_MDLL_RDCKA_mrdcka0_sleep(reg, mrdcka0_sleep) (reg)->bitfields.MRDCKA0_SLEEP = mrdcka0_sleep
#define set_MDLL_RDCKA_mrdcka0_reset(reg, mrdcka0_reset) (reg)->bitfields.MRDCKA0_RESET = mrdcka0_reset
#define set_MDLL_RDCKA_mrdcka0_range(reg, mrdcka0_range) (reg)->bitfields.MRDCKA0_RANGE = mrdcka0_range
#define set_MDLL_RDCKA_mrdcka0_ref_sel(reg, mrdcka0_ref_sel) (reg)->bitfields.MRDCKA0_REF_SEL = mrdcka0_ref_sel
#define set_MDLL_RDCKA_mrdcka0_fb_sel(reg, mrdcka0_fb_sel) (reg)->bitfields.MRDCKA0_FB_SEL = mrdcka0_fb_sel
#define set_MDLL_RDCKA_mrdcka0_ref_skew(reg, mrdcka0_ref_skew) (reg)->bitfields.MRDCKA0_REF_SKEW = mrdcka0_ref_skew
#define set_MDLL_RDCKA_mrdcka0_sinsel(reg, mrdcka0_sinsel) (reg)->bitfields.MRDCKA0_SINSEL = mrdcka0_sinsel
#define set_MDLL_RDCKA_mrdcka0_fb_skew(reg, mrdcka0_fb_skew) (reg)->bitfields.MRDCKA0_FB_SKEW = mrdcka0_fb_skew
#define set_MDLL_RDCKA_mrdcka0_bp_sel(reg, mrdcka0_bp_sel) (reg)->bitfields.MRDCKA0_BP_SEL = mrdcka0_bp_sel
#define set_MDLL_RDCKA_mrdcka1_sleep(reg, mrdcka1_sleep) (reg)->bitfields.MRDCKA1_SLEEP = mrdcka1_sleep
#define set_MDLL_RDCKA_mrdcka1_reset(reg, mrdcka1_reset) (reg)->bitfields.MRDCKA1_RESET = mrdcka1_reset
#define set_MDLL_RDCKA_mrdcka1_range(reg, mrdcka1_range) (reg)->bitfields.MRDCKA1_RANGE = mrdcka1_range
#define set_MDLL_RDCKA_mrdcka1_ref_sel(reg, mrdcka1_ref_sel) (reg)->bitfields.MRDCKA1_REF_SEL = mrdcka1_ref_sel
#define set_MDLL_RDCKA_mrdcka1_fb_sel(reg, mrdcka1_fb_sel) (reg)->bitfields.MRDCKA1_FB_SEL = mrdcka1_fb_sel
#define set_MDLL_RDCKA_mrdcka1_ref_skew(reg, mrdcka1_ref_skew) (reg)->bitfields.MRDCKA1_REF_SKEW = mrdcka1_ref_skew
#define set_MDLL_RDCKA_mrdcka1_sinsel(reg, mrdcka1_sinsel) (reg)->bitfields.MRDCKA1_SINSEL = mrdcka1_sinsel
#define set_MDLL_RDCKA_mrdcka1_fb_skew(reg, mrdcka1_fb_skew) (reg)->bitfields.MRDCKA1_FB_SKEW = mrdcka1_fb_skew
#define set_MDLL_RDCKA_mrdcka1_bp_sel(reg, mrdcka1_bp_sel) (reg)->bitfields.MRDCKA1_BP_SEL = mrdcka1_bp_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MDLL_RDCKB regMDLL_RDCKB;

#ifdef DEBUG
__inline void set_MDLL_RDCKB_mrdckb0_sleep(regMDLL_RDCKB *reg, unsigned int mrdckb0_sleep)
{
  reg->bitfields.MRDCKB0_SLEEP = mrdckb0_sleep;
  if (reg->bitfields.MRDCKB0_SLEEP != mrdckb0_sleep) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKB::MRDCKB0_SLEEP data too large\n");
}
__inline void set_MDLL_RDCKB_mrdckb0_reset(regMDLL_RDCKB *reg, unsigned int mrdckb0_reset)
{
  reg->bitfields.MRDCKB0_RESET = mrdckb0_reset;
  if (reg->bitfields.MRDCKB0_RESET != mrdckb0_reset) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKB::MRDCKB0_RESET data too large\n");
}
__inline void set_MDLL_RDCKB_mrdckb0_range(regMDLL_RDCKB *reg, unsigned int mrdckb0_range)
{
  reg->bitfields.MRDCKB0_RANGE = mrdckb0_range;
  if (reg->bitfields.MRDCKB0_RANGE != mrdckb0_range) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKB::MRDCKB0_RANGE data too large\n");
}
__inline void set_MDLL_RDCKB_mrdckb0_ref_sel(regMDLL_RDCKB *reg, unsigned int mrdckb0_ref_sel)
{
  reg->bitfields.MRDCKB0_REF_SEL = mrdckb0_ref_sel;
  if (reg->bitfields.MRDCKB0_REF_SEL != mrdckb0_ref_sel) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKB::MRDCKB0_REF_SEL data too large\n");
}
__inline void set_MDLL_RDCKB_mrdckb0_fb_sel(regMDLL_RDCKB *reg, unsigned int mrdckb0_fb_sel)
{
  reg->bitfields.MRDCKB0_FB_SEL = mrdckb0_fb_sel;
  if (reg->bitfields.MRDCKB0_FB_SEL != mrdckb0_fb_sel) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKB::MRDCKB0_FB_SEL data too large\n");
}
__inline void set_MDLL_RDCKB_mrdckb0_ref_skew(regMDLL_RDCKB *reg, unsigned int mrdckb0_ref_skew)
{
  reg->bitfields.MRDCKB0_REF_SKEW = mrdckb0_ref_skew;
  if (reg->bitfields.MRDCKB0_REF_SKEW != mrdckb0_ref_skew) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKB::MRDCKB0_REF_SKEW data too large\n");
}
__inline void set_MDLL_RDCKB_mrdckb0_sinsel(regMDLL_RDCKB *reg, unsigned int mrdckb0_sinsel)
{
  reg->bitfields.MRDCKB0_SINSEL = mrdckb0_sinsel;
  if (reg->bitfields.MRDCKB0_SINSEL != mrdckb0_sinsel) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKB::MRDCKB0_SINSEL data too large\n");
}
__inline void set_MDLL_RDCKB_mrdckb0_fb_skew(regMDLL_RDCKB *reg, unsigned int mrdckb0_fb_skew)
{
  reg->bitfields.MRDCKB0_FB_SKEW = mrdckb0_fb_skew;
  if (reg->bitfields.MRDCKB0_FB_SKEW != mrdckb0_fb_skew) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKB::MRDCKB0_FB_SKEW data too large\n");
}
__inline void set_MDLL_RDCKB_mrdckb0_bp_sel(regMDLL_RDCKB *reg, unsigned int mrdckb0_bp_sel)
{
  reg->bitfields.MRDCKB0_BP_SEL = mrdckb0_bp_sel;
  if (reg->bitfields.MRDCKB0_BP_SEL != mrdckb0_bp_sel) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKB::MRDCKB0_BP_SEL data too large\n");
}
__inline void set_MDLL_RDCKB_mrdckb1_sleep(regMDLL_RDCKB *reg, unsigned int mrdckb1_sleep)
{
  reg->bitfields.MRDCKB1_SLEEP = mrdckb1_sleep;
  if (reg->bitfields.MRDCKB1_SLEEP != mrdckb1_sleep) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKB::MRDCKB1_SLEEP data too large\n");
}
__inline void set_MDLL_RDCKB_mrdckb1_reset(regMDLL_RDCKB *reg, unsigned int mrdckb1_reset)
{
  reg->bitfields.MRDCKB1_RESET = mrdckb1_reset;
  if (reg->bitfields.MRDCKB1_RESET != mrdckb1_reset) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKB::MRDCKB1_RESET data too large\n");
}
__inline void set_MDLL_RDCKB_mrdckb1_range(regMDLL_RDCKB *reg, unsigned int mrdckb1_range)
{
  reg->bitfields.MRDCKB1_RANGE = mrdckb1_range;
  if (reg->bitfields.MRDCKB1_RANGE != mrdckb1_range) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKB::MRDCKB1_RANGE data too large\n");
}
__inline void set_MDLL_RDCKB_mrdckb1_ref_sel(regMDLL_RDCKB *reg, unsigned int mrdckb1_ref_sel)
{
  reg->bitfields.MRDCKB1_REF_SEL = mrdckb1_ref_sel;
  if (reg->bitfields.MRDCKB1_REF_SEL != mrdckb1_ref_sel) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKB::MRDCKB1_REF_SEL data too large\n");
}
__inline void set_MDLL_RDCKB_mrdckb1_fb_sel(regMDLL_RDCKB *reg, unsigned int mrdckb1_fb_sel)
{
  reg->bitfields.MRDCKB1_FB_SEL = mrdckb1_fb_sel;
  if (reg->bitfields.MRDCKB1_FB_SEL != mrdckb1_fb_sel) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKB::MRDCKB1_FB_SEL data too large\n");
}
__inline void set_MDLL_RDCKB_mrdckb1_ref_skew(regMDLL_RDCKB *reg, unsigned int mrdckb1_ref_skew)
{
  reg->bitfields.MRDCKB1_REF_SKEW = mrdckb1_ref_skew;
  if (reg->bitfields.MRDCKB1_REF_SKEW != mrdckb1_ref_skew) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKB::MRDCKB1_REF_SKEW data too large\n");
}
__inline void set_MDLL_RDCKB_mrdckb1_sinsel(regMDLL_RDCKB *reg, unsigned int mrdckb1_sinsel)
{
  reg->bitfields.MRDCKB1_SINSEL = mrdckb1_sinsel;
  if (reg->bitfields.MRDCKB1_SINSEL != mrdckb1_sinsel) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKB::MRDCKB1_SINSEL data too large\n");
}
__inline void set_MDLL_RDCKB_mrdckb1_fb_skew(regMDLL_RDCKB *reg, unsigned int mrdckb1_fb_skew)
{
  reg->bitfields.MRDCKB1_FB_SKEW = mrdckb1_fb_skew;
  if (reg->bitfields.MRDCKB1_FB_SKEW != mrdckb1_fb_skew) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKB::MRDCKB1_FB_SKEW data too large\n");
}
__inline void set_MDLL_RDCKB_mrdckb1_bp_sel(regMDLL_RDCKB *reg, unsigned int mrdckb1_bp_sel)
{
  reg->bitfields.MRDCKB1_BP_SEL = mrdckb1_bp_sel;
  if (reg->bitfields.MRDCKB1_BP_SEL != mrdckb1_bp_sel) HSLDPF(E_ERROR_MESSAGE,"MDLL_RDCKB::MRDCKB1_BP_SEL data too large\n");
}
#else
#define set_MDLL_RDCKB_mrdckb0_sleep(reg, mrdckb0_sleep) (reg)->bitfields.MRDCKB0_SLEEP = mrdckb0_sleep
#define set_MDLL_RDCKB_mrdckb0_reset(reg, mrdckb0_reset) (reg)->bitfields.MRDCKB0_RESET = mrdckb0_reset
#define set_MDLL_RDCKB_mrdckb0_range(reg, mrdckb0_range) (reg)->bitfields.MRDCKB0_RANGE = mrdckb0_range
#define set_MDLL_RDCKB_mrdckb0_ref_sel(reg, mrdckb0_ref_sel) (reg)->bitfields.MRDCKB0_REF_SEL = mrdckb0_ref_sel
#define set_MDLL_RDCKB_mrdckb0_fb_sel(reg, mrdckb0_fb_sel) (reg)->bitfields.MRDCKB0_FB_SEL = mrdckb0_fb_sel
#define set_MDLL_RDCKB_mrdckb0_ref_skew(reg, mrdckb0_ref_skew) (reg)->bitfields.MRDCKB0_REF_SKEW = mrdckb0_ref_skew
#define set_MDLL_RDCKB_mrdckb0_sinsel(reg, mrdckb0_sinsel) (reg)->bitfields.MRDCKB0_SINSEL = mrdckb0_sinsel
#define set_MDLL_RDCKB_mrdckb0_fb_skew(reg, mrdckb0_fb_skew) (reg)->bitfields.MRDCKB0_FB_SKEW = mrdckb0_fb_skew
#define set_MDLL_RDCKB_mrdckb0_bp_sel(reg, mrdckb0_bp_sel) (reg)->bitfields.MRDCKB0_BP_SEL = mrdckb0_bp_sel
#define set_MDLL_RDCKB_mrdckb1_sleep(reg, mrdckb1_sleep) (reg)->bitfields.MRDCKB1_SLEEP = mrdckb1_sleep
#define set_MDLL_RDCKB_mrdckb1_reset(reg, mrdckb1_reset) (reg)->bitfields.MRDCKB1_RESET = mrdckb1_reset
#define set_MDLL_RDCKB_mrdckb1_range(reg, mrdckb1_range) (reg)->bitfields.MRDCKB1_RANGE = mrdckb1_range
#define set_MDLL_RDCKB_mrdckb1_ref_sel(reg, mrdckb1_ref_sel) (reg)->bitfields.MRDCKB1_REF_SEL = mrdckb1_ref_sel
#define set_MDLL_RDCKB_mrdckb1_fb_sel(reg, mrdckb1_fb_sel) (reg)->bitfields.MRDCKB1_FB_SEL = mrdckb1_fb_sel
#define set_MDLL_RDCKB_mrdckb1_ref_skew(reg, mrdckb1_ref_skew) (reg)->bitfields.MRDCKB1_REF_SKEW = mrdckb1_ref_skew
#define set_MDLL_RDCKB_mrdckb1_sinsel(reg, mrdckb1_sinsel) (reg)->bitfields.MRDCKB1_SINSEL = mrdckb1_sinsel
#define set_MDLL_RDCKB_mrdckb1_fb_skew(reg, mrdckb1_fb_skew) (reg)->bitfields.MRDCKB1_FB_SKEW = mrdckb1_fb_skew
#define set_MDLL_RDCKB_mrdckb1_bp_sel(reg, mrdckb1_bp_sel) (reg)->bitfields.MRDCKB1_BP_SEL = mrdckb1_bp_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MCLK_CNTL_M6 regMCLK_CNTL_M6;

#ifdef DEBUG
__inline void set_MCLK_CNTL_M6_mclka_src_sel(regMCLK_CNTL_M6 *reg, unsigned int mclka_src_sel)
{
  reg->bitfields.MCLKA_SRC_SEL = mclka_src_sel;
  if (reg->bitfields.MCLKA_SRC_SEL != mclka_src_sel) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL_M6::MCLKA_SRC_SEL data too large\n");
}
__inline void set_MCLK_CNTL_M6_yclka_src_sel(regMCLK_CNTL_M6 *reg, unsigned int yclka_src_sel)
{
  reg->bitfields.YCLKA_SRC_SEL = yclka_src_sel;
  if (reg->bitfields.YCLKA_SRC_SEL != yclka_src_sel) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL_M6::YCLKA_SRC_SEL data too large\n");
}
__inline void set_MCLK_CNTL_M6_mclkb_src_sel(regMCLK_CNTL_M6 *reg, unsigned int mclkb_src_sel)
{
  reg->bitfields.MCLKB_SRC_SEL = mclkb_src_sel;
  if (reg->bitfields.MCLKB_SRC_SEL != mclkb_src_sel) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL_M6::MCLKB_SRC_SEL data too large\n");
}
__inline void set_MCLK_CNTL_M6_yclkb_src_sel(regMCLK_CNTL_M6 *reg, unsigned int yclkb_src_sel)
{
  reg->bitfields.YCLKB_SRC_SEL = yclkb_src_sel;
  if (reg->bitfields.YCLKB_SRC_SEL != yclkb_src_sel) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL_M6::YCLKB_SRC_SEL data too large\n");
}
__inline void set_MCLK_CNTL_M6_force_mclka(regMCLK_CNTL_M6 *reg, unsigned int force_mclka)
{
  reg->bitfields.FORCE_MCLKA = force_mclka;
  if (reg->bitfields.FORCE_MCLKA != force_mclka) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL_M6::FORCE_MCLKA data too large\n");
}
__inline void set_MCLK_CNTL_M6_force_mclkb(regMCLK_CNTL_M6 *reg, unsigned int force_mclkb)
{
  reg->bitfields.FORCE_MCLKB = force_mclkb;
  if (reg->bitfields.FORCE_MCLKB != force_mclkb) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL_M6::FORCE_MCLKB data too large\n");
}
__inline void set_MCLK_CNTL_M6_force_yclka(regMCLK_CNTL_M6 *reg, unsigned int force_yclka)
{
  reg->bitfields.FORCE_YCLKA = force_yclka;
  if (reg->bitfields.FORCE_YCLKA != force_yclka) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL_M6::FORCE_YCLKA data too large\n");
}
__inline void set_MCLK_CNTL_M6_force_yclkb(regMCLK_CNTL_M6 *reg, unsigned int force_yclkb)
{
  reg->bitfields.FORCE_YCLKB = force_yclkb;
  if (reg->bitfields.FORCE_YCLKB != force_yclkb) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL_M6::FORCE_YCLKB data too large\n");
}
__inline void set_MCLK_CNTL_M6_force_mc(regMCLK_CNTL_M6 *reg, unsigned int force_mc)
{
  reg->bitfields.FORCE_MC = force_mc;
  if (reg->bitfields.FORCE_MC != force_mc) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL_M6::FORCE_MC data too large\n");
}
__inline void set_MCLK_CNTL_M6_force_aic(regMCLK_CNTL_M6 *reg, unsigned int force_aic)
{
  reg->bitfields.FORCE_AIC = force_aic;
  if (reg->bitfields.FORCE_AIC != force_aic) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL_M6::FORCE_AIC data too large\n");
}
__inline void set_MCLK_CNTL_M6_mrdcka0_soutsel(regMCLK_CNTL_M6 *reg, unsigned int mrdcka0_soutsel)
{
  reg->bitfields.MRDCKA0_SOUTSEL = mrdcka0_soutsel;
  if (reg->bitfields.MRDCKA0_SOUTSEL != mrdcka0_soutsel) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL_M6::MRDCKA0_SOUTSEL data too large\n");
}
__inline void set_MCLK_CNTL_M6_mrdcka1_soutsel(regMCLK_CNTL_M6 *reg, unsigned int mrdcka1_soutsel)
{
  reg->bitfields.MRDCKA1_SOUTSEL = mrdcka1_soutsel;
  if (reg->bitfields.MRDCKA1_SOUTSEL != mrdcka1_soutsel) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL_M6::MRDCKA1_SOUTSEL data too large\n");
}
__inline void set_MCLK_CNTL_M6_mrdckb0_soutsel(regMCLK_CNTL_M6 *reg, unsigned int mrdckb0_soutsel)
{
  reg->bitfields.MRDCKB0_SOUTSEL = mrdckb0_soutsel;
  if (reg->bitfields.MRDCKB0_SOUTSEL != mrdckb0_soutsel) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL_M6::MRDCKB0_SOUTSEL data too large\n");
}
__inline void set_MCLK_CNTL_M6_mrdckb1_soutsel(regMCLK_CNTL_M6 *reg, unsigned int mrdckb1_soutsel)
{
  reg->bitfields.MRDCKB1_SOUTSEL = mrdckb1_soutsel;
  if (reg->bitfields.MRDCKB1_SOUTSEL != mrdckb1_soutsel) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL_M6::MRDCKB1_SOUTSEL data too large\n");
}
#else
#define set_MCLK_CNTL_M6_mclka_src_sel(reg, mclka_src_sel) (reg)->bitfields.MCLKA_SRC_SEL = mclka_src_sel
#define set_MCLK_CNTL_M6_yclka_src_sel(reg, yclka_src_sel) (reg)->bitfields.YCLKA_SRC_SEL = yclka_src_sel
#define set_MCLK_CNTL_M6_mclkb_src_sel(reg, mclkb_src_sel) (reg)->bitfields.MCLKB_SRC_SEL = mclkb_src_sel
#define set_MCLK_CNTL_M6_yclkb_src_sel(reg, yclkb_src_sel) (reg)->bitfields.YCLKB_SRC_SEL = yclkb_src_sel
#define set_MCLK_CNTL_M6_force_mclka(reg, force_mclka) (reg)->bitfields.FORCE_MCLKA = force_mclka
#define set_MCLK_CNTL_M6_force_mclkb(reg, force_mclkb) (reg)->bitfields.FORCE_MCLKB = force_mclkb
#define set_MCLK_CNTL_M6_force_yclka(reg, force_yclka) (reg)->bitfields.FORCE_YCLKA = force_yclka
#define set_MCLK_CNTL_M6_force_yclkb(reg, force_yclkb) (reg)->bitfields.FORCE_YCLKB = force_yclkb
#define set_MCLK_CNTL_M6_force_mc(reg, force_mc) (reg)->bitfields.FORCE_MC = force_mc
#define set_MCLK_CNTL_M6_force_aic(reg, force_aic) (reg)->bitfields.FORCE_AIC = force_aic
#define set_MCLK_CNTL_M6_mrdcka0_soutsel(reg, mrdcka0_soutsel) (reg)->bitfields.MRDCKA0_SOUTSEL = mrdcka0_soutsel
#define set_MCLK_CNTL_M6_mrdcka1_soutsel(reg, mrdcka1_soutsel) (reg)->bitfields.MRDCKA1_SOUTSEL = mrdcka1_soutsel
#define set_MCLK_CNTL_M6_mrdckb0_soutsel(reg, mrdckb0_soutsel) (reg)->bitfields.MRDCKB0_SOUTSEL = mrdckb0_soutsel
#define set_MCLK_CNTL_M6_mrdckb1_soutsel(reg, mrdckb1_soutsel) (reg)->bitfields.MRDCKB1_SOUTSEL = mrdckb1_soutsel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250MCLK_MISC regrv250MCLK_MISC;

#ifdef DEBUG
__inline void set_rv250MCLK_MISC_sclk_sourced_from_mpll_sel(regrv250MCLK_MISC *reg, unsigned int sclk_sourced_from_mpll_sel)
{
  reg->bitfields.SCLK_SOURCED_FROM_MPLL_SEL = sclk_sourced_from_mpll_sel;
  if (reg->bitfields.SCLK_SOURCED_FROM_MPLL_SEL != sclk_sourced_from_mpll_sel) HSLDPF(E_ERROR_MESSAGE,"rv250MCLK_MISC::SCLK_SOURCED_FROM_MPLL_SEL data too large\n");
}
__inline void set_rv250MCLK_MISC_mclk_from_spll_div_sel(regrv250MCLK_MISC *reg, unsigned int mclk_from_spll_div_sel)
{
  reg->bitfields.MCLK_FROM_SPLL_DIV_SEL = mclk_from_spll_div_sel;
  if (reg->bitfields.MCLK_FROM_SPLL_DIV_SEL != mclk_from_spll_div_sel) HSLDPF(E_ERROR_MESSAGE,"rv250MCLK_MISC::MCLK_FROM_SPLL_DIV_SEL data too large\n");
}
__inline void set_rv250MCLK_MISC_enable_sclk_from_mpll(regrv250MCLK_MISC *reg, unsigned int enable_sclk_from_mpll)
{
  reg->bitfields.ENABLE_SCLK_FROM_MPLL = enable_sclk_from_mpll;
  if (reg->bitfields.ENABLE_SCLK_FROM_MPLL != enable_sclk_from_mpll) HSLDPF(E_ERROR_MESSAGE,"rv250MCLK_MISC::ENABLE_SCLK_FROM_MPLL data too large\n");
}
__inline void set_rv250MCLK_MISC_mpll_modea_modec_hw_sel_en(regrv250MCLK_MISC *reg, unsigned int mpll_modea_modec_hw_sel_en)
{
  reg->bitfields.MPLL_MODEA_MODEC_HW_SEL_EN = mpll_modea_modec_hw_sel_en;
  if (reg->bitfields.MPLL_MODEA_MODEC_HW_SEL_EN != mpll_modea_modec_hw_sel_en) HSLDPF(E_ERROR_MESSAGE,"rv250MCLK_MISC::MPLL_MODEA_MODEC_HW_SEL_EN data too large\n");
}
__inline void set_rv250MCLK_MISC_dll_ready_lat(regrv250MCLK_MISC *reg, unsigned int dll_ready_lat)
{
  reg->bitfields.DLL_READY_LAT = dll_ready_lat;
  if (reg->bitfields.DLL_READY_LAT != dll_ready_lat) HSLDPF(E_ERROR_MESSAGE,"rv250MCLK_MISC::DLL_READY_LAT data too large\n");
}
__inline void set_rv250MCLK_MISC_mc_mclk_max_dyn_stop_lat(regrv250MCLK_MISC *reg, unsigned int mc_mclk_max_dyn_stop_lat)
{
  reg->bitfields.MC_MCLK_MAX_DYN_STOP_LAT = mc_mclk_max_dyn_stop_lat;
  if (reg->bitfields.MC_MCLK_MAX_DYN_STOP_LAT != mc_mclk_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"rv250MCLK_MISC::MC_MCLK_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_rv250MCLK_MISC_io_mclk_max_dyn_stop_lat(regrv250MCLK_MISC *reg, unsigned int io_mclk_max_dyn_stop_lat)
{
  reg->bitfields.IO_MCLK_MAX_DYN_STOP_LAT = io_mclk_max_dyn_stop_lat;
  if (reg->bitfields.IO_MCLK_MAX_DYN_STOP_LAT != io_mclk_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"rv250MCLK_MISC::IO_MCLK_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_rv250MCLK_MISC_mc_mclk_dyn_enable(regrv250MCLK_MISC *reg, unsigned int mc_mclk_dyn_enable)
{
  reg->bitfields.MC_MCLK_DYN_ENABLE = mc_mclk_dyn_enable;
  if (reg->bitfields.MC_MCLK_DYN_ENABLE != mc_mclk_dyn_enable) HSLDPF(E_ERROR_MESSAGE,"rv250MCLK_MISC::MC_MCLK_DYN_ENABLE data too large\n");
}
__inline void set_rv250MCLK_MISC_io_mclk_dyn_enable(regrv250MCLK_MISC *reg, unsigned int io_mclk_dyn_enable)
{
  reg->bitfields.IO_MCLK_DYN_ENABLE = io_mclk_dyn_enable;
  if (reg->bitfields.IO_MCLK_DYN_ENABLE != io_mclk_dyn_enable) HSLDPF(E_ERROR_MESSAGE,"rv250MCLK_MISC::IO_MCLK_DYN_ENABLE data too large\n");
}
__inline void set_rv250MCLK_MISC_cgm_clk_to_outpin(regrv250MCLK_MISC *reg, unsigned int cgm_clk_to_outpin)
{
  reg->bitfields.CGM_CLK_TO_OUTPIN = cgm_clk_to_outpin;
  if (reg->bitfields.CGM_CLK_TO_OUTPIN != cgm_clk_to_outpin) HSLDPF(E_ERROR_MESSAGE,"rv250MCLK_MISC::CGM_CLK_TO_OUTPIN data too large\n");
}
__inline void set_rv250MCLK_MISC_clk_or_count_sel(regrv250MCLK_MISC *reg, unsigned int clk_or_count_sel)
{
  reg->bitfields.CLK_OR_COUNT_SEL = clk_or_count_sel;
  if (reg->bitfields.CLK_OR_COUNT_SEL != clk_or_count_sel) HSLDPF(E_ERROR_MESSAGE,"rv250MCLK_MISC::CLK_OR_COUNT_SEL data too large\n");
}
__inline void set_rv250MCLK_MISC_en_mclk_tristate_in_suspend(regrv250MCLK_MISC *reg, unsigned int en_mclk_tristate_in_suspend)
{
  reg->bitfields.EN_MCLK_TRISTATE_IN_SUSPEND = en_mclk_tristate_in_suspend;
  if (reg->bitfields.EN_MCLK_TRISTATE_IN_SUSPEND != en_mclk_tristate_in_suspend) HSLDPF(E_ERROR_MESSAGE,"rv250MCLK_MISC::EN_MCLK_TRISTATE_IN_SUSPEND data too large\n");
}
__inline void set_rv250MCLK_MISC_cgm_spare_rd(regrv250MCLK_MISC *reg, unsigned int cgm_spare_rd)
{
  reg->bitfields.CGM_SPARE_RD = cgm_spare_rd;
  if (reg->bitfields.CGM_SPARE_RD != cgm_spare_rd) HSLDPF(E_ERROR_MESSAGE,"rv250MCLK_MISC::CGM_SPARE_RD data too large\n");
}
__inline void set_rv250MCLK_MISC_cgm_spare_a_rd(regrv250MCLK_MISC *reg, unsigned int cgm_spare_a_rd)
{
  reg->bitfields.CGM_SPARE_A_RD = cgm_spare_a_rd;
  if (reg->bitfields.CGM_SPARE_A_RD != cgm_spare_a_rd) HSLDPF(E_ERROR_MESSAGE,"rv250MCLK_MISC::CGM_SPARE_A_RD data too large\n");
}
__inline void set_rv250MCLK_MISC_tclk_to_yclkb_en(regrv250MCLK_MISC *reg, unsigned int tclk_to_yclkb_en)
{
  reg->bitfields.TCLK_TO_YCLKB_EN = tclk_to_yclkb_en;
  if (reg->bitfields.TCLK_TO_YCLKB_EN != tclk_to_yclkb_en) HSLDPF(E_ERROR_MESSAGE,"rv250MCLK_MISC::TCLK_TO_YCLKB_EN data too large\n");
}
__inline void set_rv250MCLK_MISC_cgm_spare_a(regrv250MCLK_MISC *reg, unsigned int cgm_spare_a)
{
  reg->bitfields.CGM_SPARE_A = cgm_spare_a;
  if (reg->bitfields.CGM_SPARE_A != cgm_spare_a) HSLDPF(E_ERROR_MESSAGE,"rv250MCLK_MISC::CGM_SPARE_A data too large\n");
}
#else
#define set_rv250MCLK_MISC_sclk_sourced_from_mpll_sel(reg, sclk_sourced_from_mpll_sel) (reg)->bitfields.SCLK_SOURCED_FROM_MPLL_SEL = sclk_sourced_from_mpll_sel
#define set_rv250MCLK_MISC_mclk_from_spll_div_sel(reg, mclk_from_spll_div_sel) (reg)->bitfields.MCLK_FROM_SPLL_DIV_SEL = mclk_from_spll_div_sel
#define set_rv250MCLK_MISC_enable_sclk_from_mpll(reg, enable_sclk_from_mpll) (reg)->bitfields.ENABLE_SCLK_FROM_MPLL = enable_sclk_from_mpll
#define set_rv250MCLK_MISC_mpll_modea_modec_hw_sel_en(reg, mpll_modea_modec_hw_sel_en) (reg)->bitfields.MPLL_MODEA_MODEC_HW_SEL_EN = mpll_modea_modec_hw_sel_en
#define set_rv250MCLK_MISC_dll_ready_lat(reg, dll_ready_lat) (reg)->bitfields.DLL_READY_LAT = dll_ready_lat
#define set_rv250MCLK_MISC_mc_mclk_max_dyn_stop_lat(reg, mc_mclk_max_dyn_stop_lat) (reg)->bitfields.MC_MCLK_MAX_DYN_STOP_LAT = mc_mclk_max_dyn_stop_lat
#define set_rv250MCLK_MISC_io_mclk_max_dyn_stop_lat(reg, io_mclk_max_dyn_stop_lat) (reg)->bitfields.IO_MCLK_MAX_DYN_STOP_LAT = io_mclk_max_dyn_stop_lat
#define set_rv250MCLK_MISC_mc_mclk_dyn_enable(reg, mc_mclk_dyn_enable) (reg)->bitfields.MC_MCLK_DYN_ENABLE = mc_mclk_dyn_enable
#define set_rv250MCLK_MISC_io_mclk_dyn_enable(reg, io_mclk_dyn_enable) (reg)->bitfields.IO_MCLK_DYN_ENABLE = io_mclk_dyn_enable
#define set_rv250MCLK_MISC_cgm_clk_to_outpin(reg, cgm_clk_to_outpin) (reg)->bitfields.CGM_CLK_TO_OUTPIN = cgm_clk_to_outpin
#define set_rv250MCLK_MISC_clk_or_count_sel(reg, clk_or_count_sel) (reg)->bitfields.CLK_OR_COUNT_SEL = clk_or_count_sel
#define set_rv250MCLK_MISC_en_mclk_tristate_in_suspend(reg, en_mclk_tristate_in_suspend) (reg)->bitfields.EN_MCLK_TRISTATE_IN_SUSPEND = en_mclk_tristate_in_suspend
#define set_rv250MCLK_MISC_cgm_spare_rd(reg, cgm_spare_rd) (reg)->bitfields.CGM_SPARE_RD = cgm_spare_rd
#define set_rv250MCLK_MISC_cgm_spare_a_rd(reg, cgm_spare_a_rd) (reg)->bitfields.CGM_SPARE_A_RD = cgm_spare_a_rd
#define set_rv250MCLK_MISC_tclk_to_yclkb_en(reg, tclk_to_yclkb_en) (reg)->bitfields.TCLK_TO_YCLKB_EN = tclk_to_yclkb_en
#define set_rv250MCLK_MISC_cgm_spare_a(reg, cgm_spare_a) (reg)->bitfields.CGM_SPARE_A = cgm_spare_a

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CG_TEST_MACRO_RW_WRITE regCG_TEST_MACRO_RW_WRITE;

#ifdef DEBUG
__inline void set_CG_TEST_MACRO_RW_WRITE_test_macro_rw_write1(regCG_TEST_MACRO_RW_WRITE *reg, unsigned int test_macro_rw_write1)
{
  reg->bitfields.TEST_MACRO_RW_WRITE1 = test_macro_rw_write1;
  if (reg->bitfields.TEST_MACRO_RW_WRITE1 != test_macro_rw_write1) HSLDPF(E_ERROR_MESSAGE,"CG_TEST_MACRO_RW_WRITE::TEST_MACRO_RW_WRITE1 data too large\n");
}
__inline void set_CG_TEST_MACRO_RW_WRITE_test_macro_rw_write2(regCG_TEST_MACRO_RW_WRITE *reg, unsigned int test_macro_rw_write2)
{
  reg->bitfields.TEST_MACRO_RW_WRITE2 = test_macro_rw_write2;
  if (reg->bitfields.TEST_MACRO_RW_WRITE2 != test_macro_rw_write2) HSLDPF(E_ERROR_MESSAGE,"CG_TEST_MACRO_RW_WRITE::TEST_MACRO_RW_WRITE2 data too large\n");
}
#else
#define set_CG_TEST_MACRO_RW_WRITE_test_macro_rw_write1(reg, test_macro_rw_write1) (reg)->bitfields.TEST_MACRO_RW_WRITE1 = test_macro_rw_write1
#define set_CG_TEST_MACRO_RW_WRITE_test_macro_rw_write2(reg, test_macro_rw_write2) (reg)->bitfields.TEST_MACRO_RW_WRITE2 = test_macro_rw_write2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CG_TEST_MACRO_RW_READ regCG_TEST_MACRO_RW_READ;

#ifdef DEBUG
__inline void set_CG_TEST_MACRO_RW_READ_test_macro_rw_read1(regCG_TEST_MACRO_RW_READ *reg, unsigned int test_macro_rw_read1)
{
  reg->bitfields.TEST_MACRO_RW_READ1 = test_macro_rw_read1;
  if (reg->bitfields.TEST_MACRO_RW_READ1 != test_macro_rw_read1) HSLDPF(E_ERROR_MESSAGE,"CG_TEST_MACRO_RW_READ::TEST_MACRO_RW_READ1 data too large\n");
}
__inline void set_CG_TEST_MACRO_RW_READ_test_macro_rw_read2(regCG_TEST_MACRO_RW_READ *reg, unsigned int test_macro_rw_read2)
{
  reg->bitfields.TEST_MACRO_RW_READ2 = test_macro_rw_read2;
  if (reg->bitfields.TEST_MACRO_RW_READ2 != test_macro_rw_read2) HSLDPF(E_ERROR_MESSAGE,"CG_TEST_MACRO_RW_READ::TEST_MACRO_RW_READ2 data too large\n");
}
#else
#define set_CG_TEST_MACRO_RW_READ_test_macro_rw_read1(reg, test_macro_rw_read1) (reg)->bitfields.TEST_MACRO_RW_READ1 = test_macro_rw_read1
#define set_CG_TEST_MACRO_RW_READ_test_macro_rw_read2(reg, test_macro_rw_read2) (reg)->bitfields.TEST_MACRO_RW_READ2 = test_macro_rw_read2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CG_TEST_MACRO_RW_DATA regCG_TEST_MACRO_RW_DATA;

#ifdef DEBUG
__inline void set_CG_TEST_MACRO_RW_DATA_test_macro_rw_data(regCG_TEST_MACRO_RW_DATA *reg, unsigned int test_macro_rw_data)
{
  reg->bitfields.TEST_MACRO_RW_DATA = test_macro_rw_data;
  if (reg->bitfields.TEST_MACRO_RW_DATA != test_macro_rw_data) HSLDPF(E_ERROR_MESSAGE,"CG_TEST_MACRO_RW_DATA::TEST_MACRO_RW_DATA data too large\n");
}
#else
#define set_CG_TEST_MACRO_RW_DATA_test_macro_rw_data(reg, test_macro_rw_data) (reg)->bitfields.TEST_MACRO_RW_DATA = test_macro_rw_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CG_TEST_MACRO_RW_CNTL regCG_TEST_MACRO_RW_CNTL;

#ifdef DEBUG
__inline void set_CG_TEST_MACRO_RW_CNTL_test_macro_rw_start(regCG_TEST_MACRO_RW_CNTL *reg, unsigned int test_macro_rw_start)
{
  reg->bitfields.TEST_MACRO_RW_START = test_macro_rw_start;
  if (reg->bitfields.TEST_MACRO_RW_START != test_macro_rw_start) HSLDPF(E_ERROR_MESSAGE,"CG_TEST_MACRO_RW_CNTL::TEST_MACRO_RW_START data too large\n");
}
__inline void set_CG_TEST_MACRO_RW_CNTL_test_macro_rw_op(regCG_TEST_MACRO_RW_CNTL *reg, unsigned int test_macro_rw_op)
{
  reg->bitfields.TEST_MACRO_RW_OP = test_macro_rw_op;
  if (reg->bitfields.TEST_MACRO_RW_OP != test_macro_rw_op) HSLDPF(E_ERROR_MESSAGE,"CG_TEST_MACRO_RW_CNTL::TEST_MACRO_RW_OP data too large\n");
}
__inline void set_CG_TEST_MACRO_RW_CNTL_test_macro_rw_mode(regCG_TEST_MACRO_RW_CNTL *reg, unsigned int test_macro_rw_mode)
{
  reg->bitfields.TEST_MACRO_RW_MODE = test_macro_rw_mode;
  if (reg->bitfields.TEST_MACRO_RW_MODE != test_macro_rw_mode) HSLDPF(E_ERROR_MESSAGE,"CG_TEST_MACRO_RW_CNTL::TEST_MACRO_RW_MODE data too large\n");
}
__inline void set_CG_TEST_MACRO_RW_CNTL_test_macro_rw_mismatch_sel(regCG_TEST_MACRO_RW_CNTL *reg, unsigned int test_macro_rw_mismatch_sel)
{
  reg->bitfields.TEST_MACRO_RW_MISMATCH_SEL = test_macro_rw_mismatch_sel;
  if (reg->bitfields.TEST_MACRO_RW_MISMATCH_SEL != test_macro_rw_mismatch_sel) HSLDPF(E_ERROR_MESSAGE,"CG_TEST_MACRO_RW_CNTL::TEST_MACRO_RW_MISMATCH_SEL data too large\n");
}
__inline void set_CG_TEST_MACRO_RW_CNTL_test_macro_rw_mismatch(regCG_TEST_MACRO_RW_CNTL *reg, unsigned int test_macro_rw_mismatch)
{
  reg->bitfields.TEST_MACRO_RW_MISMATCH = test_macro_rw_mismatch;
  if (reg->bitfields.TEST_MACRO_RW_MISMATCH != test_macro_rw_mismatch) HSLDPF(E_ERROR_MESSAGE,"CG_TEST_MACRO_RW_CNTL::TEST_MACRO_RW_MISMATCH data too large\n");
}
__inline void set_CG_TEST_MACRO_RW_CNTL_test_macro_rw_enable(regCG_TEST_MACRO_RW_CNTL *reg, unsigned int test_macro_rw_enable)
{
  reg->bitfields.TEST_MACRO_RW_ENABLE = test_macro_rw_enable;
  if (reg->bitfields.TEST_MACRO_RW_ENABLE != test_macro_rw_enable) HSLDPF(E_ERROR_MESSAGE,"CG_TEST_MACRO_RW_CNTL::TEST_MACRO_RW_ENABLE data too large\n");
}
__inline void set_CG_TEST_MACRO_RW_CNTL_test_macro_rw_sclk_neg_enable(regCG_TEST_MACRO_RW_CNTL *reg, unsigned int test_macro_rw_sclk_neg_enable)
{
  reg->bitfields.TEST_MACRO_RW_SCLK_NEG_ENABLE = test_macro_rw_sclk_neg_enable;
  if (reg->bitfields.TEST_MACRO_RW_SCLK_NEG_ENABLE != test_macro_rw_sclk_neg_enable) HSLDPF(E_ERROR_MESSAGE,"CG_TEST_MACRO_RW_CNTL::TEST_MACRO_RW_SCLK_NEG_ENABLE data too large\n");
}
#else
#define set_CG_TEST_MACRO_RW_CNTL_test_macro_rw_start(reg, test_macro_rw_start) (reg)->bitfields.TEST_MACRO_RW_START = test_macro_rw_start
#define set_CG_TEST_MACRO_RW_CNTL_test_macro_rw_op(reg, test_macro_rw_op) (reg)->bitfields.TEST_MACRO_RW_OP = test_macro_rw_op
#define set_CG_TEST_MACRO_RW_CNTL_test_macro_rw_mode(reg, test_macro_rw_mode) (reg)->bitfields.TEST_MACRO_RW_MODE = test_macro_rw_mode
#define set_CG_TEST_MACRO_RW_CNTL_test_macro_rw_mismatch_sel(reg, test_macro_rw_mismatch_sel) (reg)->bitfields.TEST_MACRO_RW_MISMATCH_SEL = test_macro_rw_mismatch_sel
#define set_CG_TEST_MACRO_RW_CNTL_test_macro_rw_mismatch(reg, test_macro_rw_mismatch) (reg)->bitfields.TEST_MACRO_RW_MISMATCH = test_macro_rw_mismatch
#define set_CG_TEST_MACRO_RW_CNTL_test_macro_rw_enable(reg, test_macro_rw_enable) (reg)->bitfields.TEST_MACRO_RW_ENABLE = test_macro_rw_enable
#define set_CG_TEST_MACRO_RW_CNTL_test_macro_rw_sclk_neg_enable(reg, test_macro_rw_sclk_neg_enable) (reg)->bitfields.TEST_MACRO_RW_SCLK_NEG_ENABLE = test_macro_rw_sclk_neg_enable

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union IDCT_RUNS regIDCT_RUNS;

#ifdef DEBUG
__inline void set_IDCT_RUNS_idct_runs_3(regIDCT_RUNS *reg, unsigned int idct_runs_3)
{
  reg->bitfields.IDCT_RUNS_3 = idct_runs_3;
  if (reg->bitfields.IDCT_RUNS_3 != idct_runs_3) HSLDPF(E_ERROR_MESSAGE,"IDCT_RUNS::IDCT_RUNS_3 data too large\n");
}
__inline void set_IDCT_RUNS_idct_runs_2(regIDCT_RUNS *reg, unsigned int idct_runs_2)
{
  reg->bitfields.IDCT_RUNS_2 = idct_runs_2;
  if (reg->bitfields.IDCT_RUNS_2 != idct_runs_2) HSLDPF(E_ERROR_MESSAGE,"IDCT_RUNS::IDCT_RUNS_2 data too large\n");
}
__inline void set_IDCT_RUNS_idct_runs_1(regIDCT_RUNS *reg, unsigned int idct_runs_1)
{
  reg->bitfields.IDCT_RUNS_1 = idct_runs_1;
  if (reg->bitfields.IDCT_RUNS_1 != idct_runs_1) HSLDPF(E_ERROR_MESSAGE,"IDCT_RUNS::IDCT_RUNS_1 data too large\n");
}
__inline void set_IDCT_RUNS_idct_runs_0(regIDCT_RUNS *reg, unsigned int idct_runs_0)
{
  reg->bitfields.IDCT_RUNS_0 = idct_runs_0;
  if (reg->bitfields.IDCT_RUNS_0 != idct_runs_0) HSLDPF(E_ERROR_MESSAGE,"IDCT_RUNS::IDCT_RUNS_0 data too large\n");
}
#else
#define set_IDCT_RUNS_idct_runs_3(reg, idct_runs_3) (reg)->bitfields.IDCT_RUNS_3 = idct_runs_3
#define set_IDCT_RUNS_idct_runs_2(reg, idct_runs_2) (reg)->bitfields.IDCT_RUNS_2 = idct_runs_2
#define set_IDCT_RUNS_idct_runs_1(reg, idct_runs_1) (reg)->bitfields.IDCT_RUNS_1 = idct_runs_1
#define set_IDCT_RUNS_idct_runs_0(reg, idct_runs_0) (reg)->bitfields.IDCT_RUNS_0 = idct_runs_0

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union IDCT_LEVELS regIDCT_LEVELS;

#ifdef DEBUG
__inline void set_IDCT_LEVELS_idct_level_hi(regIDCT_LEVELS *reg, unsigned int idct_level_hi)
{
  reg->bitfields.IDCT_LEVEL_HI = idct_level_hi;
  if (reg->bitfields.IDCT_LEVEL_HI != idct_level_hi) HSLDPF(E_ERROR_MESSAGE,"IDCT_LEVELS::IDCT_LEVEL_HI data too large\n");
}
__inline void set_IDCT_LEVELS_idct_level_lo(regIDCT_LEVELS *reg, unsigned int idct_level_lo)
{
  reg->bitfields.IDCT_LEVEL_LO = idct_level_lo;
  if (reg->bitfields.IDCT_LEVEL_LO != idct_level_lo) HSLDPF(E_ERROR_MESSAGE,"IDCT_LEVELS::IDCT_LEVEL_LO data too large\n");
}
#else
#define set_IDCT_LEVELS_idct_level_hi(reg, idct_level_hi) (reg)->bitfields.IDCT_LEVEL_HI = idct_level_hi
#define set_IDCT_LEVELS_idct_level_lo(reg, idct_level_lo) (reg)->bitfields.IDCT_LEVEL_LO = idct_level_lo

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union IDCT_CONTROL regIDCT_CONTROL;

#ifdef DEBUG
__inline void set_IDCT_CONTROL_idct_ctl_luma_rd_format(regIDCT_CONTROL *reg, unsigned int idct_ctl_luma_rd_format)
{
  reg->bitfields.IDCT_CTL_LUMA_RD_FORMAT = idct_ctl_luma_rd_format;
  if (reg->bitfields.IDCT_CTL_LUMA_RD_FORMAT != idct_ctl_luma_rd_format) HSLDPF(E_ERROR_MESSAGE,"IDCT_CONTROL::IDCT_CTL_LUMA_RD_FORMAT data too large\n");
}
__inline void set_IDCT_CONTROL_idct_ctl_chroma_rd_format(regIDCT_CONTROL *reg, unsigned int idct_ctl_chroma_rd_format)
{
  reg->bitfields.IDCT_CTL_CHROMA_RD_FORMAT = idct_ctl_chroma_rd_format;
  if (reg->bitfields.IDCT_CTL_CHROMA_RD_FORMAT != idct_ctl_chroma_rd_format) HSLDPF(E_ERROR_MESSAGE,"IDCT_CONTROL::IDCT_CTL_CHROMA_RD_FORMAT data too large\n");
}
__inline void set_IDCT_CONTROL_idct_ctl_scan_pattern(regIDCT_CONTROL *reg, unsigned int idct_ctl_scan_pattern)
{
  reg->bitfields.IDCT_CTL_SCAN_PATTERN = idct_ctl_scan_pattern;
  if (reg->bitfields.IDCT_CTL_SCAN_PATTERN != idct_ctl_scan_pattern) HSLDPF(E_ERROR_MESSAGE,"IDCT_CONTROL::IDCT_CTL_SCAN_PATTERN data too large\n");
}
__inline void set_IDCT_CONTROL_idct_ctl_intra(regIDCT_CONTROL *reg, unsigned int idct_ctl_intra)
{
  reg->bitfields.IDCT_CTL_INTRA = idct_ctl_intra;
  if (reg->bitfields.IDCT_CTL_INTRA != idct_ctl_intra) HSLDPF(E_ERROR_MESSAGE,"IDCT_CONTROL::IDCT_CTL_INTRA data too large\n");
}
__inline void set_IDCT_CONTROL_idct_ctl_flush(regIDCT_CONTROL *reg, unsigned int idct_ctl_flush)
{
  reg->bitfields.IDCT_CTL_FLUSH = idct_ctl_flush;
  if (reg->bitfields.IDCT_CTL_FLUSH != idct_ctl_flush) HSLDPF(E_ERROR_MESSAGE,"IDCT_CONTROL::IDCT_CTL_FLUSH data too large\n");
}
__inline void set_IDCT_CONTROL_idct_ctl_passthru(regIDCT_CONTROL *reg, unsigned int idct_ctl_passthru)
{
  reg->bitfields.IDCT_CTL_PASSTHRU = idct_ctl_passthru;
  if (reg->bitfields.IDCT_CTL_PASSTHRU != idct_ctl_passthru) HSLDPF(E_ERROR_MESSAGE,"IDCT_CONTROL::IDCT_CTL_PASSTHRU data too large\n");
}
__inline void set_IDCT_CONTROL_idct_ctl_sw_reset(regIDCT_CONTROL *reg, unsigned int idct_ctl_sw_reset)
{
  reg->bitfields.IDCT_CTL_SW_RESET = idct_ctl_sw_reset;
  if (reg->bitfields.IDCT_CTL_SW_RESET != idct_ctl_sw_reset) HSLDPF(E_ERROR_MESSAGE,"IDCT_CONTROL::IDCT_CTL_SW_RESET data too large\n");
}
__inline void set_IDCT_CONTROL_idct_ctl_constreq(regIDCT_CONTROL *reg, unsigned int idct_ctl_constreq)
{
  reg->bitfields.IDCT_CTL_CONSTREQ = idct_ctl_constreq;
  if (reg->bitfields.IDCT_CTL_CONSTREQ != idct_ctl_constreq) HSLDPF(E_ERROR_MESSAGE,"IDCT_CONTROL::IDCT_CTL_CONSTREQ data too large\n");
}
__inline void set_IDCT_CONTROL_idct_ctl_scramble(regIDCT_CONTROL *reg, unsigned int idct_ctl_scramble)
{
  reg->bitfields.IDCT_CTL_SCRAMBLE = idct_ctl_scramble;
  if (reg->bitfields.IDCT_CTL_SCRAMBLE != idct_ctl_scramble) HSLDPF(E_ERROR_MESSAGE,"IDCT_CONTROL::IDCT_CTL_SCRAMBLE data too large\n");
}
#else
#define set_IDCT_CONTROL_idct_ctl_luma_rd_format(reg, idct_ctl_luma_rd_format) (reg)->bitfields.IDCT_CTL_LUMA_RD_FORMAT = idct_ctl_luma_rd_format
#define set_IDCT_CONTROL_idct_ctl_chroma_rd_format(reg, idct_ctl_chroma_rd_format) (reg)->bitfields.IDCT_CTL_CHROMA_RD_FORMAT = idct_ctl_chroma_rd_format
#define set_IDCT_CONTROL_idct_ctl_scan_pattern(reg, idct_ctl_scan_pattern) (reg)->bitfields.IDCT_CTL_SCAN_PATTERN = idct_ctl_scan_pattern
#define set_IDCT_CONTROL_idct_ctl_intra(reg, idct_ctl_intra) (reg)->bitfields.IDCT_CTL_INTRA = idct_ctl_intra
#define set_IDCT_CONTROL_idct_ctl_flush(reg, idct_ctl_flush) (reg)->bitfields.IDCT_CTL_FLUSH = idct_ctl_flush
#define set_IDCT_CONTROL_idct_ctl_passthru(reg, idct_ctl_passthru) (reg)->bitfields.IDCT_CTL_PASSTHRU = idct_ctl_passthru
#define set_IDCT_CONTROL_idct_ctl_sw_reset(reg, idct_ctl_sw_reset) (reg)->bitfields.IDCT_CTL_SW_RESET = idct_ctl_sw_reset
#define set_IDCT_CONTROL_idct_ctl_constreq(reg, idct_ctl_constreq) (reg)->bitfields.IDCT_CTL_CONSTREQ = idct_ctl_constreq
#define set_IDCT_CONTROL_idct_ctl_scramble(reg, idct_ctl_scramble) (reg)->bitfields.IDCT_CTL_SCRAMBLE = idct_ctl_scramble

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union IDCT_AUTH_CONTROL regIDCT_AUTH_CONTROL;

#ifdef DEBUG
__inline void set_IDCT_AUTH_CONTROL_control_bits(regIDCT_AUTH_CONTROL *reg, unsigned int control_bits)
{
  reg->bitfields.CONTROL_BITS = control_bits;
  if (reg->bitfields.CONTROL_BITS != control_bits) HSLDPF(E_ERROR_MESSAGE,"IDCT_AUTH_CONTROL::CONTROL_BITS data too large\n");
}
#else
#define set_IDCT_AUTH_CONTROL_control_bits(reg, control_bits) (reg)->bitfields.CONTROL_BITS = control_bits

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union IDCT_AUTH regIDCT_AUTH;

#ifdef DEBUG
__inline void set_IDCT_AUTH_auth(regIDCT_AUTH *reg, unsigned int auth)
{
  reg->bitfields.AUTH = auth;
  if (reg->bitfields.AUTH != auth) HSLDPF(E_ERROR_MESSAGE,"IDCT_AUTH::AUTH data too large\n");
}
#else
#define set_IDCT_AUTH_auth(reg, auth) (reg)->bitfields.AUTH = auth

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_CNTL regDAC_CNTL;

#ifdef DEBUG
__inline void set_DAC_CNTL_dac_range_cntl(regDAC_CNTL *reg, unsigned int dac_range_cntl)
{
  reg->bitfields.DAC_RANGE_CNTL = dac_range_cntl;
  if (reg->bitfields.DAC_RANGE_CNTL != dac_range_cntl) HSLDPF(E_ERROR_MESSAGE,"DAC_CNTL::DAC_RANGE_CNTL data too large\n");
}
__inline void set_DAC_CNTL_dac_blanking(regDAC_CNTL *reg, unsigned int dac_blanking)
{
  reg->bitfields.DAC_BLANKING = dac_blanking;
  if (reg->bitfields.DAC_BLANKING != dac_blanking) HSLDPF(E_ERROR_MESSAGE,"DAC_CNTL::DAC_BLANKING data too large\n");
}
__inline void set_DAC_CNTL_dac_cmp_en(regDAC_CNTL *reg, unsigned int dac_cmp_en)
{
  reg->bitfields.DAC_CMP_EN = dac_cmp_en;
  if (reg->bitfields.DAC_CMP_EN != dac_cmp_en) HSLDPF(E_ERROR_MESSAGE,"DAC_CNTL::DAC_CMP_EN data too large\n");
}
__inline void set_DAC_CNTL_dac_cmp_out_r(regDAC_CNTL *reg, unsigned int dac_cmp_out_r)
{
  reg->bitfields.DAC_CMP_OUT_R = dac_cmp_out_r;
  if (reg->bitfields.DAC_CMP_OUT_R != dac_cmp_out_r) HSLDPF(E_ERROR_MESSAGE,"DAC_CNTL::DAC_CMP_OUT_R data too large\n");
}
__inline void set_DAC_CNTL_dac_cmp_out_g(regDAC_CNTL *reg, unsigned int dac_cmp_out_g)
{
  reg->bitfields.DAC_CMP_OUT_G = dac_cmp_out_g;
  if (reg->bitfields.DAC_CMP_OUT_G != dac_cmp_out_g) HSLDPF(E_ERROR_MESSAGE,"DAC_CNTL::DAC_CMP_OUT_G data too large\n");
}
__inline void set_DAC_CNTL_dac_cmp_out_b(regDAC_CNTL *reg, unsigned int dac_cmp_out_b)
{
  reg->bitfields.DAC_CMP_OUT_B = dac_cmp_out_b;
  if (reg->bitfields.DAC_CMP_OUT_B != dac_cmp_out_b) HSLDPF(E_ERROR_MESSAGE,"DAC_CNTL::DAC_CMP_OUT_B data too large\n");
}
__inline void set_DAC_CNTL_dac_cmp_output(regDAC_CNTL *reg, unsigned int dac_cmp_output)
{
  reg->bitfields.DAC_CMP_OUTPUT = dac_cmp_output;
  if (reg->bitfields.DAC_CMP_OUTPUT != dac_cmp_output) HSLDPF(E_ERROR_MESSAGE,"DAC_CNTL::DAC_CMP_OUTPUT data too large\n");
}
__inline void set_DAC_CNTL_dac_8bit_en(regDAC_CNTL *reg, unsigned int dac_8bit_en)
{
  reg->bitfields.DAC_8BIT_EN = dac_8bit_en;
  if (reg->bitfields.DAC_8BIT_EN != dac_8bit_en) HSLDPF(E_ERROR_MESSAGE,"DAC_CNTL::DAC_8BIT_EN data too large\n");
}
__inline void set_DAC_CNTL_dac_4bpp_pix_order(regDAC_CNTL *reg, unsigned int dac_4bpp_pix_order)
{
  reg->bitfields.DAC_4BPP_PIX_ORDER = dac_4bpp_pix_order;
  if (reg->bitfields.DAC_4BPP_PIX_ORDER != dac_4bpp_pix_order) HSLDPF(E_ERROR_MESSAGE,"DAC_CNTL::DAC_4BPP_PIX_ORDER data too large\n");
}
__inline void set_DAC_CNTL_dac_tvo_en(regDAC_CNTL *reg, unsigned int dac_tvo_en)
{
  reg->bitfields.DAC_TVO_EN = dac_tvo_en;
  if (reg->bitfields.DAC_TVO_EN != dac_tvo_en) HSLDPF(E_ERROR_MESSAGE,"DAC_CNTL::DAC_TVO_EN data too large\n");
}
__inline void set_DAC_CNTL_dac_vga_adr_en(regDAC_CNTL *reg, unsigned int dac_vga_adr_en)
{
  reg->bitfields.DAC_VGA_ADR_EN = dac_vga_adr_en;
  if (reg->bitfields.DAC_VGA_ADR_EN != dac_vga_adr_en) HSLDPF(E_ERROR_MESSAGE,"DAC_CNTL::DAC_VGA_ADR_EN data too large\n");
}
__inline void set_DAC_CNTL_dac_expand_mode(regDAC_CNTL *reg, unsigned int dac_expand_mode)
{
  reg->bitfields.DAC_EXPAND_MODE = dac_expand_mode;
  if (reg->bitfields.DAC_EXPAND_MODE != dac_expand_mode) HSLDPF(E_ERROR_MESSAGE,"DAC_CNTL::DAC_EXPAND_MODE data too large\n");
}
__inline void set_DAC_CNTL_dac_pdwn(regDAC_CNTL *reg, unsigned int dac_pdwn)
{
  reg->bitfields.DAC_PDWN = dac_pdwn;
  if (reg->bitfields.DAC_PDWN != dac_pdwn) HSLDPF(E_ERROR_MESSAGE,"DAC_CNTL::DAC_PDWN data too large\n");
}
__inline void set_DAC_CNTL_crt_sense(regDAC_CNTL *reg, unsigned int crt_sense)
{
  reg->bitfields.CRT_SENSE = crt_sense;
  if (reg->bitfields.CRT_SENSE != crt_sense) HSLDPF(E_ERROR_MESSAGE,"DAC_CNTL::CRT_SENSE data too large\n");
}
__inline void set_DAC_CNTL_crt_detection_on(regDAC_CNTL *reg, unsigned int crt_detection_on)
{
  reg->bitfields.CRT_DETECTION_ON = crt_detection_on;
  if (reg->bitfields.CRT_DETECTION_ON != crt_detection_on) HSLDPF(E_ERROR_MESSAGE,"DAC_CNTL::CRT_DETECTION_ON data too large\n");
}
__inline void set_DAC_CNTL_dac_crc_cont_en(regDAC_CNTL *reg, unsigned int dac_crc_cont_en)
{
  reg->bitfields.DAC_CRC_CONT_EN = dac_crc_cont_en;
  if (reg->bitfields.DAC_CRC_CONT_EN != dac_crc_cont_en) HSLDPF(E_ERROR_MESSAGE,"DAC_CNTL::DAC_CRC_CONT_EN data too large\n");
}
__inline void set_DAC_CNTL_dac_crc_en(regDAC_CNTL *reg, unsigned int dac_crc_en)
{
  reg->bitfields.DAC_CRC_EN = dac_crc_en;
  if (reg->bitfields.DAC_CRC_EN != dac_crc_en) HSLDPF(E_ERROR_MESSAGE,"DAC_CNTL::DAC_CRC_EN data too large\n");
}
__inline void set_DAC_CNTL_dac_crc_field(regDAC_CNTL *reg, unsigned int dac_crc_field)
{
  reg->bitfields.DAC_CRC_FIELD = dac_crc_field;
  if (reg->bitfields.DAC_CRC_FIELD != dac_crc_field) HSLDPF(E_ERROR_MESSAGE,"DAC_CNTL::DAC_CRC_FIELD data too large\n");
}
__inline void set_DAC_CNTL_dac_lut_counter_limit(regDAC_CNTL *reg, unsigned int dac_lut_counter_limit)
{
  reg->bitfields.DAC_LUT_COUNTER_LIMIT = dac_lut_counter_limit;
  if (reg->bitfields.DAC_LUT_COUNTER_LIMIT != dac_lut_counter_limit) HSLDPF(E_ERROR_MESSAGE,"DAC_CNTL::DAC_LUT_COUNTER_LIMIT data too large\n");
}
__inline void set_DAC_CNTL_dac_lut_read_sel(regDAC_CNTL *reg, unsigned int dac_lut_read_sel)
{
  reg->bitfields.DAC_LUT_READ_SEL = dac_lut_read_sel;
  if (reg->bitfields.DAC_LUT_READ_SEL != dac_lut_read_sel) HSLDPF(E_ERROR_MESSAGE,"DAC_CNTL::DAC_LUT_READ_SEL data too large\n");
}
__inline void set_DAC_CNTL_dac_mask(regDAC_CNTL *reg, unsigned int dac_mask)
{
  reg->bitfields.DAC_MASK = dac_mask;
  if (reg->bitfields.DAC_MASK != dac_mask) HSLDPF(E_ERROR_MESSAGE,"DAC_CNTL::DAC_MASK data too large\n");
}
#else
#define set_DAC_CNTL_dac_range_cntl(reg, dac_range_cntl) (reg)->bitfields.DAC_RANGE_CNTL = dac_range_cntl
#define set_DAC_CNTL_dac_blanking(reg, dac_blanking) (reg)->bitfields.DAC_BLANKING = dac_blanking
#define set_DAC_CNTL_dac_cmp_en(reg, dac_cmp_en) (reg)->bitfields.DAC_CMP_EN = dac_cmp_en
#define set_DAC_CNTL_dac_cmp_out_r(reg, dac_cmp_out_r) (reg)->bitfields.DAC_CMP_OUT_R = dac_cmp_out_r
#define set_DAC_CNTL_dac_cmp_out_g(reg, dac_cmp_out_g) (reg)->bitfields.DAC_CMP_OUT_G = dac_cmp_out_g
#define set_DAC_CNTL_dac_cmp_out_b(reg, dac_cmp_out_b) (reg)->bitfields.DAC_CMP_OUT_B = dac_cmp_out_b
#define set_DAC_CNTL_dac_cmp_output(reg, dac_cmp_output) (reg)->bitfields.DAC_CMP_OUTPUT = dac_cmp_output
#define set_DAC_CNTL_dac_8bit_en(reg, dac_8bit_en) (reg)->bitfields.DAC_8BIT_EN = dac_8bit_en
#define set_DAC_CNTL_dac_4bpp_pix_order(reg, dac_4bpp_pix_order) (reg)->bitfields.DAC_4BPP_PIX_ORDER = dac_4bpp_pix_order
#define set_DAC_CNTL_dac_tvo_en(reg, dac_tvo_en) (reg)->bitfields.DAC_TVO_EN = dac_tvo_en
#define set_DAC_CNTL_dac_vga_adr_en(reg, dac_vga_adr_en) (reg)->bitfields.DAC_VGA_ADR_EN = dac_vga_adr_en
#define set_DAC_CNTL_dac_expand_mode(reg, dac_expand_mode) (reg)->bitfields.DAC_EXPAND_MODE = dac_expand_mode
#define set_DAC_CNTL_dac_pdwn(reg, dac_pdwn) (reg)->bitfields.DAC_PDWN = dac_pdwn
#define set_DAC_CNTL_crt_sense(reg, crt_sense) (reg)->bitfields.CRT_SENSE = crt_sense
#define set_DAC_CNTL_crt_detection_on(reg, crt_detection_on) (reg)->bitfields.CRT_DETECTION_ON = crt_detection_on
#define set_DAC_CNTL_dac_crc_cont_en(reg, dac_crc_cont_en) (reg)->bitfields.DAC_CRC_CONT_EN = dac_crc_cont_en
#define set_DAC_CNTL_dac_crc_en(reg, dac_crc_en) (reg)->bitfields.DAC_CRC_EN = dac_crc_en
#define set_DAC_CNTL_dac_crc_field(reg, dac_crc_field) (reg)->bitfields.DAC_CRC_FIELD = dac_crc_field
#define set_DAC_CNTL_dac_lut_counter_limit(reg, dac_lut_counter_limit) (reg)->bitfields.DAC_LUT_COUNTER_LIMIT = dac_lut_counter_limit
#define set_DAC_CNTL_dac_lut_read_sel(reg, dac_lut_read_sel) (reg)->bitfields.DAC_LUT_READ_SEL = dac_lut_read_sel
#define set_DAC_CNTL_dac_mask(reg, dac_mask) (reg)->bitfields.DAC_MASK = dac_mask

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC_GEN_CNTL regCRTC_GEN_CNTL;

#ifdef DEBUG
__inline void set_CRTC_GEN_CNTL_crtc_dbl_scan_en(regCRTC_GEN_CNTL *reg, unsigned int crtc_dbl_scan_en)
{
  reg->bitfields.CRTC_DBL_SCAN_EN = crtc_dbl_scan_en;
  if (reg->bitfields.CRTC_DBL_SCAN_EN != crtc_dbl_scan_en) HSLDPF(E_ERROR_MESSAGE,"CRTC_GEN_CNTL::CRTC_DBL_SCAN_EN data too large\n");
}
__inline void set_CRTC_GEN_CNTL_crtc_interlace_en(regCRTC_GEN_CNTL *reg, unsigned int crtc_interlace_en)
{
  reg->bitfields.CRTC_INTERLACE_EN = crtc_interlace_en;
  if (reg->bitfields.CRTC_INTERLACE_EN != crtc_interlace_en) HSLDPF(E_ERROR_MESSAGE,"CRTC_GEN_CNTL::CRTC_INTERLACE_EN data too large\n");
}
__inline void set_CRTC_GEN_CNTL_crtc_c_sync_en(regCRTC_GEN_CNTL *reg, unsigned int crtc_c_sync_en)
{
  reg->bitfields.CRTC_C_SYNC_EN = crtc_c_sync_en;
  if (reg->bitfields.CRTC_C_SYNC_EN != crtc_c_sync_en) HSLDPF(E_ERROR_MESSAGE,"CRTC_GEN_CNTL::CRTC_C_SYNC_EN data too large\n");
}
__inline void set_CRTC_GEN_CNTL_crtc_pix_width(regCRTC_GEN_CNTL *reg, unsigned int crtc_pix_width)
{
  reg->bitfields.CRTC_PIX_WIDTH = crtc_pix_width;
  if (reg->bitfields.CRTC_PIX_WIDTH != crtc_pix_width) HSLDPF(E_ERROR_MESSAGE,"CRTC_GEN_CNTL::CRTC_PIX_WIDTH data too large\n");
}
__inline void set_CRTC_GEN_CNTL_crtc_cur_en(regCRTC_GEN_CNTL *reg, unsigned int crtc_cur_en)
{
  reg->bitfields.CRTC_CUR_EN = crtc_cur_en;
  if (reg->bitfields.CRTC_CUR_EN != crtc_cur_en) HSLDPF(E_ERROR_MESSAGE,"CRTC_GEN_CNTL::CRTC_CUR_EN data too large\n");
}
__inline void set_CRTC_GEN_CNTL_crtc_vstat_mode(regCRTC_GEN_CNTL *reg, unsigned int crtc_vstat_mode)
{
  reg->bitfields.CRTC_VSTAT_MODE = crtc_vstat_mode;
  if (reg->bitfields.CRTC_VSTAT_MODE != crtc_vstat_mode) HSLDPF(E_ERROR_MESSAGE,"CRTC_GEN_CNTL::CRTC_VSTAT_MODE data too large\n");
}
__inline void set_CRTC_GEN_CNTL_crtc_cur_mode(regCRTC_GEN_CNTL *reg, unsigned int crtc_cur_mode)
{
  reg->bitfields.CRTC_CUR_MODE = crtc_cur_mode;
  if (reg->bitfields.CRTC_CUR_MODE != crtc_cur_mode) HSLDPF(E_ERROR_MESSAGE,"CRTC_GEN_CNTL::CRTC_CUR_MODE data too large\n");
}
__inline void set_CRTC_GEN_CNTL_crtc_ext_disp_en(regCRTC_GEN_CNTL *reg, unsigned int crtc_ext_disp_en)
{
  reg->bitfields.CRTC_EXT_DISP_EN = crtc_ext_disp_en;
  if (reg->bitfields.CRTC_EXT_DISP_EN != crtc_ext_disp_en) HSLDPF(E_ERROR_MESSAGE,"CRTC_GEN_CNTL::CRTC_EXT_DISP_EN data too large\n");
}
__inline void set_CRTC_GEN_CNTL_crtc_en(regCRTC_GEN_CNTL *reg, unsigned int crtc_en)
{
  reg->bitfields.CRTC_EN = crtc_en;
  if (reg->bitfields.CRTC_EN != crtc_en) HSLDPF(E_ERROR_MESSAGE,"CRTC_GEN_CNTL::CRTC_EN data too large\n");
}
__inline void set_CRTC_GEN_CNTL_crtc_disp_req_en_b(regCRTC_GEN_CNTL *reg, unsigned int crtc_disp_req_en_b)
{
  reg->bitfields.CRTC_DISP_REQ_EN_B = crtc_disp_req_en_b;
  if (reg->bitfields.CRTC_DISP_REQ_EN_B != crtc_disp_req_en_b) HSLDPF(E_ERROR_MESSAGE,"CRTC_GEN_CNTL::CRTC_DISP_REQ_EN_B data too large\n");
}
#else
#define set_CRTC_GEN_CNTL_crtc_dbl_scan_en(reg, crtc_dbl_scan_en) (reg)->bitfields.CRTC_DBL_SCAN_EN = crtc_dbl_scan_en
#define set_CRTC_GEN_CNTL_crtc_interlace_en(reg, crtc_interlace_en) (reg)->bitfields.CRTC_INTERLACE_EN = crtc_interlace_en
#define set_CRTC_GEN_CNTL_crtc_c_sync_en(reg, crtc_c_sync_en) (reg)->bitfields.CRTC_C_SYNC_EN = crtc_c_sync_en
#define set_CRTC_GEN_CNTL_crtc_pix_width(reg, crtc_pix_width) (reg)->bitfields.CRTC_PIX_WIDTH = crtc_pix_width
#define set_CRTC_GEN_CNTL_crtc_cur_en(reg, crtc_cur_en) (reg)->bitfields.CRTC_CUR_EN = crtc_cur_en
#define set_CRTC_GEN_CNTL_crtc_vstat_mode(reg, crtc_vstat_mode) (reg)->bitfields.CRTC_VSTAT_MODE = crtc_vstat_mode
#define set_CRTC_GEN_CNTL_crtc_cur_mode(reg, crtc_cur_mode) (reg)->bitfields.CRTC_CUR_MODE = crtc_cur_mode
#define set_CRTC_GEN_CNTL_crtc_ext_disp_en(reg, crtc_ext_disp_en) (reg)->bitfields.CRTC_EXT_DISP_EN = crtc_ext_disp_en
#define set_CRTC_GEN_CNTL_crtc_en(reg, crtc_en) (reg)->bitfields.CRTC_EN = crtc_en
#define set_CRTC_GEN_CNTL_crtc_disp_req_en_b(reg, crtc_disp_req_en_b) (reg)->bitfields.CRTC_DISP_REQ_EN_B = crtc_disp_req_en_b

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MEM_CNTL regMEM_CNTL;

#ifdef DEBUG
__inline void set_MEM_CNTL_mem_num_channels(regMEM_CNTL *reg, unsigned int mem_num_channels)
{
  reg->bitfields.MEM_NUM_CHANNELS = mem_num_channels;
  if (reg->bitfields.MEM_NUM_CHANNELS != mem_num_channels) HSLDPF(E_ERROR_MESSAGE,"MEM_CNTL::MEM_NUM_CHANNELS data too large\n");
}
__inline void set_MEM_CNTL_mc_use_b_ch_only(regMEM_CNTL *reg, unsigned int mc_use_b_ch_only)
{
  reg->bitfields.MC_USE_B_CH_ONLY = mc_use_b_ch_only;
  if (reg->bitfields.MC_USE_B_CH_ONLY != mc_use_b_ch_only) HSLDPF(E_ERROR_MESSAGE,"MEM_CNTL::MC_USE_B_CH_ONLY data too large\n");
}
__inline void set_MEM_CNTL_disable_ap(regMEM_CNTL *reg, unsigned int disable_ap)
{
  reg->bitfields.DISABLE_AP = disable_ap;
  if (reg->bitfields.DISABLE_AP != disable_ap) HSLDPF(E_ERROR_MESSAGE,"MEM_CNTL::DISABLE_AP data too large\n");
}
__inline void set_MEM_CNTL_mem_channel_mapping(regMEM_CNTL *reg, unsigned int mem_channel_mapping)
{
  reg->bitfields.MEM_CHANNEL_MAPPING = mem_channel_mapping;
  if (reg->bitfields.MEM_CHANNEL_MAPPING != mem_channel_mapping) HSLDPF(E_ERROR_MESSAGE,"MEM_CNTL::MEM_CHANNEL_MAPPING data too large\n");
}
__inline void set_MEM_CNTL_mem_bank_mapping_a(regMEM_CNTL *reg, unsigned int mem_bank_mapping_a)
{
  reg->bitfields.MEM_BANK_MAPPING_A = mem_bank_mapping_a;
  if (reg->bitfields.MEM_BANK_MAPPING_A != mem_bank_mapping_a) HSLDPF(E_ERROR_MESSAGE,"MEM_CNTL::MEM_BANK_MAPPING_A data too large\n");
}
__inline void set_MEM_CNTL_mem_addr_mapping_a(regMEM_CNTL *reg, unsigned int mem_addr_mapping_a)
{
  reg->bitfields.MEM_ADDR_MAPPING_A = mem_addr_mapping_a;
  if (reg->bitfields.MEM_ADDR_MAPPING_A != mem_addr_mapping_a) HSLDPF(E_ERROR_MESSAGE,"MEM_CNTL::MEM_ADDR_MAPPING_A data too large\n");
}
__inline void set_MEM_CNTL_read_bus1_default_en(regMEM_CNTL *reg, unsigned int read_bus1_default_en)
{
  reg->bitfields.READ_BUS1_DEFAULT_EN = read_bus1_default_en;
  if (reg->bitfields.READ_BUS1_DEFAULT_EN != read_bus1_default_en) HSLDPF(E_ERROR_MESSAGE,"MEM_CNTL::READ_BUS1_DEFAULT_EN data too large\n");
}
__inline void set_MEM_CNTL_mem_bank_mapping_b(regMEM_CNTL *reg, unsigned int mem_bank_mapping_b)
{
  reg->bitfields.MEM_BANK_MAPPING_B = mem_bank_mapping_b;
  if (reg->bitfields.MEM_BANK_MAPPING_B != mem_bank_mapping_b) HSLDPF(E_ERROR_MESSAGE,"MEM_CNTL::MEM_BANK_MAPPING_B data too large\n");
}
__inline void set_MEM_CNTL_mem_addr_mapping_b(regMEM_CNTL *reg, unsigned int mem_addr_mapping_b)
{
  reg->bitfields.MEM_ADDR_MAPPING_B = mem_addr_mapping_b;
  if (reg->bitfields.MEM_ADDR_MAPPING_B != mem_addr_mapping_b) HSLDPF(E_ERROR_MESSAGE,"MEM_CNTL::MEM_ADDR_MAPPING_B data too large\n");
}
#else
#define set_MEM_CNTL_mem_num_channels(reg, mem_num_channels) (reg)->bitfields.MEM_NUM_CHANNELS = mem_num_channels
#define set_MEM_CNTL_mc_use_b_ch_only(reg, mc_use_b_ch_only) (reg)->bitfields.MC_USE_B_CH_ONLY = mc_use_b_ch_only
#define set_MEM_CNTL_disable_ap(reg, disable_ap) (reg)->bitfields.DISABLE_AP = disable_ap
#define set_MEM_CNTL_mem_channel_mapping(reg, mem_channel_mapping) (reg)->bitfields.MEM_CHANNEL_MAPPING = mem_channel_mapping
#define set_MEM_CNTL_mem_bank_mapping_a(reg, mem_bank_mapping_a) (reg)->bitfields.MEM_BANK_MAPPING_A = mem_bank_mapping_a
#define set_MEM_CNTL_mem_addr_mapping_a(reg, mem_addr_mapping_a) (reg)->bitfields.MEM_ADDR_MAPPING_A = mem_addr_mapping_a
#define set_MEM_CNTL_read_bus1_default_en(reg, read_bus1_default_en) (reg)->bitfields.READ_BUS1_DEFAULT_EN = read_bus1_default_en
#define set_MEM_CNTL_mem_bank_mapping_b(reg, mem_bank_mapping_b) (reg)->bitfields.MEM_BANK_MAPPING_B = mem_bank_mapping_b
#define set_MEM_CNTL_mem_addr_mapping_b(reg, mem_addr_mapping_b) (reg)->bitfields.MEM_ADDR_MAPPING_B = mem_addr_mapping_b

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_DEBUG regMC_DEBUG;

#ifdef DEBUG
__inline void set_MC_DEBUG_ignore_rw_penalty_rb0r(regMC_DEBUG *reg, unsigned int ignore_rw_penalty_rb0r)
{
  reg->bitfields.IGNORE_RW_PENALTY_RB0R = ignore_rw_penalty_rb0r;
  if (reg->bitfields.IGNORE_RW_PENALTY_RB0R != ignore_rw_penalty_rb0r) HSLDPF(E_ERROR_MESSAGE,"MC_DEBUG::IGNORE_RW_PENALTY_RB0R data too large\n");
}
__inline void set_MC_DEBUG_ignore_rw_penalty_rb1r(regMC_DEBUG *reg, unsigned int ignore_rw_penalty_rb1r)
{
  reg->bitfields.IGNORE_RW_PENALTY_RB1R = ignore_rw_penalty_rb1r;
  if (reg->bitfields.IGNORE_RW_PENALTY_RB1R != ignore_rw_penalty_rb1r) HSLDPF(E_ERROR_MESSAGE,"MC_DEBUG::IGNORE_RW_PENALTY_RB1R data too large\n");
}
__inline void set_MC_DEBUG_ignore_rw_penalty_rb0w(regMC_DEBUG *reg, unsigned int ignore_rw_penalty_rb0w)
{
  reg->bitfields.IGNORE_RW_PENALTY_RB0W = ignore_rw_penalty_rb0w;
  if (reg->bitfields.IGNORE_RW_PENALTY_RB0W != ignore_rw_penalty_rb0w) HSLDPF(E_ERROR_MESSAGE,"MC_DEBUG::IGNORE_RW_PENALTY_RB0W data too large\n");
}
__inline void set_MC_DEBUG_ignore_rw_penalty_rb1w(regMC_DEBUG *reg, unsigned int ignore_rw_penalty_rb1w)
{
  reg->bitfields.IGNORE_RW_PENALTY_RB1W = ignore_rw_penalty_rb1w;
  if (reg->bitfields.IGNORE_RW_PENALTY_RB1W != ignore_rw_penalty_rb1w) HSLDPF(E_ERROR_MESSAGE,"MC_DEBUG::IGNORE_RW_PENALTY_RB1W data too large\n");
}
__inline void set_MC_DEBUG_ignore_rw_penalty_dispr(regMC_DEBUG *reg, unsigned int ignore_rw_penalty_dispr)
{
  reg->bitfields.IGNORE_RW_PENALTY_DISPR = ignore_rw_penalty_dispr;
  if (reg->bitfields.IGNORE_RW_PENALTY_DISPR != ignore_rw_penalty_dispr) HSLDPF(E_ERROR_MESSAGE,"MC_DEBUG::IGNORE_RW_PENALTY_DISPR data too large\n");
}
__inline void set_MC_DEBUG_ignore_rw_penalty_ppr(regMC_DEBUG *reg, unsigned int ignore_rw_penalty_ppr)
{
  reg->bitfields.IGNORE_RW_PENALTY_PPR = ignore_rw_penalty_ppr;
  if (reg->bitfields.IGNORE_RW_PENALTY_PPR != ignore_rw_penalty_ppr) HSLDPF(E_ERROR_MESSAGE,"MC_DEBUG::IGNORE_RW_PENALTY_PPR data too large\n");
}
__inline void set_MC_DEBUG_ignore_rw_penalty_fixed(regMC_DEBUG *reg, unsigned int ignore_rw_penalty_fixed)
{
  reg->bitfields.IGNORE_RW_PENALTY_FIXED = ignore_rw_penalty_fixed;
  if (reg->bitfields.IGNORE_RW_PENALTY_FIXED != ignore_rw_penalty_fixed) HSLDPF(E_ERROR_MESSAGE,"MC_DEBUG::IGNORE_RW_PENALTY_FIXED data too large\n");
}
__inline void set_MC_DEBUG_mem_vipw_priority(regMC_DEBUG *reg, unsigned int mem_vipw_priority)
{
  reg->bitfields.MEM_VIPW_PRIORITY = mem_vipw_priority;
  if (reg->bitfields.MEM_VIPW_PRIORITY != mem_vipw_priority) HSLDPF(E_ERROR_MESSAGE,"MC_DEBUG::MEM_VIPW_PRIORITY data too large\n");
}
__inline void set_MC_DEBUG_en_aic_idle_det(regMC_DEBUG *reg, unsigned int en_aic_idle_det)
{
  reg->bitfields.EN_AIC_IDLE_DET = en_aic_idle_det;
  if (reg->bitfields.EN_AIC_IDLE_DET != en_aic_idle_det) HSLDPF(E_ERROR_MESSAGE,"MC_DEBUG::EN_AIC_IDLE_DET data too large\n");
}
__inline void set_MC_DEBUG_mem_mc_blackout(regMC_DEBUG *reg, unsigned int mem_mc_blackout)
{
  reg->bitfields.MEM_MC_BLACKOUT = mem_mc_blackout;
  if (reg->bitfields.MEM_MC_BLACKOUT != mem_mc_blackout) HSLDPF(E_ERROR_MESSAGE,"MC_DEBUG::MEM_MC_BLACKOUT data too large\n");
}
__inline void set_MC_DEBUG_disable_tee_sm_changes(regMC_DEBUG *reg, unsigned int disable_tee_sm_changes)
{
  reg->bitfields.DISABLE_TEE_SM_CHANGES = disable_tee_sm_changes;
  if (reg->bitfields.DISABLE_TEE_SM_CHANGES != disable_tee_sm_changes) HSLDPF(E_ERROR_MESSAGE,"MC_DEBUG::DISABLE_TEE_SM_CHANGES data too large\n");
}
__inline void set_MC_DEBUG_imp_n_value_dqs_r_back(regMC_DEBUG *reg, unsigned int imp_n_value_dqs_r_back)
{
  reg->bitfields.IMP_N_VALUE_DQS_R_BACK = imp_n_value_dqs_r_back;
  if (reg->bitfields.IMP_N_VALUE_DQS_R_BACK != imp_n_value_dqs_r_back) HSLDPF(E_ERROR_MESSAGE,"MC_DEBUG::IMP_N_VALUE_DQS_R_BACK data too large\n");
}
__inline void set_MC_DEBUG_imp_p_value_dqs_r_back(regMC_DEBUG *reg, unsigned int imp_p_value_dqs_r_back)
{
  reg->bitfields.IMP_P_VALUE_DQS_R_BACK = imp_p_value_dqs_r_back;
  if (reg->bitfields.IMP_P_VALUE_DQS_R_BACK != imp_p_value_dqs_r_back) HSLDPF(E_ERROR_MESSAGE,"MC_DEBUG::IMP_P_VALUE_DQS_R_BACK data too large\n");
}
__inline void set_MC_DEBUG_mc_debug(regMC_DEBUG *reg, unsigned int mc_debug)
{
  reg->bitfields.MC_DEBUG = mc_debug;
  if (reg->bitfields.MC_DEBUG != mc_debug) HSLDPF(E_ERROR_MESSAGE,"MC_DEBUG::MC_DEBUG data too large\n");
}
#else
#define set_MC_DEBUG_ignore_rw_penalty_rb0r(reg, ignore_rw_penalty_rb0r) (reg)->bitfields.IGNORE_RW_PENALTY_RB0R = ignore_rw_penalty_rb0r
#define set_MC_DEBUG_ignore_rw_penalty_rb1r(reg, ignore_rw_penalty_rb1r) (reg)->bitfields.IGNORE_RW_PENALTY_RB1R = ignore_rw_penalty_rb1r
#define set_MC_DEBUG_ignore_rw_penalty_rb0w(reg, ignore_rw_penalty_rb0w) (reg)->bitfields.IGNORE_RW_PENALTY_RB0W = ignore_rw_penalty_rb0w
#define set_MC_DEBUG_ignore_rw_penalty_rb1w(reg, ignore_rw_penalty_rb1w) (reg)->bitfields.IGNORE_RW_PENALTY_RB1W = ignore_rw_penalty_rb1w
#define set_MC_DEBUG_ignore_rw_penalty_dispr(reg, ignore_rw_penalty_dispr) (reg)->bitfields.IGNORE_RW_PENALTY_DISPR = ignore_rw_penalty_dispr
#define set_MC_DEBUG_ignore_rw_penalty_ppr(reg, ignore_rw_penalty_ppr) (reg)->bitfields.IGNORE_RW_PENALTY_PPR = ignore_rw_penalty_ppr
#define set_MC_DEBUG_ignore_rw_penalty_fixed(reg, ignore_rw_penalty_fixed) (reg)->bitfields.IGNORE_RW_PENALTY_FIXED = ignore_rw_penalty_fixed
#define set_MC_DEBUG_mem_vipw_priority(reg, mem_vipw_priority) (reg)->bitfields.MEM_VIPW_PRIORITY = mem_vipw_priority
#define set_MC_DEBUG_en_aic_idle_det(reg, en_aic_idle_det) (reg)->bitfields.EN_AIC_IDLE_DET = en_aic_idle_det
#define set_MC_DEBUG_mem_mc_blackout(reg, mem_mc_blackout) (reg)->bitfields.MEM_MC_BLACKOUT = mem_mc_blackout
#define set_MC_DEBUG_disable_tee_sm_changes(reg, disable_tee_sm_changes) (reg)->bitfields.DISABLE_TEE_SM_CHANGES = disable_tee_sm_changes
#define set_MC_DEBUG_imp_n_value_dqs_r_back(reg, imp_n_value_dqs_r_back) (reg)->bitfields.IMP_N_VALUE_DQS_R_BACK = imp_n_value_dqs_r_back
#define set_MC_DEBUG_imp_p_value_dqs_r_back(reg, imp_p_value_dqs_r_back) (reg)->bitfields.IMP_P_VALUE_DQS_R_BACK = imp_p_value_dqs_r_back
#define set_MC_DEBUG_mc_debug(reg, mc_debug) (reg)->bitfields.MC_DEBUG = mc_debug

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MC_IND_INDEX regMC_IND_INDEX;

#ifdef DEBUG
__inline void set_MC_IND_INDEX_mc_ind_addr(regMC_IND_INDEX *reg, unsigned int mc_ind_addr)
{
  reg->bitfields.MC_IND_ADDR = mc_ind_addr;
  if (reg->bitfields.MC_IND_ADDR != mc_ind_addr) HSLDPF(E_ERROR_MESSAGE,"MC_IND_INDEX::MC_IND_ADDR data too large\n");
}
__inline void set_MC_IND_INDEX_mc_ind_wr_en(regMC_IND_INDEX *reg, unsigned int mc_ind_wr_en)
{
  reg->bitfields.MC_IND_WR_EN = mc_ind_wr_en;
  if (reg->bitfields.MC_IND_WR_EN != mc_ind_wr_en) HSLDPF(E_ERROR_MESSAGE,"MC_IND_INDEX::MC_IND_WR_EN data too large\n");
}
#else
#define set_MC_IND_INDEX_mc_ind_addr(reg, mc_ind_addr) (reg)->bitfields.MC_IND_ADDR = mc_ind_addr
#define set_MC_IND_INDEX_mc_ind_wr_en(reg, mc_ind_wr_en) (reg)->bitfields.MC_IND_WR_EN = mc_ind_wr_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GEN_INT_CNTL regGEN_INT_CNTL;

#ifdef DEBUG
__inline void set_GEN_INT_CNTL_crtc_vblank_mask(regGEN_INT_CNTL *reg, unsigned int crtc_vblank_mask)
{
  reg->bitfields.CRTC_VBLANK_MASK = crtc_vblank_mask;
  if (reg->bitfields.CRTC_VBLANK_MASK != crtc_vblank_mask) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::CRTC_VBLANK_MASK data too large\n");
}
__inline void set_GEN_INT_CNTL_crtc_vline_mask(regGEN_INT_CNTL *reg, unsigned int crtc_vline_mask)
{
  reg->bitfields.CRTC_VLINE_MASK = crtc_vline_mask;
  if (reg->bitfields.CRTC_VLINE_MASK != crtc_vline_mask) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::CRTC_VLINE_MASK data too large\n");
}
__inline void set_GEN_INT_CNTL_crtc_vsync_mask(regGEN_INT_CNTL *reg, unsigned int crtc_vsync_mask)
{
  reg->bitfields.CRTC_VSYNC_MASK = crtc_vsync_mask;
  if (reg->bitfields.CRTC_VSYNC_MASK != crtc_vsync_mask) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::CRTC_VSYNC_MASK data too large\n");
}
__inline void set_GEN_INT_CNTL_snapshot_mask(regGEN_INT_CNTL *reg, unsigned int snapshot_mask)
{
  reg->bitfields.SNAPSHOT_MASK = snapshot_mask;
  if (reg->bitfields.SNAPSHOT_MASK != snapshot_mask) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::SNAPSHOT_MASK data too large\n");
}
__inline void set_GEN_INT_CNTL_fp_detect_mask(regGEN_INT_CNTL *reg, unsigned int fp_detect_mask)
{
  reg->bitfields.FP_DETECT_MASK = fp_detect_mask;
  if (reg->bitfields.FP_DETECT_MASK != fp_detect_mask) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::FP_DETECT_MASK data too large\n");
}
__inline void set_GEN_INT_CNTL_crtc2_vline_mask(regGEN_INT_CNTL *reg, unsigned int crtc2_vline_mask)
{
  reg->bitfields.CRTC2_VLINE_MASK = crtc2_vline_mask;
  if (reg->bitfields.CRTC2_VLINE_MASK != crtc2_vline_mask) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::CRTC2_VLINE_MASK data too large\n");
}
__inline void set_GEN_INT_CNTL_crtc2_vsync_mask(regGEN_INT_CNTL *reg, unsigned int crtc2_vsync_mask)
{
  reg->bitfields.CRTC2_VSYNC_MASK = crtc2_vsync_mask;
  if (reg->bitfields.CRTC2_VSYNC_MASK != crtc2_vsync_mask) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::CRTC2_VSYNC_MASK data too large\n");
}
__inline void set_GEN_INT_CNTL_snapshot2_mask(regGEN_INT_CNTL *reg, unsigned int snapshot2_mask)
{
  reg->bitfields.SNAPSHOT2_MASK = snapshot2_mask;
  if (reg->bitfields.SNAPSHOT2_MASK != snapshot2_mask) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::SNAPSHOT2_MASK data too large\n");
}
__inline void set_GEN_INT_CNTL_crtc2_vblank_mask(regGEN_INT_CNTL *reg, unsigned int crtc2_vblank_mask)
{
  reg->bitfields.CRTC2_VBLANK_MASK = crtc2_vblank_mask;
  if (reg->bitfields.CRTC2_VBLANK_MASK != crtc2_vblank_mask) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::CRTC2_VBLANK_MASK data too large\n");
}
__inline void set_GEN_INT_CNTL_fp2_detect_mask(regGEN_INT_CNTL *reg, unsigned int fp2_detect_mask)
{
  reg->bitfields.FP2_DETECT_MASK = fp2_detect_mask;
  if (reg->bitfields.FP2_DETECT_MASK != fp2_detect_mask) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::FP2_DETECT_MASK data too large\n");
}
__inline void set_GEN_INT_CNTL_dma_viph0_int_en(regGEN_INT_CNTL *reg, unsigned int dma_viph0_int_en)
{
  reg->bitfields.DMA_VIPH0_INT_EN = dma_viph0_int_en;
  if (reg->bitfields.DMA_VIPH0_INT_EN != dma_viph0_int_en) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::DMA_VIPH0_INT_EN data too large\n");
}
__inline void set_GEN_INT_CNTL_dma_viph1_int_en(regGEN_INT_CNTL *reg, unsigned int dma_viph1_int_en)
{
  reg->bitfields.DMA_VIPH1_INT_EN = dma_viph1_int_en;
  if (reg->bitfields.DMA_VIPH1_INT_EN != dma_viph1_int_en) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::DMA_VIPH1_INT_EN data too large\n");
}
__inline void set_GEN_INT_CNTL_dma_viph2_int_en(regGEN_INT_CNTL *reg, unsigned int dma_viph2_int_en)
{
  reg->bitfields.DMA_VIPH2_INT_EN = dma_viph2_int_en;
  if (reg->bitfields.DMA_VIPH2_INT_EN != dma_viph2_int_en) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::DMA_VIPH2_INT_EN data too large\n");
}
__inline void set_GEN_INT_CNTL_dma_viph3_int_en(regGEN_INT_CNTL *reg, unsigned int dma_viph3_int_en)
{
  reg->bitfields.DMA_VIPH3_INT_EN = dma_viph3_int_en;
  if (reg->bitfields.DMA_VIPH3_INT_EN != dma_viph3_int_en) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::DMA_VIPH3_INT_EN data too large\n");
}
__inline void set_GEN_INT_CNTL_timer_int_mask(regGEN_INT_CNTL *reg, unsigned int timer_int_mask)
{
  reg->bitfields.TIMER_INT_MASK = timer_int_mask;
  if (reg->bitfields.TIMER_INT_MASK != timer_int_mask) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::TIMER_INT_MASK data too large\n");
}
__inline void set_GEN_INT_CNTL_i2c_int_en(regGEN_INT_CNTL *reg, unsigned int i2c_int_en)
{
  reg->bitfields.I2C_INT_EN = i2c_int_en;
  if (reg->bitfields.I2C_INT_EN != i2c_int_en) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::I2C_INT_EN data too large\n");
}
__inline void set_GEN_INT_CNTL_gui_idle_mask(regGEN_INT_CNTL *reg, unsigned int gui_idle_mask)
{
  reg->bitfields.GUI_IDLE_MASK = gui_idle_mask;
  if (reg->bitfields.GUI_IDLE_MASK != gui_idle_mask) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::GUI_IDLE_MASK data too large\n");
}
__inline void set_GEN_INT_CNTL_viph_int_en(regGEN_INT_CNTL *reg, unsigned int viph_int_en)
{
  reg->bitfields.VIPH_INT_EN = viph_int_en;
  if (reg->bitfields.VIPH_INT_EN != viph_int_en) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::VIPH_INT_EN data too large\n");
}
__inline void set_GEN_INT_CNTL_sw_int_en(regGEN_INT_CNTL *reg, unsigned int sw_int_en)
{
  reg->bitfields.SW_INT_EN = sw_int_en;
  if (reg->bitfields.SW_INT_EN != sw_int_en) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::SW_INT_EN data too large\n");
}
__inline void set_GEN_INT_CNTL_hdcp_authorized_int_mask(regGEN_INT_CNTL *reg, unsigned int hdcp_authorized_int_mask)
{
  reg->bitfields.HDCP_AUTHORIZED_INT_MASK = hdcp_authorized_int_mask;
  if (reg->bitfields.HDCP_AUTHORIZED_INT_MASK != hdcp_authorized_int_mask) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::HDCP_AUTHORIZED_INT_MASK data too large\n");
}
__inline void set_GEN_INT_CNTL_dvi_i2c_int_mask(regGEN_INT_CNTL *reg, unsigned int dvi_i2c_int_mask)
{
  reg->bitfields.DVI_I2C_INT_MASK = dvi_i2c_int_mask;
  if (reg->bitfields.DVI_I2C_INT_MASK != dvi_i2c_int_mask) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::DVI_I2C_INT_MASK data too large\n");
}
__inline void set_GEN_INT_CNTL_guidma_mask(regGEN_INT_CNTL *reg, unsigned int guidma_mask)
{
  reg->bitfields.GUIDMA_MASK = guidma_mask;
  if (reg->bitfields.GUIDMA_MASK != guidma_mask) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::GUIDMA_MASK data too large\n");
}
__inline void set_GEN_INT_CNTL_viddma_mask(regGEN_INT_CNTL *reg, unsigned int viddma_mask)
{
  reg->bitfields.VIDDMA_MASK = viddma_mask;
  if (reg->bitfields.VIDDMA_MASK != viddma_mask) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_CNTL::VIDDMA_MASK data too large\n");
}
#else
#define set_GEN_INT_CNTL_crtc_vblank_mask(reg, crtc_vblank_mask) (reg)->bitfields.CRTC_VBLANK_MASK = crtc_vblank_mask
#define set_GEN_INT_CNTL_crtc_vline_mask(reg, crtc_vline_mask) (reg)->bitfields.CRTC_VLINE_MASK = crtc_vline_mask
#define set_GEN_INT_CNTL_crtc_vsync_mask(reg, crtc_vsync_mask) (reg)->bitfields.CRTC_VSYNC_MASK = crtc_vsync_mask
#define set_GEN_INT_CNTL_snapshot_mask(reg, snapshot_mask) (reg)->bitfields.SNAPSHOT_MASK = snapshot_mask
#define set_GEN_INT_CNTL_fp_detect_mask(reg, fp_detect_mask) (reg)->bitfields.FP_DETECT_MASK = fp_detect_mask
#define set_GEN_INT_CNTL_crtc2_vline_mask(reg, crtc2_vline_mask) (reg)->bitfields.CRTC2_VLINE_MASK = crtc2_vline_mask
#define set_GEN_INT_CNTL_crtc2_vsync_mask(reg, crtc2_vsync_mask) (reg)->bitfields.CRTC2_VSYNC_MASK = crtc2_vsync_mask
#define set_GEN_INT_CNTL_snapshot2_mask(reg, snapshot2_mask) (reg)->bitfields.SNAPSHOT2_MASK = snapshot2_mask
#define set_GEN_INT_CNTL_crtc2_vblank_mask(reg, crtc2_vblank_mask) (reg)->bitfields.CRTC2_VBLANK_MASK = crtc2_vblank_mask
#define set_GEN_INT_CNTL_fp2_detect_mask(reg, fp2_detect_mask) (reg)->bitfields.FP2_DETECT_MASK = fp2_detect_mask
#define set_GEN_INT_CNTL_dma_viph0_int_en(reg, dma_viph0_int_en) (reg)->bitfields.DMA_VIPH0_INT_EN = dma_viph0_int_en
#define set_GEN_INT_CNTL_dma_viph1_int_en(reg, dma_viph1_int_en) (reg)->bitfields.DMA_VIPH1_INT_EN = dma_viph1_int_en
#define set_GEN_INT_CNTL_dma_viph2_int_en(reg, dma_viph2_int_en) (reg)->bitfields.DMA_VIPH2_INT_EN = dma_viph2_int_en
#define set_GEN_INT_CNTL_dma_viph3_int_en(reg, dma_viph3_int_en) (reg)->bitfields.DMA_VIPH3_INT_EN = dma_viph3_int_en
#define set_GEN_INT_CNTL_timer_int_mask(reg, timer_int_mask) (reg)->bitfields.TIMER_INT_MASK = timer_int_mask
#define set_GEN_INT_CNTL_i2c_int_en(reg, i2c_int_en) (reg)->bitfields.I2C_INT_EN = i2c_int_en
#define set_GEN_INT_CNTL_gui_idle_mask(reg, gui_idle_mask) (reg)->bitfields.GUI_IDLE_MASK = gui_idle_mask
#define set_GEN_INT_CNTL_viph_int_en(reg, viph_int_en) (reg)->bitfields.VIPH_INT_EN = viph_int_en
#define set_GEN_INT_CNTL_sw_int_en(reg, sw_int_en) (reg)->bitfields.SW_INT_EN = sw_int_en
#define set_GEN_INT_CNTL_hdcp_authorized_int_mask(reg, hdcp_authorized_int_mask) (reg)->bitfields.HDCP_AUTHORIZED_INT_MASK = hdcp_authorized_int_mask
#define set_GEN_INT_CNTL_dvi_i2c_int_mask(reg, dvi_i2c_int_mask) (reg)->bitfields.DVI_I2C_INT_MASK = dvi_i2c_int_mask
#define set_GEN_INT_CNTL_guidma_mask(reg, guidma_mask) (reg)->bitfields.GUIDMA_MASK = guidma_mask
#define set_GEN_INT_CNTL_viddma_mask(reg, viddma_mask) (reg)->bitfields.VIDDMA_MASK = viddma_mask

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GEN_INT_STATUS regGEN_INT_STATUS;

#ifdef DEBUG
__inline void set_GEN_INT_STATUS_crtc_vblank_stat(regGEN_INT_STATUS *reg, unsigned int crtc_vblank_stat)
{
  reg->bitfields.CRTC_VBLANK_STAT = crtc_vblank_stat;
  if (reg->bitfields.CRTC_VBLANK_STAT != crtc_vblank_stat) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::CRTC_VBLANK_STAT data too large\n");
}
__inline void set_GEN_INT_STATUS_crtc_vline_stat(regGEN_INT_STATUS *reg, unsigned int crtc_vline_stat)
{
  reg->bitfields.CRTC_VLINE_STAT = crtc_vline_stat;
  if (reg->bitfields.CRTC_VLINE_STAT != crtc_vline_stat) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::CRTC_VLINE_STAT data too large\n");
}
__inline void set_GEN_INT_STATUS_crtc_vsync_stat(regGEN_INT_STATUS *reg, unsigned int crtc_vsync_stat)
{
  reg->bitfields.CRTC_VSYNC_STAT = crtc_vsync_stat;
  if (reg->bitfields.CRTC_VSYNC_STAT != crtc_vsync_stat) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::CRTC_VSYNC_STAT data too large\n");
}
__inline void set_GEN_INT_STATUS_snapshot_stat(regGEN_INT_STATUS *reg, unsigned int snapshot_stat)
{
  reg->bitfields.SNAPSHOT_STAT = snapshot_stat;
  if (reg->bitfields.SNAPSHOT_STAT != snapshot_stat) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::SNAPSHOT_STAT data too large\n");
}
__inline void set_GEN_INT_STATUS_fp_detect_stat(regGEN_INT_STATUS *reg, unsigned int fp_detect_stat)
{
  reg->bitfields.FP_DETECT_STAT = fp_detect_stat;
  if (reg->bitfields.FP_DETECT_STAT != fp_detect_stat) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::FP_DETECT_STAT data too large\n");
}
__inline void set_GEN_INT_STATUS_crtc2_vline_stat(regGEN_INT_STATUS *reg, unsigned int crtc2_vline_stat)
{
  reg->bitfields.CRTC2_VLINE_STAT = crtc2_vline_stat;
  if (reg->bitfields.CRTC2_VLINE_STAT != crtc2_vline_stat) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::CRTC2_VLINE_STAT data too large\n");
}
__inline void set_GEN_INT_STATUS_crtc2_vsync_stat(regGEN_INT_STATUS *reg, unsigned int crtc2_vsync_stat)
{
  reg->bitfields.CRTC2_VSYNC_STAT = crtc2_vsync_stat;
  if (reg->bitfields.CRTC2_VSYNC_STAT != crtc2_vsync_stat) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::CRTC2_VSYNC_STAT data too large\n");
}
__inline void set_GEN_INT_STATUS_snapshot2_stat(regGEN_INT_STATUS *reg, unsigned int snapshot2_stat)
{
  reg->bitfields.SNAPSHOT2_STAT = snapshot2_stat;
  if (reg->bitfields.SNAPSHOT2_STAT != snapshot2_stat) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::SNAPSHOT2_STAT data too large\n");
}
__inline void set_GEN_INT_STATUS_cap0_int_active(regGEN_INT_STATUS *reg, unsigned int cap0_int_active)
{
  reg->bitfields.CAP0_INT_ACTIVE = cap0_int_active;
  if (reg->bitfields.CAP0_INT_ACTIVE != cap0_int_active) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::CAP0_INT_ACTIVE data too large\n");
}
__inline void set_GEN_INT_STATUS_crtc2_vblank_stat(regGEN_INT_STATUS *reg, unsigned int crtc2_vblank_stat)
{
  reg->bitfields.CRTC2_VBLANK_STAT = crtc2_vblank_stat;
  if (reg->bitfields.CRTC2_VBLANK_STAT != crtc2_vblank_stat) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::CRTC2_VBLANK_STAT data too large\n");
}
__inline void set_GEN_INT_STATUS_fp2_detect_stat(regGEN_INT_STATUS *reg, unsigned int fp2_detect_stat)
{
  reg->bitfields.FP2_DETECT_STAT = fp2_detect_stat;
  if (reg->bitfields.FP2_DETECT_STAT != fp2_detect_stat) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::FP2_DETECT_STAT data too large\n");
}
__inline void set_GEN_INT_STATUS_dma_viph0_int(regGEN_INT_STATUS *reg, unsigned int dma_viph0_int)
{
  reg->bitfields.DMA_VIPH0_INT = dma_viph0_int;
  if (reg->bitfields.DMA_VIPH0_INT != dma_viph0_int) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::DMA_VIPH0_INT data too large\n");
}
__inline void set_GEN_INT_STATUS_dma_viph1_int(regGEN_INT_STATUS *reg, unsigned int dma_viph1_int)
{
  reg->bitfields.DMA_VIPH1_INT = dma_viph1_int;
  if (reg->bitfields.DMA_VIPH1_INT != dma_viph1_int) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::DMA_VIPH1_INT data too large\n");
}
__inline void set_GEN_INT_STATUS_dma_viph2_int(regGEN_INT_STATUS *reg, unsigned int dma_viph2_int)
{
  reg->bitfields.DMA_VIPH2_INT = dma_viph2_int;
  if (reg->bitfields.DMA_VIPH2_INT != dma_viph2_int) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::DMA_VIPH2_INT data too large\n");
}
__inline void set_GEN_INT_STATUS_dma_viph3_int(regGEN_INT_STATUS *reg, unsigned int dma_viph3_int)
{
  reg->bitfields.DMA_VIPH3_INT = dma_viph3_int;
  if (reg->bitfields.DMA_VIPH3_INT != dma_viph3_int) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::DMA_VIPH3_INT data too large\n");
}
__inline void set_GEN_INT_STATUS_timer_int_stat(regGEN_INT_STATUS *reg, unsigned int timer_int_stat)
{
  reg->bitfields.TIMER_INT_STAT = timer_int_stat;
  if (reg->bitfields.TIMER_INT_STAT != timer_int_stat) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::TIMER_INT_STAT data too large\n");
}
__inline void set_GEN_INT_STATUS_i2c_int(regGEN_INT_STATUS *reg, unsigned int i2c_int)
{
  reg->bitfields.I2C_INT = i2c_int;
  if (reg->bitfields.I2C_INT != i2c_int) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::I2C_INT data too large\n");
}
__inline void set_GEN_INT_STATUS_gui_idle_stat(regGEN_INT_STATUS *reg, unsigned int gui_idle_stat)
{
  reg->bitfields.GUI_IDLE_STAT = gui_idle_stat;
  if (reg->bitfields.GUI_IDLE_STAT != gui_idle_stat) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::GUI_IDLE_STAT data too large\n");
}
__inline void set_GEN_INT_STATUS_viph_int(regGEN_INT_STATUS *reg, unsigned int viph_int)
{
  reg->bitfields.VIPH_INT = viph_int;
  if (reg->bitfields.VIPH_INT != viph_int) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::VIPH_INT data too large\n");
}
__inline void set_GEN_INT_STATUS_sw_int(regGEN_INT_STATUS *reg, unsigned int sw_int)
{
  reg->bitfields.SW_INT = sw_int;
  if (reg->bitfields.SW_INT != sw_int) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::SW_INT data too large\n");
}
__inline void set_GEN_INT_STATUS_sw_int_set(regGEN_INT_STATUS *reg, unsigned int sw_int_set)
{
  reg->bitfields.SW_INT_SET = sw_int_set;
  if (reg->bitfields.SW_INT_SET != sw_int_set) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::SW_INT_SET data too large\n");
}
__inline void set_GEN_INT_STATUS_hdcp_authorized_int_stat(regGEN_INT_STATUS *reg, unsigned int hdcp_authorized_int_stat)
{
  reg->bitfields.HDCP_AUTHORIZED_INT_STAT = hdcp_authorized_int_stat;
  if (reg->bitfields.HDCP_AUTHORIZED_INT_STAT != hdcp_authorized_int_stat) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::HDCP_AUTHORIZED_INT_STAT data too large\n");
}
__inline void set_GEN_INT_STATUS_dvi_i2c_int_stat(regGEN_INT_STATUS *reg, unsigned int dvi_i2c_int_stat)
{
  reg->bitfields.DVI_I2C_INT_STAT = dvi_i2c_int_stat;
  if (reg->bitfields.DVI_I2C_INT_STAT != dvi_i2c_int_stat) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::DVI_I2C_INT_STAT data too large\n");
}
__inline void set_GEN_INT_STATUS_guidma_stat(regGEN_INT_STATUS *reg, unsigned int guidma_stat)
{
  reg->bitfields.GUIDMA_STAT = guidma_stat;
  if (reg->bitfields.GUIDMA_STAT != guidma_stat) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::GUIDMA_STAT data too large\n");
}
__inline void set_GEN_INT_STATUS_viddma_stat(regGEN_INT_STATUS *reg, unsigned int viddma_stat)
{
  reg->bitfields.VIDDMA_STAT = viddma_stat;
  if (reg->bitfields.VIDDMA_STAT != viddma_stat) HSLDPF(E_ERROR_MESSAGE,"GEN_INT_STATUS::VIDDMA_STAT data too large\n");
}
#else
#define set_GEN_INT_STATUS_crtc_vblank_stat(reg, crtc_vblank_stat) (reg)->bitfields.CRTC_VBLANK_STAT = crtc_vblank_stat
#define set_GEN_INT_STATUS_crtc_vline_stat(reg, crtc_vline_stat) (reg)->bitfields.CRTC_VLINE_STAT = crtc_vline_stat
#define set_GEN_INT_STATUS_crtc_vsync_stat(reg, crtc_vsync_stat) (reg)->bitfields.CRTC_VSYNC_STAT = crtc_vsync_stat
#define set_GEN_INT_STATUS_snapshot_stat(reg, snapshot_stat) (reg)->bitfields.SNAPSHOT_STAT = snapshot_stat
#define set_GEN_INT_STATUS_fp_detect_stat(reg, fp_detect_stat) (reg)->bitfields.FP_DETECT_STAT = fp_detect_stat
#define set_GEN_INT_STATUS_crtc2_vline_stat(reg, crtc2_vline_stat) (reg)->bitfields.CRTC2_VLINE_STAT = crtc2_vline_stat
#define set_GEN_INT_STATUS_crtc2_vsync_stat(reg, crtc2_vsync_stat) (reg)->bitfields.CRTC2_VSYNC_STAT = crtc2_vsync_stat
#define set_GEN_INT_STATUS_snapshot2_stat(reg, snapshot2_stat) (reg)->bitfields.SNAPSHOT2_STAT = snapshot2_stat
#define set_GEN_INT_STATUS_cap0_int_active(reg, cap0_int_active) (reg)->bitfields.CAP0_INT_ACTIVE = cap0_int_active
#define set_GEN_INT_STATUS_crtc2_vblank_stat(reg, crtc2_vblank_stat) (reg)->bitfields.CRTC2_VBLANK_STAT = crtc2_vblank_stat
#define set_GEN_INT_STATUS_fp2_detect_stat(reg, fp2_detect_stat) (reg)->bitfields.FP2_DETECT_STAT = fp2_detect_stat
#define set_GEN_INT_STATUS_dma_viph0_int(reg, dma_viph0_int) (reg)->bitfields.DMA_VIPH0_INT = dma_viph0_int
#define set_GEN_INT_STATUS_dma_viph1_int(reg, dma_viph1_int) (reg)->bitfields.DMA_VIPH1_INT = dma_viph1_int
#define set_GEN_INT_STATUS_dma_viph2_int(reg, dma_viph2_int) (reg)->bitfields.DMA_VIPH2_INT = dma_viph2_int
#define set_GEN_INT_STATUS_dma_viph3_int(reg, dma_viph3_int) (reg)->bitfields.DMA_VIPH3_INT = dma_viph3_int
#define set_GEN_INT_STATUS_timer_int_stat(reg, timer_int_stat) (reg)->bitfields.TIMER_INT_STAT = timer_int_stat
#define set_GEN_INT_STATUS_i2c_int(reg, i2c_int) (reg)->bitfields.I2C_INT = i2c_int
#define set_GEN_INT_STATUS_gui_idle_stat(reg, gui_idle_stat) (reg)->bitfields.GUI_IDLE_STAT = gui_idle_stat
#define set_GEN_INT_STATUS_viph_int(reg, viph_int) (reg)->bitfields.VIPH_INT = viph_int
#define set_GEN_INT_STATUS_sw_int(reg, sw_int) (reg)->bitfields.SW_INT = sw_int
#define set_GEN_INT_STATUS_sw_int_set(reg, sw_int_set) (reg)->bitfields.SW_INT_SET = sw_int_set
#define set_GEN_INT_STATUS_hdcp_authorized_int_stat(reg, hdcp_authorized_int_stat) (reg)->bitfields.HDCP_AUTHORIZED_INT_STAT = hdcp_authorized_int_stat
#define set_GEN_INT_STATUS_dvi_i2c_int_stat(reg, dvi_i2c_int_stat) (reg)->bitfields.DVI_I2C_INT_STAT = dvi_i2c_int_stat
#define set_GEN_INT_STATUS_guidma_stat(reg, guidma_stat) (reg)->bitfields.GUIDMA_STAT = guidma_stat
#define set_GEN_INT_STATUS_viddma_stat(reg, viddma_stat) (reg)->bitfields.VIDDMA_STAT = viddma_stat

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union r200VCLK_ECP_CNTL regr200VCLK_ECP_CNTL;

#ifdef DEBUG
__inline void set_r200VCLK_ECP_CNTL_vclk_src_sel(regr200VCLK_ECP_CNTL *reg, unsigned int vclk_src_sel)
{
  reg->bitfields.VCLK_SRC_SEL = vclk_src_sel;
  if (reg->bitfields.VCLK_SRC_SEL != vclk_src_sel) HSLDPF(E_ERROR_MESSAGE,"r200VCLK_ECP_CNTL::VCLK_SRC_SEL data too large\n");
}
__inline void set_r200VCLK_ECP_CNTL_vclk_invert(regr200VCLK_ECP_CNTL *reg, unsigned int vclk_invert)
{
  reg->bitfields.VCLK_INVERT = vclk_invert;
  if (reg->bitfields.VCLK_INVERT != vclk_invert) HSLDPF(E_ERROR_MESSAGE,"r200VCLK_ECP_CNTL::VCLK_INVERT data too large\n");
}
__inline void set_r200VCLK_ECP_CNTL_pciclk_invert(regr200VCLK_ECP_CNTL *reg, unsigned int pciclk_invert)
{
  reg->bitfields.PCICLK_INVERT = pciclk_invert;
  if (reg->bitfields.PCICLK_INVERT != pciclk_invert) HSLDPF(E_ERROR_MESSAGE,"r200VCLK_ECP_CNTL::PCICLK_INVERT data too large\n");
}
__inline void set_r200VCLK_ECP_CNTL_pixclk_always_onb(regr200VCLK_ECP_CNTL *reg, unsigned int pixclk_always_onb)
{
  reg->bitfields.PIXCLK_ALWAYS_ONb = pixclk_always_onb;
  if (reg->bitfields.PIXCLK_ALWAYS_ONb != pixclk_always_onb) HSLDPF(E_ERROR_MESSAGE,"r200VCLK_ECP_CNTL::PIXCLK_ALWAYS_ONb data too large\n");
}
__inline void set_r200VCLK_ECP_CNTL_pixclk_dac_always_onb(regr200VCLK_ECP_CNTL *reg, unsigned int pixclk_dac_always_onb)
{
  reg->bitfields.PIXCLK_DAC_ALWAYS_ONb = pixclk_dac_always_onb;
  if (reg->bitfields.PIXCLK_DAC_ALWAYS_ONb != pixclk_dac_always_onb) HSLDPF(E_ERROR_MESSAGE,"r200VCLK_ECP_CNTL::PIXCLK_DAC_ALWAYS_ONb data too large\n");
}
__inline void set_r200VCLK_ECP_CNTL_ecp_div(regr200VCLK_ECP_CNTL *reg, unsigned int ecp_div)
{
  reg->bitfields.ECP_DIV = ecp_div;
  if (reg->bitfields.ECP_DIV != ecp_div) HSLDPF(E_ERROR_MESSAGE,"r200VCLK_ECP_CNTL::ECP_DIV data too large\n");
}
__inline void set_r200VCLK_ECP_CNTL_byte_clk_post_div(regr200VCLK_ECP_CNTL *reg, unsigned int byte_clk_post_div)
{
  reg->bitfields.BYTE_CLK_POST_DIV = byte_clk_post_div;
  if (reg->bitfields.BYTE_CLK_POST_DIV != byte_clk_post_div) HSLDPF(E_ERROR_MESSAGE,"r200VCLK_ECP_CNTL::BYTE_CLK_POST_DIV data too large\n");
}
__inline void set_r200VCLK_ECP_CNTL_ecp_force_on(regr200VCLK_ECP_CNTL *reg, unsigned int ecp_force_on)
{
  reg->bitfields.ECP_FORCE_ON = ecp_force_on;
  if (reg->bitfields.ECP_FORCE_ON != ecp_force_on) HSLDPF(E_ERROR_MESSAGE,"r200VCLK_ECP_CNTL::ECP_FORCE_ON data too large\n");
}
__inline void set_r200VCLK_ECP_CNTL_subclk_force_on(regr200VCLK_ECP_CNTL *reg, unsigned int subclk_force_on)
{
  reg->bitfields.SUBCLK_FORCE_ON = subclk_force_on;
  if (reg->bitfields.SUBCLK_FORCE_ON != subclk_force_on) HSLDPF(E_ERROR_MESSAGE,"r200VCLK_ECP_CNTL::SUBCLK_FORCE_ON data too large\n");
}
__inline void set_r200VCLK_ECP_CNTL_byte_clk_out_en(regr200VCLK_ECP_CNTL *reg, unsigned int byte_clk_out_en)
{
  reg->bitfields.BYTE_CLK_OUT_EN = byte_clk_out_en;
  if (reg->bitfields.BYTE_CLK_OUT_EN != byte_clk_out_en) HSLDPF(E_ERROR_MESSAGE,"r200VCLK_ECP_CNTL::BYTE_CLK_OUT_EN data too large\n");
}
__inline void set_r200VCLK_ECP_CNTL_byte_clk_skew(regr200VCLK_ECP_CNTL *reg, unsigned int byte_clk_skew)
{
  reg->bitfields.BYTE_CLK_SKEW = byte_clk_skew;
  if (reg->bitfields.BYTE_CLK_SKEW != byte_clk_skew) HSLDPF(E_ERROR_MESSAGE,"r200VCLK_ECP_CNTL::BYTE_CLK_SKEW data too large\n");
}
#else
#define set_r200VCLK_ECP_CNTL_vclk_src_sel(reg, vclk_src_sel) (reg)->bitfields.VCLK_SRC_SEL = vclk_src_sel
#define set_r200VCLK_ECP_CNTL_vclk_invert(reg, vclk_invert) (reg)->bitfields.VCLK_INVERT = vclk_invert
#define set_r200VCLK_ECP_CNTL_pciclk_invert(reg, pciclk_invert) (reg)->bitfields.PCICLK_INVERT = pciclk_invert
#define set_r200VCLK_ECP_CNTL_pixclk_always_onb(reg, pixclk_always_onb) (reg)->bitfields.PIXCLK_ALWAYS_ONb = pixclk_always_onb
#define set_r200VCLK_ECP_CNTL_pixclk_dac_always_onb(reg, pixclk_dac_always_onb) (reg)->bitfields.PIXCLK_DAC_ALWAYS_ONb = pixclk_dac_always_onb
#define set_r200VCLK_ECP_CNTL_ecp_div(reg, ecp_div) (reg)->bitfields.ECP_DIV = ecp_div
#define set_r200VCLK_ECP_CNTL_byte_clk_post_div(reg, byte_clk_post_div) (reg)->bitfields.BYTE_CLK_POST_DIV = byte_clk_post_div
#define set_r200VCLK_ECP_CNTL_ecp_force_on(reg, ecp_force_on) (reg)->bitfields.ECP_FORCE_ON = ecp_force_on
#define set_r200VCLK_ECP_CNTL_subclk_force_on(reg, subclk_force_on) (reg)->bitfields.SUBCLK_FORCE_ON = subclk_force_on
#define set_r200VCLK_ECP_CNTL_byte_clk_out_en(reg, byte_clk_out_en) (reg)->bitfields.BYTE_CLK_OUT_EN = byte_clk_out_en
#define set_r200VCLK_ECP_CNTL_byte_clk_skew(reg, byte_clk_skew) (reg)->bitfields.BYTE_CLK_SKEW = byte_clk_skew

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union BYTE_CLK_AUX_CNTL regBYTE_CLK_AUX_CNTL;

#ifdef DEBUG
__inline void set_BYTE_CLK_AUX_CNTL_io_bytclk_src_sel(regBYTE_CLK_AUX_CNTL *reg, unsigned int io_bytclk_src_sel)
{
  reg->bitfields.IO_BYTCLK_SRC_SEL = io_bytclk_src_sel;
  if (reg->bitfields.IO_BYTCLK_SRC_SEL != io_bytclk_src_sel) HSLDPF(E_ERROR_MESSAGE,"BYTE_CLK_AUX_CNTL::IO_BYTCLK_SRC_SEL data too large\n");
}
__inline void set_BYTE_CLK_AUX_CNTL_tv_bytclk_src_sel(regBYTE_CLK_AUX_CNTL *reg, unsigned int tv_bytclk_src_sel)
{
  reg->bitfields.TV_BYTCLK_SRC_SEL = tv_bytclk_src_sel;
  if (reg->bitfields.TV_BYTCLK_SRC_SEL != tv_bytclk_src_sel) HSLDPF(E_ERROR_MESSAGE,"BYTE_CLK_AUX_CNTL::TV_BYTCLK_SRC_SEL data too large\n");
}
__inline void set_BYTE_CLK_AUX_CNTL_io_bytclk_skw_ctl(regBYTE_CLK_AUX_CNTL *reg, unsigned int io_bytclk_skw_ctl)
{
  reg->bitfields.IO_BYTCLK_SKW_CTL = io_bytclk_skw_ctl;
  if (reg->bitfields.IO_BYTCLK_SKW_CTL != io_bytclk_skw_ctl) HSLDPF(E_ERROR_MESSAGE,"BYTE_CLK_AUX_CNTL::IO_BYTCLK_SKW_CTL data too large\n");
}
__inline void set_BYTE_CLK_AUX_CNTL_tv_bytclk_skw_ctl(regBYTE_CLK_AUX_CNTL *reg, unsigned int tv_bytclk_skw_ctl)
{
  reg->bitfields.TV_BYTCLK_SKW_CTL = tv_bytclk_skw_ctl;
  if (reg->bitfields.TV_BYTCLK_SKW_CTL != tv_bytclk_skw_ctl) HSLDPF(E_ERROR_MESSAGE,"BYTE_CLK_AUX_CNTL::TV_BYTCLK_SKW_CTL data too large\n");
}
#else
#define set_BYTE_CLK_AUX_CNTL_io_bytclk_src_sel(reg, io_bytclk_src_sel) (reg)->bitfields.IO_BYTCLK_SRC_SEL = io_bytclk_src_sel
#define set_BYTE_CLK_AUX_CNTL_tv_bytclk_src_sel(reg, tv_bytclk_src_sel) (reg)->bitfields.TV_BYTCLK_SRC_SEL = tv_bytclk_src_sel
#define set_BYTE_CLK_AUX_CNTL_io_bytclk_skw_ctl(reg, io_bytclk_skw_ctl) (reg)->bitfields.IO_BYTCLK_SKW_CTL = io_bytclk_skw_ctl
#define set_BYTE_CLK_AUX_CNTL_tv_bytclk_skw_ctl(reg, tv_bytclk_skw_ctl) (reg)->bitfields.TV_BYTCLK_SKW_CTL = tv_bytclk_skw_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union r200DISP_TEST_MACRO_RW_CNTL regr200DISP_TEST_MACRO_RW_CNTL;

#ifdef DEBUG
__inline void set_r200DISP_TEST_MACRO_RW_CNTL_test_macro_rw_start(regr200DISP_TEST_MACRO_RW_CNTL *reg, unsigned int test_macro_rw_start)
{
  reg->bitfields.TEST_MACRO_RW_START = test_macro_rw_start;
  if (reg->bitfields.TEST_MACRO_RW_START != test_macro_rw_start) HSLDPF(E_ERROR_MESSAGE,"r200DISP_TEST_MACRO_RW_CNTL::TEST_MACRO_RW_START data too large\n");
}
__inline void set_r200DISP_TEST_MACRO_RW_CNTL_test_macro_rw_op(regr200DISP_TEST_MACRO_RW_CNTL *reg, unsigned int test_macro_rw_op)
{
  reg->bitfields.TEST_MACRO_RW_OP = test_macro_rw_op;
  if (reg->bitfields.TEST_MACRO_RW_OP != test_macro_rw_op) HSLDPF(E_ERROR_MESSAGE,"r200DISP_TEST_MACRO_RW_CNTL::TEST_MACRO_RW_OP data too large\n");
}
__inline void set_r200DISP_TEST_MACRO_RW_CNTL_test_macro_rw_mode(regr200DISP_TEST_MACRO_RW_CNTL *reg, unsigned int test_macro_rw_mode)
{
  reg->bitfields.TEST_MACRO_RW_MODE = test_macro_rw_mode;
  if (reg->bitfields.TEST_MACRO_RW_MODE != test_macro_rw_mode) HSLDPF(E_ERROR_MESSAGE,"r200DISP_TEST_MACRO_RW_CNTL::TEST_MACRO_RW_MODE data too large\n");
}
__inline void set_r200DISP_TEST_MACRO_RW_CNTL_test_macro_rw_mismatch_sel(regr200DISP_TEST_MACRO_RW_CNTL *reg, unsigned int test_macro_rw_mismatch_sel)
{
  reg->bitfields.TEST_MACRO_RW_MISMATCH_SEL = test_macro_rw_mismatch_sel;
  if (reg->bitfields.TEST_MACRO_RW_MISMATCH_SEL != test_macro_rw_mismatch_sel) HSLDPF(E_ERROR_MESSAGE,"r200DISP_TEST_MACRO_RW_CNTL::TEST_MACRO_RW_MISMATCH_SEL data too large\n");
}
__inline void set_r200DISP_TEST_MACRO_RW_CNTL_test_macro_rw_mismatch(regr200DISP_TEST_MACRO_RW_CNTL *reg, unsigned int test_macro_rw_mismatch)
{
  reg->bitfields.TEST_MACRO_RW_MISMATCH = test_macro_rw_mismatch;
  if (reg->bitfields.TEST_MACRO_RW_MISMATCH != test_macro_rw_mismatch) HSLDPF(E_ERROR_MESSAGE,"r200DISP_TEST_MACRO_RW_CNTL::TEST_MACRO_RW_MISMATCH data too large\n");
}
__inline void set_r200DISP_TEST_MACRO_RW_CNTL_test_macro_rw_enable(regr200DISP_TEST_MACRO_RW_CNTL *reg, unsigned int test_macro_rw_enable)
{
  reg->bitfields.TEST_MACRO_RW_ENABLE = test_macro_rw_enable;
  if (reg->bitfields.TEST_MACRO_RW_ENABLE != test_macro_rw_enable) HSLDPF(E_ERROR_MESSAGE,"r200DISP_TEST_MACRO_RW_CNTL::TEST_MACRO_RW_ENABLE data too large\n");
}
__inline void set_r200DISP_TEST_MACRO_RW_CNTL_test_macro_rw_sclk_neg_enable(regr200DISP_TEST_MACRO_RW_CNTL *reg, unsigned int test_macro_rw_sclk_neg_enable)
{
  reg->bitfields.TEST_MACRO_RW_SCLK_NEG_ENABLE = test_macro_rw_sclk_neg_enable;
  if (reg->bitfields.TEST_MACRO_RW_SCLK_NEG_ENABLE != test_macro_rw_sclk_neg_enable) HSLDPF(E_ERROR_MESSAGE,"r200DISP_TEST_MACRO_RW_CNTL::TEST_MACRO_RW_SCLK_NEG_ENABLE data too large\n");
}
__inline void set_r200DISP_TEST_MACRO_RW_CNTL_test_altclk_enable(regr200DISP_TEST_MACRO_RW_CNTL *reg, unsigned int test_altclk_enable)
{
  reg->bitfields.TEST_ALTCLK_ENABLE = test_altclk_enable;
  if (reg->bitfields.TEST_ALTCLK_ENABLE != test_altclk_enable) HSLDPF(E_ERROR_MESSAGE,"r200DISP_TEST_MACRO_RW_CNTL::TEST_ALTCLK_ENABLE data too large\n");
}
#else
#define set_r200DISP_TEST_MACRO_RW_CNTL_test_macro_rw_start(reg, test_macro_rw_start) (reg)->bitfields.TEST_MACRO_RW_START = test_macro_rw_start
#define set_r200DISP_TEST_MACRO_RW_CNTL_test_macro_rw_op(reg, test_macro_rw_op) (reg)->bitfields.TEST_MACRO_RW_OP = test_macro_rw_op
#define set_r200DISP_TEST_MACRO_RW_CNTL_test_macro_rw_mode(reg, test_macro_rw_mode) (reg)->bitfields.TEST_MACRO_RW_MODE = test_macro_rw_mode
#define set_r200DISP_TEST_MACRO_RW_CNTL_test_macro_rw_mismatch_sel(reg, test_macro_rw_mismatch_sel) (reg)->bitfields.TEST_MACRO_RW_MISMATCH_SEL = test_macro_rw_mismatch_sel
#define set_r200DISP_TEST_MACRO_RW_CNTL_test_macro_rw_mismatch(reg, test_macro_rw_mismatch) (reg)->bitfields.TEST_MACRO_RW_MISMATCH = test_macro_rw_mismatch
#define set_r200DISP_TEST_MACRO_RW_CNTL_test_macro_rw_enable(reg, test_macro_rw_enable) (reg)->bitfields.TEST_MACRO_RW_ENABLE = test_macro_rw_enable
#define set_r200DISP_TEST_MACRO_RW_CNTL_test_macro_rw_sclk_neg_enable(reg, test_macro_rw_sclk_neg_enable) (reg)->bitfields.TEST_MACRO_RW_SCLK_NEG_ENABLE = test_macro_rw_sclk_neg_enable
#define set_r200DISP_TEST_MACRO_RW_CNTL_test_altclk_enable(reg, test_altclk_enable) (reg)->bitfields.TEST_ALTCLK_ENABLE = test_altclk_enable

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union r200PIXCLKS_CNTL regr200PIXCLKS_CNTL;

#ifdef DEBUG
__inline void set_r200PIXCLKS_CNTL_pix2clk_src_sel(regr200PIXCLKS_CNTL *reg, unsigned int pix2clk_src_sel)
{
  reg->bitfields.PIX2CLK_SRC_SEL = pix2clk_src_sel;
  if (reg->bitfields.PIX2CLK_SRC_SEL != pix2clk_src_sel) HSLDPF(E_ERROR_MESSAGE,"r200PIXCLKS_CNTL::PIX2CLK_SRC_SEL data too large\n");
}
__inline void set_r200PIXCLKS_CNTL_pix2clk_invert(regr200PIXCLKS_CNTL *reg, unsigned int pix2clk_invert)
{
  reg->bitfields.PIX2CLK_INVERT = pix2clk_invert;
  if (reg->bitfields.PIX2CLK_INVERT != pix2clk_invert) HSLDPF(E_ERROR_MESSAGE,"r200PIXCLKS_CNTL::PIX2CLK_INVERT data too large\n");
}
__inline void set_r200PIXCLKS_CNTL_pciclk_invert(regr200PIXCLKS_CNTL *reg, unsigned int pciclk_invert)
{
  reg->bitfields.PCICLK_INVERT = pciclk_invert;
  if (reg->bitfields.PCICLK_INVERT != pciclk_invert) HSLDPF(E_ERROR_MESSAGE,"r200PIXCLKS_CNTL::PCICLK_INVERT data too large\n");
}
__inline void set_r200PIXCLKS_CNTL_pix2clk_always_onb(regr200PIXCLKS_CNTL *reg, unsigned int pix2clk_always_onb)
{
  reg->bitfields.PIX2CLK_ALWAYS_ONb = pix2clk_always_onb;
  if (reg->bitfields.PIX2CLK_ALWAYS_ONb != pix2clk_always_onb) HSLDPF(E_ERROR_MESSAGE,"r200PIXCLKS_CNTL::PIX2CLK_ALWAYS_ONb data too large\n");
}
__inline void set_r200PIXCLKS_CNTL_pix2clk_dac_always_onb(regr200PIXCLKS_CNTL *reg, unsigned int pix2clk_dac_always_onb)
{
  reg->bitfields.PIX2CLK_DAC_ALWAYS_ONb = pix2clk_dac_always_onb;
  if (reg->bitfields.PIX2CLK_DAC_ALWAYS_ONb != pix2clk_dac_always_onb) HSLDPF(E_ERROR_MESSAGE,"r200PIXCLKS_CNTL::PIX2CLK_DAC_ALWAYS_ONb data too large\n");
}
__inline void set_r200PIXCLKS_CNTL_pixclk_tv_src_sel(regr200PIXCLKS_CNTL *reg, unsigned int pixclk_tv_src_sel)
{
  reg->bitfields.PIXCLK_TV_SRC_SEL = pixclk_tv_src_sel;
  if (reg->bitfields.PIXCLK_TV_SRC_SEL != pixclk_tv_src_sel) HSLDPF(E_ERROR_MESSAGE,"r200PIXCLKS_CNTL::PIXCLK_TV_SRC_SEL data too large\n");
}
__inline void set_r200PIXCLKS_CNTL_dvoclk_always_onb(regr200PIXCLKS_CNTL *reg, unsigned int dvoclk_always_onb)
{
  reg->bitfields.DVOCLK_ALWAYS_ONb = dvoclk_always_onb;
  if (reg->bitfields.DVOCLK_ALWAYS_ONb != dvoclk_always_onb) HSLDPF(E_ERROR_MESSAGE,"r200PIXCLKS_CNTL::DVOCLK_ALWAYS_ONb data too large\n");
}
__inline void set_r200PIXCLKS_CNTL_pixclk_blend_always_onb(regr200PIXCLKS_CNTL *reg, unsigned int pixclk_blend_always_onb)
{
  reg->bitfields.PIXCLK_BLEND_ALWAYS_ONb = pixclk_blend_always_onb;
  if (reg->bitfields.PIXCLK_BLEND_ALWAYS_ONb != pixclk_blend_always_onb) HSLDPF(E_ERROR_MESSAGE,"r200PIXCLKS_CNTL::PIXCLK_BLEND_ALWAYS_ONb data too large\n");
}
__inline void set_r200PIXCLKS_CNTL_pixclk_gv_always_onb(regr200PIXCLKS_CNTL *reg, unsigned int pixclk_gv_always_onb)
{
  reg->bitfields.PIXCLK_GV_ALWAYS_ONb = pixclk_gv_always_onb;
  if (reg->bitfields.PIXCLK_GV_ALWAYS_ONb != pixclk_gv_always_onb) HSLDPF(E_ERROR_MESSAGE,"r200PIXCLKS_CNTL::PIXCLK_GV_ALWAYS_ONb data too large\n");
}
__inline void set_r200PIXCLKS_CNTL_pixclk_dvo_always_onb(regr200PIXCLKS_CNTL *reg, unsigned int pixclk_dvo_always_onb)
{
  reg->bitfields.PIXCLK_DVO_ALWAYS_ONb = pixclk_dvo_always_onb;
  if (reg->bitfields.PIXCLK_DVO_ALWAYS_ONb != pixclk_dvo_always_onb) HSLDPF(E_ERROR_MESSAGE,"r200PIXCLKS_CNTL::PIXCLK_DVO_ALWAYS_ONb data too large\n");
}
__inline void set_r200PIXCLKS_CNTL_pixclk_tmds_always_onb(regr200PIXCLKS_CNTL *reg, unsigned int pixclk_tmds_always_onb)
{
  reg->bitfields.PIXCLK_TMDS_ALWAYS_ONb = pixclk_tmds_always_onb;
  if (reg->bitfields.PIXCLK_TMDS_ALWAYS_ONb != pixclk_tmds_always_onb) HSLDPF(E_ERROR_MESSAGE,"r200PIXCLKS_CNTL::PIXCLK_TMDS_ALWAYS_ONb data too large\n");
}
__inline void set_r200PIXCLKS_CNTL_pixclk_trans_always_onb(regr200PIXCLKS_CNTL *reg, unsigned int pixclk_trans_always_onb)
{
  reg->bitfields.PIXCLK_TRANS_ALWAYS_ONb = pixclk_trans_always_onb;
  if (reg->bitfields.PIXCLK_TRANS_ALWAYS_ONb != pixclk_trans_always_onb) HSLDPF(E_ERROR_MESSAGE,"r200PIXCLKS_CNTL::PIXCLK_TRANS_ALWAYS_ONb data too large\n");
}
__inline void set_r200PIXCLKS_CNTL_pixclk_tvo_always_onb(regr200PIXCLKS_CNTL *reg, unsigned int pixclk_tvo_always_onb)
{
  reg->bitfields.PIXCLK_TVO_ALWAYS_ONb = pixclk_tvo_always_onb;
  if (reg->bitfields.PIXCLK_TVO_ALWAYS_ONb != pixclk_tvo_always_onb) HSLDPF(E_ERROR_MESSAGE,"r200PIXCLKS_CNTL::PIXCLK_TVO_ALWAYS_ONb data too large\n");
}
__inline void set_r200PIXCLKS_CNTL_p2gclk_always_onb(regr200PIXCLKS_CNTL *reg, unsigned int p2gclk_always_onb)
{
  reg->bitfields.P2GCLK_ALWAYS_ONb = p2gclk_always_onb;
  if (reg->bitfields.P2GCLK_ALWAYS_ONb != p2gclk_always_onb) HSLDPF(E_ERROR_MESSAGE,"r200PIXCLKS_CNTL::P2GCLK_ALWAYS_ONb data too large\n");
}
__inline void set_r200PIXCLKS_CNTL_p2g2clk_always_onb(regr200PIXCLKS_CNTL *reg, unsigned int p2g2clk_always_onb)
{
  reg->bitfields.P2G2CLK_ALWAYS_ONb = p2g2clk_always_onb;
  if (reg->bitfields.P2G2CLK_ALWAYS_ONb != p2g2clk_always_onb) HSLDPF(E_ERROR_MESSAGE,"r200PIXCLKS_CNTL::P2G2CLK_ALWAYS_ONb data too large\n");
}
__inline void set_r200PIXCLKS_CNTL_dvoclkc_src_sel(regr200PIXCLKS_CNTL *reg, unsigned int dvoclkc_src_sel)
{
  reg->bitfields.DVOCLKC_SRC_SEL = dvoclkc_src_sel;
  if (reg->bitfields.DVOCLKC_SRC_SEL != dvoclkc_src_sel) HSLDPF(E_ERROR_MESSAGE,"r200PIXCLKS_CNTL::DVOCLKC_SRC_SEL data too large\n");
}
__inline void set_r200PIXCLKS_CNTL_dvoclkd_src_sel(regr200PIXCLKS_CNTL *reg, unsigned int dvoclkd_src_sel)
{
  reg->bitfields.DVOCLKD_SRC_SEL = dvoclkd_src_sel;
  if (reg->bitfields.DVOCLKD_SRC_SEL != dvoclkd_src_sel) HSLDPF(E_ERROR_MESSAGE,"r200PIXCLKS_CNTL::DVOCLKD_SRC_SEL data too large\n");
}
__inline void set_r200PIXCLKS_CNTL_dvoclkc_skw_ctl(regr200PIXCLKS_CNTL *reg, unsigned int dvoclkc_skw_ctl)
{
  reg->bitfields.DVOCLKC_SKW_CTL = dvoclkc_skw_ctl;
  if (reg->bitfields.DVOCLKC_SKW_CTL != dvoclkc_skw_ctl) HSLDPF(E_ERROR_MESSAGE,"r200PIXCLKS_CNTL::DVOCLKC_SKW_CTL data too large\n");
}
__inline void set_r200PIXCLKS_CNTL_dvoclkd_skw_ctl(regr200PIXCLKS_CNTL *reg, unsigned int dvoclkd_skw_ctl)
{
  reg->bitfields.DVOCLKD_SKW_CTL = dvoclkd_skw_ctl;
  if (reg->bitfields.DVOCLKD_SKW_CTL != dvoclkd_skw_ctl) HSLDPF(E_ERROR_MESSAGE,"r200PIXCLKS_CNTL::DVOCLKD_SKW_CTL data too large\n");
}
#else
#define set_r200PIXCLKS_CNTL_pix2clk_src_sel(reg, pix2clk_src_sel) (reg)->bitfields.PIX2CLK_SRC_SEL = pix2clk_src_sel
#define set_r200PIXCLKS_CNTL_pix2clk_invert(reg, pix2clk_invert) (reg)->bitfields.PIX2CLK_INVERT = pix2clk_invert
#define set_r200PIXCLKS_CNTL_pciclk_invert(reg, pciclk_invert) (reg)->bitfields.PCICLK_INVERT = pciclk_invert
#define set_r200PIXCLKS_CNTL_pix2clk_always_onb(reg, pix2clk_always_onb) (reg)->bitfields.PIX2CLK_ALWAYS_ONb = pix2clk_always_onb
#define set_r200PIXCLKS_CNTL_pix2clk_dac_always_onb(reg, pix2clk_dac_always_onb) (reg)->bitfields.PIX2CLK_DAC_ALWAYS_ONb = pix2clk_dac_always_onb
#define set_r200PIXCLKS_CNTL_pixclk_tv_src_sel(reg, pixclk_tv_src_sel) (reg)->bitfields.PIXCLK_TV_SRC_SEL = pixclk_tv_src_sel
#define set_r200PIXCLKS_CNTL_dvoclk_always_onb(reg, dvoclk_always_onb) (reg)->bitfields.DVOCLK_ALWAYS_ONb = dvoclk_always_onb
#define set_r200PIXCLKS_CNTL_pixclk_blend_always_onb(reg, pixclk_blend_always_onb) (reg)->bitfields.PIXCLK_BLEND_ALWAYS_ONb = pixclk_blend_always_onb
#define set_r200PIXCLKS_CNTL_pixclk_gv_always_onb(reg, pixclk_gv_always_onb) (reg)->bitfields.PIXCLK_GV_ALWAYS_ONb = pixclk_gv_always_onb
#define set_r200PIXCLKS_CNTL_pixclk_dvo_always_onb(reg, pixclk_dvo_always_onb) (reg)->bitfields.PIXCLK_DVO_ALWAYS_ONb = pixclk_dvo_always_onb
#define set_r200PIXCLKS_CNTL_pixclk_tmds_always_onb(reg, pixclk_tmds_always_onb) (reg)->bitfields.PIXCLK_TMDS_ALWAYS_ONb = pixclk_tmds_always_onb
#define set_r200PIXCLKS_CNTL_pixclk_trans_always_onb(reg, pixclk_trans_always_onb) (reg)->bitfields.PIXCLK_TRANS_ALWAYS_ONb = pixclk_trans_always_onb
#define set_r200PIXCLKS_CNTL_pixclk_tvo_always_onb(reg, pixclk_tvo_always_onb) (reg)->bitfields.PIXCLK_TVO_ALWAYS_ONb = pixclk_tvo_always_onb
#define set_r200PIXCLKS_CNTL_p2gclk_always_onb(reg, p2gclk_always_onb) (reg)->bitfields.P2GCLK_ALWAYS_ONb = p2gclk_always_onb
#define set_r200PIXCLKS_CNTL_p2g2clk_always_onb(reg, p2g2clk_always_onb) (reg)->bitfields.P2G2CLK_ALWAYS_ONb = p2g2clk_always_onb
#define set_r200PIXCLKS_CNTL_dvoclkc_src_sel(reg, dvoclkc_src_sel) (reg)->bitfields.DVOCLKC_SRC_SEL = dvoclkc_src_sel
#define set_r200PIXCLKS_CNTL_dvoclkd_src_sel(reg, dvoclkd_src_sel) (reg)->bitfields.DVOCLKD_SRC_SEL = dvoclkd_src_sel
#define set_r200PIXCLKS_CNTL_dvoclkc_skw_ctl(reg, dvoclkc_skw_ctl) (reg)->bitfields.DVOCLKC_SKW_CTL = dvoclkc_skw_ctl
#define set_r200PIXCLKS_CNTL_dvoclkd_skw_ctl(reg, dvoclkd_skw_ctl) (reg)->bitfields.DVOCLKD_SKW_CTL = dvoclkd_skw_ctl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TIMER_INT_CNTL regTIMER_INT_CNTL;

#ifdef DEBUG
__inline void set_TIMER_INT_CNTL_timer_int_cnt(regTIMER_INT_CNTL *reg, unsigned int timer_int_cnt)
{
  reg->bitfields.TIMER_INT_CNT = timer_int_cnt;
  if (reg->bitfields.TIMER_INT_CNT != timer_int_cnt) HSLDPF(E_ERROR_MESSAGE,"TIMER_INT_CNTL::TIMER_INT_CNT data too large\n");
}
__inline void set_TIMER_INT_CNTL_timer_int_en(regTIMER_INT_CNTL *reg, unsigned int timer_int_en)
{
  reg->bitfields.TIMER_INT_EN = timer_int_en;
  if (reg->bitfields.TIMER_INT_EN != timer_int_en) HSLDPF(E_ERROR_MESSAGE,"TIMER_INT_CNTL::TIMER_INT_EN data too large\n");
}
__inline void set_TIMER_INT_CNTL_timer_int_running(regTIMER_INT_CNTL *reg, unsigned int timer_int_running)
{
  reg->bitfields.TIMER_INT_RUNNING = timer_int_running;
  if (reg->bitfields.TIMER_INT_RUNNING != timer_int_running) HSLDPF(E_ERROR_MESSAGE,"TIMER_INT_CNTL::TIMER_INT_RUNNING data too large\n");
}
#else
#define set_TIMER_INT_CNTL_timer_int_cnt(reg, timer_int_cnt) (reg)->bitfields.TIMER_INT_CNT = timer_int_cnt
#define set_TIMER_INT_CNTL_timer_int_en(reg, timer_int_en) (reg)->bitfields.TIMER_INT_EN = timer_int_en
#define set_TIMER_INT_CNTL_timer_int_running(reg, timer_int_running) (reg)->bitfields.TIMER_INT_RUNNING = timer_int_running

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union FP_GEN_CNTL regFP_GEN_CNTL;

#ifdef DEBUG
__inline void set_FP_GEN_CNTL_fp_on(regFP_GEN_CNTL *reg, unsigned int fp_on)
{
  reg->bitfields.FP_ON = fp_on;
  if (reg->bitfields.FP_ON != fp_on) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::FP_ON data too large\n");
}
__inline void set_FP_GEN_CNTL_fp_blank_en(regFP_GEN_CNTL *reg, unsigned int fp_blank_en)
{
  reg->bitfields.FP_BLANK_EN = fp_blank_en;
  if (reg->bitfields.FP_BLANK_EN != fp_blank_en) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::FP_BLANK_EN data too large\n");
}
__inline void set_FP_GEN_CNTL_tmds_en(regFP_GEN_CNTL *reg, unsigned int tmds_en)
{
  reg->bitfields.TMDS_EN = tmds_en;
  if (reg->bitfields.TMDS_EN != tmds_en) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::TMDS_EN data too large\n");
}
__inline void set_FP_GEN_CNTL_panel_format(regFP_GEN_CNTL *reg, unsigned int panel_format)
{
  reg->bitfields.PANEL_FORMAT = panel_format;
  if (reg->bitfields.PANEL_FORMAT != panel_format) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::PANEL_FORMAT data too large\n");
}
__inline void set_FP_GEN_CNTL_no_of_grey(regFP_GEN_CNTL *reg, unsigned int no_of_grey)
{
  reg->bitfields.NO_OF_GREY = no_of_grey;
  if (reg->bitfields.NO_OF_GREY != no_of_grey) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::NO_OF_GREY data too large\n");
}
__inline void set_FP_GEN_CNTL_fp_rst_fm(regFP_GEN_CNTL *reg, unsigned int fp_rst_fm)
{
  reg->bitfields.FP_RST_FM = fp_rst_fm;
  if (reg->bitfields.FP_RST_FM != fp_rst_fm) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::FP_RST_FM data too large\n");
}
__inline void set_FP_GEN_CNTL_fp_en_tmds(regFP_GEN_CNTL *reg, unsigned int fp_en_tmds)
{
  reg->bitfields.FP_EN_TMDS = fp_en_tmds;
  if (reg->bitfields.FP_EN_TMDS != fp_en_tmds) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::FP_EN_TMDS data too large\n");
}
__inline void set_FP_GEN_CNTL_fp_detect_sense(regFP_GEN_CNTL *reg, unsigned int fp_detect_sense)
{
  reg->bitfields.FP_DETECT_SENSE = fp_detect_sense;
  if (reg->bitfields.FP_DETECT_SENSE != fp_detect_sense) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::FP_DETECT_SENSE data too large\n");
}
__inline void set_FP_GEN_CNTL_fp_detect_int_pol(regFP_GEN_CNTL *reg, unsigned int fp_detect_int_pol)
{
  reg->bitfields.FP_DETECT_INT_POL = fp_detect_int_pol;
  if (reg->bitfields.FP_DETECT_INT_POL != fp_detect_int_pol) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::FP_DETECT_INT_POL data too large\n");
}
__inline void set_FP_GEN_CNTL_fp_source_sel(regFP_GEN_CNTL *reg, unsigned int fp_source_sel)
{
  reg->bitfields.FP_SOURCE_SEL = fp_source_sel;
  if (reg->bitfields.FP_SOURCE_SEL != fp_source_sel) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::FP_SOURCE_SEL data too large\n");
}
__inline void set_FP_GEN_CNTL_fp_detect_en(regFP_GEN_CNTL *reg, unsigned int fp_detect_en)
{
  reg->bitfields.FP_DETECT_EN = fp_detect_en;
  if (reg->bitfields.FP_DETECT_EN != fp_detect_en) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::FP_DETECT_EN data too large\n");
}
__inline void set_FP_GEN_CNTL_fp_use_vga_hvsync(regFP_GEN_CNTL *reg, unsigned int fp_use_vga_hvsync)
{
  reg->bitfields.FP_USE_VGA_HVSYNC = fp_use_vga_hvsync;
  if (reg->bitfields.FP_USE_VGA_HVSYNC != fp_use_vga_hvsync) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::FP_USE_VGA_HVSYNC data too large\n");
}
__inline void set_FP_GEN_CNTL_fp_use_vga_sync_polarity(regFP_GEN_CNTL *reg, unsigned int fp_use_vga_sync_polarity)
{
  reg->bitfields.FP_USE_VGA_SYNC_POLARITY = fp_use_vga_sync_polarity;
  if (reg->bitfields.FP_USE_VGA_SYNC_POLARITY != fp_use_vga_sync_polarity) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::FP_USE_VGA_SYNC_POLARITY data too large\n");
}
__inline void set_FP_GEN_CNTL_crtc_dont_shadow_vpar(regFP_GEN_CNTL *reg, unsigned int crtc_dont_shadow_vpar)
{
  reg->bitfields.CRTC_DONT_SHADOW_VPAR = crtc_dont_shadow_vpar;
  if (reg->bitfields.CRTC_DONT_SHADOW_VPAR != crtc_dont_shadow_vpar) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::CRTC_DONT_SHADOW_VPAR data too large\n");
}
__inline void set_FP_GEN_CNTL_crtc_dont_shadow_hend(regFP_GEN_CNTL *reg, unsigned int crtc_dont_shadow_hend)
{
  reg->bitfields.CRTC_DONT_SHADOW_HEND = crtc_dont_shadow_hend;
  if (reg->bitfields.CRTC_DONT_SHADOW_HEND != crtc_dont_shadow_hend) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::CRTC_DONT_SHADOW_HEND data too large\n");
}
__inline void set_FP_GEN_CNTL_crtc_use_shadowed_vend(regFP_GEN_CNTL *reg, unsigned int crtc_use_shadowed_vend)
{
  reg->bitfields.CRTC_USE_SHADOWED_VEND = crtc_use_shadowed_vend;
  if (reg->bitfields.CRTC_USE_SHADOWED_VEND != crtc_use_shadowed_vend) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::CRTC_USE_SHADOWED_VEND data too large\n");
}
__inline void set_FP_GEN_CNTL_crtc_use_shadowed_rowcur(regFP_GEN_CNTL *reg, unsigned int crtc_use_shadowed_rowcur)
{
  reg->bitfields.CRTC_USE_SHADOWED_ROWCUR = crtc_use_shadowed_rowcur;
  if (reg->bitfields.CRTC_USE_SHADOWED_ROWCUR != crtc_use_shadowed_rowcur) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::CRTC_USE_SHADOWED_ROWCUR data too large\n");
}
__inline void set_FP_GEN_CNTL_rmx_hvsync_control_en(regFP_GEN_CNTL *reg, unsigned int rmx_hvsync_control_en)
{
  reg->bitfields.RMX_HVSYNC_CONTROL_EN = rmx_hvsync_control_en;
  if (reg->bitfields.RMX_HVSYNC_CONTROL_EN != rmx_hvsync_control_en) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::RMX_HVSYNC_CONTROL_EN data too large\n");
}
__inline void set_FP_GEN_CNTL_dfp_sync_sel(regFP_GEN_CNTL *reg, unsigned int dfp_sync_sel)
{
  reg->bitfields.DFP_SYNC_SEL = dfp_sync_sel;
  if (reg->bitfields.DFP_SYNC_SEL != dfp_sync_sel) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::DFP_SYNC_SEL data too large\n");
}
__inline void set_FP_GEN_CNTL_crtc_lock_8dot(regFP_GEN_CNTL *reg, unsigned int crtc_lock_8dot)
{
  reg->bitfields.CRTC_LOCK_8DOT = crtc_lock_8dot;
  if (reg->bitfields.CRTC_LOCK_8DOT != crtc_lock_8dot) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::CRTC_LOCK_8DOT data too large\n");
}
__inline void set_FP_GEN_CNTL_crt_sync_sel(regFP_GEN_CNTL *reg, unsigned int crt_sync_sel)
{
  reg->bitfields.CRT_SYNC_SEL = crt_sync_sel;
  if (reg->bitfields.CRT_SYNC_SEL != crt_sync_sel) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::CRT_SYNC_SEL data too large\n");
}
__inline void set_FP_GEN_CNTL_fp_use_shadow_en(regFP_GEN_CNTL *reg, unsigned int fp_use_shadow_en)
{
  reg->bitfields.FP_USE_SHADOW_EN = fp_use_shadow_en;
  if (reg->bitfields.FP_USE_SHADOW_EN != fp_use_shadow_en) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::FP_USE_SHADOW_EN data too large\n");
}
__inline void set_FP_GEN_CNTL_dont_rst_charen(regFP_GEN_CNTL *reg, unsigned int dont_rst_charen)
{
  reg->bitfields.DONT_RST_CHAREN = dont_rst_charen;
  if (reg->bitfields.DONT_RST_CHAREN != dont_rst_charen) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::DONT_RST_CHAREN data too large\n");
}
__inline void set_FP_GEN_CNTL_crt_sync_alt_sel(regFP_GEN_CNTL *reg, unsigned int crt_sync_alt_sel)
{
  reg->bitfields.CRT_SYNC_ALT_SEL = crt_sync_alt_sel;
  if (reg->bitfields.CRT_SYNC_ALT_SEL != crt_sync_alt_sel) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::CRT_SYNC_ALT_SEL data too large\n");
}
__inline void set_FP_GEN_CNTL_crtc_use_nonshadow_hparams_for_blank(regFP_GEN_CNTL *reg, unsigned int crtc_use_nonshadow_hparams_for_blank)
{
  reg->bitfields.CRTC_USE_NONSHADOW_HPARAMS_FOR_BLANK = crtc_use_nonshadow_hparams_for_blank;
  if (reg->bitfields.CRTC_USE_NONSHADOW_HPARAMS_FOR_BLANK != crtc_use_nonshadow_hparams_for_blank) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::CRTC_USE_NONSHADOW_HPARAMS_FOR_BLANK data too large\n");
}
__inline void set_FP_GEN_CNTL_crtc_use_nonshadow_vparams_for_blank(regFP_GEN_CNTL *reg, unsigned int crtc_use_nonshadow_vparams_for_blank)
{
  reg->bitfields.CRTC_USE_NONSHADOW_VPARAMS_FOR_BLANK = crtc_use_nonshadow_vparams_for_blank;
  if (reg->bitfields.CRTC_USE_NONSHADOW_VPARAMS_FOR_BLANK != crtc_use_nonshadow_vparams_for_blank) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::CRTC_USE_NONSHADOW_VPARAMS_FOR_BLANK data too large\n");
}
__inline void set_FP_GEN_CNTL_crtc_vga_xoverscan_color(regFP_GEN_CNTL *reg, unsigned int crtc_vga_xoverscan_color)
{
  reg->bitfields.CRTC_VGA_XOVERSCAN_COLOR = crtc_vga_xoverscan_color;
  if (reg->bitfields.CRTC_VGA_XOVERSCAN_COLOR != crtc_vga_xoverscan_color) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::CRTC_VGA_XOVERSCAN_COLOR data too large\n");
}
__inline void set_FP_GEN_CNTL_crtc_vga_xoverscan_divby2_en(regFP_GEN_CNTL *reg, unsigned int crtc_vga_xoverscan_divby2_en)
{
  reg->bitfields.CRTC_VGA_XOVERSCAN_DIVBY2_EN = crtc_vga_xoverscan_divby2_en;
  if (reg->bitfields.CRTC_VGA_XOVERSCAN_DIVBY2_EN != crtc_vga_xoverscan_divby2_en) HSLDPF(E_ERROR_MESSAGE,"FP_GEN_CNTL::CRTC_VGA_XOVERSCAN_DIVBY2_EN data too large\n");
}
#else
#define set_FP_GEN_CNTL_fp_on(reg, fp_on) (reg)->bitfields.FP_ON = fp_on
#define set_FP_GEN_CNTL_fp_blank_en(reg, fp_blank_en) (reg)->bitfields.FP_BLANK_EN = fp_blank_en
#define set_FP_GEN_CNTL_tmds_en(reg, tmds_en) (reg)->bitfields.TMDS_EN = tmds_en
#define set_FP_GEN_CNTL_panel_format(reg, panel_format) (reg)->bitfields.PANEL_FORMAT = panel_format
#define set_FP_GEN_CNTL_no_of_grey(reg, no_of_grey) (reg)->bitfields.NO_OF_GREY = no_of_grey
#define set_FP_GEN_CNTL_fp_rst_fm(reg, fp_rst_fm) (reg)->bitfields.FP_RST_FM = fp_rst_fm
#define set_FP_GEN_CNTL_fp_en_tmds(reg, fp_en_tmds) (reg)->bitfields.FP_EN_TMDS = fp_en_tmds
#define set_FP_GEN_CNTL_fp_detect_sense(reg, fp_detect_sense) (reg)->bitfields.FP_DETECT_SENSE = fp_detect_sense
#define set_FP_GEN_CNTL_fp_detect_int_pol(reg, fp_detect_int_pol) (reg)->bitfields.FP_DETECT_INT_POL = fp_detect_int_pol
#define set_FP_GEN_CNTL_fp_source_sel(reg, fp_source_sel) (reg)->bitfields.FP_SOURCE_SEL = fp_source_sel
#define set_FP_GEN_CNTL_fp_detect_en(reg, fp_detect_en) (reg)->bitfields.FP_DETECT_EN = fp_detect_en
#define set_FP_GEN_CNTL_fp_use_vga_hvsync(reg, fp_use_vga_hvsync) (reg)->bitfields.FP_USE_VGA_HVSYNC = fp_use_vga_hvsync
#define set_FP_GEN_CNTL_fp_use_vga_sync_polarity(reg, fp_use_vga_sync_polarity) (reg)->bitfields.FP_USE_VGA_SYNC_POLARITY = fp_use_vga_sync_polarity
#define set_FP_GEN_CNTL_crtc_dont_shadow_vpar(reg, crtc_dont_shadow_vpar) (reg)->bitfields.CRTC_DONT_SHADOW_VPAR = crtc_dont_shadow_vpar
#define set_FP_GEN_CNTL_crtc_dont_shadow_hend(reg, crtc_dont_shadow_hend) (reg)->bitfields.CRTC_DONT_SHADOW_HEND = crtc_dont_shadow_hend
#define set_FP_GEN_CNTL_crtc_use_shadowed_vend(reg, crtc_use_shadowed_vend) (reg)->bitfields.CRTC_USE_SHADOWED_VEND = crtc_use_shadowed_vend
#define set_FP_GEN_CNTL_crtc_use_shadowed_rowcur(reg, crtc_use_shadowed_rowcur) (reg)->bitfields.CRTC_USE_SHADOWED_ROWCUR = crtc_use_shadowed_rowcur
#define set_FP_GEN_CNTL_rmx_hvsync_control_en(reg, rmx_hvsync_control_en) (reg)->bitfields.RMX_HVSYNC_CONTROL_EN = rmx_hvsync_control_en
#define set_FP_GEN_CNTL_dfp_sync_sel(reg, dfp_sync_sel) (reg)->bitfields.DFP_SYNC_SEL = dfp_sync_sel
#define set_FP_GEN_CNTL_crtc_lock_8dot(reg, crtc_lock_8dot) (reg)->bitfields.CRTC_LOCK_8DOT = crtc_lock_8dot
#define set_FP_GEN_CNTL_crt_sync_sel(reg, crt_sync_sel) (reg)->bitfields.CRT_SYNC_SEL = crt_sync_sel
#define set_FP_GEN_CNTL_fp_use_shadow_en(reg, fp_use_shadow_en) (reg)->bitfields.FP_USE_SHADOW_EN = fp_use_shadow_en
#define set_FP_GEN_CNTL_dont_rst_charen(reg, dont_rst_charen) (reg)->bitfields.DONT_RST_CHAREN = dont_rst_charen
#define set_FP_GEN_CNTL_crt_sync_alt_sel(reg, crt_sync_alt_sel) (reg)->bitfields.CRT_SYNC_ALT_SEL = crt_sync_alt_sel
#define set_FP_GEN_CNTL_crtc_use_nonshadow_hparams_for_blank(reg, crtc_use_nonshadow_hparams_for_blank) (reg)->bitfields.CRTC_USE_NONSHADOW_HPARAMS_FOR_BLANK = crtc_use_nonshadow_hparams_for_blank
#define set_FP_GEN_CNTL_crtc_use_nonshadow_vparams_for_blank(reg, crtc_use_nonshadow_vparams_for_blank) (reg)->bitfields.CRTC_USE_NONSHADOW_VPARAMS_FOR_BLANK = crtc_use_nonshadow_vparams_for_blank
#define set_FP_GEN_CNTL_crtc_vga_xoverscan_color(reg, crtc_vga_xoverscan_color) (reg)->bitfields.CRTC_VGA_XOVERSCAN_COLOR = crtc_vga_xoverscan_color
#define set_FP_GEN_CNTL_crtc_vga_xoverscan_divby2_en(reg, crtc_vga_xoverscan_divby2_en) (reg)->bitfields.CRTC_VGA_XOVERSCAN_DIVBY2_EN = crtc_vga_xoverscan_divby2_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union FP2_GEN_CNTL regFP2_GEN_CNTL;

#ifdef DEBUG
__inline void set_FP2_GEN_CNTL_fp2_blank_en(regFP2_GEN_CNTL *reg, unsigned int fp2_blank_en)
{
  reg->bitfields.FP2_BLANK_EN = fp2_blank_en;
  if (reg->bitfields.FP2_BLANK_EN != fp2_blank_en) HSLDPF(E_ERROR_MESSAGE,"FP2_GEN_CNTL::FP2_BLANK_EN data too large\n");
}
__inline void set_FP2_GEN_CNTL_fp2_on(regFP2_GEN_CNTL *reg, unsigned int fp2_on)
{
  reg->bitfields.FP2_ON = fp2_on;
  if (reg->bitfields.FP2_ON != fp2_on) HSLDPF(E_ERROR_MESSAGE,"FP2_GEN_CNTL::FP2_ON data too large\n");
}
__inline void set_FP2_GEN_CNTL_fp2_panel_format(regFP2_GEN_CNTL *reg, unsigned int fp2_panel_format)
{
  reg->bitfields.FP2_PANEL_FORMAT = fp2_panel_format;
  if (reg->bitfields.FP2_PANEL_FORMAT != fp2_panel_format) HSLDPF(E_ERROR_MESSAGE,"FP2_GEN_CNTL::FP2_PANEL_FORMAT data too large\n");
}
__inline void set_FP2_GEN_CNTL_fp2_no_of_grey(regFP2_GEN_CNTL *reg, unsigned int fp2_no_of_grey)
{
  reg->bitfields.FP2_NO_OF_GREY = fp2_no_of_grey;
  if (reg->bitfields.FP2_NO_OF_GREY != fp2_no_of_grey) HSLDPF(E_ERROR_MESSAGE,"FP2_GEN_CNTL::FP2_NO_OF_GREY data too large\n");
}
__inline void set_FP2_GEN_CNTL_fp2_rst_fm(regFP2_GEN_CNTL *reg, unsigned int fp2_rst_fm)
{
  reg->bitfields.FP2_RST_FM = fp2_rst_fm;
  if (reg->bitfields.FP2_RST_FM != fp2_rst_fm) HSLDPF(E_ERROR_MESSAGE,"FP2_GEN_CNTL::FP2_RST_FM data too large\n");
}
__inline void set_FP2_GEN_CNTL_fp2_detect_sense(regFP2_GEN_CNTL *reg, unsigned int fp2_detect_sense)
{
  reg->bitfields.FP2_DETECT_SENSE = fp2_detect_sense;
  if (reg->bitfields.FP2_DETECT_SENSE != fp2_detect_sense) HSLDPF(E_ERROR_MESSAGE,"FP2_GEN_CNTL::FP2_DETECT_SENSE data too large\n");
}
__inline void set_FP2_GEN_CNTL_fp2_detect_int_pol(regFP2_GEN_CNTL *reg, unsigned int fp2_detect_int_pol)
{
  reg->bitfields.FP2_DETECT_INT_POL = fp2_detect_int_pol;
  if (reg->bitfields.FP2_DETECT_INT_POL != fp2_detect_int_pol) HSLDPF(E_ERROR_MESSAGE,"FP2_GEN_CNTL::FP2_DETECT_INT_POL data too large\n");
}
__inline void set_FP2_GEN_CNTL_fp2_source_sel(regFP2_GEN_CNTL *reg, unsigned int fp2_source_sel)
{
  reg->bitfields.FP2_SOURCE_SEL = fp2_source_sel;
  if (reg->bitfields.FP2_SOURCE_SEL != fp2_source_sel) HSLDPF(E_ERROR_MESSAGE,"FP2_GEN_CNTL::FP2_SOURCE_SEL data too large\n");
}
__inline void set_FP2_GEN_CNTL_fp2_crc_en(regFP2_GEN_CNTL *reg, unsigned int fp2_crc_en)
{
  reg->bitfields.FP2_CRC_EN = fp2_crc_en;
  if (reg->bitfields.FP2_CRC_EN != fp2_crc_en) HSLDPF(E_ERROR_MESSAGE,"FP2_GEN_CNTL::FP2_CRC_EN data too large\n");
}
__inline void set_FP2_GEN_CNTL_dvo_en(regFP2_GEN_CNTL *reg, unsigned int dvo_en)
{
  reg->bitfields.DVO_EN = dvo_en;
  if (reg->bitfields.DVO_EN != dvo_en) HSLDPF(E_ERROR_MESSAGE,"FP2_GEN_CNTL::DVO_EN data too large\n");
}
__inline void set_FP2_GEN_CNTL_dvo_tmds_ctl3(regFP2_GEN_CNTL *reg, unsigned int dvo_tmds_ctl3)
{
  reg->bitfields.DVO_TMDS_CTL3 = dvo_tmds_ctl3;
  if (reg->bitfields.DVO_TMDS_CTL3 != dvo_tmds_ctl3) HSLDPF(E_ERROR_MESSAGE,"FP2_GEN_CNTL::DVO_TMDS_CTL3 data too large\n");
}
__inline void set_FP2_GEN_CNTL_dvo_rate_sel(regFP2_GEN_CNTL *reg, unsigned int dvo_rate_sel)
{
  reg->bitfields.DVO_RATE_SEL = dvo_rate_sel;
  if (reg->bitfields.DVO_RATE_SEL != dvo_rate_sel) HSLDPF(E_ERROR_MESSAGE,"FP2_GEN_CNTL::DVO_RATE_SEL data too large\n");
}
__inline void set_FP2_GEN_CNTL_dvo_clock_mode(regFP2_GEN_CNTL *reg, unsigned int dvo_clock_mode)
{
  reg->bitfields.DVO_CLOCK_MODE = dvo_clock_mode;
  if (reg->bitfields.DVO_CLOCK_MODE != dvo_clock_mode) HSLDPF(E_ERROR_MESSAGE,"FP2_GEN_CNTL::DVO_CLOCK_MODE data too large\n");
}
__inline void set_FP2_GEN_CNTL_dvo_dual_channel_en(regFP2_GEN_CNTL *reg, unsigned int dvo_dual_channel_en)
{
  reg->bitfields.DVO_DUAL_CHANNEL_EN = dvo_dual_channel_en;
  if (reg->bitfields.DVO_DUAL_CHANNEL_EN != dvo_dual_channel_en) HSLDPF(E_ERROR_MESSAGE,"FP2_GEN_CNTL::DVO_DUAL_CHANNEL_EN data too large\n");
}
__inline void set_FP2_GEN_CNTL_dvo_tmds_ctl3_sel(regFP2_GEN_CNTL *reg, unsigned int dvo_tmds_ctl3_sel)
{
  reg->bitfields.DVO_TMDS_CTL3_SEL = dvo_tmds_ctl3_sel;
  if (reg->bitfields.DVO_TMDS_CTL3_SEL != dvo_tmds_ctl3_sel) HSLDPF(E_ERROR_MESSAGE,"FP2_GEN_CNTL::DVO_TMDS_CTL3_SEL data too large\n");
}
#else
#define set_FP2_GEN_CNTL_fp2_blank_en(reg, fp2_blank_en) (reg)->bitfields.FP2_BLANK_EN = fp2_blank_en
#define set_FP2_GEN_CNTL_fp2_on(reg, fp2_on) (reg)->bitfields.FP2_ON = fp2_on
#define set_FP2_GEN_CNTL_fp2_panel_format(reg, fp2_panel_format) (reg)->bitfields.FP2_PANEL_FORMAT = fp2_panel_format
#define set_FP2_GEN_CNTL_fp2_no_of_grey(reg, fp2_no_of_grey) (reg)->bitfields.FP2_NO_OF_GREY = fp2_no_of_grey
#define set_FP2_GEN_CNTL_fp2_rst_fm(reg, fp2_rst_fm) (reg)->bitfields.FP2_RST_FM = fp2_rst_fm
#define set_FP2_GEN_CNTL_fp2_detect_sense(reg, fp2_detect_sense) (reg)->bitfields.FP2_DETECT_SENSE = fp2_detect_sense
#define set_FP2_GEN_CNTL_fp2_detect_int_pol(reg, fp2_detect_int_pol) (reg)->bitfields.FP2_DETECT_INT_POL = fp2_detect_int_pol
#define set_FP2_GEN_CNTL_fp2_source_sel(reg, fp2_source_sel) (reg)->bitfields.FP2_SOURCE_SEL = fp2_source_sel
#define set_FP2_GEN_CNTL_fp2_crc_en(reg, fp2_crc_en) (reg)->bitfields.FP2_CRC_EN = fp2_crc_en
#define set_FP2_GEN_CNTL_dvo_en(reg, dvo_en) (reg)->bitfields.DVO_EN = dvo_en
#define set_FP2_GEN_CNTL_dvo_tmds_ctl3(reg, dvo_tmds_ctl3) (reg)->bitfields.DVO_TMDS_CTL3 = dvo_tmds_ctl3
#define set_FP2_GEN_CNTL_dvo_rate_sel(reg, dvo_rate_sel) (reg)->bitfields.DVO_RATE_SEL = dvo_rate_sel
#define set_FP2_GEN_CNTL_dvo_clock_mode(reg, dvo_clock_mode) (reg)->bitfields.DVO_CLOCK_MODE = dvo_clock_mode
#define set_FP2_GEN_CNTL_dvo_dual_channel_en(reg, dvo_dual_channel_en) (reg)->bitfields.DVO_DUAL_CHANNEL_EN = dvo_dual_channel_en
#define set_FP2_GEN_CNTL_dvo_tmds_ctl3_sel(reg, dvo_tmds_ctl3_sel) (reg)->bitfields.DVO_TMDS_CTL3_SEL = dvo_tmds_ctl3_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DVO_CRC regDVO_CRC;

#ifdef DEBUG
__inline void set_DVO_CRC_dvo_crc_sig_rgb(regDVO_CRC *reg, unsigned int dvo_crc_sig_rgb)
{
  reg->bitfields.DVO_CRC_SIG_RGB = dvo_crc_sig_rgb;
  if (reg->bitfields.DVO_CRC_SIG_RGB != dvo_crc_sig_rgb) HSLDPF(E_ERROR_MESSAGE,"DVO_CRC::DVO_CRC_SIG_RGB data too large\n");
}
__inline void set_DVO_CRC_dvo_crc_sig_c(regDVO_CRC *reg, unsigned int dvo_crc_sig_c)
{
  reg->bitfields.DVO_CRC_SIG_C = dvo_crc_sig_c;
  if (reg->bitfields.DVO_CRC_SIG_C != dvo_crc_sig_c) HSLDPF(E_ERROR_MESSAGE,"DVO_CRC::DVO_CRC_SIG_C data too large\n");
}
#else
#define set_DVO_CRC_dvo_crc_sig_rgb(reg, dvo_crc_sig_rgb) (reg)->bitfields.DVO_CRC_SIG_RGB = dvo_crc_sig_rgb
#define set_DVO_CRC_dvo_crc_sig_c(reg, dvo_crc_sig_c) (reg)->bitfields.DVO_CRC_SIG_C = dvo_crc_sig_c

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union AUX_WINDOW_HORZ_CNTL regAUX_WINDOW_HORZ_CNTL;

#ifdef DEBUG
__inline void set_AUX_WINDOW_HORZ_CNTL_aux_win_horz_start(regAUX_WINDOW_HORZ_CNTL *reg, unsigned int aux_win_horz_start)
{
  reg->bitfields.AUX_WIN_HORZ_START = aux_win_horz_start;
  if (reg->bitfields.AUX_WIN_HORZ_START != aux_win_horz_start) HSLDPF(E_ERROR_MESSAGE,"AUX_WINDOW_HORZ_CNTL::AUX_WIN_HORZ_START data too large\n");
}
__inline void set_AUX_WINDOW_HORZ_CNTL_aux_win_horz_end(regAUX_WINDOW_HORZ_CNTL *reg, unsigned int aux_win_horz_end)
{
  reg->bitfields.AUX_WIN_HORZ_END = aux_win_horz_end;
  if (reg->bitfields.AUX_WIN_HORZ_END != aux_win_horz_end) HSLDPF(E_ERROR_MESSAGE,"AUX_WINDOW_HORZ_CNTL::AUX_WIN_HORZ_END data too large\n");
}
__inline void set_AUX_WINDOW_HORZ_CNTL_aux_win_en(regAUX_WINDOW_HORZ_CNTL *reg, unsigned int aux_win_en)
{
  reg->bitfields.AUX_WIN_EN = aux_win_en;
  if (reg->bitfields.AUX_WIN_EN != aux_win_en) HSLDPF(E_ERROR_MESSAGE,"AUX_WINDOW_HORZ_CNTL::AUX_WIN_EN data too large\n");
}
__inline void set_AUX_WINDOW_HORZ_CNTL_aux_win_out_delay_r2(regAUX_WINDOW_HORZ_CNTL *reg, unsigned int aux_win_out_delay_r2)
{
  reg->bitfields.AUX_WIN_OUT_DELAY_R2 = aux_win_out_delay_r2;
  if (reg->bitfields.AUX_WIN_OUT_DELAY_R2 != aux_win_out_delay_r2) HSLDPF(E_ERROR_MESSAGE,"AUX_WINDOW_HORZ_CNTL::AUX_WIN_OUT_DELAY_R2 data too large\n");
}
__inline void set_AUX_WINDOW_HORZ_CNTL_aux_win_src_sel(regAUX_WINDOW_HORZ_CNTL *reg, unsigned int aux_win_src_sel)
{
  reg->bitfields.AUX_WIN_SRC_SEL = aux_win_src_sel;
  if (reg->bitfields.AUX_WIN_SRC_SEL != aux_win_src_sel) HSLDPF(E_ERROR_MESSAGE,"AUX_WINDOW_HORZ_CNTL::AUX_WIN_SRC_SEL data too large\n");
}
__inline void set_AUX_WINDOW_HORZ_CNTL_aux_win_lock(regAUX_WINDOW_HORZ_CNTL *reg, unsigned int aux_win_lock)
{
  reg->bitfields.AUX_WIN_LOCK = aux_win_lock;
  if (reg->bitfields.AUX_WIN_LOCK != aux_win_lock) HSLDPF(E_ERROR_MESSAGE,"AUX_WINDOW_HORZ_CNTL::AUX_WIN_LOCK data too large\n");
}
#else
#define set_AUX_WINDOW_HORZ_CNTL_aux_win_horz_start(reg, aux_win_horz_start) (reg)->bitfields.AUX_WIN_HORZ_START = aux_win_horz_start
#define set_AUX_WINDOW_HORZ_CNTL_aux_win_horz_end(reg, aux_win_horz_end) (reg)->bitfields.AUX_WIN_HORZ_END = aux_win_horz_end
#define set_AUX_WINDOW_HORZ_CNTL_aux_win_en(reg, aux_win_en) (reg)->bitfields.AUX_WIN_EN = aux_win_en
#define set_AUX_WINDOW_HORZ_CNTL_aux_win_out_delay_r2(reg, aux_win_out_delay_r2) (reg)->bitfields.AUX_WIN_OUT_DELAY_R2 = aux_win_out_delay_r2
#define set_AUX_WINDOW_HORZ_CNTL_aux_win_src_sel(reg, aux_win_src_sel) (reg)->bitfields.AUX_WIN_SRC_SEL = aux_win_src_sel
#define set_AUX_WINDOW_HORZ_CNTL_aux_win_lock(reg, aux_win_lock) (reg)->bitfields.AUX_WIN_LOCK = aux_win_lock

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DVI_I2C_CNTL_0 regDVI_I2C_CNTL_0;

#ifdef DEBUG
__inline void set_DVI_I2C_CNTL_0_i2c_done(regDVI_I2C_CNTL_0 *reg, unsigned int i2c_done)
{
  reg->bitfields.I2C_DONE = i2c_done;
  if (reg->bitfields.I2C_DONE != i2c_done) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_CNTL_0::I2C_DONE data too large\n");
}
__inline void set_DVI_I2C_CNTL_0_i2c_nack(regDVI_I2C_CNTL_0 *reg, unsigned int i2c_nack)
{
  reg->bitfields.I2C_NACK = i2c_nack;
  if (reg->bitfields.I2C_NACK != i2c_nack) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_CNTL_0::I2C_NACK data too large\n");
}
__inline void set_DVI_I2C_CNTL_0_i2c_halt(regDVI_I2C_CNTL_0 *reg, unsigned int i2c_halt)
{
  reg->bitfields.I2C_HALT = i2c_halt;
  if (reg->bitfields.I2C_HALT != i2c_halt) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_CNTL_0::I2C_HALT data too large\n");
}
__inline void set_DVI_I2C_CNTL_0_dvi_i2c_pin_sel(regDVI_I2C_CNTL_0 *reg, unsigned int dvi_i2c_pin_sel)
{
  reg->bitfields.DVI_I2C_PIN_SEL = dvi_i2c_pin_sel;
  if (reg->bitfields.DVI_I2C_PIN_SEL != dvi_i2c_pin_sel) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_CNTL_0::DVI_I2C_PIN_SEL data too large\n");
}
__inline void set_DVI_I2C_CNTL_0_i2c_soft_rst(regDVI_I2C_CNTL_0 *reg, unsigned int i2c_soft_rst)
{
  reg->bitfields.I2C_SOFT_RST = i2c_soft_rst;
  if (reg->bitfields.I2C_SOFT_RST != i2c_soft_rst) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_CNTL_0::I2C_SOFT_RST data too large\n");
}
__inline void set_DVI_I2C_CNTL_0_i2c_drive_en(regDVI_I2C_CNTL_0 *reg, unsigned int i2c_drive_en)
{
  reg->bitfields.I2C_DRIVE_EN = i2c_drive_en;
  if (reg->bitfields.I2C_DRIVE_EN != i2c_drive_en) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_CNTL_0::I2C_DRIVE_EN data too large\n");
}
__inline void set_DVI_I2C_CNTL_0_i2c_drive_sel(regDVI_I2C_CNTL_0 *reg, unsigned int i2c_drive_sel)
{
  reg->bitfields.I2C_DRIVE_SEL = i2c_drive_sel;
  if (reg->bitfields.I2C_DRIVE_SEL != i2c_drive_sel) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_CNTL_0::I2C_DRIVE_SEL data too large\n");
}
__inline void set_DVI_I2C_CNTL_0_i2c_start(regDVI_I2C_CNTL_0 *reg, unsigned int i2c_start)
{
  reg->bitfields.I2C_START = i2c_start;
  if (reg->bitfields.I2C_START != i2c_start) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_CNTL_0::I2C_START data too large\n");
}
__inline void set_DVI_I2C_CNTL_0_i2c_stop(regDVI_I2C_CNTL_0 *reg, unsigned int i2c_stop)
{
  reg->bitfields.I2C_STOP = i2c_stop;
  if (reg->bitfields.I2C_STOP != i2c_stop) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_CNTL_0::I2C_STOP data too large\n");
}
__inline void set_DVI_I2C_CNTL_0_i2c_receive(regDVI_I2C_CNTL_0 *reg, unsigned int i2c_receive)
{
  reg->bitfields.I2C_RECEIVE = i2c_receive;
  if (reg->bitfields.I2C_RECEIVE != i2c_receive) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_CNTL_0::I2C_RECEIVE data too large\n");
}
__inline void set_DVI_I2C_CNTL_0_i2c_abort(regDVI_I2C_CNTL_0 *reg, unsigned int i2c_abort)
{
  reg->bitfields.I2C_ABORT = i2c_abort;
  if (reg->bitfields.I2C_ABORT != i2c_abort) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_CNTL_0::I2C_ABORT data too large\n");
}
__inline void set_DVI_I2C_CNTL_0_i2c_go(regDVI_I2C_CNTL_0 *reg, unsigned int i2c_go)
{
  reg->bitfields.I2C_GO = i2c_go;
  if (reg->bitfields.I2C_GO != i2c_go) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_CNTL_0::I2C_GO data too large\n");
}
__inline void set_DVI_I2C_CNTL_0_sw_wants_to_use_dvi_i2c(regDVI_I2C_CNTL_0 *reg, unsigned int sw_wants_to_use_dvi_i2c)
{
  reg->bitfields.SW_WANTS_TO_USE_DVI_I2C = sw_wants_to_use_dvi_i2c;
  if (reg->bitfields.SW_WANTS_TO_USE_DVI_I2C != sw_wants_to_use_dvi_i2c) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_CNTL_0::SW_WANTS_TO_USE_DVI_I2C data too large\n");
}
__inline void set_DVI_I2C_CNTL_0_sw_done_using_dvi_i2c(regDVI_I2C_CNTL_0 *reg, unsigned int sw_done_using_dvi_i2c)
{
  reg->bitfields.SW_DONE_USING_DVI_I2C = sw_done_using_dvi_i2c;
  if (reg->bitfields.SW_DONE_USING_DVI_I2C != sw_done_using_dvi_i2c) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_CNTL_0::SW_DONE_USING_DVI_I2C data too large\n");
}
__inline void set_DVI_I2C_CNTL_0_abort_hw_dvi_i2c(regDVI_I2C_CNTL_0 *reg, unsigned int abort_hw_dvi_i2c)
{
  reg->bitfields.ABORT_HW_DVI_I2C = abort_hw_dvi_i2c;
  if (reg->bitfields.ABORT_HW_DVI_I2C != abort_hw_dvi_i2c) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_CNTL_0::ABORT_HW_DVI_I2C data too large\n");
}
__inline void set_DVI_I2C_CNTL_0_i2c_prescale(regDVI_I2C_CNTL_0 *reg, unsigned int i2c_prescale)
{
  reg->bitfields.I2C_PRESCALE = i2c_prescale;
  if (reg->bitfields.I2C_PRESCALE != i2c_prescale) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_CNTL_0::I2C_PRESCALE data too large\n");
}
#else
#define set_DVI_I2C_CNTL_0_i2c_done(reg, i2c_done) (reg)->bitfields.I2C_DONE = i2c_done
#define set_DVI_I2C_CNTL_0_i2c_nack(reg, i2c_nack) (reg)->bitfields.I2C_NACK = i2c_nack
#define set_DVI_I2C_CNTL_0_i2c_halt(reg, i2c_halt) (reg)->bitfields.I2C_HALT = i2c_halt
#define set_DVI_I2C_CNTL_0_dvi_i2c_pin_sel(reg, dvi_i2c_pin_sel) (reg)->bitfields.DVI_I2C_PIN_SEL = dvi_i2c_pin_sel
#define set_DVI_I2C_CNTL_0_i2c_soft_rst(reg, i2c_soft_rst) (reg)->bitfields.I2C_SOFT_RST = i2c_soft_rst
#define set_DVI_I2C_CNTL_0_i2c_drive_en(reg, i2c_drive_en) (reg)->bitfields.I2C_DRIVE_EN = i2c_drive_en
#define set_DVI_I2C_CNTL_0_i2c_drive_sel(reg, i2c_drive_sel) (reg)->bitfields.I2C_DRIVE_SEL = i2c_drive_sel
#define set_DVI_I2C_CNTL_0_i2c_start(reg, i2c_start) (reg)->bitfields.I2C_START = i2c_start
#define set_DVI_I2C_CNTL_0_i2c_stop(reg, i2c_stop) (reg)->bitfields.I2C_STOP = i2c_stop
#define set_DVI_I2C_CNTL_0_i2c_receive(reg, i2c_receive) (reg)->bitfields.I2C_RECEIVE = i2c_receive
#define set_DVI_I2C_CNTL_0_i2c_abort(reg, i2c_abort) (reg)->bitfields.I2C_ABORT = i2c_abort
#define set_DVI_I2C_CNTL_0_i2c_go(reg, i2c_go) (reg)->bitfields.I2C_GO = i2c_go
#define set_DVI_I2C_CNTL_0_sw_wants_to_use_dvi_i2c(reg, sw_wants_to_use_dvi_i2c) (reg)->bitfields.SW_WANTS_TO_USE_DVI_I2C = sw_wants_to_use_dvi_i2c
#define set_DVI_I2C_CNTL_0_sw_done_using_dvi_i2c(reg, sw_done_using_dvi_i2c) (reg)->bitfields.SW_DONE_USING_DVI_I2C = sw_done_using_dvi_i2c
#define set_DVI_I2C_CNTL_0_abort_hw_dvi_i2c(reg, abort_hw_dvi_i2c) (reg)->bitfields.ABORT_HW_DVI_I2C = abort_hw_dvi_i2c
#define set_DVI_I2C_CNTL_0_i2c_prescale(reg, i2c_prescale) (reg)->bitfields.I2C_PRESCALE = i2c_prescale

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DVI_I2C_CNTL_1 regDVI_I2C_CNTL_1;

#ifdef DEBUG
__inline void set_DVI_I2C_CNTL_1_i2c_data_count(regDVI_I2C_CNTL_1 *reg, unsigned int i2c_data_count)
{
  reg->bitfields.I2C_DATA_COUNT = i2c_data_count;
  if (reg->bitfields.I2C_DATA_COUNT != i2c_data_count) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_CNTL_1::I2C_DATA_COUNT data too large\n");
}
__inline void set_DVI_I2C_CNTL_1_i2c_addr_count_r2(regDVI_I2C_CNTL_1 *reg, unsigned int i2c_addr_count_r2)
{
  reg->bitfields.I2C_ADDR_COUNT_R2 = i2c_addr_count_r2;
  if (reg->bitfields.I2C_ADDR_COUNT_R2 != i2c_addr_count_r2) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_CNTL_1::I2C_ADDR_COUNT_R2 data too large\n");
}
__inline void set_DVI_I2C_CNTL_1_i2c_intra_byte_delay(regDVI_I2C_CNTL_1 *reg, unsigned int i2c_intra_byte_delay)
{
  reg->bitfields.I2C_INTRA_BYTE_DELAY = i2c_intra_byte_delay;
  if (reg->bitfields.I2C_INTRA_BYTE_DELAY != i2c_intra_byte_delay) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_CNTL_1::I2C_INTRA_BYTE_DELAY data too large\n");
}
__inline void set_DVI_I2C_CNTL_1_i2c_sel(regDVI_I2C_CNTL_1 *reg, unsigned int i2c_sel)
{
  reg->bitfields.I2C_SEL = i2c_sel;
  if (reg->bitfields.I2C_SEL != i2c_sel) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_CNTL_1::I2C_SEL data too large\n");
}
__inline void set_DVI_I2C_CNTL_1_i2c_en(regDVI_I2C_CNTL_1 *reg, unsigned int i2c_en)
{
  reg->bitfields.I2C_EN = i2c_en;
  if (reg->bitfields.I2C_EN != i2c_en) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_CNTL_1::I2C_EN data too large\n");
}
__inline void set_DVI_I2C_CNTL_1_i2c_time_limit(regDVI_I2C_CNTL_1 *reg, unsigned int i2c_time_limit)
{
  reg->bitfields.I2C_TIME_LIMIT = i2c_time_limit;
  if (reg->bitfields.I2C_TIME_LIMIT != i2c_time_limit) HSLDPF(E_ERROR_MESSAGE,"DVI_I2C_CNTL_1::I2C_TIME_LIMIT data too large\n");
}
#else
#define set_DVI_I2C_CNTL_1_i2c_data_count(reg, i2c_data_count) (reg)->bitfields.I2C_DATA_COUNT = i2c_data_count
#define set_DVI_I2C_CNTL_1_i2c_addr_count_r2(reg, i2c_addr_count_r2) (reg)->bitfields.I2C_ADDR_COUNT_R2 = i2c_addr_count_r2
#define set_DVI_I2C_CNTL_1_i2c_intra_byte_delay(reg, i2c_intra_byte_delay) (reg)->bitfields.I2C_INTRA_BYTE_DELAY = i2c_intra_byte_delay
#define set_DVI_I2C_CNTL_1_i2c_sel(reg, i2c_sel) (reg)->bitfields.I2C_SEL = i2c_sel
#define set_DVI_I2C_CNTL_1_i2c_en(reg, i2c_en) (reg)->bitfields.I2C_EN = i2c_en
#define set_DVI_I2C_CNTL_1_i2c_time_limit(reg, i2c_time_limit) (reg)->bitfields.I2C_TIME_LIMIT = i2c_time_limit

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union GRPH_BUFFER_CNTL regGRPH_BUFFER_CNTL;

#ifdef DEBUG
__inline void set_GRPH_BUFFER_CNTL_grph_start_req(regGRPH_BUFFER_CNTL *reg, unsigned int grph_start_req)
{
  reg->bitfields.GRPH_START_REQ = grph_start_req;
  if (reg->bitfields.GRPH_START_REQ != grph_start_req) HSLDPF(E_ERROR_MESSAGE,"GRPH_BUFFER_CNTL::GRPH_START_REQ data too large\n");
}
__inline void set_GRPH_BUFFER_CNTL_grph_stop_req(regGRPH_BUFFER_CNTL *reg, unsigned int grph_stop_req)
{
  reg->bitfields.GRPH_STOP_REQ = grph_stop_req;
  if (reg->bitfields.GRPH_STOP_REQ != grph_stop_req) HSLDPF(E_ERROR_MESSAGE,"GRPH_BUFFER_CNTL::GRPH_STOP_REQ data too large\n");
}
__inline void set_GRPH_BUFFER_CNTL_grph_critical_point(regGRPH_BUFFER_CNTL *reg, unsigned int grph_critical_point)
{
  reg->bitfields.GRPH_CRITICAL_POINT = grph_critical_point;
  if (reg->bitfields.GRPH_CRITICAL_POINT != grph_critical_point) HSLDPF(E_ERROR_MESSAGE,"GRPH_BUFFER_CNTL::GRPH_CRITICAL_POINT data too large\n");
}
__inline void set_GRPH_BUFFER_CNTL_grph_critical_cntl(regGRPH_BUFFER_CNTL *reg, unsigned int grph_critical_cntl)
{
  reg->bitfields.GRPH_CRITICAL_CNTL = grph_critical_cntl;
  if (reg->bitfields.GRPH_CRITICAL_CNTL != grph_critical_cntl) HSLDPF(E_ERROR_MESSAGE,"GRPH_BUFFER_CNTL::GRPH_CRITICAL_CNTL data too large\n");
}
__inline void set_GRPH_BUFFER_CNTL_grph_buffer_size(regGRPH_BUFFER_CNTL *reg, unsigned int grph_buffer_size)
{
  reg->bitfields.GRPH_BUFFER_SIZE = grph_buffer_size;
  if (reg->bitfields.GRPH_BUFFER_SIZE != grph_buffer_size) HSLDPF(E_ERROR_MESSAGE,"GRPH_BUFFER_CNTL::GRPH_BUFFER_SIZE data too large\n");
}
__inline void set_GRPH_BUFFER_CNTL_grph_critical_at_sof(regGRPH_BUFFER_CNTL *reg, unsigned int grph_critical_at_sof)
{
  reg->bitfields.GRPH_CRITICAL_AT_SOF = grph_critical_at_sof;
  if (reg->bitfields.GRPH_CRITICAL_AT_SOF != grph_critical_at_sof) HSLDPF(E_ERROR_MESSAGE,"GRPH_BUFFER_CNTL::GRPH_CRITICAL_AT_SOF data too large\n");
}
__inline void set_GRPH_BUFFER_CNTL_grph_stop_cntl(regGRPH_BUFFER_CNTL *reg, unsigned int grph_stop_cntl)
{
  reg->bitfields.GRPH_STOP_CNTL = grph_stop_cntl;
  if (reg->bitfields.GRPH_STOP_CNTL != grph_stop_cntl) HSLDPF(E_ERROR_MESSAGE,"GRPH_BUFFER_CNTL::GRPH_STOP_CNTL data too large\n");
}
#else
#define set_GRPH_BUFFER_CNTL_grph_start_req(reg, grph_start_req) (reg)->bitfields.GRPH_START_REQ = grph_start_req
#define set_GRPH_BUFFER_CNTL_grph_stop_req(reg, grph_stop_req) (reg)->bitfields.GRPH_STOP_REQ = grph_stop_req
#define set_GRPH_BUFFER_CNTL_grph_critical_point(reg, grph_critical_point) (reg)->bitfields.GRPH_CRITICAL_POINT = grph_critical_point
#define set_GRPH_BUFFER_CNTL_grph_critical_cntl(reg, grph_critical_cntl) (reg)->bitfields.GRPH_CRITICAL_CNTL = grph_critical_cntl
#define set_GRPH_BUFFER_CNTL_grph_buffer_size(reg, grph_buffer_size) (reg)->bitfields.GRPH_BUFFER_SIZE = grph_buffer_size
#define set_GRPH_BUFFER_CNTL_grph_critical_at_sof(reg, grph_critical_at_sof) (reg)->bitfields.GRPH_CRITICAL_AT_SOF = grph_critical_at_sof
#define set_GRPH_BUFFER_CNTL_grph_stop_cntl(reg, grph_stop_cntl) (reg)->bitfields.GRPH_STOP_CNTL = grph_stop_cntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC2_OFFSET_RIGHT regCRTC2_OFFSET_RIGHT;

#ifdef DEBUG
__inline void set_CRTC2_OFFSET_RIGHT_crtc2_offset_right(regCRTC2_OFFSET_RIGHT *reg, unsigned int crtc2_offset_right)
{
  reg->bitfields.CRTC2_OFFSET_RIGHT = crtc2_offset_right;
  if (reg->bitfields.CRTC2_OFFSET_RIGHT != crtc2_offset_right) HSLDPF(E_ERROR_MESSAGE,"CRTC2_OFFSET_RIGHT::CRTC2_OFFSET_RIGHT data too large\n");
}
__inline void set_CRTC2_OFFSET_RIGHT_crtc2_gui_trig_offset(regCRTC2_OFFSET_RIGHT *reg, unsigned int crtc2_gui_trig_offset)
{
  reg->bitfields.CRTC2_GUI_TRIG_OFFSET = crtc2_gui_trig_offset;
  if (reg->bitfields.CRTC2_GUI_TRIG_OFFSET != crtc2_gui_trig_offset) HSLDPF(E_ERROR_MESSAGE,"CRTC2_OFFSET_RIGHT::CRTC2_GUI_TRIG_OFFSET data too large\n");
}
__inline void set_CRTC2_OFFSET_RIGHT_crtc2_offset_lock(regCRTC2_OFFSET_RIGHT *reg, unsigned int crtc2_offset_lock)
{
  reg->bitfields.CRTC2_OFFSET_LOCK = crtc2_offset_lock;
  if (reg->bitfields.CRTC2_OFFSET_LOCK != crtc2_offset_lock) HSLDPF(E_ERROR_MESSAGE,"CRTC2_OFFSET_RIGHT::CRTC2_OFFSET_LOCK data too large\n");
}
#else
#define set_CRTC2_OFFSET_RIGHT_crtc2_offset_right(reg, crtc2_offset_right) (reg)->bitfields.CRTC2_OFFSET_RIGHT = crtc2_offset_right
#define set_CRTC2_OFFSET_RIGHT_crtc2_gui_trig_offset(reg, crtc2_gui_trig_offset) (reg)->bitfields.CRTC2_GUI_TRIG_OFFSET = crtc2_gui_trig_offset
#define set_CRTC2_OFFSET_RIGHT_crtc2_offset_lock(reg, crtc2_offset_lock) (reg)->bitfields.CRTC2_OFFSET_LOCK = crtc2_offset_lock

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC2_OFFSET_CNTL regCRTC2_OFFSET_CNTL;

#ifdef DEBUG
__inline void set_CRTC2_OFFSET_CNTL_crtc2_tile_line(regCRTC2_OFFSET_CNTL *reg, unsigned int crtc2_tile_line)
{
  reg->bitfields.CRTC2_TILE_LINE = crtc2_tile_line;
  if (reg->bitfields.CRTC2_TILE_LINE != crtc2_tile_line) HSLDPF(E_ERROR_MESSAGE,"CRTC2_OFFSET_CNTL::CRTC2_TILE_LINE data too large\n");
}
__inline void set_CRTC2_OFFSET_CNTL_crtc2_tile_line_right(regCRTC2_OFFSET_CNTL *reg, unsigned int crtc2_tile_line_right)
{
  reg->bitfields.CRTC2_TILE_LINE_RIGHT = crtc2_tile_line_right;
  if (reg->bitfields.CRTC2_TILE_LINE_RIGHT != crtc2_tile_line_right) HSLDPF(E_ERROR_MESSAGE,"CRTC2_OFFSET_CNTL::CRTC2_TILE_LINE_RIGHT data too large\n");
}
__inline void set_CRTC2_OFFSET_CNTL_crtc2_tile_en_right(regCRTC2_OFFSET_CNTL *reg, unsigned int crtc2_tile_en_right)
{
  reg->bitfields.CRTC2_TILE_EN_RIGHT = crtc2_tile_en_right;
  if (reg->bitfields.CRTC2_TILE_EN_RIGHT != crtc2_tile_en_right) HSLDPF(E_ERROR_MESSAGE,"CRTC2_OFFSET_CNTL::CRTC2_TILE_EN_RIGHT data too large\n");
}
__inline void set_CRTC2_OFFSET_CNTL_crtc2_tile_en(regCRTC2_OFFSET_CNTL *reg, unsigned int crtc2_tile_en)
{
  reg->bitfields.CRTC2_TILE_EN = crtc2_tile_en;
  if (reg->bitfields.CRTC2_TILE_EN != crtc2_tile_en) HSLDPF(E_ERROR_MESSAGE,"CRTC2_OFFSET_CNTL::CRTC2_TILE_EN data too large\n");
}
__inline void set_CRTC2_OFFSET_CNTL_crtc2_offset_flip_cntl(regCRTC2_OFFSET_CNTL *reg, unsigned int crtc2_offset_flip_cntl)
{
  reg->bitfields.CRTC2_OFFSET_FLIP_CNTL = crtc2_offset_flip_cntl;
  if (reg->bitfields.CRTC2_OFFSET_FLIP_CNTL != crtc2_offset_flip_cntl) HSLDPF(E_ERROR_MESSAGE,"CRTC2_OFFSET_CNTL::CRTC2_OFFSET_FLIP_CNTL data too large\n");
}
__inline void set_CRTC2_OFFSET_CNTL_crtc2_stereo_offset_en(regCRTC2_OFFSET_CNTL *reg, unsigned int crtc2_stereo_offset_en)
{
  reg->bitfields.CRTC2_STEREO_OFFSET_EN = crtc2_stereo_offset_en;
  if (reg->bitfields.CRTC2_STEREO_OFFSET_EN != crtc2_stereo_offset_en) HSLDPF(E_ERROR_MESSAGE,"CRTC2_OFFSET_CNTL::CRTC2_STEREO_OFFSET_EN data too large\n");
}
__inline void set_CRTC2_OFFSET_CNTL_crtc2_stereo_sync_en(regCRTC2_OFFSET_CNTL *reg, unsigned int crtc2_stereo_sync_en)
{
  reg->bitfields.CRTC2_STEREO_SYNC_EN = crtc2_stereo_sync_en;
  if (reg->bitfields.CRTC2_STEREO_SYNC_EN != crtc2_stereo_sync_en) HSLDPF(E_ERROR_MESSAGE,"CRTC2_OFFSET_CNTL::CRTC2_STEREO_SYNC_EN data too large\n");
}
__inline void set_CRTC2_OFFSET_CNTL_crtc2_stereo_sync(regCRTC2_OFFSET_CNTL *reg, unsigned int crtc2_stereo_sync)
{
  reg->bitfields.CRTC2_STEREO_SYNC = crtc2_stereo_sync;
  if (reg->bitfields.CRTC2_STEREO_SYNC != crtc2_stereo_sync) HSLDPF(E_ERROR_MESSAGE,"CRTC2_OFFSET_CNTL::CRTC2_STEREO_SYNC data too large\n");
}
__inline void set_CRTC2_OFFSET_CNTL_crtc2_gui_trig_offset_left_en(regCRTC2_OFFSET_CNTL *reg, unsigned int crtc2_gui_trig_offset_left_en)
{
  reg->bitfields.CRTC2_GUI_TRIG_OFFSET_LEFT_EN = crtc2_gui_trig_offset_left_en;
  if (reg->bitfields.CRTC2_GUI_TRIG_OFFSET_LEFT_EN != crtc2_gui_trig_offset_left_en) HSLDPF(E_ERROR_MESSAGE,"CRTC2_OFFSET_CNTL::CRTC2_GUI_TRIG_OFFSET_LEFT_EN data too large\n");
}
__inline void set_CRTC2_OFFSET_CNTL_crtc2_gui_trig_offset_right_en(regCRTC2_OFFSET_CNTL *reg, unsigned int crtc2_gui_trig_offset_right_en)
{
  reg->bitfields.CRTC2_GUI_TRIG_OFFSET_RIGHT_EN = crtc2_gui_trig_offset_right_en;
  if (reg->bitfields.CRTC2_GUI_TRIG_OFFSET_RIGHT_EN != crtc2_gui_trig_offset_right_en) HSLDPF(E_ERROR_MESSAGE,"CRTC2_OFFSET_CNTL::CRTC2_GUI_TRIG_OFFSET_RIGHT_EN data too large\n");
}
__inline void set_CRTC2_OFFSET_CNTL_crtc2_gui_trig_offset(regCRTC2_OFFSET_CNTL *reg, unsigned int crtc2_gui_trig_offset)
{
  reg->bitfields.CRTC2_GUI_TRIG_OFFSET = crtc2_gui_trig_offset;
  if (reg->bitfields.CRTC2_GUI_TRIG_OFFSET != crtc2_gui_trig_offset) HSLDPF(E_ERROR_MESSAGE,"CRTC2_OFFSET_CNTL::CRTC2_GUI_TRIG_OFFSET data too large\n");
}
__inline void set_CRTC2_OFFSET_CNTL_crtc2_offset_lock(regCRTC2_OFFSET_CNTL *reg, unsigned int crtc2_offset_lock)
{
  reg->bitfields.CRTC2_OFFSET_LOCK = crtc2_offset_lock;
  if (reg->bitfields.CRTC2_OFFSET_LOCK != crtc2_offset_lock) HSLDPF(E_ERROR_MESSAGE,"CRTC2_OFFSET_CNTL::CRTC2_OFFSET_LOCK data too large\n");
}
#else
#define set_CRTC2_OFFSET_CNTL_crtc2_tile_line(reg, crtc2_tile_line) (reg)->bitfields.CRTC2_TILE_LINE = crtc2_tile_line
#define set_CRTC2_OFFSET_CNTL_crtc2_tile_line_right(reg, crtc2_tile_line_right) (reg)->bitfields.CRTC2_TILE_LINE_RIGHT = crtc2_tile_line_right
#define set_CRTC2_OFFSET_CNTL_crtc2_tile_en_right(reg, crtc2_tile_en_right) (reg)->bitfields.CRTC2_TILE_EN_RIGHT = crtc2_tile_en_right
#define set_CRTC2_OFFSET_CNTL_crtc2_tile_en(reg, crtc2_tile_en) (reg)->bitfields.CRTC2_TILE_EN = crtc2_tile_en
#define set_CRTC2_OFFSET_CNTL_crtc2_offset_flip_cntl(reg, crtc2_offset_flip_cntl) (reg)->bitfields.CRTC2_OFFSET_FLIP_CNTL = crtc2_offset_flip_cntl
#define set_CRTC2_OFFSET_CNTL_crtc2_stereo_offset_en(reg, crtc2_stereo_offset_en) (reg)->bitfields.CRTC2_STEREO_OFFSET_EN = crtc2_stereo_offset_en
#define set_CRTC2_OFFSET_CNTL_crtc2_stereo_sync_en(reg, crtc2_stereo_sync_en) (reg)->bitfields.CRTC2_STEREO_SYNC_EN = crtc2_stereo_sync_en
#define set_CRTC2_OFFSET_CNTL_crtc2_stereo_sync(reg, crtc2_stereo_sync) (reg)->bitfields.CRTC2_STEREO_SYNC = crtc2_stereo_sync
#define set_CRTC2_OFFSET_CNTL_crtc2_gui_trig_offset_left_en(reg, crtc2_gui_trig_offset_left_en) (reg)->bitfields.CRTC2_GUI_TRIG_OFFSET_LEFT_EN = crtc2_gui_trig_offset_left_en
#define set_CRTC2_OFFSET_CNTL_crtc2_gui_trig_offset_right_en(reg, crtc2_gui_trig_offset_right_en) (reg)->bitfields.CRTC2_GUI_TRIG_OFFSET_RIGHT_EN = crtc2_gui_trig_offset_right_en
#define set_CRTC2_OFFSET_CNTL_crtc2_gui_trig_offset(reg, crtc2_gui_trig_offset) (reg)->bitfields.CRTC2_GUI_TRIG_OFFSET = crtc2_gui_trig_offset
#define set_CRTC2_OFFSET_CNTL_crtc2_offset_lock(reg, crtc2_offset_lock) (reg)->bitfields.CRTC2_OFFSET_LOCK = crtc2_offset_lock

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC2_PITCH regCRTC2_PITCH;

#ifdef DEBUG
__inline void set_CRTC2_PITCH_crtc2_pitch(regCRTC2_PITCH *reg, unsigned int crtc2_pitch)
{
  reg->bitfields.CRTC2_PITCH = crtc2_pitch;
  if (reg->bitfields.CRTC2_PITCH != crtc2_pitch) HSLDPF(E_ERROR_MESSAGE,"CRTC2_PITCH::CRTC2_PITCH data too large\n");
}
__inline void set_CRTC2_PITCH_crtc2_pitch_right(regCRTC2_PITCH *reg, unsigned int crtc2_pitch_right)
{
  reg->bitfields.CRTC2_PITCH_RIGHT = crtc2_pitch_right;
  if (reg->bitfields.CRTC2_PITCH_RIGHT != crtc2_pitch_right) HSLDPF(E_ERROR_MESSAGE,"CRTC2_PITCH::CRTC2_PITCH_RIGHT data too large\n");
}
#else
#define set_CRTC2_PITCH_crtc2_pitch(reg, crtc2_pitch) (reg)->bitfields.CRTC2_PITCH = crtc2_pitch
#define set_CRTC2_PITCH_crtc2_pitch_right(reg, crtc2_pitch_right) (reg)->bitfields.CRTC2_PITCH_RIGHT = crtc2_pitch_right

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DVO_STRENGTH_CNTL regDVO_STRENGTH_CNTL;

#ifdef DEBUG
__inline void set_DVO_STRENGTH_CNTL_dvo_sp(regDVO_STRENGTH_CNTL *reg, unsigned int dvo_sp)
{
  reg->bitfields.DVO_SP = dvo_sp;
  if (reg->bitfields.DVO_SP != dvo_sp) HSLDPF(E_ERROR_MESSAGE,"DVO_STRENGTH_CNTL::DVO_SP data too large\n");
}
__inline void set_DVO_STRENGTH_CNTL_dvo_sn(regDVO_STRENGTH_CNTL *reg, unsigned int dvo_sn)
{
  reg->bitfields.DVO_SN = dvo_sn;
  if (reg->bitfields.DVO_SN != dvo_sn) HSLDPF(E_ERROR_MESSAGE,"DVO_STRENGTH_CNTL::DVO_SN data too large\n");
}
__inline void set_DVO_STRENGTH_CNTL_dvoclk_sp(regDVO_STRENGTH_CNTL *reg, unsigned int dvoclk_sp)
{
  reg->bitfields.DVOCLK_SP = dvoclk_sp;
  if (reg->bitfields.DVOCLK_SP != dvoclk_sp) HSLDPF(E_ERROR_MESSAGE,"DVO_STRENGTH_CNTL::DVOCLK_SP data too large\n");
}
__inline void set_DVO_STRENGTH_CNTL_dvoclk_sn(regDVO_STRENGTH_CNTL *reg, unsigned int dvoclk_sn)
{
  reg->bitfields.DVOCLK_SN = dvoclk_sn;
  if (reg->bitfields.DVOCLK_SN != dvoclk_sn) HSLDPF(E_ERROR_MESSAGE,"DVO_STRENGTH_CNTL::DVOCLK_SN data too large\n");
}
__inline void set_DVO_STRENGTH_CNTL_dvo_srp(regDVO_STRENGTH_CNTL *reg, unsigned int dvo_srp)
{
  reg->bitfields.DVO_SRP = dvo_srp;
  if (reg->bitfields.DVO_SRP != dvo_srp) HSLDPF(E_ERROR_MESSAGE,"DVO_STRENGTH_CNTL::DVO_SRP data too large\n");
}
__inline void set_DVO_STRENGTH_CNTL_dvo_srn(regDVO_STRENGTH_CNTL *reg, unsigned int dvo_srn)
{
  reg->bitfields.DVO_SRN = dvo_srn;
  if (reg->bitfields.DVO_SRN != dvo_srn) HSLDPF(E_ERROR_MESSAGE,"DVO_STRENGTH_CNTL::DVO_SRN data too large\n");
}
__inline void set_DVO_STRENGTH_CNTL_dvoclk_srp(regDVO_STRENGTH_CNTL *reg, unsigned int dvoclk_srp)
{
  reg->bitfields.DVOCLK_SRP = dvoclk_srp;
  if (reg->bitfields.DVOCLK_SRP != dvoclk_srp) HSLDPF(E_ERROR_MESSAGE,"DVO_STRENGTH_CNTL::DVOCLK_SRP data too large\n");
}
__inline void set_DVO_STRENGTH_CNTL_dvoclk_srn(regDVO_STRENGTH_CNTL *reg, unsigned int dvoclk_srn)
{
  reg->bitfields.DVOCLK_SRN = dvoclk_srn;
  if (reg->bitfields.DVOCLK_SRN != dvoclk_srn) HSLDPF(E_ERROR_MESSAGE,"DVO_STRENGTH_CNTL::DVOCLK_SRN data too large\n");
}
#else
#define set_DVO_STRENGTH_CNTL_dvo_sp(reg, dvo_sp) (reg)->bitfields.DVO_SP = dvo_sp
#define set_DVO_STRENGTH_CNTL_dvo_sn(reg, dvo_sn) (reg)->bitfields.DVO_SN = dvo_sn
#define set_DVO_STRENGTH_CNTL_dvoclk_sp(reg, dvoclk_sp) (reg)->bitfields.DVOCLK_SP = dvoclk_sp
#define set_DVO_STRENGTH_CNTL_dvoclk_sn(reg, dvoclk_sn) (reg)->bitfields.DVOCLK_SN = dvoclk_sn
#define set_DVO_STRENGTH_CNTL_dvo_srp(reg, dvo_srp) (reg)->bitfields.DVO_SRP = dvo_srp
#define set_DVO_STRENGTH_CNTL_dvo_srn(reg, dvo_srn) (reg)->bitfields.DVO_SRN = dvo_srn
#define set_DVO_STRENGTH_CNTL_dvoclk_srp(reg, dvoclk_srp) (reg)->bitfields.DVOCLK_SRP = dvoclk_srp
#define set_DVO_STRENGTH_CNTL_dvoclk_srn(reg, dvoclk_srn) (reg)->bitfields.DVOCLK_SRN = dvoclk_srn

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TVO_STRENGTH_CNTL regTVO_STRENGTH_CNTL;

#ifdef DEBUG
__inline void set_TVO_STRENGTH_CNTL_tvo_sp(regTVO_STRENGTH_CNTL *reg, unsigned int tvo_sp)
{
  reg->bitfields.TVO_SP = tvo_sp;
  if (reg->bitfields.TVO_SP != tvo_sp) HSLDPF(E_ERROR_MESSAGE,"TVO_STRENGTH_CNTL::TVO_SP data too large\n");
}
__inline void set_TVO_STRENGTH_CNTL_tvo_sn(regTVO_STRENGTH_CNTL *reg, unsigned int tvo_sn)
{
  reg->bitfields.TVO_SN = tvo_sn;
  if (reg->bitfields.TVO_SN != tvo_sn) HSLDPF(E_ERROR_MESSAGE,"TVO_STRENGTH_CNTL::TVO_SN data too large\n");
}
__inline void set_TVO_STRENGTH_CNTL_tvoclk_sp(regTVO_STRENGTH_CNTL *reg, unsigned int tvoclk_sp)
{
  reg->bitfields.TVOCLK_SP = tvoclk_sp;
  if (reg->bitfields.TVOCLK_SP != tvoclk_sp) HSLDPF(E_ERROR_MESSAGE,"TVO_STRENGTH_CNTL::TVOCLK_SP data too large\n");
}
__inline void set_TVO_STRENGTH_CNTL_tvoclk_sn(regTVO_STRENGTH_CNTL *reg, unsigned int tvoclk_sn)
{
  reg->bitfields.TVOCLK_SN = tvoclk_sn;
  if (reg->bitfields.TVOCLK_SN != tvoclk_sn) HSLDPF(E_ERROR_MESSAGE,"TVO_STRENGTH_CNTL::TVOCLK_SN data too large\n");
}
__inline void set_TVO_STRENGTH_CNTL_tvo_srp(regTVO_STRENGTH_CNTL *reg, unsigned int tvo_srp)
{
  reg->bitfields.TVO_SRP = tvo_srp;
  if (reg->bitfields.TVO_SRP != tvo_srp) HSLDPF(E_ERROR_MESSAGE,"TVO_STRENGTH_CNTL::TVO_SRP data too large\n");
}
__inline void set_TVO_STRENGTH_CNTL_tvo_srn(regTVO_STRENGTH_CNTL *reg, unsigned int tvo_srn)
{
  reg->bitfields.TVO_SRN = tvo_srn;
  if (reg->bitfields.TVO_SRN != tvo_srn) HSLDPF(E_ERROR_MESSAGE,"TVO_STRENGTH_CNTL::TVO_SRN data too large\n");
}
__inline void set_TVO_STRENGTH_CNTL_tvoclk_srp(regTVO_STRENGTH_CNTL *reg, unsigned int tvoclk_srp)
{
  reg->bitfields.TVOCLK_SRP = tvoclk_srp;
  if (reg->bitfields.TVOCLK_SRP != tvoclk_srp) HSLDPF(E_ERROR_MESSAGE,"TVO_STRENGTH_CNTL::TVOCLK_SRP data too large\n");
}
__inline void set_TVO_STRENGTH_CNTL_tvoclk_srn(regTVO_STRENGTH_CNTL *reg, unsigned int tvoclk_srn)
{
  reg->bitfields.TVOCLK_SRN = tvoclk_srn;
  if (reg->bitfields.TVOCLK_SRN != tvoclk_srn) HSLDPF(E_ERROR_MESSAGE,"TVO_STRENGTH_CNTL::TVOCLK_SRN data too large\n");
}
#else
#define set_TVO_STRENGTH_CNTL_tvo_sp(reg, tvo_sp) (reg)->bitfields.TVO_SP = tvo_sp
#define set_TVO_STRENGTH_CNTL_tvo_sn(reg, tvo_sn) (reg)->bitfields.TVO_SN = tvo_sn
#define set_TVO_STRENGTH_CNTL_tvoclk_sp(reg, tvoclk_sp) (reg)->bitfields.TVOCLK_SP = tvoclk_sp
#define set_TVO_STRENGTH_CNTL_tvoclk_sn(reg, tvoclk_sn) (reg)->bitfields.TVOCLK_SN = tvoclk_sn
#define set_TVO_STRENGTH_CNTL_tvo_srp(reg, tvo_srp) (reg)->bitfields.TVO_SRP = tvo_srp
#define set_TVO_STRENGTH_CNTL_tvo_srn(reg, tvo_srn) (reg)->bitfields.TVO_SRN = tvo_srn
#define set_TVO_STRENGTH_CNTL_tvoclk_srp(reg, tvoclk_srp) (reg)->bitfields.TVOCLK_SRP = tvoclk_srp
#define set_TVO_STRENGTH_CNTL_tvoclk_srn(reg, tvoclk_srn) (reg)->bitfields.TVOCLK_SRN = tvoclk_srn

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CRTC2_GEN_CNTL regCRTC2_GEN_CNTL;

#ifdef DEBUG
__inline void set_CRTC2_GEN_CNTL_crtc2_dbl_scan_en(regCRTC2_GEN_CNTL *reg, unsigned int crtc2_dbl_scan_en)
{
  reg->bitfields.CRTC2_DBL_SCAN_EN = crtc2_dbl_scan_en;
  if (reg->bitfields.CRTC2_DBL_SCAN_EN != crtc2_dbl_scan_en) HSLDPF(E_ERROR_MESSAGE,"CRTC2_GEN_CNTL::CRTC2_DBL_SCAN_EN data too large\n");
}
__inline void set_CRTC2_GEN_CNTL_crtc2_interlace_en(regCRTC2_GEN_CNTL *reg, unsigned int crtc2_interlace_en)
{
  reg->bitfields.CRTC2_INTERLACE_EN = crtc2_interlace_en;
  if (reg->bitfields.CRTC2_INTERLACE_EN != crtc2_interlace_en) HSLDPF(E_ERROR_MESSAGE,"CRTC2_GEN_CNTL::CRTC2_INTERLACE_EN data too large\n");
}
__inline void set_CRTC2_GEN_CNTL_crtc2_pix_width(regCRTC2_GEN_CNTL *reg, unsigned int crtc2_pix_width)
{
  reg->bitfields.CRTC2_PIX_WIDTH = crtc2_pix_width;
  if (reg->bitfields.CRTC2_PIX_WIDTH != crtc2_pix_width) HSLDPF(E_ERROR_MESSAGE,"CRTC2_GEN_CNTL::CRTC2_PIX_WIDTH data too large\n");
}
__inline void set_CRTC2_GEN_CNTL_crtc2_cur_en(regCRTC2_GEN_CNTL *reg, unsigned int crtc2_cur_en)
{
  reg->bitfields.CRTC2_CUR_EN = crtc2_cur_en;
  if (reg->bitfields.CRTC2_CUR_EN != crtc2_cur_en) HSLDPF(E_ERROR_MESSAGE,"CRTC2_GEN_CNTL::CRTC2_CUR_EN data too large\n");
}
__inline void set_CRTC2_GEN_CNTL_crtc2_cur_mode(regCRTC2_GEN_CNTL *reg, unsigned int crtc2_cur_mode)
{
  reg->bitfields.CRTC2_CUR_MODE = crtc2_cur_mode;
  if (reg->bitfields.CRTC2_CUR_MODE != crtc2_cur_mode) HSLDPF(E_ERROR_MESSAGE,"CRTC2_GEN_CNTL::CRTC2_CUR_MODE data too large\n");
}
__inline void set_CRTC2_GEN_CNTL_crtc2_display_dis(regCRTC2_GEN_CNTL *reg, unsigned int crtc2_display_dis)
{
  reg->bitfields.CRTC2_DISPLAY_DIS = crtc2_display_dis;
  if (reg->bitfields.CRTC2_DISPLAY_DIS != crtc2_display_dis) HSLDPF(E_ERROR_MESSAGE,"CRTC2_GEN_CNTL::CRTC2_DISPLAY_DIS data too large\n");
}
__inline void set_CRTC2_GEN_CNTL_crtc2_en(regCRTC2_GEN_CNTL *reg, unsigned int crtc2_en)
{
  reg->bitfields.CRTC2_EN = crtc2_en;
  if (reg->bitfields.CRTC2_EN != crtc2_en) HSLDPF(E_ERROR_MESSAGE,"CRTC2_GEN_CNTL::CRTC2_EN data too large\n");
}
__inline void set_CRTC2_GEN_CNTL_crtc2_disp_req_en_b(regCRTC2_GEN_CNTL *reg, unsigned int crtc2_disp_req_en_b)
{
  reg->bitfields.CRTC2_DISP_REQ_EN_B = crtc2_disp_req_en_b;
  if (reg->bitfields.CRTC2_DISP_REQ_EN_B != crtc2_disp_req_en_b) HSLDPF(E_ERROR_MESSAGE,"CRTC2_GEN_CNTL::CRTC2_DISP_REQ_EN_B data too large\n");
}
#else
#define set_CRTC2_GEN_CNTL_crtc2_dbl_scan_en(reg, crtc2_dbl_scan_en) (reg)->bitfields.CRTC2_DBL_SCAN_EN = crtc2_dbl_scan_en
#define set_CRTC2_GEN_CNTL_crtc2_interlace_en(reg, crtc2_interlace_en) (reg)->bitfields.CRTC2_INTERLACE_EN = crtc2_interlace_en
#define set_CRTC2_GEN_CNTL_crtc2_pix_width(reg, crtc2_pix_width) (reg)->bitfields.CRTC2_PIX_WIDTH = crtc2_pix_width
#define set_CRTC2_GEN_CNTL_crtc2_cur_en(reg, crtc2_cur_en) (reg)->bitfields.CRTC2_CUR_EN = crtc2_cur_en
#define set_CRTC2_GEN_CNTL_crtc2_cur_mode(reg, crtc2_cur_mode) (reg)->bitfields.CRTC2_CUR_MODE = crtc2_cur_mode
#define set_CRTC2_GEN_CNTL_crtc2_display_dis(reg, crtc2_display_dis) (reg)->bitfields.CRTC2_DISPLAY_DIS = crtc2_display_dis
#define set_CRTC2_GEN_CNTL_crtc2_en(reg, crtc2_en) (reg)->bitfields.CRTC2_EN = crtc2_en
#define set_CRTC2_GEN_CNTL_crtc2_disp_req_en_b(reg, crtc2_disp_req_en_b) (reg)->bitfields.CRTC2_DISP_REQ_EN_B = crtc2_disp_req_en_b

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_SCALE_CNTL regOV0_SCALE_CNTL;

#ifdef DEBUG
__inline void set_OV0_SCALE_CNTL_ov0_no_read_behind_scan(regOV0_SCALE_CNTL *reg, unsigned int ov0_no_read_behind_scan)
{
  reg->bitfields.OV0_NO_READ_BEHIND_SCAN = ov0_no_read_behind_scan;
  if (reg->bitfields.OV0_NO_READ_BEHIND_SCAN != ov0_no_read_behind_scan) HSLDPF(E_ERROR_MESSAGE,"OV0_SCALE_CNTL::OV0_NO_READ_BEHIND_SCAN data too large\n");
}
__inline void set_OV0_SCALE_CNTL_ov0_horz_pick_nearest(regOV0_SCALE_CNTL *reg, unsigned int ov0_horz_pick_nearest)
{
  reg->bitfields.OV0_HORZ_PICK_NEAREST = ov0_horz_pick_nearest;
  if (reg->bitfields.OV0_HORZ_PICK_NEAREST != ov0_horz_pick_nearest) HSLDPF(E_ERROR_MESSAGE,"OV0_SCALE_CNTL::OV0_HORZ_PICK_NEAREST data too large\n");
}
__inline void set_OV0_SCALE_CNTL_ov0_vert_pick_nearest(regOV0_SCALE_CNTL *reg, unsigned int ov0_vert_pick_nearest)
{
  reg->bitfields.OV0_VERT_PICK_NEAREST = ov0_vert_pick_nearest;
  if (reg->bitfields.OV0_VERT_PICK_NEAREST != ov0_vert_pick_nearest) HSLDPF(E_ERROR_MESSAGE,"OV0_SCALE_CNTL::OV0_VERT_PICK_NEAREST data too large\n");
}
__inline void set_OV0_SCALE_CNTL_ov0_signed_uv(regOV0_SCALE_CNTL *reg, unsigned int ov0_signed_uv)
{
  reg->bitfields.OV0_SIGNED_UV = ov0_signed_uv;
  if (reg->bitfields.OV0_SIGNED_UV != ov0_signed_uv) HSLDPF(E_ERROR_MESSAGE,"OV0_SCALE_CNTL::OV0_SIGNED_UV data too large\n");
}
__inline void set_OV0_SCALE_CNTL_ov0_surface_format(regOV0_SCALE_CNTL *reg, unsigned int ov0_surface_format)
{
  reg->bitfields.OV0_SURFACE_FORMAT = ov0_surface_format;
  if (reg->bitfields.OV0_SURFACE_FORMAT != ov0_surface_format) HSLDPF(E_ERROR_MESSAGE,"OV0_SCALE_CNTL::OV0_SURFACE_FORMAT data too large\n");
}
__inline void set_OV0_SCALE_CNTL_ov0_adaptive_deint(regOV0_SCALE_CNTL *reg, unsigned int ov0_adaptive_deint)
{
  reg->bitfields.OV0_ADAPTIVE_DEINT = ov0_adaptive_deint;
  if (reg->bitfields.OV0_ADAPTIVE_DEINT != ov0_adaptive_deint) HSLDPF(E_ERROR_MESSAGE,"OV0_SCALE_CNTL::OV0_ADAPTIVE_DEINT data too large\n");
}
__inline void set_OV0_SCALE_CNTL_ov0_temporal_deint(regOV0_SCALE_CNTL *reg, unsigned int ov0_temporal_deint)
{
  reg->bitfields.OV0_TEMPORAL_DEINT = ov0_temporal_deint;
  if (reg->bitfields.OV0_TEMPORAL_DEINT != ov0_temporal_deint) HSLDPF(E_ERROR_MESSAGE,"OV0_SCALE_CNTL::OV0_TEMPORAL_DEINT data too large\n");
}
__inline void set_OV0_SCALE_CNTL_ov0_crtc_sel(regOV0_SCALE_CNTL *reg, unsigned int ov0_crtc_sel)
{
  reg->bitfields.OV0_CRTC_SEL = ov0_crtc_sel;
  if (reg->bitfields.OV0_CRTC_SEL != ov0_crtc_sel) HSLDPF(E_ERROR_MESSAGE,"OV0_SCALE_CNTL::OV0_CRTC_SEL data too large\n");
}
__inline void set_OV0_SCALE_CNTL_ov0_pulldown_on_p1_only(regOV0_SCALE_CNTL *reg, unsigned int ov0_pulldown_on_p1_only)
{
  reg->bitfields.OV0_PULLDOWN_ON_P1_ONLY = ov0_pulldown_on_p1_only;
  if (reg->bitfields.OV0_PULLDOWN_ON_P1_ONLY != ov0_pulldown_on_p1_only) HSLDPF(E_ERROR_MESSAGE,"OV0_SCALE_CNTL::OV0_PULLDOWN_ON_P1_ONLY data too large\n");
}
__inline void set_OV0_SCALE_CNTL_ov0_burst_per_plane(regOV0_SCALE_CNTL *reg, unsigned int ov0_burst_per_plane)
{
  reg->bitfields.OV0_BURST_PER_PLANE = ov0_burst_per_plane;
  if (reg->bitfields.OV0_BURST_PER_PLANE != ov0_burst_per_plane) HSLDPF(E_ERROR_MESSAGE,"OV0_SCALE_CNTL::OV0_BURST_PER_PLANE data too large\n");
}
__inline void set_OV0_SCALE_CNTL_ov0_double_buffer_regs(regOV0_SCALE_CNTL *reg, unsigned int ov0_double_buffer_regs)
{
  reg->bitfields.OV0_DOUBLE_BUFFER_REGS = ov0_double_buffer_regs;
  if (reg->bitfields.OV0_DOUBLE_BUFFER_REGS != ov0_double_buffer_regs) HSLDPF(E_ERROR_MESSAGE,"OV0_SCALE_CNTL::OV0_DOUBLE_BUFFER_REGS data too large\n");
}
__inline void set_OV0_SCALE_CNTL_ov0_bandwidth(regOV0_SCALE_CNTL *reg, unsigned int ov0_bandwidth)
{
  reg->bitfields.OV0_BANDWIDTH = ov0_bandwidth;
  if (reg->bitfields.OV0_BANDWIDTH != ov0_bandwidth) HSLDPF(E_ERROR_MESSAGE,"OV0_SCALE_CNTL::OV0_BANDWIDTH data too large\n");
}
__inline void set_OV0_SCALE_CNTL_ov0_lin_trans_bypass(regOV0_SCALE_CNTL *reg, unsigned int ov0_lin_trans_bypass)
{
  reg->bitfields.OV0_LIN_TRANS_BYPASS = ov0_lin_trans_bypass;
  if (reg->bitfields.OV0_LIN_TRANS_BYPASS != ov0_lin_trans_bypass) HSLDPF(E_ERROR_MESSAGE,"OV0_SCALE_CNTL::OV0_LIN_TRANS_BYPASS data too large\n");
}
__inline void set_OV0_SCALE_CNTL_ov0_int_emu(regOV0_SCALE_CNTL *reg, unsigned int ov0_int_emu)
{
  reg->bitfields.OV0_INT_EMU = ov0_int_emu;
  if (reg->bitfields.OV0_INT_EMU != ov0_int_emu) HSLDPF(E_ERROR_MESSAGE,"OV0_SCALE_CNTL::OV0_INT_EMU data too large\n");
}
__inline void set_OV0_SCALE_CNTL_ov0_overlay_en(regOV0_SCALE_CNTL *reg, unsigned int ov0_overlay_en)
{
  reg->bitfields.OV0_OVERLAY_EN = ov0_overlay_en;
  if (reg->bitfields.OV0_OVERLAY_EN != ov0_overlay_en) HSLDPF(E_ERROR_MESSAGE,"OV0_SCALE_CNTL::OV0_OVERLAY_EN data too large\n");
}
__inline void set_OV0_SCALE_CNTL_ov0_soft_reset(regOV0_SCALE_CNTL *reg, unsigned int ov0_soft_reset)
{
  reg->bitfields.OV0_SOFT_RESET = ov0_soft_reset;
  if (reg->bitfields.OV0_SOFT_RESET != ov0_soft_reset) HSLDPF(E_ERROR_MESSAGE,"OV0_SCALE_CNTL::OV0_SOFT_RESET data too large\n");
}
#else
#define set_OV0_SCALE_CNTL_ov0_no_read_behind_scan(reg, ov0_no_read_behind_scan) (reg)->bitfields.OV0_NO_READ_BEHIND_SCAN = ov0_no_read_behind_scan
#define set_OV0_SCALE_CNTL_ov0_horz_pick_nearest(reg, ov0_horz_pick_nearest) (reg)->bitfields.OV0_HORZ_PICK_NEAREST = ov0_horz_pick_nearest
#define set_OV0_SCALE_CNTL_ov0_vert_pick_nearest(reg, ov0_vert_pick_nearest) (reg)->bitfields.OV0_VERT_PICK_NEAREST = ov0_vert_pick_nearest
#define set_OV0_SCALE_CNTL_ov0_signed_uv(reg, ov0_signed_uv) (reg)->bitfields.OV0_SIGNED_UV = ov0_signed_uv
#define set_OV0_SCALE_CNTL_ov0_surface_format(reg, ov0_surface_format) (reg)->bitfields.OV0_SURFACE_FORMAT = ov0_surface_format
#define set_OV0_SCALE_CNTL_ov0_adaptive_deint(reg, ov0_adaptive_deint) (reg)->bitfields.OV0_ADAPTIVE_DEINT = ov0_adaptive_deint
#define set_OV0_SCALE_CNTL_ov0_temporal_deint(reg, ov0_temporal_deint) (reg)->bitfields.OV0_TEMPORAL_DEINT = ov0_temporal_deint
#define set_OV0_SCALE_CNTL_ov0_crtc_sel(reg, ov0_crtc_sel) (reg)->bitfields.OV0_CRTC_SEL = ov0_crtc_sel
#define set_OV0_SCALE_CNTL_ov0_pulldown_on_p1_only(reg, ov0_pulldown_on_p1_only) (reg)->bitfields.OV0_PULLDOWN_ON_P1_ONLY = ov0_pulldown_on_p1_only
#define set_OV0_SCALE_CNTL_ov0_burst_per_plane(reg, ov0_burst_per_plane) (reg)->bitfields.OV0_BURST_PER_PLANE = ov0_burst_per_plane
#define set_OV0_SCALE_CNTL_ov0_double_buffer_regs(reg, ov0_double_buffer_regs) (reg)->bitfields.OV0_DOUBLE_BUFFER_REGS = ov0_double_buffer_regs
#define set_OV0_SCALE_CNTL_ov0_bandwidth(reg, ov0_bandwidth) (reg)->bitfields.OV0_BANDWIDTH = ov0_bandwidth
#define set_OV0_SCALE_CNTL_ov0_lin_trans_bypass(reg, ov0_lin_trans_bypass) (reg)->bitfields.OV0_LIN_TRANS_BYPASS = ov0_lin_trans_bypass
#define set_OV0_SCALE_CNTL_ov0_int_emu(reg, ov0_int_emu) (reg)->bitfields.OV0_INT_EMU = ov0_int_emu
#define set_OV0_SCALE_CNTL_ov0_overlay_en(reg, ov0_overlay_en) (reg)->bitfields.OV0_OVERLAY_EN = ov0_overlay_en
#define set_OV0_SCALE_CNTL_ov0_soft_reset(reg, ov0_soft_reset) (reg)->bitfields.OV0_SOFT_RESET = ov0_soft_reset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_DEINTERLACE_PATTERN regOV0_DEINTERLACE_PATTERN;

#ifdef DEBUG
__inline void set_OV0_DEINTERLACE_PATTERN_ov0_deint_pat_r2(regOV0_DEINTERLACE_PATTERN *reg, unsigned int ov0_deint_pat_r2)
{
  reg->bitfields.OV0_DEINT_PAT_R2 = ov0_deint_pat_r2;
  if (reg->bitfields.OV0_DEINT_PAT_R2 != ov0_deint_pat_r2) HSLDPF(E_ERROR_MESSAGE,"OV0_DEINTERLACE_PATTERN::OV0_DEINT_PAT_R2 data too large\n");
}
__inline void set_OV0_DEINTERLACE_PATTERN_ov0_deint_pat_pntr_r2(regOV0_DEINTERLACE_PATTERN *reg, unsigned int ov0_deint_pat_pntr_r2)
{
  reg->bitfields.OV0_DEINT_PAT_PNTR_R2 = ov0_deint_pat_pntr_r2;
  if (reg->bitfields.OV0_DEINT_PAT_PNTR_R2 != ov0_deint_pat_pntr_r2) HSLDPF(E_ERROR_MESSAGE,"OV0_DEINTERLACE_PATTERN::OV0_DEINT_PAT_PNTR_R2 data too large\n");
}
__inline void set_OV0_DEINTERLACE_PATTERN_ov0_deint_pat_len_m1_r2(regOV0_DEINTERLACE_PATTERN *reg, unsigned int ov0_deint_pat_len_m1_r2)
{
  reg->bitfields.OV0_DEINT_PAT_LEN_M1_R2 = ov0_deint_pat_len_m1_r2;
  if (reg->bitfields.OV0_DEINT_PAT_LEN_M1_R2 != ov0_deint_pat_len_m1_r2) HSLDPF(E_ERROR_MESSAGE,"OV0_DEINTERLACE_PATTERN::OV0_DEINT_PAT_LEN_M1_R2 data too large\n");
}
#else
#define set_OV0_DEINTERLACE_PATTERN_ov0_deint_pat_r2(reg, ov0_deint_pat_r2) (reg)->bitfields.OV0_DEINT_PAT_R2 = ov0_deint_pat_r2
#define set_OV0_DEINTERLACE_PATTERN_ov0_deint_pat_pntr_r2(reg, ov0_deint_pat_pntr_r2) (reg)->bitfields.OV0_DEINT_PAT_PNTR_R2 = ov0_deint_pat_pntr_r2
#define set_OV0_DEINTERLACE_PATTERN_ov0_deint_pat_len_m1_r2(reg, ov0_deint_pat_len_m1_r2) (reg)->bitfields.OV0_DEINT_PAT_LEN_M1_R2 = ov0_deint_pat_len_m1_r2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_TEST regOV0_TEST;

#ifdef DEBUG
__inline void set_OV0_TEST_ov0_subpic_only(regOV0_TEST *reg, unsigned int ov0_subpic_only)
{
  reg->bitfields.OV0_SUBPIC_ONLY = ov0_subpic_only;
  if (reg->bitfields.OV0_SUBPIC_ONLY != ov0_subpic_only) HSLDPF(E_ERROR_MESSAGE,"OV0_TEST::OV0_SUBPIC_ONLY data too large\n");
}
__inline void set_OV0_TEST_ov0_swap_uv(regOV0_TEST *reg, unsigned int ov0_swap_uv)
{
  reg->bitfields.OV0_SWAP_UV = ov0_swap_uv;
  if (reg->bitfields.OV0_SWAP_UV != ov0_swap_uv) HSLDPF(E_ERROR_MESSAGE,"OV0_TEST::OV0_SWAP_UV data too large\n");
}
__inline void set_OV0_TEST_ov0_noroundup(regOV0_TEST *reg, unsigned int ov0_noroundup)
{
  reg->bitfields.OV0_NOROUNDUP = ov0_noroundup;
  if (reg->bitfields.OV0_NOROUNDUP != ov0_noroundup) HSLDPF(E_ERROR_MESSAGE,"OV0_TEST::OV0_NOROUNDUP data too large\n");
}
__inline void set_OV0_TEST_ov0_4th_line_rule_en(regOV0_TEST *reg, unsigned int ov0_4th_line_rule_en)
{
  reg->bitfields.OV0_4TH_LINE_RULE_EN = ov0_4th_line_rule_en;
  if (reg->bitfields.OV0_4TH_LINE_RULE_EN != ov0_4th_line_rule_en) HSLDPF(E_ERROR_MESSAGE,"OV0_TEST::OV0_4TH_LINE_RULE_EN data too large\n");
}
__inline void set_OV0_TEST_ov0_read_behind_scan_margin(regOV0_TEST *reg, unsigned int ov0_read_behind_scan_margin)
{
  reg->bitfields.OV0_READ_BEHIND_SCAN_MARGIN = ov0_read_behind_scan_margin;
  if (reg->bitfields.OV0_READ_BEHIND_SCAN_MARGIN != ov0_read_behind_scan_margin) HSLDPF(E_ERROR_MESSAGE,"OV0_TEST::OV0_READ_BEHIND_SCAN_MARGIN data too large\n");
}
#else
#define set_OV0_TEST_ov0_subpic_only(reg, ov0_subpic_only) (reg)->bitfields.OV0_SUBPIC_ONLY = ov0_subpic_only
#define set_OV0_TEST_ov0_swap_uv(reg, ov0_swap_uv) (reg)->bitfields.OV0_SWAP_UV = ov0_swap_uv
#define set_OV0_TEST_ov0_noroundup(reg, ov0_noroundup) (reg)->bitfields.OV0_NOROUNDUP = ov0_noroundup
#define set_OV0_TEST_ov0_4th_line_rule_en(reg, ov0_4th_line_rule_en) (reg)->bitfields.OV0_4TH_LINE_RULE_EN = ov0_4th_line_rule_en
#define set_OV0_TEST_ov0_read_behind_scan_margin(reg, ov0_read_behind_scan_margin) (reg)->bitfields.OV0_READ_BEHIND_SCAN_MARGIN = ov0_read_behind_scan_margin

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_32PULLDOWN_ACCUM regOV0_32PULLDOWN_ACCUM;

#ifdef DEBUG
__inline void set_OV0_32PULLDOWN_ACCUM_ov0_32pulldown_accum(regOV0_32PULLDOWN_ACCUM *reg, unsigned int ov0_32pulldown_accum)
{
  reg->bitfields.OV0_32PULLDOWN_ACCUM = ov0_32pulldown_accum;
  if (reg->bitfields.OV0_32PULLDOWN_ACCUM != ov0_32pulldown_accum) HSLDPF(E_ERROR_MESSAGE,"OV0_32PULLDOWN_ACCUM::OV0_32PULLDOWN_ACCUM data too large\n");
}
__inline void set_OV0_32PULLDOWN_ACCUM_ov0_32pulldown_accum_valid(regOV0_32PULLDOWN_ACCUM *reg, unsigned int ov0_32pulldown_accum_valid)
{
  reg->bitfields.OV0_32PULLDOWN_ACCUM_VALID = ov0_32pulldown_accum_valid;
  if (reg->bitfields.OV0_32PULLDOWN_ACCUM_VALID != ov0_32pulldown_accum_valid) HSLDPF(E_ERROR_MESSAGE,"OV0_32PULLDOWN_ACCUM::OV0_32PULLDOWN_ACCUM_VALID data too large\n");
}
__inline void set_OV0_32PULLDOWN_ACCUM_ov0_32pulldown_accum_skipped(regOV0_32PULLDOWN_ACCUM *reg, unsigned int ov0_32pulldown_accum_skipped)
{
  reg->bitfields.OV0_32PULLDOWN_ACCUM_SKIPPED = ov0_32pulldown_accum_skipped;
  if (reg->bitfields.OV0_32PULLDOWN_ACCUM_SKIPPED != ov0_32pulldown_accum_skipped) HSLDPF(E_ERROR_MESSAGE,"OV0_32PULLDOWN_ACCUM::OV0_32PULLDOWN_ACCUM_SKIPPED data too large\n");
}
#else
#define set_OV0_32PULLDOWN_ACCUM_ov0_32pulldown_accum(reg, ov0_32pulldown_accum) (reg)->bitfields.OV0_32PULLDOWN_ACCUM = ov0_32pulldown_accum
#define set_OV0_32PULLDOWN_ACCUM_ov0_32pulldown_accum_valid(reg, ov0_32pulldown_accum_valid) (reg)->bitfields.OV0_32PULLDOWN_ACCUM_VALID = ov0_32pulldown_accum_valid
#define set_OV0_32PULLDOWN_ACCUM_ov0_32pulldown_accum_skipped(reg, ov0_32pulldown_accum_skipped) (reg)->bitfields.OV0_32PULLDOWN_ACCUM_SKIPPED = ov0_32pulldown_accum_skipped

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_TEMPORAL_DEINT_CNTL regOV0_TEMPORAL_DEINT_CNTL;

#ifdef DEBUG
__inline void set_OV0_TEMPORAL_DEINT_CNTL_ov0_dto_en(regOV0_TEMPORAL_DEINT_CNTL *reg, unsigned int ov0_dto_en)
{
  reg->bitfields.OV0_DTO_EN = ov0_dto_en;
  if (reg->bitfields.OV0_DTO_EN != ov0_dto_en) HSLDPF(E_ERROR_MESSAGE,"OV0_TEMPORAL_DEINT_CNTL::OV0_DTO_EN data too large\n");
}
__inline void set_OV0_TEMPORAL_DEINT_CNTL_ov0_clear_fifo(regOV0_TEMPORAL_DEINT_CNTL *reg, unsigned int ov0_clear_fifo)
{
  reg->bitfields.OV0_CLEAR_FIFO = ov0_clear_fifo;
  if (reg->bitfields.OV0_CLEAR_FIFO != ov0_clear_fifo) HSLDPF(E_ERROR_MESSAGE,"OV0_TEMPORAL_DEINT_CNTL::OV0_CLEAR_FIFO data too large\n");
}
__inline void set_OV0_TEMPORAL_DEINT_CNTL_ov0_dto_accum_force(regOV0_TEMPORAL_DEINT_CNTL *reg, unsigned int ov0_dto_accum_force)
{
  reg->bitfields.OV0_DTO_ACCUM_FORCE = ov0_dto_accum_force;
  if (reg->bitfields.OV0_DTO_ACCUM_FORCE != ov0_dto_accum_force) HSLDPF(E_ERROR_MESSAGE,"OV0_TEMPORAL_DEINT_CNTL::OV0_DTO_ACCUM_FORCE data too large\n");
}
__inline void set_OV0_TEMPORAL_DEINT_CNTL_ov0_deint_latest_submits(regOV0_TEMPORAL_DEINT_CNTL *reg, unsigned int ov0_deint_latest_submits)
{
  reg->bitfields.OV0_DEINT_LATEST_SUBMITS = ov0_deint_latest_submits;
  if (reg->bitfields.OV0_DEINT_LATEST_SUBMITS != ov0_deint_latest_submits) HSLDPF(E_ERROR_MESSAGE,"OV0_TEMPORAL_DEINT_CNTL::OV0_DEINT_LATEST_SUBMITS data too large\n");
}
__inline void set_OV0_TEMPORAL_DEINT_CNTL_ov0_underflow_recovery_mode(regOV0_TEMPORAL_DEINT_CNTL *reg, unsigned int ov0_underflow_recovery_mode)
{
  reg->bitfields.OV0_UNDERFLOW_RECOVERY_MODE = ov0_underflow_recovery_mode;
  if (reg->bitfields.OV0_UNDERFLOW_RECOVERY_MODE != ov0_underflow_recovery_mode) HSLDPF(E_ERROR_MESSAGE,"OV0_TEMPORAL_DEINT_CNTL::OV0_UNDERFLOW_RECOVERY_MODE data too large\n");
}
__inline void set_OV0_TEMPORAL_DEINT_CNTL_ov0_no_dto_reset_on_overflow(regOV0_TEMPORAL_DEINT_CNTL *reg, unsigned int ov0_no_dto_reset_on_overflow)
{
  reg->bitfields.OV0_NO_DTO_RESET_ON_OVERFLOW = ov0_no_dto_reset_on_overflow;
  if (reg->bitfields.OV0_NO_DTO_RESET_ON_OVERFLOW != ov0_no_dto_reset_on_overflow) HSLDPF(E_ERROR_MESSAGE,"OV0_TEMPORAL_DEINT_CNTL::OV0_NO_DTO_RESET_ON_OVERFLOW data too large\n");
}
__inline void set_OV0_TEMPORAL_DEINT_CNTL_ov0_dto_accum_overflow_en(regOV0_TEMPORAL_DEINT_CNTL *reg, unsigned int ov0_dto_accum_overflow_en)
{
  reg->bitfields.OV0_DTO_ACCUM_OVERFLOW_EN = ov0_dto_accum_overflow_en;
  if (reg->bitfields.OV0_DTO_ACCUM_OVERFLOW_EN != ov0_dto_accum_overflow_en) HSLDPF(E_ERROR_MESSAGE,"OV0_TEMPORAL_DEINT_CNTL::OV0_DTO_ACCUM_OVERFLOW_EN data too large\n");
}
__inline void set_OV0_TEMPORAL_DEINT_CNTL_ov0_dto_force_on_pol_pair(regOV0_TEMPORAL_DEINT_CNTL *reg, unsigned int ov0_dto_force_on_pol_pair)
{
  reg->bitfields.OV0_DTO_FORCE_ON_POL_PAIR = ov0_dto_force_on_pol_pair;
  if (reg->bitfields.OV0_DTO_FORCE_ON_POL_PAIR != ov0_dto_force_on_pol_pair) HSLDPF(E_ERROR_MESSAGE,"OV0_TEMPORAL_DEINT_CNTL::OV0_DTO_FORCE_ON_POL_PAIR data too large\n");
}
__inline void set_OV0_TEMPORAL_DEINT_CNTL_ov0_dto_lock(regOV0_TEMPORAL_DEINT_CNTL *reg, unsigned int ov0_dto_lock)
{
  reg->bitfields.OV0_DTO_LOCK = ov0_dto_lock;
  if (reg->bitfields.OV0_DTO_LOCK != ov0_dto_lock) HSLDPF(E_ERROR_MESSAGE,"OV0_TEMPORAL_DEINT_CNTL::OV0_DTO_LOCK data too large\n");
}
__inline void set_OV0_TEMPORAL_DEINT_CNTL_ov0_hde_divide_by(regOV0_TEMPORAL_DEINT_CNTL *reg, unsigned int ov0_hde_divide_by)
{
  reg->bitfields.OV0_HDE_DIVIDE_BY = ov0_hde_divide_by;
  if (reg->bitfields.OV0_HDE_DIVIDE_BY != ov0_hde_divide_by) HSLDPF(E_ERROR_MESSAGE,"OV0_TEMPORAL_DEINT_CNTL::OV0_HDE_DIVIDE_BY data too large\n");
}
__inline void set_OV0_TEMPORAL_DEINT_CNTL_ov0_auto_dto_loop_en(regOV0_TEMPORAL_DEINT_CNTL *reg, unsigned int ov0_auto_dto_loop_en)
{
  reg->bitfields.OV0_AUTO_DTO_LOOP_EN = ov0_auto_dto_loop_en;
  if (reg->bitfields.OV0_AUTO_DTO_LOOP_EN != ov0_auto_dto_loop_en) HSLDPF(E_ERROR_MESSAGE,"OV0_TEMPORAL_DEINT_CNTL::OV0_AUTO_DTO_LOOP_EN data too large\n");
}
__inline void set_OV0_TEMPORAL_DEINT_CNTL_ov0_use_soft_deint_alpha(regOV0_TEMPORAL_DEINT_CNTL *reg, unsigned int ov0_use_soft_deint_alpha)
{
  reg->bitfields.OV0_USE_SOFT_DEINT_ALPHA = ov0_use_soft_deint_alpha;
  if (reg->bitfields.OV0_USE_SOFT_DEINT_ALPHA != ov0_use_soft_deint_alpha) HSLDPF(E_ERROR_MESSAGE,"OV0_TEMPORAL_DEINT_CNTL::OV0_USE_SOFT_DEINT_ALPHA data too large\n");
}
__inline void set_OV0_TEMPORAL_DEINT_CNTL_ov0_soft_deint_alpha(regOV0_TEMPORAL_DEINT_CNTL *reg, unsigned int ov0_soft_deint_alpha)
{
  reg->bitfields.OV0_SOFT_DEINT_ALPHA = ov0_soft_deint_alpha;
  if (reg->bitfields.OV0_SOFT_DEINT_ALPHA != ov0_soft_deint_alpha) HSLDPF(E_ERROR_MESSAGE,"OV0_TEMPORAL_DEINT_CNTL::OV0_SOFT_DEINT_ALPHA data too large\n");
}
__inline void set_OV0_TEMPORAL_DEINT_CNTL_ov0_invert_alpha(regOV0_TEMPORAL_DEINT_CNTL *reg, unsigned int ov0_invert_alpha)
{
  reg->bitfields.OV0_INVERT_ALPHA = ov0_invert_alpha;
  if (reg->bitfields.OV0_INVERT_ALPHA != ov0_invert_alpha) HSLDPF(E_ERROR_MESSAGE,"OV0_TEMPORAL_DEINT_CNTL::OV0_INVERT_ALPHA data too large\n");
}
__inline void set_OV0_TEMPORAL_DEINT_CNTL_ov0_source_changed(regOV0_TEMPORAL_DEINT_CNTL *reg, unsigned int ov0_source_changed)
{
  reg->bitfields.OV0_SOURCE_CHANGED = ov0_source_changed;
  if (reg->bitfields.OV0_SOURCE_CHANGED != ov0_source_changed) HSLDPF(E_ERROR_MESSAGE,"OV0_TEMPORAL_DEINT_CNTL::OV0_SOURCE_CHANGED data too large\n");
}
__inline void set_OV0_TEMPORAL_DEINT_CNTL_ov0_fifo_filled(regOV0_TEMPORAL_DEINT_CNTL *reg, unsigned int ov0_fifo_filled)
{
  reg->bitfields.OV0_FIFO_FILLED = ov0_fifo_filled;
  if (reg->bitfields.OV0_FIFO_FILLED != ov0_fifo_filled) HSLDPF(E_ERROR_MESSAGE,"OV0_TEMPORAL_DEINT_CNTL::OV0_FIFO_FILLED data too large\n");
}
__inline void set_OV0_TEMPORAL_DEINT_CNTL_ov0_fifo_read_pntr(regOV0_TEMPORAL_DEINT_CNTL *reg, unsigned int ov0_fifo_read_pntr)
{
  reg->bitfields.OV0_FIFO_READ_PNTR = ov0_fifo_read_pntr;
  if (reg->bitfields.OV0_FIFO_READ_PNTR != ov0_fifo_read_pntr) HSLDPF(E_ERROR_MESSAGE,"OV0_TEMPORAL_DEINT_CNTL::OV0_FIFO_READ_PNTR data too large\n");
}
__inline void set_OV0_TEMPORAL_DEINT_CNTL_ov0_dto_accum_loaded(regOV0_TEMPORAL_DEINT_CNTL *reg, unsigned int ov0_dto_accum_loaded)
{
  reg->bitfields.OV0_DTO_ACCUM_LOADED = ov0_dto_accum_loaded;
  if (reg->bitfields.OV0_DTO_ACCUM_LOADED != ov0_dto_accum_loaded) HSLDPF(E_ERROR_MESSAGE,"OV0_TEMPORAL_DEINT_CNTL::OV0_DTO_ACCUM_LOADED data too large\n");
}
__inline void set_OV0_TEMPORAL_DEINT_CNTL_ov0_fifo_underflow(regOV0_TEMPORAL_DEINT_CNTL *reg, unsigned int ov0_fifo_underflow)
{
  reg->bitfields.OV0_FIFO_UNDERFLOW = ov0_fifo_underflow;
  if (reg->bitfields.OV0_FIFO_UNDERFLOW != ov0_fifo_underflow) HSLDPF(E_ERROR_MESSAGE,"OV0_TEMPORAL_DEINT_CNTL::OV0_FIFO_UNDERFLOW data too large\n");
}
__inline void set_OV0_TEMPORAL_DEINT_CNTL_ov0_fifo_overflow(regOV0_TEMPORAL_DEINT_CNTL *reg, unsigned int ov0_fifo_overflow)
{
  reg->bitfields.OV0_FIFO_OVERFLOW = ov0_fifo_overflow;
  if (reg->bitfields.OV0_FIFO_OVERFLOW != ov0_fifo_overflow) HSLDPF(E_ERROR_MESSAGE,"OV0_TEMPORAL_DEINT_CNTL::OV0_FIFO_OVERFLOW data too large\n");
}
#else
#define set_OV0_TEMPORAL_DEINT_CNTL_ov0_dto_en(reg, ov0_dto_en) (reg)->bitfields.OV0_DTO_EN = ov0_dto_en
#define set_OV0_TEMPORAL_DEINT_CNTL_ov0_clear_fifo(reg, ov0_clear_fifo) (reg)->bitfields.OV0_CLEAR_FIFO = ov0_clear_fifo
#define set_OV0_TEMPORAL_DEINT_CNTL_ov0_dto_accum_force(reg, ov0_dto_accum_force) (reg)->bitfields.OV0_DTO_ACCUM_FORCE = ov0_dto_accum_force
#define set_OV0_TEMPORAL_DEINT_CNTL_ov0_deint_latest_submits(reg, ov0_deint_latest_submits) (reg)->bitfields.OV0_DEINT_LATEST_SUBMITS = ov0_deint_latest_submits
#define set_OV0_TEMPORAL_DEINT_CNTL_ov0_underflow_recovery_mode(reg, ov0_underflow_recovery_mode) (reg)->bitfields.OV0_UNDERFLOW_RECOVERY_MODE = ov0_underflow_recovery_mode
#define set_OV0_TEMPORAL_DEINT_CNTL_ov0_no_dto_reset_on_overflow(reg, ov0_no_dto_reset_on_overflow) (reg)->bitfields.OV0_NO_DTO_RESET_ON_OVERFLOW = ov0_no_dto_reset_on_overflow
#define set_OV0_TEMPORAL_DEINT_CNTL_ov0_dto_accum_overflow_en(reg, ov0_dto_accum_overflow_en) (reg)->bitfields.OV0_DTO_ACCUM_OVERFLOW_EN = ov0_dto_accum_overflow_en
#define set_OV0_TEMPORAL_DEINT_CNTL_ov0_dto_force_on_pol_pair(reg, ov0_dto_force_on_pol_pair) (reg)->bitfields.OV0_DTO_FORCE_ON_POL_PAIR = ov0_dto_force_on_pol_pair
#define set_OV0_TEMPORAL_DEINT_CNTL_ov0_dto_lock(reg, ov0_dto_lock) (reg)->bitfields.OV0_DTO_LOCK = ov0_dto_lock
#define set_OV0_TEMPORAL_DEINT_CNTL_ov0_hde_divide_by(reg, ov0_hde_divide_by) (reg)->bitfields.OV0_HDE_DIVIDE_BY = ov0_hde_divide_by
#define set_OV0_TEMPORAL_DEINT_CNTL_ov0_auto_dto_loop_en(reg, ov0_auto_dto_loop_en) (reg)->bitfields.OV0_AUTO_DTO_LOOP_EN = ov0_auto_dto_loop_en
#define set_OV0_TEMPORAL_DEINT_CNTL_ov0_use_soft_deint_alpha(reg, ov0_use_soft_deint_alpha) (reg)->bitfields.OV0_USE_SOFT_DEINT_ALPHA = ov0_use_soft_deint_alpha
#define set_OV0_TEMPORAL_DEINT_CNTL_ov0_soft_deint_alpha(reg, ov0_soft_deint_alpha) (reg)->bitfields.OV0_SOFT_DEINT_ALPHA = ov0_soft_deint_alpha
#define set_OV0_TEMPORAL_DEINT_CNTL_ov0_invert_alpha(reg, ov0_invert_alpha) (reg)->bitfields.OV0_INVERT_ALPHA = ov0_invert_alpha
#define set_OV0_TEMPORAL_DEINT_CNTL_ov0_source_changed(reg, ov0_source_changed) (reg)->bitfields.OV0_SOURCE_CHANGED = ov0_source_changed
#define set_OV0_TEMPORAL_DEINT_CNTL_ov0_fifo_filled(reg, ov0_fifo_filled) (reg)->bitfields.OV0_FIFO_FILLED = ov0_fifo_filled
#define set_OV0_TEMPORAL_DEINT_CNTL_ov0_fifo_read_pntr(reg, ov0_fifo_read_pntr) (reg)->bitfields.OV0_FIFO_READ_PNTR = ov0_fifo_read_pntr
#define set_OV0_TEMPORAL_DEINT_CNTL_ov0_dto_accum_loaded(reg, ov0_dto_accum_loaded) (reg)->bitfields.OV0_DTO_ACCUM_LOADED = ov0_dto_accum_loaded
#define set_OV0_TEMPORAL_DEINT_CNTL_ov0_fifo_underflow(reg, ov0_fifo_underflow) (reg)->bitfields.OV0_FIFO_UNDERFLOW = ov0_fifo_underflow
#define set_OV0_TEMPORAL_DEINT_CNTL_ov0_fifo_overflow(reg, ov0_fifo_overflow) (reg)->bitfields.OV0_FIFO_OVERFLOW = ov0_fifo_overflow

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_DTO_ACCUM_0 regOV0_DTO_ACCUM_0;

#ifdef DEBUG
__inline void set_OV0_DTO_ACCUM_0_ov0_dto_accum_init(regOV0_DTO_ACCUM_0 *reg, unsigned int ov0_dto_accum_init)
{
  reg->bitfields.OV0_DTO_ACCUM_INIT = ov0_dto_accum_init;
  if (reg->bitfields.OV0_DTO_ACCUM_INIT != ov0_dto_accum_init) HSLDPF(E_ERROR_MESSAGE,"OV0_DTO_ACCUM_0::OV0_DTO_ACCUM_INIT data too large\n");
}
#else
#define set_OV0_DTO_ACCUM_0_ov0_dto_accum_init(reg, ov0_dto_accum_init) (reg)->bitfields.OV0_DTO_ACCUM_INIT = ov0_dto_accum_init

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_DTO_ACCUM_1 regOV0_DTO_ACCUM_1;

#ifdef DEBUG
__inline void set_OV0_DTO_ACCUM_1_ov0_accum_pol_pair_val(regOV0_DTO_ACCUM_1 *reg, unsigned int ov0_accum_pol_pair_val)
{
  reg->bitfields.OV0_ACCUM_POL_PAIR_VAL = ov0_accum_pol_pair_val;
  if (reg->bitfields.OV0_ACCUM_POL_PAIR_VAL != ov0_accum_pol_pair_val) HSLDPF(E_ERROR_MESSAGE,"OV0_DTO_ACCUM_1::OV0_ACCUM_POL_PAIR_VAL data too large\n");
}
#else
#define set_OV0_DTO_ACCUM_1_ov0_accum_pol_pair_val(reg, ov0_accum_pol_pair_val) (reg)->bitfields.OV0_ACCUM_POL_PAIR_VAL = ov0_accum_pol_pair_val

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_DTO_ACCUM_2 regOV0_DTO_ACCUM_2;

#ifdef DEBUG
__inline void set_OV0_DTO_ACCUM_2_ov0_dto_accum(regOV0_DTO_ACCUM_2 *reg, unsigned int ov0_dto_accum)
{
  reg->bitfields.OV0_DTO_ACCUM = ov0_dto_accum;
  if (reg->bitfields.OV0_DTO_ACCUM != ov0_dto_accum) HSLDPF(E_ERROR_MESSAGE,"OV0_DTO_ACCUM_2::OV0_DTO_ACCUM data too large\n");
}
#else
#define set_OV0_DTO_ACCUM_2_ov0_dto_accum(reg, ov0_dto_accum) (reg)->bitfields.OV0_DTO_ACCUM = ov0_dto_accum

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_DTO_INC regOV0_DTO_INC;

#ifdef DEBUG
__inline void set_OV0_DTO_INC_ov0_dto_inc(regOV0_DTO_INC *reg, unsigned int ov0_dto_inc)
{
  reg->bitfields.OV0_DTO_INC = ov0_dto_inc;
  if (reg->bitfields.OV0_DTO_INC != ov0_dto_inc) HSLDPF(E_ERROR_MESSAGE,"OV0_DTO_INC::OV0_DTO_INC data too large\n");
}
__inline void set_OV0_DTO_INC_ov0_dto_inc_adj(regOV0_DTO_INC *reg, unsigned int ov0_dto_inc_adj)
{
  reg->bitfields.OV0_DTO_INC_ADJ = ov0_dto_inc_adj;
  if (reg->bitfields.OV0_DTO_INC_ADJ != ov0_dto_inc_adj) HSLDPF(E_ERROR_MESSAGE,"OV0_DTO_INC::OV0_DTO_INC_ADJ data too large\n");
}
#else
#define set_OV0_DTO_INC_ov0_dto_inc(reg, ov0_dto_inc) (reg)->bitfields.OV0_DTO_INC = ov0_dto_inc
#define set_OV0_DTO_INC_ov0_dto_inc_adj(reg, ov0_dto_inc_adj) (reg)->bitfields.OV0_DTO_INC_ADJ = ov0_dto_inc_adj

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_MISC_CNTL regDISP_MISC_CNTL;

#ifdef DEBUG
__inline void set_DISP_MISC_CNTL_soft_reset_grph_pp(regDISP_MISC_CNTL *reg, unsigned int soft_reset_grph_pp)
{
  reg->bitfields.SOFT_RESET_GRPH_PP = soft_reset_grph_pp;
  if (reg->bitfields.SOFT_RESET_GRPH_PP != soft_reset_grph_pp) HSLDPF(E_ERROR_MESSAGE,"DISP_MISC_CNTL::SOFT_RESET_GRPH_PP data too large\n");
}
__inline void set_DISP_MISC_CNTL_soft_reset_subpic_pp(regDISP_MISC_CNTL *reg, unsigned int soft_reset_subpic_pp)
{
  reg->bitfields.SOFT_RESET_SUBPIC_PP = soft_reset_subpic_pp;
  if (reg->bitfields.SOFT_RESET_SUBPIC_PP != soft_reset_subpic_pp) HSLDPF(E_ERROR_MESSAGE,"DISP_MISC_CNTL::SOFT_RESET_SUBPIC_PP data too large\n");
}
__inline void set_DISP_MISC_CNTL_soft_reset_ov0_pp(regDISP_MISC_CNTL *reg, unsigned int soft_reset_ov0_pp)
{
  reg->bitfields.SOFT_RESET_OV0_PP = soft_reset_ov0_pp;
  if (reg->bitfields.SOFT_RESET_OV0_PP != soft_reset_ov0_pp) HSLDPF(E_ERROR_MESSAGE,"DISP_MISC_CNTL::SOFT_RESET_OV0_PP data too large\n");
}
__inline void set_DISP_MISC_CNTL_soft_reset_grph_sclk(regDISP_MISC_CNTL *reg, unsigned int soft_reset_grph_sclk)
{
  reg->bitfields.SOFT_RESET_GRPH_SCLK = soft_reset_grph_sclk;
  if (reg->bitfields.SOFT_RESET_GRPH_SCLK != soft_reset_grph_sclk) HSLDPF(E_ERROR_MESSAGE,"DISP_MISC_CNTL::SOFT_RESET_GRPH_SCLK data too large\n");
}
__inline void set_DISP_MISC_CNTL_soft_reset_subpic_sclk(regDISP_MISC_CNTL *reg, unsigned int soft_reset_subpic_sclk)
{
  reg->bitfields.SOFT_RESET_SUBPIC_SCLK = soft_reset_subpic_sclk;
  if (reg->bitfields.SOFT_RESET_SUBPIC_SCLK != soft_reset_subpic_sclk) HSLDPF(E_ERROR_MESSAGE,"DISP_MISC_CNTL::SOFT_RESET_SUBPIC_SCLK data too large\n");
}
__inline void set_DISP_MISC_CNTL_soft_reset_ov0_sclk(regDISP_MISC_CNTL *reg, unsigned int soft_reset_ov0_sclk)
{
  reg->bitfields.SOFT_RESET_OV0_SCLK = soft_reset_ov0_sclk;
  if (reg->bitfields.SOFT_RESET_OV0_SCLK != soft_reset_ov0_sclk) HSLDPF(E_ERROR_MESSAGE,"DISP_MISC_CNTL::SOFT_RESET_OV0_SCLK data too large\n");
}
__inline void set_DISP_MISC_CNTL_sync_strength(regDISP_MISC_CNTL *reg, unsigned int sync_strength)
{
  reg->bitfields.SYNC_STRENGTH = sync_strength;
  if (reg->bitfields.SYNC_STRENGTH != sync_strength) HSLDPF(E_ERROR_MESSAGE,"DISP_MISC_CNTL::SYNC_STRENGTH data too large\n");
}
__inline void set_DISP_MISC_CNTL_sync_pad_flop_en(regDISP_MISC_CNTL *reg, unsigned int sync_pad_flop_en)
{
  reg->bitfields.SYNC_PAD_FLOP_EN = sync_pad_flop_en;
  if (reg->bitfields.SYNC_PAD_FLOP_EN != sync_pad_flop_en) HSLDPF(E_ERROR_MESSAGE,"DISP_MISC_CNTL::SYNC_PAD_FLOP_EN data too large\n");
}
__inline void set_DISP_MISC_CNTL_soft_reset_grph2_pp(regDISP_MISC_CNTL *reg, unsigned int soft_reset_grph2_pp)
{
  reg->bitfields.SOFT_RESET_GRPH2_PP = soft_reset_grph2_pp;
  if (reg->bitfields.SOFT_RESET_GRPH2_PP != soft_reset_grph2_pp) HSLDPF(E_ERROR_MESSAGE,"DISP_MISC_CNTL::SOFT_RESET_GRPH2_PP data too large\n");
}
__inline void set_DISP_MISC_CNTL_soft_reset_grph2_sclk(regDISP_MISC_CNTL *reg, unsigned int soft_reset_grph2_sclk)
{
  reg->bitfields.SOFT_RESET_GRPH2_SCLK = soft_reset_grph2_sclk;
  if (reg->bitfields.SOFT_RESET_GRPH2_SCLK != soft_reset_grph2_sclk) HSLDPF(E_ERROR_MESSAGE,"DISP_MISC_CNTL::SOFT_RESET_GRPH2_SCLK data too large\n");
}
__inline void set_DISP_MISC_CNTL_soft_reset_tmds(regDISP_MISC_CNTL *reg, unsigned int soft_reset_tmds)
{
  reg->bitfields.SOFT_RESET_TMDS = soft_reset_tmds;
  if (reg->bitfields.SOFT_RESET_TMDS != soft_reset_tmds) HSLDPF(E_ERROR_MESSAGE,"DISP_MISC_CNTL::SOFT_RESET_TMDS data too large\n");
}
__inline void set_DISP_MISC_CNTL_soft_reset_dvo(regDISP_MISC_CNTL *reg, unsigned int soft_reset_dvo)
{
  reg->bitfields.SOFT_RESET_DVO = soft_reset_dvo;
  if (reg->bitfields.SOFT_RESET_DVO != soft_reset_dvo) HSLDPF(E_ERROR_MESSAGE,"DISP_MISC_CNTL::SOFT_RESET_DVO data too large\n");
}
__inline void set_DISP_MISC_CNTL_soft_reset_hdcp(regDISP_MISC_CNTL *reg, unsigned int soft_reset_hdcp)
{
  reg->bitfields.SOFT_RESET_HDCP = soft_reset_hdcp;
  if (reg->bitfields.SOFT_RESET_HDCP != soft_reset_hdcp) HSLDPF(E_ERROR_MESSAGE,"DISP_MISC_CNTL::SOFT_RESET_HDCP data too large\n");
}
__inline void set_DISP_MISC_CNTL_palette2_mem_rd_margin(regDISP_MISC_CNTL *reg, unsigned int palette2_mem_rd_margin)
{
  reg->bitfields.PALETTE2_MEM_RD_MARGIN = palette2_mem_rd_margin;
  if (reg->bitfields.PALETTE2_MEM_RD_MARGIN != palette2_mem_rd_margin) HSLDPF(E_ERROR_MESSAGE,"DISP_MISC_CNTL::PALETTE2_MEM_RD_MARGIN data too large\n");
}
__inline void set_DISP_MISC_CNTL_palette_mem_rd_margin(regDISP_MISC_CNTL *reg, unsigned int palette_mem_rd_margin)
{
  reg->bitfields.PALETTE_MEM_RD_MARGIN = palette_mem_rd_margin;
  if (reg->bitfields.PALETTE_MEM_RD_MARGIN != palette_mem_rd_margin) HSLDPF(E_ERROR_MESSAGE,"DISP_MISC_CNTL::PALETTE_MEM_RD_MARGIN data too large\n");
}
__inline void set_DISP_MISC_CNTL_rmx_buf_mem_rd_margin(regDISP_MISC_CNTL *reg, unsigned int rmx_buf_mem_rd_margin)
{
  reg->bitfields.RMX_BUF_MEM_RD_MARGIN = rmx_buf_mem_rd_margin;
  if (reg->bitfields.RMX_BUF_MEM_RD_MARGIN != rmx_buf_mem_rd_margin) HSLDPF(E_ERROR_MESSAGE,"DISP_MISC_CNTL::RMX_BUF_MEM_RD_MARGIN data too large\n");
}
#else
#define set_DISP_MISC_CNTL_soft_reset_grph_pp(reg, soft_reset_grph_pp) (reg)->bitfields.SOFT_RESET_GRPH_PP = soft_reset_grph_pp
#define set_DISP_MISC_CNTL_soft_reset_subpic_pp(reg, soft_reset_subpic_pp) (reg)->bitfields.SOFT_RESET_SUBPIC_PP = soft_reset_subpic_pp
#define set_DISP_MISC_CNTL_soft_reset_ov0_pp(reg, soft_reset_ov0_pp) (reg)->bitfields.SOFT_RESET_OV0_PP = soft_reset_ov0_pp
#define set_DISP_MISC_CNTL_soft_reset_grph_sclk(reg, soft_reset_grph_sclk) (reg)->bitfields.SOFT_RESET_GRPH_SCLK = soft_reset_grph_sclk
#define set_DISP_MISC_CNTL_soft_reset_subpic_sclk(reg, soft_reset_subpic_sclk) (reg)->bitfields.SOFT_RESET_SUBPIC_SCLK = soft_reset_subpic_sclk
#define set_DISP_MISC_CNTL_soft_reset_ov0_sclk(reg, soft_reset_ov0_sclk) (reg)->bitfields.SOFT_RESET_OV0_SCLK = soft_reset_ov0_sclk
#define set_DISP_MISC_CNTL_sync_strength(reg, sync_strength) (reg)->bitfields.SYNC_STRENGTH = sync_strength
#define set_DISP_MISC_CNTL_sync_pad_flop_en(reg, sync_pad_flop_en) (reg)->bitfields.SYNC_PAD_FLOP_EN = sync_pad_flop_en
#define set_DISP_MISC_CNTL_soft_reset_grph2_pp(reg, soft_reset_grph2_pp) (reg)->bitfields.SOFT_RESET_GRPH2_PP = soft_reset_grph2_pp
#define set_DISP_MISC_CNTL_soft_reset_grph2_sclk(reg, soft_reset_grph2_sclk) (reg)->bitfields.SOFT_RESET_GRPH2_SCLK = soft_reset_grph2_sclk
#define set_DISP_MISC_CNTL_soft_reset_tmds(reg, soft_reset_tmds) (reg)->bitfields.SOFT_RESET_TMDS = soft_reset_tmds
#define set_DISP_MISC_CNTL_soft_reset_dvo(reg, soft_reset_dvo) (reg)->bitfields.SOFT_RESET_DVO = soft_reset_dvo
#define set_DISP_MISC_CNTL_soft_reset_hdcp(reg, soft_reset_hdcp) (reg)->bitfields.SOFT_RESET_HDCP = soft_reset_hdcp
#define set_DISP_MISC_CNTL_palette2_mem_rd_margin(reg, palette2_mem_rd_margin) (reg)->bitfields.PALETTE2_MEM_RD_MARGIN = palette2_mem_rd_margin
#define set_DISP_MISC_CNTL_palette_mem_rd_margin(reg, palette_mem_rd_margin) (reg)->bitfields.PALETTE_MEM_RD_MARGIN = palette_mem_rd_margin
#define set_DISP_MISC_CNTL_rmx_buf_mem_rd_margin(reg, rmx_buf_mem_rd_margin) (reg)->bitfields.RMX_BUF_MEM_RD_MARGIN = rmx_buf_mem_rd_margin

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_PWR_MAN regDISP_PWR_MAN;

#ifdef DEBUG
__inline void set_DISP_PWR_MAN_disp_pwr_man_d3_crtc_en(regDISP_PWR_MAN *reg, unsigned int disp_pwr_man_d3_crtc_en)
{
  reg->bitfields.DISP_PWR_MAN_D3_CRTC_EN = disp_pwr_man_d3_crtc_en;
  if (reg->bitfields.DISP_PWR_MAN_D3_CRTC_EN != disp_pwr_man_d3_crtc_en) HSLDPF(E_ERROR_MESSAGE,"DISP_PWR_MAN::DISP_PWR_MAN_D3_CRTC_EN data too large\n");
}
__inline void set_DISP_PWR_MAN_disp2_pwr_man_d3_crtc2_en(regDISP_PWR_MAN *reg, unsigned int disp2_pwr_man_d3_crtc2_en)
{
  reg->bitfields.DISP2_PWR_MAN_D3_CRTC2_EN = disp2_pwr_man_d3_crtc2_en;
  if (reg->bitfields.DISP2_PWR_MAN_D3_CRTC2_EN != disp2_pwr_man_d3_crtc2_en) HSLDPF(E_ERROR_MESSAGE,"DISP_PWR_MAN::DISP2_PWR_MAN_D3_CRTC2_EN data too large\n");
}
__inline void set_DISP_PWR_MAN_disp_pwr_man_dpms(regDISP_PWR_MAN *reg, unsigned int disp_pwr_man_dpms)
{
  reg->bitfields.DISP_PWR_MAN_DPMS = disp_pwr_man_dpms;
  if (reg->bitfields.DISP_PWR_MAN_DPMS != disp_pwr_man_dpms) HSLDPF(E_ERROR_MESSAGE,"DISP_PWR_MAN::DISP_PWR_MAN_DPMS data too large\n");
}
__inline void set_DISP_PWR_MAN_disp_d3_rst(regDISP_PWR_MAN *reg, unsigned int disp_d3_rst)
{
  reg->bitfields.DISP_D3_RST = disp_d3_rst;
  if (reg->bitfields.DISP_D3_RST != disp_d3_rst) HSLDPF(E_ERROR_MESSAGE,"DISP_PWR_MAN::DISP_D3_RST data too large\n");
}
__inline void set_DISP_PWR_MAN_disp_d3_reg_rst(regDISP_PWR_MAN *reg, unsigned int disp_d3_reg_rst)
{
  reg->bitfields.DISP_D3_REG_RST = disp_d3_reg_rst;
  if (reg->bitfields.DISP_D3_REG_RST != disp_d3_reg_rst) HSLDPF(E_ERROR_MESSAGE,"DISP_PWR_MAN::DISP_D3_REG_RST data too large\n");
}
__inline void set_DISP_PWR_MAN_disp_d3_grph_rst(regDISP_PWR_MAN *reg, unsigned int disp_d3_grph_rst)
{
  reg->bitfields.DISP_D3_GRPH_RST = disp_d3_grph_rst;
  if (reg->bitfields.DISP_D3_GRPH_RST != disp_d3_grph_rst) HSLDPF(E_ERROR_MESSAGE,"DISP_PWR_MAN::DISP_D3_GRPH_RST data too large\n");
}
__inline void set_DISP_PWR_MAN_disp_d3_subpic_rst(regDISP_PWR_MAN *reg, unsigned int disp_d3_subpic_rst)
{
  reg->bitfields.DISP_D3_SUBPIC_RST = disp_d3_subpic_rst;
  if (reg->bitfields.DISP_D3_SUBPIC_RST != disp_d3_subpic_rst) HSLDPF(E_ERROR_MESSAGE,"DISP_PWR_MAN::DISP_D3_SUBPIC_RST data too large\n");
}
__inline void set_DISP_PWR_MAN_disp_d3_ov0_rst(regDISP_PWR_MAN *reg, unsigned int disp_d3_ov0_rst)
{
  reg->bitfields.DISP_D3_OV0_RST = disp_d3_ov0_rst;
  if (reg->bitfields.DISP_D3_OV0_RST != disp_d3_ov0_rst) HSLDPF(E_ERROR_MESSAGE,"DISP_PWR_MAN::DISP_D3_OV0_RST data too large\n");
}
__inline void set_DISP_PWR_MAN_disp_d1d2_grph_rst(regDISP_PWR_MAN *reg, unsigned int disp_d1d2_grph_rst)
{
  reg->bitfields.DISP_D1D2_GRPH_RST = disp_d1d2_grph_rst;
  if (reg->bitfields.DISP_D1D2_GRPH_RST != disp_d1d2_grph_rst) HSLDPF(E_ERROR_MESSAGE,"DISP_PWR_MAN::DISP_D1D2_GRPH_RST data too large\n");
}
__inline void set_DISP_PWR_MAN_disp_d1d2_subpic_rst(regDISP_PWR_MAN *reg, unsigned int disp_d1d2_subpic_rst)
{
  reg->bitfields.DISP_D1D2_SUBPIC_RST = disp_d1d2_subpic_rst;
  if (reg->bitfields.DISP_D1D2_SUBPIC_RST != disp_d1d2_subpic_rst) HSLDPF(E_ERROR_MESSAGE,"DISP_PWR_MAN::DISP_D1D2_SUBPIC_RST data too large\n");
}
__inline void set_DISP_PWR_MAN_disp_d1d2_ov0_rst(regDISP_PWR_MAN *reg, unsigned int disp_d1d2_ov0_rst)
{
  reg->bitfields.DISP_D1D2_OV0_RST = disp_d1d2_ov0_rst;
  if (reg->bitfields.DISP_D1D2_OV0_RST != disp_d1d2_ov0_rst) HSLDPF(E_ERROR_MESSAGE,"DISP_PWR_MAN::DISP_D1D2_OV0_RST data too large\n");
}
__inline void set_DISP_PWR_MAN_disp_dvo_enable_rst(regDISP_PWR_MAN *reg, unsigned int disp_dvo_enable_rst)
{
  reg->bitfields.DISP_DVO_ENABLE_RST = disp_dvo_enable_rst;
  if (reg->bitfields.DISP_DVO_ENABLE_RST != disp_dvo_enable_rst) HSLDPF(E_ERROR_MESSAGE,"DISP_PWR_MAN::DISP_DVO_ENABLE_RST data too large\n");
}
#else
#define set_DISP_PWR_MAN_disp_pwr_man_d3_crtc_en(reg, disp_pwr_man_d3_crtc_en) (reg)->bitfields.DISP_PWR_MAN_D3_CRTC_EN = disp_pwr_man_d3_crtc_en
#define set_DISP_PWR_MAN_disp2_pwr_man_d3_crtc2_en(reg, disp2_pwr_man_d3_crtc2_en) (reg)->bitfields.DISP2_PWR_MAN_D3_CRTC2_EN = disp2_pwr_man_d3_crtc2_en
#define set_DISP_PWR_MAN_disp_pwr_man_dpms(reg, disp_pwr_man_dpms) (reg)->bitfields.DISP_PWR_MAN_DPMS = disp_pwr_man_dpms
#define set_DISP_PWR_MAN_disp_d3_rst(reg, disp_d3_rst) (reg)->bitfields.DISP_D3_RST = disp_d3_rst
#define set_DISP_PWR_MAN_disp_d3_reg_rst(reg, disp_d3_reg_rst) (reg)->bitfields.DISP_D3_REG_RST = disp_d3_reg_rst
#define set_DISP_PWR_MAN_disp_d3_grph_rst(reg, disp_d3_grph_rst) (reg)->bitfields.DISP_D3_GRPH_RST = disp_d3_grph_rst
#define set_DISP_PWR_MAN_disp_d3_subpic_rst(reg, disp_d3_subpic_rst) (reg)->bitfields.DISP_D3_SUBPIC_RST = disp_d3_subpic_rst
#define set_DISP_PWR_MAN_disp_d3_ov0_rst(reg, disp_d3_ov0_rst) (reg)->bitfields.DISP_D3_OV0_RST = disp_d3_ov0_rst
#define set_DISP_PWR_MAN_disp_d1d2_grph_rst(reg, disp_d1d2_grph_rst) (reg)->bitfields.DISP_D1D2_GRPH_RST = disp_d1d2_grph_rst
#define set_DISP_PWR_MAN_disp_d1d2_subpic_rst(reg, disp_d1d2_subpic_rst) (reg)->bitfields.DISP_D1D2_SUBPIC_RST = disp_d1d2_subpic_rst
#define set_DISP_PWR_MAN_disp_d1d2_ov0_rst(reg, disp_d1d2_ov0_rst) (reg)->bitfields.DISP_D1D2_OV0_RST = disp_d1d2_ov0_rst
#define set_DISP_PWR_MAN_disp_dvo_enable_rst(reg, disp_dvo_enable_rst) (reg)->bitfields.DISP_DVO_ENABLE_RST = disp_dvo_enable_rst

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_HW_DEBUG regDISP_HW_DEBUG;

#ifdef DEBUG
__inline void set_DISP_HW_DEBUG_disp_hw_0_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_0_debug)
{
  reg->bitfields.DISP_HW_0_DEBUG = disp_hw_0_debug;
  if (reg->bitfields.DISP_HW_0_DEBUG != disp_hw_0_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_0_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_1_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_1_debug)
{
  reg->bitfields.DISP_HW_1_DEBUG = disp_hw_1_debug;
  if (reg->bitfields.DISP_HW_1_DEBUG != disp_hw_1_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_1_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_2_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_2_debug)
{
  reg->bitfields.DISP_HW_2_DEBUG = disp_hw_2_debug;
  if (reg->bitfields.DISP_HW_2_DEBUG != disp_hw_2_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_2_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_3_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_3_debug)
{
  reg->bitfields.DISP_HW_3_DEBUG = disp_hw_3_debug;
  if (reg->bitfields.DISP_HW_3_DEBUG != disp_hw_3_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_3_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_4_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_4_debug)
{
  reg->bitfields.DISP_HW_4_DEBUG = disp_hw_4_debug;
  if (reg->bitfields.DISP_HW_4_DEBUG != disp_hw_4_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_4_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_5_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_5_debug)
{
  reg->bitfields.DISP_HW_5_DEBUG = disp_hw_5_debug;
  if (reg->bitfields.DISP_HW_5_DEBUG != disp_hw_5_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_5_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_6_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_6_debug)
{
  reg->bitfields.DISP_HW_6_DEBUG = disp_hw_6_debug;
  if (reg->bitfields.DISP_HW_6_DEBUG != disp_hw_6_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_6_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_7_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_7_debug)
{
  reg->bitfields.DISP_HW_7_DEBUG = disp_hw_7_debug;
  if (reg->bitfields.DISP_HW_7_DEBUG != disp_hw_7_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_7_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_8_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_8_debug)
{
  reg->bitfields.DISP_HW_8_DEBUG = disp_hw_8_debug;
  if (reg->bitfields.DISP_HW_8_DEBUG != disp_hw_8_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_8_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_9_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_9_debug)
{
  reg->bitfields.DISP_HW_9_DEBUG = disp_hw_9_debug;
  if (reg->bitfields.DISP_HW_9_DEBUG != disp_hw_9_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_9_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_a_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_a_debug)
{
  reg->bitfields.DISP_HW_A_DEBUG = disp_hw_a_debug;
  if (reg->bitfields.DISP_HW_A_DEBUG != disp_hw_a_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_A_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_b_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_b_debug)
{
  reg->bitfields.DISP_HW_B_DEBUG = disp_hw_b_debug;
  if (reg->bitfields.DISP_HW_B_DEBUG != disp_hw_b_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_B_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_c_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_c_debug)
{
  reg->bitfields.DISP_HW_C_DEBUG = disp_hw_c_debug;
  if (reg->bitfields.DISP_HW_C_DEBUG != disp_hw_c_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_C_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_d_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_d_debug)
{
  reg->bitfields.DISP_HW_D_DEBUG = disp_hw_d_debug;
  if (reg->bitfields.DISP_HW_D_DEBUG != disp_hw_d_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_D_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_e_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_e_debug)
{
  reg->bitfields.DISP_HW_E_DEBUG = disp_hw_e_debug;
  if (reg->bitfields.DISP_HW_E_DEBUG != disp_hw_e_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_E_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_f_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_f_debug)
{
  reg->bitfields.DISP_HW_F_DEBUG = disp_hw_f_debug;
  if (reg->bitfields.DISP_HW_F_DEBUG != disp_hw_f_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_F_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_10_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_10_debug)
{
  reg->bitfields.DISP_HW_10_DEBUG = disp_hw_10_debug;
  if (reg->bitfields.DISP_HW_10_DEBUG != disp_hw_10_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_10_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_11_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_11_debug)
{
  reg->bitfields.DISP_HW_11_DEBUG = disp_hw_11_debug;
  if (reg->bitfields.DISP_HW_11_DEBUG != disp_hw_11_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_11_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_12_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_12_debug)
{
  reg->bitfields.DISP_HW_12_DEBUG = disp_hw_12_debug;
  if (reg->bitfields.DISP_HW_12_DEBUG != disp_hw_12_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_12_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_13_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_13_debug)
{
  reg->bitfields.DISP_HW_13_DEBUG = disp_hw_13_debug;
  if (reg->bitfields.DISP_HW_13_DEBUG != disp_hw_13_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_13_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_14_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_14_debug)
{
  reg->bitfields.DISP_HW_14_DEBUG = disp_hw_14_debug;
  if (reg->bitfields.DISP_HW_14_DEBUG != disp_hw_14_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_14_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_15_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_15_debug)
{
  reg->bitfields.DISP_HW_15_DEBUG = disp_hw_15_debug;
  if (reg->bitfields.DISP_HW_15_DEBUG != disp_hw_15_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_15_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_16_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_16_debug)
{
  reg->bitfields.DISP_HW_16_DEBUG = disp_hw_16_debug;
  if (reg->bitfields.DISP_HW_16_DEBUG != disp_hw_16_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_16_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_17_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_17_debug)
{
  reg->bitfields.DISP_HW_17_DEBUG = disp_hw_17_debug;
  if (reg->bitfields.DISP_HW_17_DEBUG != disp_hw_17_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_17_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_18_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_18_debug)
{
  reg->bitfields.DISP_HW_18_DEBUG = disp_hw_18_debug;
  if (reg->bitfields.DISP_HW_18_DEBUG != disp_hw_18_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_18_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_19_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_19_debug)
{
  reg->bitfields.DISP_HW_19_DEBUG = disp_hw_19_debug;
  if (reg->bitfields.DISP_HW_19_DEBUG != disp_hw_19_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_19_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_1a_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_1a_debug)
{
  reg->bitfields.DISP_HW_1A_DEBUG = disp_hw_1a_debug;
  if (reg->bitfields.DISP_HW_1A_DEBUG != disp_hw_1a_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_1A_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_1b_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_1b_debug)
{
  reg->bitfields.DISP_HW_1B_DEBUG = disp_hw_1b_debug;
  if (reg->bitfields.DISP_HW_1B_DEBUG != disp_hw_1b_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_1B_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_1c_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_1c_debug)
{
  reg->bitfields.DISP_HW_1C_DEBUG = disp_hw_1c_debug;
  if (reg->bitfields.DISP_HW_1C_DEBUG != disp_hw_1c_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_1C_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_1d_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_1d_debug)
{
  reg->bitfields.DISP_HW_1D_DEBUG = disp_hw_1d_debug;
  if (reg->bitfields.DISP_HW_1D_DEBUG != disp_hw_1d_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_1D_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_1e_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_1e_debug)
{
  reg->bitfields.DISP_HW_1E_DEBUG = disp_hw_1e_debug;
  if (reg->bitfields.DISP_HW_1E_DEBUG != disp_hw_1e_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_1E_DEBUG data too large\n");
}
__inline void set_DISP_HW_DEBUG_disp_hw_1f_debug(regDISP_HW_DEBUG *reg, unsigned int disp_hw_1f_debug)
{
  reg->bitfields.DISP_HW_1F_DEBUG = disp_hw_1f_debug;
  if (reg->bitfields.DISP_HW_1F_DEBUG != disp_hw_1f_debug) HSLDPF(E_ERROR_MESSAGE,"DISP_HW_DEBUG::DISP_HW_1F_DEBUG data too large\n");
}
#else
#define set_DISP_HW_DEBUG_disp_hw_0_debug(reg, disp_hw_0_debug) (reg)->bitfields.DISP_HW_0_DEBUG = disp_hw_0_debug
#define set_DISP_HW_DEBUG_disp_hw_1_debug(reg, disp_hw_1_debug) (reg)->bitfields.DISP_HW_1_DEBUG = disp_hw_1_debug
#define set_DISP_HW_DEBUG_disp_hw_2_debug(reg, disp_hw_2_debug) (reg)->bitfields.DISP_HW_2_DEBUG = disp_hw_2_debug
#define set_DISP_HW_DEBUG_disp_hw_3_debug(reg, disp_hw_3_debug) (reg)->bitfields.DISP_HW_3_DEBUG = disp_hw_3_debug
#define set_DISP_HW_DEBUG_disp_hw_4_debug(reg, disp_hw_4_debug) (reg)->bitfields.DISP_HW_4_DEBUG = disp_hw_4_debug
#define set_DISP_HW_DEBUG_disp_hw_5_debug(reg, disp_hw_5_debug) (reg)->bitfields.DISP_HW_5_DEBUG = disp_hw_5_debug
#define set_DISP_HW_DEBUG_disp_hw_6_debug(reg, disp_hw_6_debug) (reg)->bitfields.DISP_HW_6_DEBUG = disp_hw_6_debug
#define set_DISP_HW_DEBUG_disp_hw_7_debug(reg, disp_hw_7_debug) (reg)->bitfields.DISP_HW_7_DEBUG = disp_hw_7_debug
#define set_DISP_HW_DEBUG_disp_hw_8_debug(reg, disp_hw_8_debug) (reg)->bitfields.DISP_HW_8_DEBUG = disp_hw_8_debug
#define set_DISP_HW_DEBUG_disp_hw_9_debug(reg, disp_hw_9_debug) (reg)->bitfields.DISP_HW_9_DEBUG = disp_hw_9_debug
#define set_DISP_HW_DEBUG_disp_hw_a_debug(reg, disp_hw_a_debug) (reg)->bitfields.DISP_HW_A_DEBUG = disp_hw_a_debug
#define set_DISP_HW_DEBUG_disp_hw_b_debug(reg, disp_hw_b_debug) (reg)->bitfields.DISP_HW_B_DEBUG = disp_hw_b_debug
#define set_DISP_HW_DEBUG_disp_hw_c_debug(reg, disp_hw_c_debug) (reg)->bitfields.DISP_HW_C_DEBUG = disp_hw_c_debug
#define set_DISP_HW_DEBUG_disp_hw_d_debug(reg, disp_hw_d_debug) (reg)->bitfields.DISP_HW_D_DEBUG = disp_hw_d_debug
#define set_DISP_HW_DEBUG_disp_hw_e_debug(reg, disp_hw_e_debug) (reg)->bitfields.DISP_HW_E_DEBUG = disp_hw_e_debug
#define set_DISP_HW_DEBUG_disp_hw_f_debug(reg, disp_hw_f_debug) (reg)->bitfields.DISP_HW_F_DEBUG = disp_hw_f_debug
#define set_DISP_HW_DEBUG_disp_hw_10_debug(reg, disp_hw_10_debug) (reg)->bitfields.DISP_HW_10_DEBUG = disp_hw_10_debug
#define set_DISP_HW_DEBUG_disp_hw_11_debug(reg, disp_hw_11_debug) (reg)->bitfields.DISP_HW_11_DEBUG = disp_hw_11_debug
#define set_DISP_HW_DEBUG_disp_hw_12_debug(reg, disp_hw_12_debug) (reg)->bitfields.DISP_HW_12_DEBUG = disp_hw_12_debug
#define set_DISP_HW_DEBUG_disp_hw_13_debug(reg, disp_hw_13_debug) (reg)->bitfields.DISP_HW_13_DEBUG = disp_hw_13_debug
#define set_DISP_HW_DEBUG_disp_hw_14_debug(reg, disp_hw_14_debug) (reg)->bitfields.DISP_HW_14_DEBUG = disp_hw_14_debug
#define set_DISP_HW_DEBUG_disp_hw_15_debug(reg, disp_hw_15_debug) (reg)->bitfields.DISP_HW_15_DEBUG = disp_hw_15_debug
#define set_DISP_HW_DEBUG_disp_hw_16_debug(reg, disp_hw_16_debug) (reg)->bitfields.DISP_HW_16_DEBUG = disp_hw_16_debug
#define set_DISP_HW_DEBUG_disp_hw_17_debug(reg, disp_hw_17_debug) (reg)->bitfields.DISP_HW_17_DEBUG = disp_hw_17_debug
#define set_DISP_HW_DEBUG_disp_hw_18_debug(reg, disp_hw_18_debug) (reg)->bitfields.DISP_HW_18_DEBUG = disp_hw_18_debug
#define set_DISP_HW_DEBUG_disp_hw_19_debug(reg, disp_hw_19_debug) (reg)->bitfields.DISP_HW_19_DEBUG = disp_hw_19_debug
#define set_DISP_HW_DEBUG_disp_hw_1a_debug(reg, disp_hw_1a_debug) (reg)->bitfields.DISP_HW_1A_DEBUG = disp_hw_1a_debug
#define set_DISP_HW_DEBUG_disp_hw_1b_debug(reg, disp_hw_1b_debug) (reg)->bitfields.DISP_HW_1B_DEBUG = disp_hw_1b_debug
#define set_DISP_HW_DEBUG_disp_hw_1c_debug(reg, disp_hw_1c_debug) (reg)->bitfields.DISP_HW_1C_DEBUG = disp_hw_1c_debug
#define set_DISP_HW_DEBUG_disp_hw_1d_debug(reg, disp_hw_1d_debug) (reg)->bitfields.DISP_HW_1D_DEBUG = disp_hw_1d_debug
#define set_DISP_HW_DEBUG_disp_hw_1e_debug(reg, disp_hw_1e_debug) (reg)->bitfields.DISP_HW_1E_DEBUG = disp_hw_1e_debug
#define set_DISP_HW_DEBUG_disp_hw_1f_debug(reg, disp_hw_1f_debug) (reg)->bitfields.DISP_HW_1F_DEBUG = disp_hw_1f_debug

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_LIN_TRANS_A regOV0_LIN_TRANS_A;

#ifdef DEBUG
__inline void set_OV0_LIN_TRANS_A_ov0_lin_trans_cb_r(regOV0_LIN_TRANS_A *reg, unsigned int ov0_lin_trans_cb_r)
{
  reg->bitfields.OV0_LIN_TRANS_Cb_R = ov0_lin_trans_cb_r;
  if (reg->bitfields.OV0_LIN_TRANS_Cb_R != ov0_lin_trans_cb_r) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_A::OV0_LIN_TRANS_Cb_R data too large\n");
}
__inline void set_OV0_LIN_TRANS_A_ov0_lin_trans_y_r(regOV0_LIN_TRANS_A *reg, unsigned int ov0_lin_trans_y_r)
{
  reg->bitfields.OV0_LIN_TRANS_Y_R = ov0_lin_trans_y_r;
  if (reg->bitfields.OV0_LIN_TRANS_Y_R != ov0_lin_trans_y_r) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_A::OV0_LIN_TRANS_Y_R data too large\n");
}
#else
#define set_OV0_LIN_TRANS_A_ov0_lin_trans_cb_r(reg, ov0_lin_trans_cb_r) (reg)->bitfields.OV0_LIN_TRANS_Cb_R = ov0_lin_trans_cb_r
#define set_OV0_LIN_TRANS_A_ov0_lin_trans_y_r(reg, ov0_lin_trans_y_r) (reg)->bitfields.OV0_LIN_TRANS_Y_R = ov0_lin_trans_y_r

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_LIN_TRANS_B regOV0_LIN_TRANS_B;

#ifdef DEBUG
__inline void set_OV0_LIN_TRANS_B_ov0_lin_trans_off_r(regOV0_LIN_TRANS_B *reg, unsigned int ov0_lin_trans_off_r)
{
  reg->bitfields.OV0_LIN_TRANS_OFF_R = ov0_lin_trans_off_r;
  if (reg->bitfields.OV0_LIN_TRANS_OFF_R != ov0_lin_trans_off_r) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_B::OV0_LIN_TRANS_OFF_R data too large\n");
}
__inline void set_OV0_LIN_TRANS_B_ov0_lin_trans_cr_r(regOV0_LIN_TRANS_B *reg, unsigned int ov0_lin_trans_cr_r)
{
  reg->bitfields.OV0_LIN_TRANS_Cr_R = ov0_lin_trans_cr_r;
  if (reg->bitfields.OV0_LIN_TRANS_Cr_R != ov0_lin_trans_cr_r) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_B::OV0_LIN_TRANS_Cr_R data too large\n");
}
#else
#define set_OV0_LIN_TRANS_B_ov0_lin_trans_off_r(reg, ov0_lin_trans_off_r) (reg)->bitfields.OV0_LIN_TRANS_OFF_R = ov0_lin_trans_off_r
#define set_OV0_LIN_TRANS_B_ov0_lin_trans_cr_r(reg, ov0_lin_trans_cr_r) (reg)->bitfields.OV0_LIN_TRANS_Cr_R = ov0_lin_trans_cr_r

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_LIN_TRANS_C regOV0_LIN_TRANS_C;

#ifdef DEBUG
__inline void set_OV0_LIN_TRANS_C_ov0_lin_trans_cb_g(regOV0_LIN_TRANS_C *reg, unsigned int ov0_lin_trans_cb_g)
{
  reg->bitfields.OV0_LIN_TRANS_Cb_G = ov0_lin_trans_cb_g;
  if (reg->bitfields.OV0_LIN_TRANS_Cb_G != ov0_lin_trans_cb_g) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_C::OV0_LIN_TRANS_Cb_G data too large\n");
}
__inline void set_OV0_LIN_TRANS_C_ov0_lin_trans_y_g(regOV0_LIN_TRANS_C *reg, unsigned int ov0_lin_trans_y_g)
{
  reg->bitfields.OV0_LIN_TRANS_Y_G = ov0_lin_trans_y_g;
  if (reg->bitfields.OV0_LIN_TRANS_Y_G != ov0_lin_trans_y_g) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_C::OV0_LIN_TRANS_Y_G data too large\n");
}
#else
#define set_OV0_LIN_TRANS_C_ov0_lin_trans_cb_g(reg, ov0_lin_trans_cb_g) (reg)->bitfields.OV0_LIN_TRANS_Cb_G = ov0_lin_trans_cb_g
#define set_OV0_LIN_TRANS_C_ov0_lin_trans_y_g(reg, ov0_lin_trans_y_g) (reg)->bitfields.OV0_LIN_TRANS_Y_G = ov0_lin_trans_y_g

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_LIN_TRANS_D regOV0_LIN_TRANS_D;

#ifdef DEBUG
__inline void set_OV0_LIN_TRANS_D_ov0_lin_trans_off_g(regOV0_LIN_TRANS_D *reg, unsigned int ov0_lin_trans_off_g)
{
  reg->bitfields.OV0_LIN_TRANS_OFF_G = ov0_lin_trans_off_g;
  if (reg->bitfields.OV0_LIN_TRANS_OFF_G != ov0_lin_trans_off_g) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_D::OV0_LIN_TRANS_OFF_G data too large\n");
}
__inline void set_OV0_LIN_TRANS_D_ov0_lin_trans_cr_g(regOV0_LIN_TRANS_D *reg, unsigned int ov0_lin_trans_cr_g)
{
  reg->bitfields.OV0_LIN_TRANS_Cr_G = ov0_lin_trans_cr_g;
  if (reg->bitfields.OV0_LIN_TRANS_Cr_G != ov0_lin_trans_cr_g) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_D::OV0_LIN_TRANS_Cr_G data too large\n");
}
#else
#define set_OV0_LIN_TRANS_D_ov0_lin_trans_off_g(reg, ov0_lin_trans_off_g) (reg)->bitfields.OV0_LIN_TRANS_OFF_G = ov0_lin_trans_off_g
#define set_OV0_LIN_TRANS_D_ov0_lin_trans_cr_g(reg, ov0_lin_trans_cr_g) (reg)->bitfields.OV0_LIN_TRANS_Cr_G = ov0_lin_trans_cr_g

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_LIN_TRANS_E regOV0_LIN_TRANS_E;

#ifdef DEBUG
__inline void set_OV0_LIN_TRANS_E_ov0_lin_trans_cb_b(regOV0_LIN_TRANS_E *reg, unsigned int ov0_lin_trans_cb_b)
{
  reg->bitfields.OV0_LIN_TRANS_Cb_B = ov0_lin_trans_cb_b;
  if (reg->bitfields.OV0_LIN_TRANS_Cb_B != ov0_lin_trans_cb_b) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_E::OV0_LIN_TRANS_Cb_B data too large\n");
}
__inline void set_OV0_LIN_TRANS_E_ov0_lin_trans_y_b(regOV0_LIN_TRANS_E *reg, unsigned int ov0_lin_trans_y_b)
{
  reg->bitfields.OV0_LIN_TRANS_Y_B = ov0_lin_trans_y_b;
  if (reg->bitfields.OV0_LIN_TRANS_Y_B != ov0_lin_trans_y_b) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_E::OV0_LIN_TRANS_Y_B data too large\n");
}
#else
#define set_OV0_LIN_TRANS_E_ov0_lin_trans_cb_b(reg, ov0_lin_trans_cb_b) (reg)->bitfields.OV0_LIN_TRANS_Cb_B = ov0_lin_trans_cb_b
#define set_OV0_LIN_TRANS_E_ov0_lin_trans_y_b(reg, ov0_lin_trans_y_b) (reg)->bitfields.OV0_LIN_TRANS_Y_B = ov0_lin_trans_y_b

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_LIN_TRANS_F regOV0_LIN_TRANS_F;

#ifdef DEBUG
__inline void set_OV0_LIN_TRANS_F_ov0_lin_trans_off_b(regOV0_LIN_TRANS_F *reg, unsigned int ov0_lin_trans_off_b)
{
  reg->bitfields.OV0_LIN_TRANS_OFF_B = ov0_lin_trans_off_b;
  if (reg->bitfields.OV0_LIN_TRANS_OFF_B != ov0_lin_trans_off_b) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_F::OV0_LIN_TRANS_OFF_B data too large\n");
}
__inline void set_OV0_LIN_TRANS_F_ov0_lin_trans_cr_b(regOV0_LIN_TRANS_F *reg, unsigned int ov0_lin_trans_cr_b)
{
  reg->bitfields.OV0_LIN_TRANS_Cr_B = ov0_lin_trans_cr_b;
  if (reg->bitfields.OV0_LIN_TRANS_Cr_B != ov0_lin_trans_cr_b) HSLDPF(E_ERROR_MESSAGE,"OV0_LIN_TRANS_F::OV0_LIN_TRANS_Cr_B data too large\n");
}
#else
#define set_OV0_LIN_TRANS_F_ov0_lin_trans_off_b(reg, ov0_lin_trans_off_b) (reg)->bitfields.OV0_LIN_TRANS_OFF_B = ov0_lin_trans_off_b
#define set_OV0_LIN_TRANS_F_ov0_lin_trans_cr_b(reg, ov0_lin_trans_cr_b) (reg)->bitfields.OV0_LIN_TRANS_Cr_B = ov0_lin_trans_cr_b

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_GAMMA_380_3BF regOV0_GAMMA_380_3BF;

#ifdef DEBUG
__inline void set_OV0_GAMMA_380_3BF_ov0_gamma_380_3bf_offset_r2(regOV0_GAMMA_380_3BF *reg, unsigned int ov0_gamma_380_3bf_offset_r2)
{
  reg->bitfields.OV0_GAMMA_380_3BF_OFFSET_R2 = ov0_gamma_380_3bf_offset_r2;
  if (reg->bitfields.OV0_GAMMA_380_3BF_OFFSET_R2 != ov0_gamma_380_3bf_offset_r2) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_380_3BF::OV0_GAMMA_380_3BF_OFFSET_R2 data too large\n");
}
__inline void set_OV0_GAMMA_380_3BF_ov0_gamma_380_3bf_slope(regOV0_GAMMA_380_3BF *reg, unsigned int ov0_gamma_380_3bf_slope)
{
  reg->bitfields.OV0_GAMMA_380_3BF_SLOPE = ov0_gamma_380_3bf_slope;
  if (reg->bitfields.OV0_GAMMA_380_3BF_SLOPE != ov0_gamma_380_3bf_slope) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_380_3BF::OV0_GAMMA_380_3BF_SLOPE data too large\n");
}
#else
#define set_OV0_GAMMA_380_3BF_ov0_gamma_380_3bf_offset_r2(reg, ov0_gamma_380_3bf_offset_r2) (reg)->bitfields.OV0_GAMMA_380_3BF_OFFSET_R2 = ov0_gamma_380_3bf_offset_r2
#define set_OV0_GAMMA_380_3BF_ov0_gamma_380_3bf_slope(reg, ov0_gamma_380_3bf_slope) (reg)->bitfields.OV0_GAMMA_380_3BF_SLOPE = ov0_gamma_380_3bf_slope

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_GAMMA_3C0_3FF regOV0_GAMMA_3C0_3FF;

#ifdef DEBUG
__inline void set_OV0_GAMMA_3C0_3FF_ov0_gamma_3c0_3ff_offset_r2(regOV0_GAMMA_3C0_3FF *reg, unsigned int ov0_gamma_3c0_3ff_offset_r2)
{
  reg->bitfields.OV0_GAMMA_3C0_3FF_OFFSET_R2 = ov0_gamma_3c0_3ff_offset_r2;
  if (reg->bitfields.OV0_GAMMA_3C0_3FF_OFFSET_R2 != ov0_gamma_3c0_3ff_offset_r2) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_3C0_3FF::OV0_GAMMA_3C0_3FF_OFFSET_R2 data too large\n");
}
__inline void set_OV0_GAMMA_3C0_3FF_ov0_gamma_3c0_3ff_slope(regOV0_GAMMA_3C0_3FF *reg, unsigned int ov0_gamma_3c0_3ff_slope)
{
  reg->bitfields.OV0_GAMMA_3C0_3FF_SLOPE = ov0_gamma_3c0_3ff_slope;
  if (reg->bitfields.OV0_GAMMA_3C0_3FF_SLOPE != ov0_gamma_3c0_3ff_slope) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_3C0_3FF::OV0_GAMMA_3C0_3FF_SLOPE data too large\n");
}
#else
#define set_OV0_GAMMA_3C0_3FF_ov0_gamma_3c0_3ff_offset_r2(reg, ov0_gamma_3c0_3ff_offset_r2) (reg)->bitfields.OV0_GAMMA_3C0_3FF_OFFSET_R2 = ov0_gamma_3c0_3ff_offset_r2
#define set_OV0_GAMMA_3C0_3FF_ov0_gamma_3c0_3ff_slope(reg, ov0_gamma_3c0_3ff_slope) (reg)->bitfields.OV0_GAMMA_3C0_3FF_SLOPE = ov0_gamma_3c0_3ff_slope

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_GAMMA_80_BF regOV0_GAMMA_80_BF;

#ifdef DEBUG
__inline void set_OV0_GAMMA_80_BF_ov0_gamma_80_bf_offset(regOV0_GAMMA_80_BF *reg, unsigned int ov0_gamma_80_bf_offset)
{
  reg->bitfields.OV0_GAMMA_80_BF_OFFSET = ov0_gamma_80_bf_offset;
  if (reg->bitfields.OV0_GAMMA_80_BF_OFFSET != ov0_gamma_80_bf_offset) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_80_BF::OV0_GAMMA_80_BF_OFFSET data too large\n");
}
__inline void set_OV0_GAMMA_80_BF_ov0_gamma_80_bf_slope(regOV0_GAMMA_80_BF *reg, unsigned int ov0_gamma_80_bf_slope)
{
  reg->bitfields.OV0_GAMMA_80_BF_SLOPE = ov0_gamma_80_bf_slope;
  if (reg->bitfields.OV0_GAMMA_80_BF_SLOPE != ov0_gamma_80_bf_slope) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_80_BF::OV0_GAMMA_80_BF_SLOPE data too large\n");
}
#else
#define set_OV0_GAMMA_80_BF_ov0_gamma_80_bf_offset(reg, ov0_gamma_80_bf_offset) (reg)->bitfields.OV0_GAMMA_80_BF_OFFSET = ov0_gamma_80_bf_offset
#define set_OV0_GAMMA_80_BF_ov0_gamma_80_bf_slope(reg, ov0_gamma_80_bf_slope) (reg)->bitfields.OV0_GAMMA_80_BF_SLOPE = ov0_gamma_80_bf_slope

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_GAMMA_C0_FF regOV0_GAMMA_C0_FF;

#ifdef DEBUG
__inline void set_OV0_GAMMA_C0_FF_ov0_gamma_c0_ff_offset(regOV0_GAMMA_C0_FF *reg, unsigned int ov0_gamma_c0_ff_offset)
{
  reg->bitfields.OV0_GAMMA_C0_FF_OFFSET = ov0_gamma_c0_ff_offset;
  if (reg->bitfields.OV0_GAMMA_C0_FF_OFFSET != ov0_gamma_c0_ff_offset) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_C0_FF::OV0_GAMMA_C0_FF_OFFSET data too large\n");
}
__inline void set_OV0_GAMMA_C0_FF_ov0_gamma_c0_ff_slope(regOV0_GAMMA_C0_FF *reg, unsigned int ov0_gamma_c0_ff_slope)
{
  reg->bitfields.OV0_GAMMA_C0_FF_SLOPE = ov0_gamma_c0_ff_slope;
  if (reg->bitfields.OV0_GAMMA_C0_FF_SLOPE != ov0_gamma_c0_ff_slope) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_C0_FF::OV0_GAMMA_C0_FF_SLOPE data too large\n");
}
#else
#define set_OV0_GAMMA_C0_FF_ov0_gamma_c0_ff_offset(reg, ov0_gamma_c0_ff_offset) (reg)->bitfields.OV0_GAMMA_C0_FF_OFFSET = ov0_gamma_c0_ff_offset
#define set_OV0_GAMMA_C0_FF_ov0_gamma_c0_ff_slope(reg, ov0_gamma_c0_ff_slope) (reg)->bitfields.OV0_GAMMA_C0_FF_SLOPE = ov0_gamma_c0_ff_slope

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_GAMMA_100_13F regOV0_GAMMA_100_13F;

#ifdef DEBUG
__inline void set_OV0_GAMMA_100_13F_ov0_gamma_100_13f_offset(regOV0_GAMMA_100_13F *reg, unsigned int ov0_gamma_100_13f_offset)
{
  reg->bitfields.OV0_GAMMA_100_13F_OFFSET = ov0_gamma_100_13f_offset;
  if (reg->bitfields.OV0_GAMMA_100_13F_OFFSET != ov0_gamma_100_13f_offset) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_100_13F::OV0_GAMMA_100_13F_OFFSET data too large\n");
}
__inline void set_OV0_GAMMA_100_13F_ov0_gamma_100_13f_slope(regOV0_GAMMA_100_13F *reg, unsigned int ov0_gamma_100_13f_slope)
{
  reg->bitfields.OV0_GAMMA_100_13F_SLOPE = ov0_gamma_100_13f_slope;
  if (reg->bitfields.OV0_GAMMA_100_13F_SLOPE != ov0_gamma_100_13f_slope) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_100_13F::OV0_GAMMA_100_13F_SLOPE data too large\n");
}
#else
#define set_OV0_GAMMA_100_13F_ov0_gamma_100_13f_offset(reg, ov0_gamma_100_13f_offset) (reg)->bitfields.OV0_GAMMA_100_13F_OFFSET = ov0_gamma_100_13f_offset
#define set_OV0_GAMMA_100_13F_ov0_gamma_100_13f_slope(reg, ov0_gamma_100_13f_slope) (reg)->bitfields.OV0_GAMMA_100_13F_SLOPE = ov0_gamma_100_13f_slope

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_GAMMA_140_17F regOV0_GAMMA_140_17F;

#ifdef DEBUG
__inline void set_OV0_GAMMA_140_17F_ov0_gamma_140_17f_offset(regOV0_GAMMA_140_17F *reg, unsigned int ov0_gamma_140_17f_offset)
{
  reg->bitfields.OV0_GAMMA_140_17F_OFFSET = ov0_gamma_140_17f_offset;
  if (reg->bitfields.OV0_GAMMA_140_17F_OFFSET != ov0_gamma_140_17f_offset) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_140_17F::OV0_GAMMA_140_17F_OFFSET data too large\n");
}
__inline void set_OV0_GAMMA_140_17F_ov0_gamma_140_17f_slope(regOV0_GAMMA_140_17F *reg, unsigned int ov0_gamma_140_17f_slope)
{
  reg->bitfields.OV0_GAMMA_140_17F_SLOPE = ov0_gamma_140_17f_slope;
  if (reg->bitfields.OV0_GAMMA_140_17F_SLOPE != ov0_gamma_140_17f_slope) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_140_17F::OV0_GAMMA_140_17F_SLOPE data too large\n");
}
#else
#define set_OV0_GAMMA_140_17F_ov0_gamma_140_17f_offset(reg, ov0_gamma_140_17f_offset) (reg)->bitfields.OV0_GAMMA_140_17F_OFFSET = ov0_gamma_140_17f_offset
#define set_OV0_GAMMA_140_17F_ov0_gamma_140_17f_slope(reg, ov0_gamma_140_17f_slope) (reg)->bitfields.OV0_GAMMA_140_17F_SLOPE = ov0_gamma_140_17f_slope

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_GAMMA_180_1BF regOV0_GAMMA_180_1BF;

#ifdef DEBUG
__inline void set_OV0_GAMMA_180_1BF_ov0_gamma_180_1bf_offset(regOV0_GAMMA_180_1BF *reg, unsigned int ov0_gamma_180_1bf_offset)
{
  reg->bitfields.OV0_GAMMA_180_1BF_OFFSET = ov0_gamma_180_1bf_offset;
  if (reg->bitfields.OV0_GAMMA_180_1BF_OFFSET != ov0_gamma_180_1bf_offset) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_180_1BF::OV0_GAMMA_180_1BF_OFFSET data too large\n");
}
__inline void set_OV0_GAMMA_180_1BF_ov0_gamma_180_1bf_slope(regOV0_GAMMA_180_1BF *reg, unsigned int ov0_gamma_180_1bf_slope)
{
  reg->bitfields.OV0_GAMMA_180_1BF_SLOPE = ov0_gamma_180_1bf_slope;
  if (reg->bitfields.OV0_GAMMA_180_1BF_SLOPE != ov0_gamma_180_1bf_slope) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_180_1BF::OV0_GAMMA_180_1BF_SLOPE data too large\n");
}
#else
#define set_OV0_GAMMA_180_1BF_ov0_gamma_180_1bf_offset(reg, ov0_gamma_180_1bf_offset) (reg)->bitfields.OV0_GAMMA_180_1BF_OFFSET = ov0_gamma_180_1bf_offset
#define set_OV0_GAMMA_180_1BF_ov0_gamma_180_1bf_slope(reg, ov0_gamma_180_1bf_slope) (reg)->bitfields.OV0_GAMMA_180_1BF_SLOPE = ov0_gamma_180_1bf_slope

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_GAMMA_1C0_1FF regOV0_GAMMA_1C0_1FF;

#ifdef DEBUG
__inline void set_OV0_GAMMA_1C0_1FF_ov0_gamma_1c0_1ff_offset(regOV0_GAMMA_1C0_1FF *reg, unsigned int ov0_gamma_1c0_1ff_offset)
{
  reg->bitfields.OV0_GAMMA_1C0_1FF_OFFSET = ov0_gamma_1c0_1ff_offset;
  if (reg->bitfields.OV0_GAMMA_1C0_1FF_OFFSET != ov0_gamma_1c0_1ff_offset) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_1C0_1FF::OV0_GAMMA_1C0_1FF_OFFSET data too large\n");
}
__inline void set_OV0_GAMMA_1C0_1FF_ov0_gamma_1c0_1ff_slope(regOV0_GAMMA_1C0_1FF *reg, unsigned int ov0_gamma_1c0_1ff_slope)
{
  reg->bitfields.OV0_GAMMA_1C0_1FF_SLOPE = ov0_gamma_1c0_1ff_slope;
  if (reg->bitfields.OV0_GAMMA_1C0_1FF_SLOPE != ov0_gamma_1c0_1ff_slope) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_1C0_1FF::OV0_GAMMA_1C0_1FF_SLOPE data too large\n");
}
#else
#define set_OV0_GAMMA_1C0_1FF_ov0_gamma_1c0_1ff_offset(reg, ov0_gamma_1c0_1ff_offset) (reg)->bitfields.OV0_GAMMA_1C0_1FF_OFFSET = ov0_gamma_1c0_1ff_offset
#define set_OV0_GAMMA_1C0_1FF_ov0_gamma_1c0_1ff_slope(reg, ov0_gamma_1c0_1ff_slope) (reg)->bitfields.OV0_GAMMA_1C0_1FF_SLOPE = ov0_gamma_1c0_1ff_slope

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_GAMMA_200_23F regOV0_GAMMA_200_23F;

#ifdef DEBUG
__inline void set_OV0_GAMMA_200_23F_ov0_gamma_200_23f_offset(regOV0_GAMMA_200_23F *reg, unsigned int ov0_gamma_200_23f_offset)
{
  reg->bitfields.OV0_GAMMA_200_23F_OFFSET = ov0_gamma_200_23f_offset;
  if (reg->bitfields.OV0_GAMMA_200_23F_OFFSET != ov0_gamma_200_23f_offset) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_200_23F::OV0_GAMMA_200_23F_OFFSET data too large\n");
}
__inline void set_OV0_GAMMA_200_23F_ov0_gamma_200_23f_slope(regOV0_GAMMA_200_23F *reg, unsigned int ov0_gamma_200_23f_slope)
{
  reg->bitfields.OV0_GAMMA_200_23F_SLOPE = ov0_gamma_200_23f_slope;
  if (reg->bitfields.OV0_GAMMA_200_23F_SLOPE != ov0_gamma_200_23f_slope) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_200_23F::OV0_GAMMA_200_23F_SLOPE data too large\n");
}
#else
#define set_OV0_GAMMA_200_23F_ov0_gamma_200_23f_offset(reg, ov0_gamma_200_23f_offset) (reg)->bitfields.OV0_GAMMA_200_23F_OFFSET = ov0_gamma_200_23f_offset
#define set_OV0_GAMMA_200_23F_ov0_gamma_200_23f_slope(reg, ov0_gamma_200_23f_slope) (reg)->bitfields.OV0_GAMMA_200_23F_SLOPE = ov0_gamma_200_23f_slope

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_GAMMA_240_27F regOV0_GAMMA_240_27F;

#ifdef DEBUG
__inline void set_OV0_GAMMA_240_27F_ov0_gamma_240_27f_offset(regOV0_GAMMA_240_27F *reg, unsigned int ov0_gamma_240_27f_offset)
{
  reg->bitfields.OV0_GAMMA_240_27F_OFFSET = ov0_gamma_240_27f_offset;
  if (reg->bitfields.OV0_GAMMA_240_27F_OFFSET != ov0_gamma_240_27f_offset) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_240_27F::OV0_GAMMA_240_27F_OFFSET data too large\n");
}
__inline void set_OV0_GAMMA_240_27F_ov0_gamma_240_27f_slope(regOV0_GAMMA_240_27F *reg, unsigned int ov0_gamma_240_27f_slope)
{
  reg->bitfields.OV0_GAMMA_240_27F_SLOPE = ov0_gamma_240_27f_slope;
  if (reg->bitfields.OV0_GAMMA_240_27F_SLOPE != ov0_gamma_240_27f_slope) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_240_27F::OV0_GAMMA_240_27F_SLOPE data too large\n");
}
#else
#define set_OV0_GAMMA_240_27F_ov0_gamma_240_27f_offset(reg, ov0_gamma_240_27f_offset) (reg)->bitfields.OV0_GAMMA_240_27F_OFFSET = ov0_gamma_240_27f_offset
#define set_OV0_GAMMA_240_27F_ov0_gamma_240_27f_slope(reg, ov0_gamma_240_27f_slope) (reg)->bitfields.OV0_GAMMA_240_27F_SLOPE = ov0_gamma_240_27f_slope

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_GAMMA_280_2BF regOV0_GAMMA_280_2BF;

#ifdef DEBUG
__inline void set_OV0_GAMMA_280_2BF_ov0_gamma_280_2bf_offset(regOV0_GAMMA_280_2BF *reg, unsigned int ov0_gamma_280_2bf_offset)
{
  reg->bitfields.OV0_GAMMA_280_2BF_OFFSET = ov0_gamma_280_2bf_offset;
  if (reg->bitfields.OV0_GAMMA_280_2BF_OFFSET != ov0_gamma_280_2bf_offset) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_280_2BF::OV0_GAMMA_280_2BF_OFFSET data too large\n");
}
__inline void set_OV0_GAMMA_280_2BF_ov0_gamma_280_2bf_slope(regOV0_GAMMA_280_2BF *reg, unsigned int ov0_gamma_280_2bf_slope)
{
  reg->bitfields.OV0_GAMMA_280_2BF_SLOPE = ov0_gamma_280_2bf_slope;
  if (reg->bitfields.OV0_GAMMA_280_2BF_SLOPE != ov0_gamma_280_2bf_slope) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_280_2BF::OV0_GAMMA_280_2BF_SLOPE data too large\n");
}
#else
#define set_OV0_GAMMA_280_2BF_ov0_gamma_280_2bf_offset(reg, ov0_gamma_280_2bf_offset) (reg)->bitfields.OV0_GAMMA_280_2BF_OFFSET = ov0_gamma_280_2bf_offset
#define set_OV0_GAMMA_280_2BF_ov0_gamma_280_2bf_slope(reg, ov0_gamma_280_2bf_slope) (reg)->bitfields.OV0_GAMMA_280_2BF_SLOPE = ov0_gamma_280_2bf_slope

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_GAMMA_2C0_2FF regOV0_GAMMA_2C0_2FF;

#ifdef DEBUG
__inline void set_OV0_GAMMA_2C0_2FF_ov0_gamma_2c0_2ff_offset(regOV0_GAMMA_2C0_2FF *reg, unsigned int ov0_gamma_2c0_2ff_offset)
{
  reg->bitfields.OV0_GAMMA_2C0_2FF_OFFSET = ov0_gamma_2c0_2ff_offset;
  if (reg->bitfields.OV0_GAMMA_2C0_2FF_OFFSET != ov0_gamma_2c0_2ff_offset) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_2C0_2FF::OV0_GAMMA_2C0_2FF_OFFSET data too large\n");
}
__inline void set_OV0_GAMMA_2C0_2FF_ov0_gamma_2c0_2ff_slope(regOV0_GAMMA_2C0_2FF *reg, unsigned int ov0_gamma_2c0_2ff_slope)
{
  reg->bitfields.OV0_GAMMA_2C0_2FF_SLOPE = ov0_gamma_2c0_2ff_slope;
  if (reg->bitfields.OV0_GAMMA_2C0_2FF_SLOPE != ov0_gamma_2c0_2ff_slope) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_2C0_2FF::OV0_GAMMA_2C0_2FF_SLOPE data too large\n");
}
#else
#define set_OV0_GAMMA_2C0_2FF_ov0_gamma_2c0_2ff_offset(reg, ov0_gamma_2c0_2ff_offset) (reg)->bitfields.OV0_GAMMA_2C0_2FF_OFFSET = ov0_gamma_2c0_2ff_offset
#define set_OV0_GAMMA_2C0_2FF_ov0_gamma_2c0_2ff_slope(reg, ov0_gamma_2c0_2ff_slope) (reg)->bitfields.OV0_GAMMA_2C0_2FF_SLOPE = ov0_gamma_2c0_2ff_slope

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_GAMMA_300_33F regOV0_GAMMA_300_33F;

#ifdef DEBUG
__inline void set_OV0_GAMMA_300_33F_ov0_gamma_300_33f_offset(regOV0_GAMMA_300_33F *reg, unsigned int ov0_gamma_300_33f_offset)
{
  reg->bitfields.OV0_GAMMA_300_33F_OFFSET = ov0_gamma_300_33f_offset;
  if (reg->bitfields.OV0_GAMMA_300_33F_OFFSET != ov0_gamma_300_33f_offset) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_300_33F::OV0_GAMMA_300_33F_OFFSET data too large\n");
}
__inline void set_OV0_GAMMA_300_33F_ov0_gamma_300_33f_slope(regOV0_GAMMA_300_33F *reg, unsigned int ov0_gamma_300_33f_slope)
{
  reg->bitfields.OV0_GAMMA_300_33F_SLOPE = ov0_gamma_300_33f_slope;
  if (reg->bitfields.OV0_GAMMA_300_33F_SLOPE != ov0_gamma_300_33f_slope) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_300_33F::OV0_GAMMA_300_33F_SLOPE data too large\n");
}
#else
#define set_OV0_GAMMA_300_33F_ov0_gamma_300_33f_offset(reg, ov0_gamma_300_33f_offset) (reg)->bitfields.OV0_GAMMA_300_33F_OFFSET = ov0_gamma_300_33f_offset
#define set_OV0_GAMMA_300_33F_ov0_gamma_300_33f_slope(reg, ov0_gamma_300_33f_slope) (reg)->bitfields.OV0_GAMMA_300_33F_SLOPE = ov0_gamma_300_33f_slope

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union OV0_GAMMA_340_37F regOV0_GAMMA_340_37F;

#ifdef DEBUG
__inline void set_OV0_GAMMA_340_37F_ov0_gamma_340_37f_offset(regOV0_GAMMA_340_37F *reg, unsigned int ov0_gamma_340_37f_offset)
{
  reg->bitfields.OV0_GAMMA_340_37F_OFFSET = ov0_gamma_340_37f_offset;
  if (reg->bitfields.OV0_GAMMA_340_37F_OFFSET != ov0_gamma_340_37f_offset) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_340_37F::OV0_GAMMA_340_37F_OFFSET data too large\n");
}
__inline void set_OV0_GAMMA_340_37F_ov0_gamma_340_37f_slope(regOV0_GAMMA_340_37F *reg, unsigned int ov0_gamma_340_37f_slope)
{
  reg->bitfields.OV0_GAMMA_340_37F_SLOPE = ov0_gamma_340_37f_slope;
  if (reg->bitfields.OV0_GAMMA_340_37F_SLOPE != ov0_gamma_340_37f_slope) HSLDPF(E_ERROR_MESSAGE,"OV0_GAMMA_340_37F::OV0_GAMMA_340_37F_SLOPE data too large\n");
}
#else
#define set_OV0_GAMMA_340_37F_ov0_gamma_340_37f_offset(reg, ov0_gamma_340_37f_offset) (reg)->bitfields.OV0_GAMMA_340_37F_OFFSET = ov0_gamma_340_37f_offset
#define set_OV0_GAMMA_340_37F_ov0_gamma_340_37f_slope(reg, ov0_gamma_340_37f_slope) (reg)->bitfields.OV0_GAMMA_340_37F_SLOPE = ov0_gamma_340_37f_slope

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_MERGE_CNTL regDISP_MERGE_CNTL;

#ifdef DEBUG
__inline void set_DISP_MERGE_CNTL_disp_alpha_mode(regDISP_MERGE_CNTL *reg, unsigned int disp_alpha_mode)
{
  reg->bitfields.DISP_ALPHA_MODE = disp_alpha_mode;
  if (reg->bitfields.DISP_ALPHA_MODE != disp_alpha_mode) HSLDPF(E_ERROR_MESSAGE,"DISP_MERGE_CNTL::DISP_ALPHA_MODE data too large\n");
}
__inline void set_DISP_MERGE_CNTL_disp_alpha_inv(regDISP_MERGE_CNTL *reg, unsigned int disp_alpha_inv)
{
  reg->bitfields.DISP_ALPHA_INV = disp_alpha_inv;
  if (reg->bitfields.DISP_ALPHA_INV != disp_alpha_inv) HSLDPF(E_ERROR_MESSAGE,"DISP_MERGE_CNTL::DISP_ALPHA_INV data too large\n");
}
__inline void set_DISP_MERGE_CNTL_disp_alpha_premult(regDISP_MERGE_CNTL *reg, unsigned int disp_alpha_premult)
{
  reg->bitfields.DISP_ALPHA_PREMULT = disp_alpha_premult;
  if (reg->bitfields.DISP_ALPHA_PREMULT != disp_alpha_premult) HSLDPF(E_ERROR_MESSAGE,"DISP_MERGE_CNTL::DISP_ALPHA_PREMULT data too large\n");
}
__inline void set_DISP_MERGE_CNTL_disp_rgb_offset_en(regDISP_MERGE_CNTL *reg, unsigned int disp_rgb_offset_en)
{
  reg->bitfields.DISP_RGB_OFFSET_EN = disp_rgb_offset_en;
  if (reg->bitfields.DISP_RGB_OFFSET_EN != disp_rgb_offset_en) HSLDPF(E_ERROR_MESSAGE,"DISP_MERGE_CNTL::DISP_RGB_OFFSET_EN data too large\n");
}
__inline void set_DISP_MERGE_CNTL_disp_lin_trans_bypass(regDISP_MERGE_CNTL *reg, unsigned int disp_lin_trans_bypass)
{
  reg->bitfields.DISP_LIN_TRANS_BYPASS = disp_lin_trans_bypass;
  if (reg->bitfields.DISP_LIN_TRANS_BYPASS != disp_lin_trans_bypass) HSLDPF(E_ERROR_MESSAGE,"DISP_MERGE_CNTL::DISP_LIN_TRANS_BYPASS data too large\n");
}
__inline void set_DISP_MERGE_CNTL_disp_grph_alpha(regDISP_MERGE_CNTL *reg, unsigned int disp_grph_alpha)
{
  reg->bitfields.DISP_GRPH_ALPHA = disp_grph_alpha;
  if (reg->bitfields.DISP_GRPH_ALPHA != disp_grph_alpha) HSLDPF(E_ERROR_MESSAGE,"DISP_MERGE_CNTL::DISP_GRPH_ALPHA data too large\n");
}
__inline void set_DISP_MERGE_CNTL_disp_ov0_alpha(regDISP_MERGE_CNTL *reg, unsigned int disp_ov0_alpha)
{
  reg->bitfields.DISP_OV0_ALPHA = disp_ov0_alpha;
  if (reg->bitfields.DISP_OV0_ALPHA != disp_ov0_alpha) HSLDPF(E_ERROR_MESSAGE,"DISP_MERGE_CNTL::DISP_OV0_ALPHA data too large\n");
}
#else
#define set_DISP_MERGE_CNTL_disp_alpha_mode(reg, disp_alpha_mode) (reg)->bitfields.DISP_ALPHA_MODE = disp_alpha_mode
#define set_DISP_MERGE_CNTL_disp_alpha_inv(reg, disp_alpha_inv) (reg)->bitfields.DISP_ALPHA_INV = disp_alpha_inv
#define set_DISP_MERGE_CNTL_disp_alpha_premult(reg, disp_alpha_premult) (reg)->bitfields.DISP_ALPHA_PREMULT = disp_alpha_premult
#define set_DISP_MERGE_CNTL_disp_rgb_offset_en(reg, disp_rgb_offset_en) (reg)->bitfields.DISP_RGB_OFFSET_EN = disp_rgb_offset_en
#define set_DISP_MERGE_CNTL_disp_lin_trans_bypass(reg, disp_lin_trans_bypass) (reg)->bitfields.DISP_LIN_TRANS_BYPASS = disp_lin_trans_bypass
#define set_DISP_MERGE_CNTL_disp_grph_alpha(reg, disp_grph_alpha) (reg)->bitfields.DISP_GRPH_ALPHA = disp_grph_alpha
#define set_DISP_MERGE_CNTL_disp_ov0_alpha(reg, disp_ov0_alpha) (reg)->bitfields.DISP_OV0_ALPHA = disp_ov0_alpha

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_OUTPUT_CNTL regDISP_OUTPUT_CNTL;

#ifdef DEBUG
__inline void set_DISP_OUTPUT_CNTL_disp_dac_source(regDISP_OUTPUT_CNTL *reg, unsigned int disp_dac_source)
{
  reg->bitfields.DISP_DAC_SOURCE = disp_dac_source;
  if (reg->bitfields.DISP_DAC_SOURCE != disp_dac_source) HSLDPF(E_ERROR_MESSAGE,"DISP_OUTPUT_CNTL::DISP_DAC_SOURCE data too large\n");
}
__inline void set_DISP_OUTPUT_CNTL_disp_trans_matrix_sel(regDISP_OUTPUT_CNTL *reg, unsigned int disp_trans_matrix_sel)
{
  reg->bitfields.DISP_TRANS_MATRIX_SEL = disp_trans_matrix_sel;
  if (reg->bitfields.DISP_TRANS_MATRIX_SEL != disp_trans_matrix_sel) HSLDPF(E_ERROR_MESSAGE,"DISP_OUTPUT_CNTL::DISP_TRANS_MATRIX_SEL data too large\n");
}
__inline void set_DISP_OUTPUT_CNTL_disp_rmx_dith_en(regDISP_OUTPUT_CNTL *reg, unsigned int disp_rmx_dith_en)
{
  reg->bitfields.DISP_RMX_DITH_EN = disp_rmx_dith_en;
  if (reg->bitfields.DISP_RMX_DITH_EN != disp_rmx_dith_en) HSLDPF(E_ERROR_MESSAGE,"DISP_OUTPUT_CNTL::DISP_RMX_DITH_EN data too large\n");
}
__inline void set_DISP_OUTPUT_CNTL_disp_trans_source(regDISP_OUTPUT_CNTL *reg, unsigned int disp_trans_source)
{
  reg->bitfields.DISP_TRANS_SOURCE = disp_trans_source;
  if (reg->bitfields.DISP_TRANS_SOURCE != disp_trans_source) HSLDPF(E_ERROR_MESSAGE,"DISP_OUTPUT_CNTL::DISP_TRANS_SOURCE data too large\n");
}
__inline void set_DISP_OUTPUT_CNTL_disp_tv_source(regDISP_OUTPUT_CNTL *reg, unsigned int disp_tv_source)
{
  reg->bitfields.DISP_TV_SOURCE = disp_tv_source;
  if (reg->bitfields.DISP_TV_SOURCE != disp_tv_source) HSLDPF(E_ERROR_MESSAGE,"DISP_OUTPUT_CNTL::DISP_TV_SOURCE data too large\n");
}
__inline void set_DISP_OUTPUT_CNTL_disp_tv_mode(regDISP_OUTPUT_CNTL *reg, unsigned int disp_tv_mode)
{
  reg->bitfields.DISP_TV_MODE = disp_tv_mode;
  if (reg->bitfields.DISP_TV_MODE != disp_tv_mode) HSLDPF(E_ERROR_MESSAGE,"DISP_OUTPUT_CNTL::DISP_TV_MODE data too large\n");
}
__inline void set_DISP_OUTPUT_CNTL_disp_tv_yg_dith_en(regDISP_OUTPUT_CNTL *reg, unsigned int disp_tv_yg_dith_en)
{
  reg->bitfields.DISP_TV_YG_DITH_EN = disp_tv_yg_dith_en;
  if (reg->bitfields.DISP_TV_YG_DITH_EN != disp_tv_yg_dith_en) HSLDPF(E_ERROR_MESSAGE,"DISP_OUTPUT_CNTL::DISP_TV_YG_DITH_EN data too large\n");
}
__inline void set_DISP_OUTPUT_CNTL_disp_tv_cbb_crr_dith_en(regDISP_OUTPUT_CNTL *reg, unsigned int disp_tv_cbb_crr_dith_en)
{
  reg->bitfields.DISP_TV_CbB_CrR_DITH_EN = disp_tv_cbb_crr_dith_en;
  if (reg->bitfields.DISP_TV_CbB_CrR_DITH_EN != disp_tv_cbb_crr_dith_en) HSLDPF(E_ERROR_MESSAGE,"DISP_OUTPUT_CNTL::DISP_TV_CbB_CrR_DITH_EN data too large\n");
}
__inline void set_DISP_OUTPUT_CNTL_disp_tv_bit_width(regDISP_OUTPUT_CNTL *reg, unsigned int disp_tv_bit_width)
{
  reg->bitfields.DISP_TV_BIT_WIDTH = disp_tv_bit_width;
  if (reg->bitfields.DISP_TV_BIT_WIDTH != disp_tv_bit_width) HSLDPF(E_ERROR_MESSAGE,"DISP_OUTPUT_CNTL::DISP_TV_BIT_WIDTH data too large\n");
}
__inline void set_DISP_OUTPUT_CNTL_disp_tv_sync_mode(regDISP_OUTPUT_CNTL *reg, unsigned int disp_tv_sync_mode)
{
  reg->bitfields.DISP_TV_SYNC_MODE = disp_tv_sync_mode;
  if (reg->bitfields.DISP_TV_SYNC_MODE != disp_tv_sync_mode) HSLDPF(E_ERROR_MESSAGE,"DISP_OUTPUT_CNTL::DISP_TV_SYNC_MODE data too large\n");
}
__inline void set_DISP_OUTPUT_CNTL_disp_tv_sync_force(regDISP_OUTPUT_CNTL *reg, unsigned int disp_tv_sync_force)
{
  reg->bitfields.DISP_TV_SYNC_FORCE = disp_tv_sync_force;
  if (reg->bitfields.DISP_TV_SYNC_FORCE != disp_tv_sync_force) HSLDPF(E_ERROR_MESSAGE,"DISP_OUTPUT_CNTL::DISP_TV_SYNC_FORCE data too large\n");
}
__inline void set_DISP_OUTPUT_CNTL_disp_tv_sync_color(regDISP_OUTPUT_CNTL *reg, unsigned int disp_tv_sync_color)
{
  reg->bitfields.DISP_TV_SYNC_COLOR = disp_tv_sync_color;
  if (reg->bitfields.DISP_TV_SYNC_COLOR != disp_tv_sync_color) HSLDPF(E_ERROR_MESSAGE,"DISP_OUTPUT_CNTL::DISP_TV_SYNC_COLOR data too large\n");
}
__inline void set_DISP_OUTPUT_CNTL_disp_tv_even_flag_cntl(regDISP_OUTPUT_CNTL *reg, unsigned int disp_tv_even_flag_cntl)
{
  reg->bitfields.DISP_TV_EVEN_FLAG_CNTL = disp_tv_even_flag_cntl;
  if (reg->bitfields.DISP_TV_EVEN_FLAG_CNTL != disp_tv_even_flag_cntl) HSLDPF(E_ERROR_MESSAGE,"DISP_OUTPUT_CNTL::DISP_TV_EVEN_FLAG_CNTL data too large\n");
}
__inline void set_DISP_OUTPUT_CNTL_disp_tv_sync_status(regDISP_OUTPUT_CNTL *reg, unsigned int disp_tv_sync_status)
{
  reg->bitfields.DISP_TV_SYNC_STATUS = disp_tv_sync_status;
  if (reg->bitfields.DISP_TV_SYNC_STATUS != disp_tv_sync_status) HSLDPF(E_ERROR_MESSAGE,"DISP_OUTPUT_CNTL::DISP_TV_SYNC_STATUS data too large\n");
}
#else
#define set_DISP_OUTPUT_CNTL_disp_dac_source(reg, disp_dac_source) (reg)->bitfields.DISP_DAC_SOURCE = disp_dac_source
#define set_DISP_OUTPUT_CNTL_disp_trans_matrix_sel(reg, disp_trans_matrix_sel) (reg)->bitfields.DISP_TRANS_MATRIX_SEL = disp_trans_matrix_sel
#define set_DISP_OUTPUT_CNTL_disp_rmx_dith_en(reg, disp_rmx_dith_en) (reg)->bitfields.DISP_RMX_DITH_EN = disp_rmx_dith_en
#define set_DISP_OUTPUT_CNTL_disp_trans_source(reg, disp_trans_source) (reg)->bitfields.DISP_TRANS_SOURCE = disp_trans_source
#define set_DISP_OUTPUT_CNTL_disp_tv_source(reg, disp_tv_source) (reg)->bitfields.DISP_TV_SOURCE = disp_tv_source
#define set_DISP_OUTPUT_CNTL_disp_tv_mode(reg, disp_tv_mode) (reg)->bitfields.DISP_TV_MODE = disp_tv_mode
#define set_DISP_OUTPUT_CNTL_disp_tv_yg_dith_en(reg, disp_tv_yg_dith_en) (reg)->bitfields.DISP_TV_YG_DITH_EN = disp_tv_yg_dith_en
#define set_DISP_OUTPUT_CNTL_disp_tv_cbb_crr_dith_en(reg, disp_tv_cbb_crr_dith_en) (reg)->bitfields.DISP_TV_CbB_CrR_DITH_EN = disp_tv_cbb_crr_dith_en
#define set_DISP_OUTPUT_CNTL_disp_tv_bit_width(reg, disp_tv_bit_width) (reg)->bitfields.DISP_TV_BIT_WIDTH = disp_tv_bit_width
#define set_DISP_OUTPUT_CNTL_disp_tv_sync_mode(reg, disp_tv_sync_mode) (reg)->bitfields.DISP_TV_SYNC_MODE = disp_tv_sync_mode
#define set_DISP_OUTPUT_CNTL_disp_tv_sync_force(reg, disp_tv_sync_force) (reg)->bitfields.DISP_TV_SYNC_FORCE = disp_tv_sync_force
#define set_DISP_OUTPUT_CNTL_disp_tv_sync_color(reg, disp_tv_sync_color) (reg)->bitfields.DISP_TV_SYNC_COLOR = disp_tv_sync_color
#define set_DISP_OUTPUT_CNTL_disp_tv_even_flag_cntl(reg, disp_tv_even_flag_cntl) (reg)->bitfields.DISP_TV_EVEN_FLAG_CNTL = disp_tv_even_flag_cntl
#define set_DISP_OUTPUT_CNTL_disp_tv_sync_status(reg, disp_tv_sync_status) (reg)->bitfields.DISP_TV_SYNC_STATUS = disp_tv_sync_status

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_TV_OUT_CNTL regDISP_TV_OUT_CNTL;

#ifdef DEBUG
__inline void set_DISP_TV_OUT_CNTL_disp_tv_out_yg_filter(regDISP_TV_OUT_CNTL *reg, unsigned int disp_tv_out_yg_filter)
{
  reg->bitfields.DISP_TV_OUT_YG_FILTER = disp_tv_out_yg_filter;
  if (reg->bitfields.DISP_TV_OUT_YG_FILTER != disp_tv_out_yg_filter) HSLDPF(E_ERROR_MESSAGE,"DISP_TV_OUT_CNTL::DISP_TV_OUT_YG_FILTER data too large\n");
}
__inline void set_DISP_TV_OUT_CNTL_disp_tv_out_yg_sample(regDISP_TV_OUT_CNTL *reg, unsigned int disp_tv_out_yg_sample)
{
  reg->bitfields.DISP_TV_OUT_YG_SAMPLE = disp_tv_out_yg_sample;
  if (reg->bitfields.DISP_TV_OUT_YG_SAMPLE != disp_tv_out_yg_sample) HSLDPF(E_ERROR_MESSAGE,"DISP_TV_OUT_CNTL::DISP_TV_OUT_YG_SAMPLE data too large\n");
}
__inline void set_DISP_TV_OUT_CNTL_disp_tv_out_crr_filter(regDISP_TV_OUT_CNTL *reg, unsigned int disp_tv_out_crr_filter)
{
  reg->bitfields.DISP_TV_OUT_CrR_FILTER = disp_tv_out_crr_filter;
  if (reg->bitfields.DISP_TV_OUT_CrR_FILTER != disp_tv_out_crr_filter) HSLDPF(E_ERROR_MESSAGE,"DISP_TV_OUT_CNTL::DISP_TV_OUT_CrR_FILTER data too large\n");
}
__inline void set_DISP_TV_OUT_CNTL_disp_tv_out_crr_sample(regDISP_TV_OUT_CNTL *reg, unsigned int disp_tv_out_crr_sample)
{
  reg->bitfields.DISP_TV_OUT_CrR_SAMPLE = disp_tv_out_crr_sample;
  if (reg->bitfields.DISP_TV_OUT_CrR_SAMPLE != disp_tv_out_crr_sample) HSLDPF(E_ERROR_MESSAGE,"DISP_TV_OUT_CNTL::DISP_TV_OUT_CrR_SAMPLE data too large\n");
}
__inline void set_DISP_TV_OUT_CNTL_disp_tv_out_cbb_filter(regDISP_TV_OUT_CNTL *reg, unsigned int disp_tv_out_cbb_filter)
{
  reg->bitfields.DISP_TV_OUT_CbB_FILTER = disp_tv_out_cbb_filter;
  if (reg->bitfields.DISP_TV_OUT_CbB_FILTER != disp_tv_out_cbb_filter) HSLDPF(E_ERROR_MESSAGE,"DISP_TV_OUT_CNTL::DISP_TV_OUT_CbB_FILTER data too large\n");
}
__inline void set_DISP_TV_OUT_CNTL_disp_tv_out_cbb_sample(regDISP_TV_OUT_CNTL *reg, unsigned int disp_tv_out_cbb_sample)
{
  reg->bitfields.DISP_TV_OUT_CbB_SAMPLE = disp_tv_out_cbb_sample;
  if (reg->bitfields.DISP_TV_OUT_CbB_SAMPLE != disp_tv_out_cbb_sample) HSLDPF(E_ERROR_MESSAGE,"DISP_TV_OUT_CNTL::DISP_TV_OUT_CbB_SAMPLE data too large\n");
}
__inline void set_DISP_TV_OUT_CNTL_disp_tv_subsample_cntl(regDISP_TV_OUT_CNTL *reg, unsigned int disp_tv_subsample_cntl)
{
  reg->bitfields.DISP_TV_SUBSAMPLE_CNTL = disp_tv_subsample_cntl;
  if (reg->bitfields.DISP_TV_SUBSAMPLE_CNTL != disp_tv_subsample_cntl) HSLDPF(E_ERROR_MESSAGE,"DISP_TV_OUT_CNTL::DISP_TV_SUBSAMPLE_CNTL data too large\n");
}
__inline void set_DISP_TV_OUT_CNTL_disp_tv_h_downscale(regDISP_TV_OUT_CNTL *reg, unsigned int disp_tv_h_downscale)
{
  reg->bitfields.DISP_TV_H_DOWNSCALE = disp_tv_h_downscale;
  if (reg->bitfields.DISP_TV_H_DOWNSCALE != disp_tv_h_downscale) HSLDPF(E_ERROR_MESSAGE,"DISP_TV_OUT_CNTL::DISP_TV_H_DOWNSCALE data too large\n");
}
__inline void set_DISP_TV_OUT_CNTL_disp_tv_path_src(regDISP_TV_OUT_CNTL *reg, unsigned int disp_tv_path_src)
{
  reg->bitfields.DISP_TV_PATH_SRC = disp_tv_path_src;
  if (reg->bitfields.DISP_TV_PATH_SRC != disp_tv_path_src) HSLDPF(E_ERROR_MESSAGE,"DISP_TV_OUT_CNTL::DISP_TV_PATH_SRC data too large\n");
}
__inline void set_DISP_TV_OUT_CNTL_disp_tv_color_space(regDISP_TV_OUT_CNTL *reg, unsigned int disp_tv_color_space)
{
  reg->bitfields.DISP_TV_COLOR_SPACE = disp_tv_color_space;
  if (reg->bitfields.DISP_TV_COLOR_SPACE != disp_tv_color_space) HSLDPF(E_ERROR_MESSAGE,"DISP_TV_OUT_CNTL::DISP_TV_COLOR_SPACE data too large\n");
}
__inline void set_DISP_TV_OUT_CNTL_disp_tv_dith_mode(regDISP_TV_OUT_CNTL *reg, unsigned int disp_tv_dith_mode)
{
  reg->bitfields.DISP_TV_DITH_MODE = disp_tv_dith_mode;
  if (reg->bitfields.DISP_TV_DITH_MODE != disp_tv_dith_mode) HSLDPF(E_ERROR_MESSAGE,"DISP_TV_OUT_CNTL::DISP_TV_DITH_MODE data too large\n");
}
__inline void set_DISP_TV_OUT_CNTL_disp_tv_data_zero_sel(regDISP_TV_OUT_CNTL *reg, unsigned int disp_tv_data_zero_sel)
{
  reg->bitfields.DISP_TV_DATA_ZERO_SEL = disp_tv_data_zero_sel;
  if (reg->bitfields.DISP_TV_DATA_ZERO_SEL != disp_tv_data_zero_sel) HSLDPF(E_ERROR_MESSAGE,"DISP_TV_OUT_CNTL::DISP_TV_DATA_ZERO_SEL data too large\n");
}
__inline void set_DISP_TV_OUT_CNTL_disp_tv_clko_sel(regDISP_TV_OUT_CNTL *reg, unsigned int disp_tv_clko_sel)
{
  reg->bitfields.DISP_TV_CLKO_SEL = disp_tv_clko_sel;
  if (reg->bitfields.DISP_TV_CLKO_SEL != disp_tv_clko_sel) HSLDPF(E_ERROR_MESSAGE,"DISP_TV_OUT_CNTL::DISP_TV_CLKO_SEL data too large\n");
}
__inline void set_DISP_TV_OUT_CNTL_disp_tv_clko_out_en(regDISP_TV_OUT_CNTL *reg, unsigned int disp_tv_clko_out_en)
{
  reg->bitfields.DISP_TV_CLKO_OUT_EN = disp_tv_clko_out_en;
  if (reg->bitfields.DISP_TV_CLKO_OUT_EN != disp_tv_clko_out_en) HSLDPF(E_ERROR_MESSAGE,"DISP_TV_OUT_CNTL::DISP_TV_CLKO_OUT_EN data too large\n");
}
__inline void set_DISP_TV_OUT_CNTL_disp_tv_downscale_cntl(regDISP_TV_OUT_CNTL *reg, unsigned int disp_tv_downscale_cntl)
{
  reg->bitfields.DISP_TV_DOWNSCALE_CNTL = disp_tv_downscale_cntl;
  if (reg->bitfields.DISP_TV_DOWNSCALE_CNTL != disp_tv_downscale_cntl) HSLDPF(E_ERROR_MESSAGE,"DISP_TV_OUT_CNTL::DISP_TV_DOWNSCALE_CNTL data too large\n");
}
#else
#define set_DISP_TV_OUT_CNTL_disp_tv_out_yg_filter(reg, disp_tv_out_yg_filter) (reg)->bitfields.DISP_TV_OUT_YG_FILTER = disp_tv_out_yg_filter
#define set_DISP_TV_OUT_CNTL_disp_tv_out_yg_sample(reg, disp_tv_out_yg_sample) (reg)->bitfields.DISP_TV_OUT_YG_SAMPLE = disp_tv_out_yg_sample
#define set_DISP_TV_OUT_CNTL_disp_tv_out_crr_filter(reg, disp_tv_out_crr_filter) (reg)->bitfields.DISP_TV_OUT_CrR_FILTER = disp_tv_out_crr_filter
#define set_DISP_TV_OUT_CNTL_disp_tv_out_crr_sample(reg, disp_tv_out_crr_sample) (reg)->bitfields.DISP_TV_OUT_CrR_SAMPLE = disp_tv_out_crr_sample
#define set_DISP_TV_OUT_CNTL_disp_tv_out_cbb_filter(reg, disp_tv_out_cbb_filter) (reg)->bitfields.DISP_TV_OUT_CbB_FILTER = disp_tv_out_cbb_filter
#define set_DISP_TV_OUT_CNTL_disp_tv_out_cbb_sample(reg, disp_tv_out_cbb_sample) (reg)->bitfields.DISP_TV_OUT_CbB_SAMPLE = disp_tv_out_cbb_sample
#define set_DISP_TV_OUT_CNTL_disp_tv_subsample_cntl(reg, disp_tv_subsample_cntl) (reg)->bitfields.DISP_TV_SUBSAMPLE_CNTL = disp_tv_subsample_cntl
#define set_DISP_TV_OUT_CNTL_disp_tv_h_downscale(reg, disp_tv_h_downscale) (reg)->bitfields.DISP_TV_H_DOWNSCALE = disp_tv_h_downscale
#define set_DISP_TV_OUT_CNTL_disp_tv_path_src(reg, disp_tv_path_src) (reg)->bitfields.DISP_TV_PATH_SRC = disp_tv_path_src
#define set_DISP_TV_OUT_CNTL_disp_tv_color_space(reg, disp_tv_color_space) (reg)->bitfields.DISP_TV_COLOR_SPACE = disp_tv_color_space
#define set_DISP_TV_OUT_CNTL_disp_tv_dith_mode(reg, disp_tv_dith_mode) (reg)->bitfields.DISP_TV_DITH_MODE = disp_tv_dith_mode
#define set_DISP_TV_OUT_CNTL_disp_tv_data_zero_sel(reg, disp_tv_data_zero_sel) (reg)->bitfields.DISP_TV_DATA_ZERO_SEL = disp_tv_data_zero_sel
#define set_DISP_TV_OUT_CNTL_disp_tv_clko_sel(reg, disp_tv_clko_sel) (reg)->bitfields.DISP_TV_CLKO_SEL = disp_tv_clko_sel
#define set_DISP_TV_OUT_CNTL_disp_tv_clko_out_en(reg, disp_tv_clko_out_en) (reg)->bitfields.DISP_TV_CLKO_OUT_EN = disp_tv_clko_out_en
#define set_DISP_TV_OUT_CNTL_disp_tv_downscale_cntl(reg, disp_tv_downscale_cntl) (reg)->bitfields.DISP_TV_DOWNSCALE_CNTL = disp_tv_downscale_cntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_LIN_TRANS_GRPH_A regDISP_LIN_TRANS_GRPH_A;

#ifdef DEBUG
__inline void set_DISP_LIN_TRANS_GRPH_A_disp_lin_trans_grph_c2(regDISP_LIN_TRANS_GRPH_A *reg, unsigned int disp_lin_trans_grph_c2)
{
  reg->bitfields.DISP_LIN_TRANS_GRPH_C2 = disp_lin_trans_grph_c2;
  if (reg->bitfields.DISP_LIN_TRANS_GRPH_C2 != disp_lin_trans_grph_c2) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_GRPH_A::DISP_LIN_TRANS_GRPH_C2 data too large\n");
}
__inline void set_DISP_LIN_TRANS_GRPH_A_disp_lin_trans_grph_c1(regDISP_LIN_TRANS_GRPH_A *reg, unsigned int disp_lin_trans_grph_c1)
{
  reg->bitfields.DISP_LIN_TRANS_GRPH_C1 = disp_lin_trans_grph_c1;
  if (reg->bitfields.DISP_LIN_TRANS_GRPH_C1 != disp_lin_trans_grph_c1) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_GRPH_A::DISP_LIN_TRANS_GRPH_C1 data too large\n");
}
#else
#define set_DISP_LIN_TRANS_GRPH_A_disp_lin_trans_grph_c2(reg, disp_lin_trans_grph_c2) (reg)->bitfields.DISP_LIN_TRANS_GRPH_C2 = disp_lin_trans_grph_c2
#define set_DISP_LIN_TRANS_GRPH_A_disp_lin_trans_grph_c1(reg, disp_lin_trans_grph_c1) (reg)->bitfields.DISP_LIN_TRANS_GRPH_C1 = disp_lin_trans_grph_c1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_LIN_TRANS_GRPH_B regDISP_LIN_TRANS_GRPH_B;

#ifdef DEBUG
__inline void set_DISP_LIN_TRANS_GRPH_B_disp_lin_trans_grph_c4(regDISP_LIN_TRANS_GRPH_B *reg, unsigned int disp_lin_trans_grph_c4)
{
  reg->bitfields.DISP_LIN_TRANS_GRPH_C4 = disp_lin_trans_grph_c4;
  if (reg->bitfields.DISP_LIN_TRANS_GRPH_C4 != disp_lin_trans_grph_c4) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_GRPH_B::DISP_LIN_TRANS_GRPH_C4 data too large\n");
}
__inline void set_DISP_LIN_TRANS_GRPH_B_disp_lin_trans_grph_c3(regDISP_LIN_TRANS_GRPH_B *reg, unsigned int disp_lin_trans_grph_c3)
{
  reg->bitfields.DISP_LIN_TRANS_GRPH_C3 = disp_lin_trans_grph_c3;
  if (reg->bitfields.DISP_LIN_TRANS_GRPH_C3 != disp_lin_trans_grph_c3) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_GRPH_B::DISP_LIN_TRANS_GRPH_C3 data too large\n");
}
#else
#define set_DISP_LIN_TRANS_GRPH_B_disp_lin_trans_grph_c4(reg, disp_lin_trans_grph_c4) (reg)->bitfields.DISP_LIN_TRANS_GRPH_C4 = disp_lin_trans_grph_c4
#define set_DISP_LIN_TRANS_GRPH_B_disp_lin_trans_grph_c3(reg, disp_lin_trans_grph_c3) (reg)->bitfields.DISP_LIN_TRANS_GRPH_C3 = disp_lin_trans_grph_c3

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_LIN_TRANS_GRPH_C regDISP_LIN_TRANS_GRPH_C;

#ifdef DEBUG
__inline void set_DISP_LIN_TRANS_GRPH_C_disp_lin_trans_grph_c6(regDISP_LIN_TRANS_GRPH_C *reg, unsigned int disp_lin_trans_grph_c6)
{
  reg->bitfields.DISP_LIN_TRANS_GRPH_C6 = disp_lin_trans_grph_c6;
  if (reg->bitfields.DISP_LIN_TRANS_GRPH_C6 != disp_lin_trans_grph_c6) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_GRPH_C::DISP_LIN_TRANS_GRPH_C6 data too large\n");
}
__inline void set_DISP_LIN_TRANS_GRPH_C_disp_lin_trans_grph_c5(regDISP_LIN_TRANS_GRPH_C *reg, unsigned int disp_lin_trans_grph_c5)
{
  reg->bitfields.DISP_LIN_TRANS_GRPH_C5 = disp_lin_trans_grph_c5;
  if (reg->bitfields.DISP_LIN_TRANS_GRPH_C5 != disp_lin_trans_grph_c5) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_GRPH_C::DISP_LIN_TRANS_GRPH_C5 data too large\n");
}
#else
#define set_DISP_LIN_TRANS_GRPH_C_disp_lin_trans_grph_c6(reg, disp_lin_trans_grph_c6) (reg)->bitfields.DISP_LIN_TRANS_GRPH_C6 = disp_lin_trans_grph_c6
#define set_DISP_LIN_TRANS_GRPH_C_disp_lin_trans_grph_c5(reg, disp_lin_trans_grph_c5) (reg)->bitfields.DISP_LIN_TRANS_GRPH_C5 = disp_lin_trans_grph_c5

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_LIN_TRANS_GRPH_D regDISP_LIN_TRANS_GRPH_D;

#ifdef DEBUG
__inline void set_DISP_LIN_TRANS_GRPH_D_disp_lin_trans_grph_c8(regDISP_LIN_TRANS_GRPH_D *reg, unsigned int disp_lin_trans_grph_c8)
{
  reg->bitfields.DISP_LIN_TRANS_GRPH_C8 = disp_lin_trans_grph_c8;
  if (reg->bitfields.DISP_LIN_TRANS_GRPH_C8 != disp_lin_trans_grph_c8) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_GRPH_D::DISP_LIN_TRANS_GRPH_C8 data too large\n");
}
__inline void set_DISP_LIN_TRANS_GRPH_D_disp_lin_trans_grph_c7(regDISP_LIN_TRANS_GRPH_D *reg, unsigned int disp_lin_trans_grph_c7)
{
  reg->bitfields.DISP_LIN_TRANS_GRPH_C7 = disp_lin_trans_grph_c7;
  if (reg->bitfields.DISP_LIN_TRANS_GRPH_C7 != disp_lin_trans_grph_c7) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_GRPH_D::DISP_LIN_TRANS_GRPH_C7 data too large\n");
}
#else
#define set_DISP_LIN_TRANS_GRPH_D_disp_lin_trans_grph_c8(reg, disp_lin_trans_grph_c8) (reg)->bitfields.DISP_LIN_TRANS_GRPH_C8 = disp_lin_trans_grph_c8
#define set_DISP_LIN_TRANS_GRPH_D_disp_lin_trans_grph_c7(reg, disp_lin_trans_grph_c7) (reg)->bitfields.DISP_LIN_TRANS_GRPH_C7 = disp_lin_trans_grph_c7

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_LIN_TRANS_GRPH_E regDISP_LIN_TRANS_GRPH_E;

#ifdef DEBUG
__inline void set_DISP_LIN_TRANS_GRPH_E_disp_lin_trans_grph_c10(regDISP_LIN_TRANS_GRPH_E *reg, unsigned int disp_lin_trans_grph_c10)
{
  reg->bitfields.DISP_LIN_TRANS_GRPH_C10 = disp_lin_trans_grph_c10;
  if (reg->bitfields.DISP_LIN_TRANS_GRPH_C10 != disp_lin_trans_grph_c10) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_GRPH_E::DISP_LIN_TRANS_GRPH_C10 data too large\n");
}
__inline void set_DISP_LIN_TRANS_GRPH_E_disp_lin_trans_grph_c9(regDISP_LIN_TRANS_GRPH_E *reg, unsigned int disp_lin_trans_grph_c9)
{
  reg->bitfields.DISP_LIN_TRANS_GRPH_C9 = disp_lin_trans_grph_c9;
  if (reg->bitfields.DISP_LIN_TRANS_GRPH_C9 != disp_lin_trans_grph_c9) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_GRPH_E::DISP_LIN_TRANS_GRPH_C9 data too large\n");
}
#else
#define set_DISP_LIN_TRANS_GRPH_E_disp_lin_trans_grph_c10(reg, disp_lin_trans_grph_c10) (reg)->bitfields.DISP_LIN_TRANS_GRPH_C10 = disp_lin_trans_grph_c10
#define set_DISP_LIN_TRANS_GRPH_E_disp_lin_trans_grph_c9(reg, disp_lin_trans_grph_c9) (reg)->bitfields.DISP_LIN_TRANS_GRPH_C9 = disp_lin_trans_grph_c9

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_LIN_TRANS_GRPH_F regDISP_LIN_TRANS_GRPH_F;

#ifdef DEBUG
__inline void set_DISP_LIN_TRANS_GRPH_F_disp_lin_trans_grph_c12(regDISP_LIN_TRANS_GRPH_F *reg, unsigned int disp_lin_trans_grph_c12)
{
  reg->bitfields.DISP_LIN_TRANS_GRPH_C12 = disp_lin_trans_grph_c12;
  if (reg->bitfields.DISP_LIN_TRANS_GRPH_C12 != disp_lin_trans_grph_c12) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_GRPH_F::DISP_LIN_TRANS_GRPH_C12 data too large\n");
}
__inline void set_DISP_LIN_TRANS_GRPH_F_disp_lin_trans_grph_c11(regDISP_LIN_TRANS_GRPH_F *reg, unsigned int disp_lin_trans_grph_c11)
{
  reg->bitfields.DISP_LIN_TRANS_GRPH_C11 = disp_lin_trans_grph_c11;
  if (reg->bitfields.DISP_LIN_TRANS_GRPH_C11 != disp_lin_trans_grph_c11) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_GRPH_F::DISP_LIN_TRANS_GRPH_C11 data too large\n");
}
#else
#define set_DISP_LIN_TRANS_GRPH_F_disp_lin_trans_grph_c12(reg, disp_lin_trans_grph_c12) (reg)->bitfields.DISP_LIN_TRANS_GRPH_C12 = disp_lin_trans_grph_c12
#define set_DISP_LIN_TRANS_GRPH_F_disp_lin_trans_grph_c11(reg, disp_lin_trans_grph_c11) (reg)->bitfields.DISP_LIN_TRANS_GRPH_C11 = disp_lin_trans_grph_c11

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_LIN_TRANS_VID_A regDISP_LIN_TRANS_VID_A;

#ifdef DEBUG
__inline void set_DISP_LIN_TRANS_VID_A_disp_lin_trans_vid_c2(regDISP_LIN_TRANS_VID_A *reg, unsigned int disp_lin_trans_vid_c2)
{
  reg->bitfields.DISP_LIN_TRANS_VID_C2 = disp_lin_trans_vid_c2;
  if (reg->bitfields.DISP_LIN_TRANS_VID_C2 != disp_lin_trans_vid_c2) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_VID_A::DISP_LIN_TRANS_VID_C2 data too large\n");
}
__inline void set_DISP_LIN_TRANS_VID_A_disp_lin_trans_vid_c1(regDISP_LIN_TRANS_VID_A *reg, unsigned int disp_lin_trans_vid_c1)
{
  reg->bitfields.DISP_LIN_TRANS_VID_C1 = disp_lin_trans_vid_c1;
  if (reg->bitfields.DISP_LIN_TRANS_VID_C1 != disp_lin_trans_vid_c1) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_VID_A::DISP_LIN_TRANS_VID_C1 data too large\n");
}
#else
#define set_DISP_LIN_TRANS_VID_A_disp_lin_trans_vid_c2(reg, disp_lin_trans_vid_c2) (reg)->bitfields.DISP_LIN_TRANS_VID_C2 = disp_lin_trans_vid_c2
#define set_DISP_LIN_TRANS_VID_A_disp_lin_trans_vid_c1(reg, disp_lin_trans_vid_c1) (reg)->bitfields.DISP_LIN_TRANS_VID_C1 = disp_lin_trans_vid_c1

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_LIN_TRANS_VID_B regDISP_LIN_TRANS_VID_B;

#ifdef DEBUG
__inline void set_DISP_LIN_TRANS_VID_B_disp_lin_trans_vid_c4(regDISP_LIN_TRANS_VID_B *reg, unsigned int disp_lin_trans_vid_c4)
{
  reg->bitfields.DISP_LIN_TRANS_VID_C4 = disp_lin_trans_vid_c4;
  if (reg->bitfields.DISP_LIN_TRANS_VID_C4 != disp_lin_trans_vid_c4) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_VID_B::DISP_LIN_TRANS_VID_C4 data too large\n");
}
__inline void set_DISP_LIN_TRANS_VID_B_disp_lin_trans_vid_c3(regDISP_LIN_TRANS_VID_B *reg, unsigned int disp_lin_trans_vid_c3)
{
  reg->bitfields.DISP_LIN_TRANS_VID_C3 = disp_lin_trans_vid_c3;
  if (reg->bitfields.DISP_LIN_TRANS_VID_C3 != disp_lin_trans_vid_c3) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_VID_B::DISP_LIN_TRANS_VID_C3 data too large\n");
}
#else
#define set_DISP_LIN_TRANS_VID_B_disp_lin_trans_vid_c4(reg, disp_lin_trans_vid_c4) (reg)->bitfields.DISP_LIN_TRANS_VID_C4 = disp_lin_trans_vid_c4
#define set_DISP_LIN_TRANS_VID_B_disp_lin_trans_vid_c3(reg, disp_lin_trans_vid_c3) (reg)->bitfields.DISP_LIN_TRANS_VID_C3 = disp_lin_trans_vid_c3

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_LIN_TRANS_VID_C regDISP_LIN_TRANS_VID_C;

#ifdef DEBUG
__inline void set_DISP_LIN_TRANS_VID_C_disp_lin_trans_vid_c6(regDISP_LIN_TRANS_VID_C *reg, unsigned int disp_lin_trans_vid_c6)
{
  reg->bitfields.DISP_LIN_TRANS_VID_C6 = disp_lin_trans_vid_c6;
  if (reg->bitfields.DISP_LIN_TRANS_VID_C6 != disp_lin_trans_vid_c6) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_VID_C::DISP_LIN_TRANS_VID_C6 data too large\n");
}
__inline void set_DISP_LIN_TRANS_VID_C_disp_lin_trans_vid_c5(regDISP_LIN_TRANS_VID_C *reg, unsigned int disp_lin_trans_vid_c5)
{
  reg->bitfields.DISP_LIN_TRANS_VID_C5 = disp_lin_trans_vid_c5;
  if (reg->bitfields.DISP_LIN_TRANS_VID_C5 != disp_lin_trans_vid_c5) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_VID_C::DISP_LIN_TRANS_VID_C5 data too large\n");
}
#else
#define set_DISP_LIN_TRANS_VID_C_disp_lin_trans_vid_c6(reg, disp_lin_trans_vid_c6) (reg)->bitfields.DISP_LIN_TRANS_VID_C6 = disp_lin_trans_vid_c6
#define set_DISP_LIN_TRANS_VID_C_disp_lin_trans_vid_c5(reg, disp_lin_trans_vid_c5) (reg)->bitfields.DISP_LIN_TRANS_VID_C5 = disp_lin_trans_vid_c5

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_LIN_TRANS_VID_D regDISP_LIN_TRANS_VID_D;

#ifdef DEBUG
__inline void set_DISP_LIN_TRANS_VID_D_disp_lin_trans_vid_c8(regDISP_LIN_TRANS_VID_D *reg, unsigned int disp_lin_trans_vid_c8)
{
  reg->bitfields.DISP_LIN_TRANS_VID_C8 = disp_lin_trans_vid_c8;
  if (reg->bitfields.DISP_LIN_TRANS_VID_C8 != disp_lin_trans_vid_c8) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_VID_D::DISP_LIN_TRANS_VID_C8 data too large\n");
}
__inline void set_DISP_LIN_TRANS_VID_D_disp_lin_trans_vid_c7(regDISP_LIN_TRANS_VID_D *reg, unsigned int disp_lin_trans_vid_c7)
{
  reg->bitfields.DISP_LIN_TRANS_VID_C7 = disp_lin_trans_vid_c7;
  if (reg->bitfields.DISP_LIN_TRANS_VID_C7 != disp_lin_trans_vid_c7) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_VID_D::DISP_LIN_TRANS_VID_C7 data too large\n");
}
#else
#define set_DISP_LIN_TRANS_VID_D_disp_lin_trans_vid_c8(reg, disp_lin_trans_vid_c8) (reg)->bitfields.DISP_LIN_TRANS_VID_C8 = disp_lin_trans_vid_c8
#define set_DISP_LIN_TRANS_VID_D_disp_lin_trans_vid_c7(reg, disp_lin_trans_vid_c7) (reg)->bitfields.DISP_LIN_TRANS_VID_C7 = disp_lin_trans_vid_c7

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_LIN_TRANS_VID_E regDISP_LIN_TRANS_VID_E;

#ifdef DEBUG
__inline void set_DISP_LIN_TRANS_VID_E_disp_lin_trans_vid_c10(regDISP_LIN_TRANS_VID_E *reg, unsigned int disp_lin_trans_vid_c10)
{
  reg->bitfields.DISP_LIN_TRANS_VID_C10 = disp_lin_trans_vid_c10;
  if (reg->bitfields.DISP_LIN_TRANS_VID_C10 != disp_lin_trans_vid_c10) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_VID_E::DISP_LIN_TRANS_VID_C10 data too large\n");
}
__inline void set_DISP_LIN_TRANS_VID_E_disp_lin_trans_vid_c9(regDISP_LIN_TRANS_VID_E *reg, unsigned int disp_lin_trans_vid_c9)
{
  reg->bitfields.DISP_LIN_TRANS_VID_C9 = disp_lin_trans_vid_c9;
  if (reg->bitfields.DISP_LIN_TRANS_VID_C9 != disp_lin_trans_vid_c9) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_VID_E::DISP_LIN_TRANS_VID_C9 data too large\n");
}
#else
#define set_DISP_LIN_TRANS_VID_E_disp_lin_trans_vid_c10(reg, disp_lin_trans_vid_c10) (reg)->bitfields.DISP_LIN_TRANS_VID_C10 = disp_lin_trans_vid_c10
#define set_DISP_LIN_TRANS_VID_E_disp_lin_trans_vid_c9(reg, disp_lin_trans_vid_c9) (reg)->bitfields.DISP_LIN_TRANS_VID_C9 = disp_lin_trans_vid_c9

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DISP_LIN_TRANS_VID_F regDISP_LIN_TRANS_VID_F;

#ifdef DEBUG
__inline void set_DISP_LIN_TRANS_VID_F_disp_lin_trans_vid_c12(regDISP_LIN_TRANS_VID_F *reg, unsigned int disp_lin_trans_vid_c12)
{
  reg->bitfields.DISP_LIN_TRANS_VID_C12 = disp_lin_trans_vid_c12;
  if (reg->bitfields.DISP_LIN_TRANS_VID_C12 != disp_lin_trans_vid_c12) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_VID_F::DISP_LIN_TRANS_VID_C12 data too large\n");
}
__inline void set_DISP_LIN_TRANS_VID_F_disp_lin_trans_vid_c11(regDISP_LIN_TRANS_VID_F *reg, unsigned int disp_lin_trans_vid_c11)
{
  reg->bitfields.DISP_LIN_TRANS_VID_C11 = disp_lin_trans_vid_c11;
  if (reg->bitfields.DISP_LIN_TRANS_VID_C11 != disp_lin_trans_vid_c11) HSLDPF(E_ERROR_MESSAGE,"DISP_LIN_TRANS_VID_F::DISP_LIN_TRANS_VID_C11 data too large\n");
}
#else
#define set_DISP_LIN_TRANS_VID_F_disp_lin_trans_vid_c12(reg, disp_lin_trans_vid_c12) (reg)->bitfields.DISP_LIN_TRANS_VID_C12 = disp_lin_trans_vid_c12
#define set_DISP_LIN_TRANS_VID_F_disp_lin_trans_vid_c11(reg, disp_lin_trans_vid_c11) (reg)->bitfields.DISP_LIN_TRANS_VID_C11 = disp_lin_trans_vid_c11

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_EMBEDDED_SYNC_CNTL regDAC_EMBEDDED_SYNC_CNTL;

#ifdef DEBUG
__inline void set_DAC_EMBEDDED_SYNC_CNTL_dac_embed_sync_en_y_g(regDAC_EMBEDDED_SYNC_CNTL *reg, unsigned int dac_embed_sync_en_y_g)
{
  reg->bitfields.DAC_EMBED_SYNC_EN_Y_G = dac_embed_sync_en_y_g;
  if (reg->bitfields.DAC_EMBED_SYNC_EN_Y_G != dac_embed_sync_en_y_g) HSLDPF(E_ERROR_MESSAGE,"DAC_EMBEDDED_SYNC_CNTL::DAC_EMBED_SYNC_EN_Y_G data too large\n");
}
__inline void set_DAC_EMBEDDED_SYNC_CNTL_dac_embed_sync_en_cb_b(regDAC_EMBEDDED_SYNC_CNTL *reg, unsigned int dac_embed_sync_en_cb_b)
{
  reg->bitfields.DAC_EMBED_SYNC_EN_Cb_B = dac_embed_sync_en_cb_b;
  if (reg->bitfields.DAC_EMBED_SYNC_EN_Cb_B != dac_embed_sync_en_cb_b) HSLDPF(E_ERROR_MESSAGE,"DAC_EMBEDDED_SYNC_CNTL::DAC_EMBED_SYNC_EN_Cb_B data too large\n");
}
__inline void set_DAC_EMBEDDED_SYNC_CNTL_dac_embed_sync_en_cr_r(regDAC_EMBEDDED_SYNC_CNTL *reg, unsigned int dac_embed_sync_en_cr_r)
{
  reg->bitfields.DAC_EMBED_SYNC_EN_Cr_R = dac_embed_sync_en_cr_r;
  if (reg->bitfields.DAC_EMBED_SYNC_EN_Cr_R != dac_embed_sync_en_cr_r) HSLDPF(E_ERROR_MESSAGE,"DAC_EMBEDDED_SYNC_CNTL::DAC_EMBED_SYNC_EN_Cr_R data too large\n");
}
__inline void set_DAC_EMBEDDED_SYNC_CNTL_dac_trilevel_sync_en(regDAC_EMBEDDED_SYNC_CNTL *reg, unsigned int dac_trilevel_sync_en)
{
  reg->bitfields.DAC_TRILEVEL_SYNC_EN = dac_trilevel_sync_en;
  if (reg->bitfields.DAC_TRILEVEL_SYNC_EN != dac_trilevel_sync_en) HSLDPF(E_ERROR_MESSAGE,"DAC_EMBEDDED_SYNC_CNTL::DAC_TRILEVEL_SYNC_EN data too large\n");
}
__inline void set_DAC_EMBEDDED_SYNC_CNTL_dac_embed_vsync_en_y_g(regDAC_EMBEDDED_SYNC_CNTL *reg, unsigned int dac_embed_vsync_en_y_g)
{
  reg->bitfields.DAC_EMBED_VSYNC_EN_Y_G = dac_embed_vsync_en_y_g;
  if (reg->bitfields.DAC_EMBED_VSYNC_EN_Y_G != dac_embed_vsync_en_y_g) HSLDPF(E_ERROR_MESSAGE,"DAC_EMBEDDED_SYNC_CNTL::DAC_EMBED_VSYNC_EN_Y_G data too large\n");
}
__inline void set_DAC_EMBEDDED_SYNC_CNTL_dac_embed_vsync_en_cbcr_br(regDAC_EMBEDDED_SYNC_CNTL *reg, unsigned int dac_embed_vsync_en_cbcr_br)
{
  reg->bitfields.DAC_EMBED_VSYNC_EN_CbCr_BR = dac_embed_vsync_en_cbcr_br;
  if (reg->bitfields.DAC_EMBED_VSYNC_EN_CbCr_BR != dac_embed_vsync_en_cbcr_br) HSLDPF(E_ERROR_MESSAGE,"DAC_EMBEDDED_SYNC_CNTL::DAC_EMBED_VSYNC_EN_CbCr_BR data too large\n");
}
__inline void set_DAC_EMBEDDED_SYNC_CNTL_dac_hsync_wid_lsb(regDAC_EMBEDDED_SYNC_CNTL *reg, unsigned int dac_hsync_wid_lsb)
{
  reg->bitfields.DAC_HSYNC_WID_LSB = dac_hsync_wid_lsb;
  if (reg->bitfields.DAC_HSYNC_WID_LSB != dac_hsync_wid_lsb) HSLDPF(E_ERROR_MESSAGE,"DAC_EMBEDDED_SYNC_CNTL::DAC_HSYNC_WID_LSB data too large\n");
}
#else
#define set_DAC_EMBEDDED_SYNC_CNTL_dac_embed_sync_en_y_g(reg, dac_embed_sync_en_y_g) (reg)->bitfields.DAC_EMBED_SYNC_EN_Y_G = dac_embed_sync_en_y_g
#define set_DAC_EMBEDDED_SYNC_CNTL_dac_embed_sync_en_cb_b(reg, dac_embed_sync_en_cb_b) (reg)->bitfields.DAC_EMBED_SYNC_EN_Cb_B = dac_embed_sync_en_cb_b
#define set_DAC_EMBEDDED_SYNC_CNTL_dac_embed_sync_en_cr_r(reg, dac_embed_sync_en_cr_r) (reg)->bitfields.DAC_EMBED_SYNC_EN_Cr_R = dac_embed_sync_en_cr_r
#define set_DAC_EMBEDDED_SYNC_CNTL_dac_trilevel_sync_en(reg, dac_trilevel_sync_en) (reg)->bitfields.DAC_TRILEVEL_SYNC_EN = dac_trilevel_sync_en
#define set_DAC_EMBEDDED_SYNC_CNTL_dac_embed_vsync_en_y_g(reg, dac_embed_vsync_en_y_g) (reg)->bitfields.DAC_EMBED_VSYNC_EN_Y_G = dac_embed_vsync_en_y_g
#define set_DAC_EMBEDDED_SYNC_CNTL_dac_embed_vsync_en_cbcr_br(reg, dac_embed_vsync_en_cbcr_br) (reg)->bitfields.DAC_EMBED_VSYNC_EN_CbCr_BR = dac_embed_vsync_en_cbcr_br
#define set_DAC_EMBEDDED_SYNC_CNTL_dac_hsync_wid_lsb(reg, dac_hsync_wid_lsb) (reg)->bitfields.DAC_HSYNC_WID_LSB = dac_hsync_wid_lsb

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_BROAD_PULSE regDAC_BROAD_PULSE;

#ifdef DEBUG
__inline void set_DAC_BROAD_PULSE_dac_broad_pulse_start_r2(regDAC_BROAD_PULSE *reg, unsigned int dac_broad_pulse_start_r2)
{
  reg->bitfields.DAC_BROAD_PULSE_START_R2 = dac_broad_pulse_start_r2;
  if (reg->bitfields.DAC_BROAD_PULSE_START_R2 != dac_broad_pulse_start_r2) HSLDPF(E_ERROR_MESSAGE,"DAC_BROAD_PULSE::DAC_BROAD_PULSE_START_R2 data too large\n");
}
__inline void set_DAC_BROAD_PULSE_dac_broad_pulse_end_r2(regDAC_BROAD_PULSE *reg, unsigned int dac_broad_pulse_end_r2)
{
  reg->bitfields.DAC_BROAD_PULSE_END_R2 = dac_broad_pulse_end_r2;
  if (reg->bitfields.DAC_BROAD_PULSE_END_R2 != dac_broad_pulse_end_r2) HSLDPF(E_ERROR_MESSAGE,"DAC_BROAD_PULSE::DAC_BROAD_PULSE_END_R2 data too large\n");
}
#else
#define set_DAC_BROAD_PULSE_dac_broad_pulse_start_r2(reg, dac_broad_pulse_start_r2) (reg)->bitfields.DAC_BROAD_PULSE_START_R2 = dac_broad_pulse_start_r2
#define set_DAC_BROAD_PULSE_dac_broad_pulse_end_r2(reg, dac_broad_pulse_end_r2) (reg)->bitfields.DAC_BROAD_PULSE_END_R2 = dac_broad_pulse_end_r2

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_SKEW_CLKS regDAC_SKEW_CLKS;

#ifdef DEBUG
__inline void set_DAC_SKEW_CLKS_dac_skew_clks(regDAC_SKEW_CLKS *reg, unsigned int dac_skew_clks)
{
  reg->bitfields.DAC_SKEW_CLKS = dac_skew_clks;
  if (reg->bitfields.DAC_SKEW_CLKS != dac_skew_clks) HSLDPF(E_ERROR_MESSAGE,"DAC_SKEW_CLKS::DAC_SKEW_CLKS data too large\n");
}
#else
#define set_DAC_SKEW_CLKS_dac_skew_clks(reg, dac_skew_clks) (reg)->bitfields.DAC_SKEW_CLKS = dac_skew_clks

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_INCR regDAC_INCR;

#ifdef DEBUG
__inline void set_DAC_INCR_dac_incr_y_g(regDAC_INCR *reg, unsigned int dac_incr_y_g)
{
  reg->bitfields.DAC_INCR_Y_G = dac_incr_y_g;
  if (reg->bitfields.DAC_INCR_Y_G != dac_incr_y_g) HSLDPF(E_ERROR_MESSAGE,"DAC_INCR::DAC_INCR_Y_G data too large\n");
}
__inline void set_DAC_INCR_dac_incr_crcb_rb(regDAC_INCR *reg, unsigned int dac_incr_crcb_rb)
{
  reg->bitfields.DAC_INCR_CrCb_RB = dac_incr_crcb_rb;
  if (reg->bitfields.DAC_INCR_CrCb_RB != dac_incr_crcb_rb) HSLDPF(E_ERROR_MESSAGE,"DAC_INCR::DAC_INCR_CrCb_RB data too large\n");
}
#else
#define set_DAC_INCR_dac_incr_y_g(reg, dac_incr_y_g) (reg)->bitfields.DAC_INCR_Y_G = dac_incr_y_g
#define set_DAC_INCR_dac_incr_crcb_rb(reg, dac_incr_crcb_rb) (reg)->bitfields.DAC_INCR_CrCb_RB = dac_incr_crcb_rb

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_NEG_SYNC_LEVEL regDAC_NEG_SYNC_LEVEL;

#ifdef DEBUG
__inline void set_DAC_NEG_SYNC_LEVEL_dac_neg_sync_level_y_g(regDAC_NEG_SYNC_LEVEL *reg, unsigned int dac_neg_sync_level_y_g)
{
  reg->bitfields.DAC_NEG_SYNC_LEVEL_Y_G = dac_neg_sync_level_y_g;
  if (reg->bitfields.DAC_NEG_SYNC_LEVEL_Y_G != dac_neg_sync_level_y_g) HSLDPF(E_ERROR_MESSAGE,"DAC_NEG_SYNC_LEVEL::DAC_NEG_SYNC_LEVEL_Y_G data too large\n");
}
__inline void set_DAC_NEG_SYNC_LEVEL_dac_neg_sync_level_crcb_rb(regDAC_NEG_SYNC_LEVEL *reg, unsigned int dac_neg_sync_level_crcb_rb)
{
  reg->bitfields.DAC_NEG_SYNC_LEVEL_CrCb_RB = dac_neg_sync_level_crcb_rb;
  if (reg->bitfields.DAC_NEG_SYNC_LEVEL_CrCb_RB != dac_neg_sync_level_crcb_rb) HSLDPF(E_ERROR_MESSAGE,"DAC_NEG_SYNC_LEVEL::DAC_NEG_SYNC_LEVEL_CrCb_RB data too large\n");
}
#else
#define set_DAC_NEG_SYNC_LEVEL_dac_neg_sync_level_y_g(reg, dac_neg_sync_level_y_g) (reg)->bitfields.DAC_NEG_SYNC_LEVEL_Y_G = dac_neg_sync_level_y_g
#define set_DAC_NEG_SYNC_LEVEL_dac_neg_sync_level_crcb_rb(reg, dac_neg_sync_level_crcb_rb) (reg)->bitfields.DAC_NEG_SYNC_LEVEL_CrCb_RB = dac_neg_sync_level_crcb_rb

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_POS_SYNC_LEVEL regDAC_POS_SYNC_LEVEL;

#ifdef DEBUG
__inline void set_DAC_POS_SYNC_LEVEL_dac_pos_sync_level_y_g(regDAC_POS_SYNC_LEVEL *reg, unsigned int dac_pos_sync_level_y_g)
{
  reg->bitfields.DAC_POS_SYNC_LEVEL_Y_G = dac_pos_sync_level_y_g;
  if (reg->bitfields.DAC_POS_SYNC_LEVEL_Y_G != dac_pos_sync_level_y_g) HSLDPF(E_ERROR_MESSAGE,"DAC_POS_SYNC_LEVEL::DAC_POS_SYNC_LEVEL_Y_G data too large\n");
}
__inline void set_DAC_POS_SYNC_LEVEL_dac_pos_sync_level_crcb_rb(regDAC_POS_SYNC_LEVEL *reg, unsigned int dac_pos_sync_level_crcb_rb)
{
  reg->bitfields.DAC_POS_SYNC_LEVEL_CrCb_RB = dac_pos_sync_level_crcb_rb;
  if (reg->bitfields.DAC_POS_SYNC_LEVEL_CrCb_RB != dac_pos_sync_level_crcb_rb) HSLDPF(E_ERROR_MESSAGE,"DAC_POS_SYNC_LEVEL::DAC_POS_SYNC_LEVEL_CrCb_RB data too large\n");
}
#else
#define set_DAC_POS_SYNC_LEVEL_dac_pos_sync_level_y_g(reg, dac_pos_sync_level_y_g) (reg)->bitfields.DAC_POS_SYNC_LEVEL_Y_G = dac_pos_sync_level_y_g
#define set_DAC_POS_SYNC_LEVEL_dac_pos_sync_level_crcb_rb(reg, dac_pos_sync_level_crcb_rb) (reg)->bitfields.DAC_POS_SYNC_LEVEL_CrCb_RB = dac_pos_sync_level_crcb_rb

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_BLANK_LEVEL regDAC_BLANK_LEVEL;

#ifdef DEBUG
__inline void set_DAC_BLANK_LEVEL_dac_blank_level_y_g(regDAC_BLANK_LEVEL *reg, unsigned int dac_blank_level_y_g)
{
  reg->bitfields.DAC_BLANK_LEVEL_Y_G = dac_blank_level_y_g;
  if (reg->bitfields.DAC_BLANK_LEVEL_Y_G != dac_blank_level_y_g) HSLDPF(E_ERROR_MESSAGE,"DAC_BLANK_LEVEL::DAC_BLANK_LEVEL_Y_G data too large\n");
}
__inline void set_DAC_BLANK_LEVEL_dac_blank_level_crcb_rb(regDAC_BLANK_LEVEL *reg, unsigned int dac_blank_level_crcb_rb)
{
  reg->bitfields.DAC_BLANK_LEVEL_CrCb_RB = dac_blank_level_crcb_rb;
  if (reg->bitfields.DAC_BLANK_LEVEL_CrCb_RB != dac_blank_level_crcb_rb) HSLDPF(E_ERROR_MESSAGE,"DAC_BLANK_LEVEL::DAC_BLANK_LEVEL_CrCb_RB data too large\n");
}
#else
#define set_DAC_BLANK_LEVEL_dac_blank_level_y_g(reg, dac_blank_level_y_g) (reg)->bitfields.DAC_BLANK_LEVEL_Y_G = dac_blank_level_y_g
#define set_DAC_BLANK_LEVEL_dac_blank_level_crcb_rb(reg, dac_blank_level_crcb_rb) (reg)->bitfields.DAC_BLANK_LEVEL_CrCb_RB = dac_blank_level_crcb_rb

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_SYNC_EQUALIZATION regDAC_SYNC_EQUALIZATION;

#ifdef DEBUG
__inline void set_DAC_SYNC_EQUALIZATION_dac_sync_eq_start(regDAC_SYNC_EQUALIZATION *reg, unsigned int dac_sync_eq_start)
{
  reg->bitfields.DAC_SYNC_EQ_START = dac_sync_eq_start;
  if (reg->bitfields.DAC_SYNC_EQ_START != dac_sync_eq_start) HSLDPF(E_ERROR_MESSAGE,"DAC_SYNC_EQUALIZATION::DAC_SYNC_EQ_START data too large\n");
}
__inline void set_DAC_SYNC_EQUALIZATION_dac_sync_eq_end(regDAC_SYNC_EQUALIZATION *reg, unsigned int dac_sync_eq_end)
{
  reg->bitfields.DAC_SYNC_EQ_END = dac_sync_eq_end;
  if (reg->bitfields.DAC_SYNC_EQ_END != dac_sync_eq_end) HSLDPF(E_ERROR_MESSAGE,"DAC_SYNC_EQUALIZATION::DAC_SYNC_EQ_END data too large\n");
}
#else
#define set_DAC_SYNC_EQUALIZATION_dac_sync_eq_start(reg, dac_sync_eq_start) (reg)->bitfields.DAC_SYNC_EQ_START = dac_sync_eq_start
#define set_DAC_SYNC_EQUALIZATION_dac_sync_eq_end(reg, dac_sync_eq_end) (reg)->bitfields.DAC_SYNC_EQ_END = dac_sync_eq_end

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_MV_CNTL regDAC_MV_CNTL;

#ifdef DEBUG
__inline void set_DAC_MV_CNTL_dac_mv_agc_pulse_en(regDAC_MV_CNTL *reg, unsigned int dac_mv_agc_pulse_en)
{
  reg->bitfields.DAC_MV_AGC_PULSE_EN = dac_mv_agc_pulse_en;
  if (reg->bitfields.DAC_MV_AGC_PULSE_EN != dac_mv_agc_pulse_en) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_CNTL::DAC_MV_AGC_PULSE_EN data too large\n");
}
__inline void set_DAC_MV_CNTL_dac_mv_blank_en(regDAC_MV_CNTL *reg, unsigned int dac_mv_blank_en)
{
  reg->bitfields.DAC_MV_BLANK_EN = dac_mv_blank_en;
  if (reg->bitfields.DAC_MV_BLANK_EN != dac_mv_blank_en) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_CNTL::DAC_MV_BLANK_EN data too large\n");
}
__inline void set_DAC_MV_CNTL_dac_mv_bp_pulse_en(regDAC_MV_CNTL *reg, unsigned int dac_mv_bp_pulse_en)
{
  reg->bitfields.DAC_MV_BP_PULSE_EN = dac_mv_bp_pulse_en;
  if (reg->bitfields.DAC_MV_BP_PULSE_EN != dac_mv_bp_pulse_en) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_CNTL::DAC_MV_BP_PULSE_EN data too large\n");
}
__inline void set_DAC_MV_CNTL_dac_mv_agc_pulse_count(regDAC_MV_CNTL *reg, unsigned int dac_mv_agc_pulse_count)
{
  reg->bitfields.DAC_MV_AGC_PULSE_COUNT = dac_mv_agc_pulse_count;
  if (reg->bitfields.DAC_MV_AGC_PULSE_COUNT != dac_mv_agc_pulse_count) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_CNTL::DAC_MV_AGC_PULSE_COUNT data too large\n");
}
__inline void set_DAC_MV_CNTL_dac_mv_write_en(regDAC_MV_CNTL *reg, unsigned int dac_mv_write_en)
{
  reg->bitfields.DAC_MV_WRITE_EN = dac_mv_write_en;
  if (reg->bitfields.DAC_MV_WRITE_EN != dac_mv_write_en) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_CNTL::DAC_MV_WRITE_EN data too large\n");
}
#else
#define set_DAC_MV_CNTL_dac_mv_agc_pulse_en(reg, dac_mv_agc_pulse_en) (reg)->bitfields.DAC_MV_AGC_PULSE_EN = dac_mv_agc_pulse_en
#define set_DAC_MV_CNTL_dac_mv_blank_en(reg, dac_mv_blank_en) (reg)->bitfields.DAC_MV_BLANK_EN = dac_mv_blank_en
#define set_DAC_MV_CNTL_dac_mv_bp_pulse_en(reg, dac_mv_bp_pulse_en) (reg)->bitfields.DAC_MV_BP_PULSE_EN = dac_mv_bp_pulse_en
#define set_DAC_MV_CNTL_dac_mv_agc_pulse_count(reg, dac_mv_agc_pulse_count) (reg)->bitfields.DAC_MV_AGC_PULSE_COUNT = dac_mv_agc_pulse_count
#define set_DAC_MV_CNTL_dac_mv_write_en(reg, dac_mv_write_en) (reg)->bitfields.DAC_MV_WRITE_EN = dac_mv_write_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_MV_AGC_PULSE_LINES regDAC_MV_AGC_PULSE_LINES;

#ifdef DEBUG
__inline void set_DAC_MV_AGC_PULSE_LINES_dac_mv_agc_vstart(regDAC_MV_AGC_PULSE_LINES *reg, unsigned int dac_mv_agc_vstart)
{
  reg->bitfields.DAC_MV_AGC_VSTART = dac_mv_agc_vstart;
  if (reg->bitfields.DAC_MV_AGC_VSTART != dac_mv_agc_vstart) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_AGC_PULSE_LINES::DAC_MV_AGC_VSTART data too large\n");
}
__inline void set_DAC_MV_AGC_PULSE_LINES_dac_mv_agc_vend(regDAC_MV_AGC_PULSE_LINES *reg, unsigned int dac_mv_agc_vend)
{
  reg->bitfields.DAC_MV_AGC_VEND = dac_mv_agc_vend;
  if (reg->bitfields.DAC_MV_AGC_VEND != dac_mv_agc_vend) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_AGC_PULSE_LINES::DAC_MV_AGC_VEND data too large\n");
}
#else
#define set_DAC_MV_AGC_PULSE_LINES_dac_mv_agc_vstart(reg, dac_mv_agc_vstart) (reg)->bitfields.DAC_MV_AGC_VSTART = dac_mv_agc_vstart
#define set_DAC_MV_AGC_PULSE_LINES_dac_mv_agc_vend(reg, dac_mv_agc_vend) (reg)->bitfields.DAC_MV_AGC_VEND = dac_mv_agc_vend

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_MV_AGC_PULSE_POS regDAC_MV_AGC_PULSE_POS;

#ifdef DEBUG
__inline void set_DAC_MV_AGC_PULSE_POS_dac_mv_pseudo_start(regDAC_MV_AGC_PULSE_POS *reg, unsigned int dac_mv_pseudo_start)
{
  reg->bitfields.DAC_MV_PSEUDO_START = dac_mv_pseudo_start;
  if (reg->bitfields.DAC_MV_PSEUDO_START != dac_mv_pseudo_start) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_AGC_PULSE_POS::DAC_MV_PSEUDO_START data too large\n");
}
__inline void set_DAC_MV_AGC_PULSE_POS_dac_mv_pseudo_space(regDAC_MV_AGC_PULSE_POS *reg, unsigned int dac_mv_pseudo_space)
{
  reg->bitfields.DAC_MV_PSEUDO_SPACE = dac_mv_pseudo_space;
  if (reg->bitfields.DAC_MV_PSEUDO_SPACE != dac_mv_pseudo_space) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_AGC_PULSE_POS::DAC_MV_PSEUDO_SPACE data too large\n");
}
#else
#define set_DAC_MV_AGC_PULSE_POS_dac_mv_pseudo_start(reg, dac_mv_pseudo_start) (reg)->bitfields.DAC_MV_PSEUDO_START = dac_mv_pseudo_start
#define set_DAC_MV_AGC_PULSE_POS_dac_mv_pseudo_space(reg, dac_mv_pseudo_space) (reg)->bitfields.DAC_MV_PSEUDO_SPACE = dac_mv_pseudo_space

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_MV_AGC_PULSE_WIDTH regDAC_MV_AGC_PULSE_WIDTH;

#ifdef DEBUG
__inline void set_DAC_MV_AGC_PULSE_WIDTH_dac_mv_agc_width(regDAC_MV_AGC_PULSE_WIDTH *reg, unsigned int dac_mv_agc_width)
{
  reg->bitfields.DAC_MV_AGC_WIDTH = dac_mv_agc_width;
  if (reg->bitfields.DAC_MV_AGC_WIDTH != dac_mv_agc_width) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_AGC_PULSE_WIDTH::DAC_MV_AGC_WIDTH data too large\n");
}
__inline void set_DAC_MV_AGC_PULSE_WIDTH_dac_mv_pseudo_width(regDAC_MV_AGC_PULSE_WIDTH *reg, unsigned int dac_mv_pseudo_width)
{
  reg->bitfields.DAC_MV_PSEUDO_WIDTH = dac_mv_pseudo_width;
  if (reg->bitfields.DAC_MV_PSEUDO_WIDTH != dac_mv_pseudo_width) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_AGC_PULSE_WIDTH::DAC_MV_PSEUDO_WIDTH data too large\n");
}
#else
#define set_DAC_MV_AGC_PULSE_WIDTH_dac_mv_agc_width(reg, dac_mv_agc_width) (reg)->bitfields.DAC_MV_AGC_WIDTH = dac_mv_agc_width
#define set_DAC_MV_AGC_PULSE_WIDTH_dac_mv_pseudo_width(reg, dac_mv_pseudo_width) (reg)->bitfields.DAC_MV_PSEUDO_WIDTH = dac_mv_pseudo_width

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_MV_AGC_PULSE_LEVELS regDAC_MV_AGC_PULSE_LEVELS;

#ifdef DEBUG
__inline void set_DAC_MV_AGC_PULSE_LEVELS_dac_mv_agc_level_max(regDAC_MV_AGC_PULSE_LEVELS *reg, unsigned int dac_mv_agc_level_max)
{
  reg->bitfields.DAC_MV_AGC_LEVEL_MAX = dac_mv_agc_level_max;
  if (reg->bitfields.DAC_MV_AGC_LEVEL_MAX != dac_mv_agc_level_max) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_AGC_PULSE_LEVELS::DAC_MV_AGC_LEVEL_MAX data too large\n");
}
__inline void set_DAC_MV_AGC_PULSE_LEVELS_dac_mv_agc_level_incr(regDAC_MV_AGC_PULSE_LEVELS *reg, unsigned int dac_mv_agc_level_incr)
{
  reg->bitfields.DAC_MV_AGC_LEVEL_INCR = dac_mv_agc_level_incr;
  if (reg->bitfields.DAC_MV_AGC_LEVEL_INCR != dac_mv_agc_level_incr) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_AGC_PULSE_LEVELS::DAC_MV_AGC_LEVEL_INCR data too large\n");
}
#else
#define set_DAC_MV_AGC_PULSE_LEVELS_dac_mv_agc_level_max(reg, dac_mv_agc_level_max) (reg)->bitfields.DAC_MV_AGC_LEVEL_MAX = dac_mv_agc_level_max
#define set_DAC_MV_AGC_PULSE_LEVELS_dac_mv_agc_level_incr(reg, dac_mv_agc_level_incr) (reg)->bitfields.DAC_MV_AGC_LEVEL_INCR = dac_mv_agc_level_incr

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_MV_AGC_CYCLE regDAC_MV_AGC_CYCLE;

#ifdef DEBUG
__inline void set_DAC_MV_AGC_CYCLE_dac_mv_agc_max_fields(regDAC_MV_AGC_CYCLE *reg, unsigned int dac_mv_agc_max_fields)
{
  reg->bitfields.DAC_MV_AGC_MAX_FIELDS = dac_mv_agc_max_fields;
  if (reg->bitfields.DAC_MV_AGC_MAX_FIELDS != dac_mv_agc_max_fields) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_AGC_CYCLE::DAC_MV_AGC_MAX_FIELDS data too large\n");
}
__inline void set_DAC_MV_AGC_CYCLE_dac_mv_agc_min_fields(regDAC_MV_AGC_CYCLE *reg, unsigned int dac_mv_agc_min_fields)
{
  reg->bitfields.DAC_MV_AGC_MIN_FIELDS = dac_mv_agc_min_fields;
  if (reg->bitfields.DAC_MV_AGC_MIN_FIELDS != dac_mv_agc_min_fields) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_AGC_CYCLE::DAC_MV_AGC_MIN_FIELDS data too large\n");
}
__inline void set_DAC_MV_AGC_CYCLE_dac_mv_agc_skew_fields(regDAC_MV_AGC_CYCLE *reg, unsigned int dac_mv_agc_skew_fields)
{
  reg->bitfields.DAC_MV_AGC_SKEW_FIELDS = dac_mv_agc_skew_fields;
  if (reg->bitfields.DAC_MV_AGC_SKEW_FIELDS != dac_mv_agc_skew_fields) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_AGC_CYCLE::DAC_MV_AGC_SKEW_FIELDS data too large\n");
}
#else
#define set_DAC_MV_AGC_CYCLE_dac_mv_agc_max_fields(reg, dac_mv_agc_max_fields) (reg)->bitfields.DAC_MV_AGC_MAX_FIELDS = dac_mv_agc_max_fields
#define set_DAC_MV_AGC_CYCLE_dac_mv_agc_min_fields(reg, dac_mv_agc_min_fields) (reg)->bitfields.DAC_MV_AGC_MIN_FIELDS = dac_mv_agc_min_fields
#define set_DAC_MV_AGC_CYCLE_dac_mv_agc_skew_fields(reg, dac_mv_agc_skew_fields) (reg)->bitfields.DAC_MV_AGC_SKEW_FIELDS = dac_mv_agc_skew_fields

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_MV_BLANK_LINES regDAC_MV_BLANK_LINES;

#ifdef DEBUG
__inline void set_DAC_MV_BLANK_LINES_dac_mv_blank_vstart(regDAC_MV_BLANK_LINES *reg, unsigned int dac_mv_blank_vstart)
{
  reg->bitfields.DAC_MV_BLANK_VSTART = dac_mv_blank_vstart;
  if (reg->bitfields.DAC_MV_BLANK_VSTART != dac_mv_blank_vstart) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_BLANK_LINES::DAC_MV_BLANK_VSTART data too large\n");
}
__inline void set_DAC_MV_BLANK_LINES_dac_mv_blank_vend(regDAC_MV_BLANK_LINES *reg, unsigned int dac_mv_blank_vend)
{
  reg->bitfields.DAC_MV_BLANK_VEND = dac_mv_blank_vend;
  if (reg->bitfields.DAC_MV_BLANK_VEND != dac_mv_blank_vend) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_BLANK_LINES::DAC_MV_BLANK_VEND data too large\n");
}
#else
#define set_DAC_MV_BLANK_LINES_dac_mv_blank_vstart(reg, dac_mv_blank_vstart) (reg)->bitfields.DAC_MV_BLANK_VSTART = dac_mv_blank_vstart
#define set_DAC_MV_BLANK_LINES_dac_mv_blank_vend(reg, dac_mv_blank_vend) (reg)->bitfields.DAC_MV_BLANK_VEND = dac_mv_blank_vend

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_MV_BLANK_LEVEL regDAC_MV_BLANK_LEVEL;

#ifdef DEBUG
__inline void set_DAC_MV_BLANK_LEVEL_dac_mv_blank_level(regDAC_MV_BLANK_LEVEL *reg, unsigned int dac_mv_blank_level)
{
  reg->bitfields.DAC_MV_BLANK_LEVEL = dac_mv_blank_level;
  if (reg->bitfields.DAC_MV_BLANK_LEVEL != dac_mv_blank_level) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_BLANK_LEVEL::DAC_MV_BLANK_LEVEL data too large\n");
}
#else
#define set_DAC_MV_BLANK_LEVEL_dac_mv_blank_level(reg, dac_mv_blank_level) (reg)->bitfields.DAC_MV_BLANK_LEVEL = dac_mv_blank_level

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_MV_BP_PULSE_LINES regDAC_MV_BP_PULSE_LINES;

#ifdef DEBUG
__inline void set_DAC_MV_BP_PULSE_LINES_dac_mv_bp_pulse_vstart(regDAC_MV_BP_PULSE_LINES *reg, unsigned int dac_mv_bp_pulse_vstart)
{
  reg->bitfields.DAC_MV_BP_PULSE_VSTART = dac_mv_bp_pulse_vstart;
  if (reg->bitfields.DAC_MV_BP_PULSE_VSTART != dac_mv_bp_pulse_vstart) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_BP_PULSE_LINES::DAC_MV_BP_PULSE_VSTART data too large\n");
}
__inline void set_DAC_MV_BP_PULSE_LINES_dac_mv_bp_pulse_vend(regDAC_MV_BP_PULSE_LINES *reg, unsigned int dac_mv_bp_pulse_vend)
{
  reg->bitfields.DAC_MV_BP_PULSE_VEND = dac_mv_bp_pulse_vend;
  if (reg->bitfields.DAC_MV_BP_PULSE_VEND != dac_mv_bp_pulse_vend) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_BP_PULSE_LINES::DAC_MV_BP_PULSE_VEND data too large\n");
}
#else
#define set_DAC_MV_BP_PULSE_LINES_dac_mv_bp_pulse_vstart(reg, dac_mv_bp_pulse_vstart) (reg)->bitfields.DAC_MV_BP_PULSE_VSTART = dac_mv_bp_pulse_vstart
#define set_DAC_MV_BP_PULSE_LINES_dac_mv_bp_pulse_vend(reg, dac_mv_bp_pulse_vend) (reg)->bitfields.DAC_MV_BP_PULSE_VEND = dac_mv_bp_pulse_vend

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_MV_BP_PULSE regDAC_MV_BP_PULSE;

#ifdef DEBUG
__inline void set_DAC_MV_BP_PULSE_dac_mv_bp_pulse_nom_level(regDAC_MV_BP_PULSE *reg, unsigned int dac_mv_bp_pulse_nom_level)
{
  reg->bitfields.DAC_MV_BP_PULSE_NOM_LEVEL = dac_mv_bp_pulse_nom_level;
  if (reg->bitfields.DAC_MV_BP_PULSE_NOM_LEVEL != dac_mv_bp_pulse_nom_level) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_BP_PULSE::DAC_MV_BP_PULSE_NOM_LEVEL data too large\n");
}
__inline void set_DAC_MV_BP_PULSE_dac_mv_bp_pulse_mod_level(regDAC_MV_BP_PULSE *reg, unsigned int dac_mv_bp_pulse_mod_level)
{
  reg->bitfields.DAC_MV_BP_PULSE_MOD_LEVEL = dac_mv_bp_pulse_mod_level;
  if (reg->bitfields.DAC_MV_BP_PULSE_MOD_LEVEL != dac_mv_bp_pulse_mod_level) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_BP_PULSE::DAC_MV_BP_PULSE_MOD_LEVEL data too large\n");
}
__inline void set_DAC_MV_BP_PULSE_dac_mv_bp_pulse_width(regDAC_MV_BP_PULSE *reg, unsigned int dac_mv_bp_pulse_width)
{
  reg->bitfields.DAC_MV_BP_PULSE_WIDTH = dac_mv_bp_pulse_width;
  if (reg->bitfields.DAC_MV_BP_PULSE_WIDTH != dac_mv_bp_pulse_width) HSLDPF(E_ERROR_MESSAGE,"DAC_MV_BP_PULSE::DAC_MV_BP_PULSE_WIDTH data too large\n");
}
#else
#define set_DAC_MV_BP_PULSE_dac_mv_bp_pulse_nom_level(reg, dac_mv_bp_pulse_nom_level) (reg)->bitfields.DAC_MV_BP_PULSE_NOM_LEVEL = dac_mv_bp_pulse_nom_level
#define set_DAC_MV_BP_PULSE_dac_mv_bp_pulse_mod_level(reg, dac_mv_bp_pulse_mod_level) (reg)->bitfields.DAC_MV_BP_PULSE_MOD_LEVEL = dac_mv_bp_pulse_mod_level
#define set_DAC_MV_BP_PULSE_dac_mv_bp_pulse_width(reg, dac_mv_bp_pulse_width) (reg)->bitfields.DAC_MV_BP_PULSE_WIDTH = dac_mv_bp_pulse_width

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_CGMS_LINES regDAC_CGMS_LINES;

#ifdef DEBUG
__inline void set_DAC_CGMS_LINES_dac_cgms_vstart(regDAC_CGMS_LINES *reg, unsigned int dac_cgms_vstart)
{
  reg->bitfields.DAC_CGMS_VSTART = dac_cgms_vstart;
  if (reg->bitfields.DAC_CGMS_VSTART != dac_cgms_vstart) HSLDPF(E_ERROR_MESSAGE,"DAC_CGMS_LINES::DAC_CGMS_VSTART data too large\n");
}
__inline void set_DAC_CGMS_LINES_dac_cgms_vend(regDAC_CGMS_LINES *reg, unsigned int dac_cgms_vend)
{
  reg->bitfields.DAC_CGMS_VEND = dac_cgms_vend;
  if (reg->bitfields.DAC_CGMS_VEND != dac_cgms_vend) HSLDPF(E_ERROR_MESSAGE,"DAC_CGMS_LINES::DAC_CGMS_VEND data too large\n");
}
__inline void set_DAC_CGMS_LINES_dac_cgms_rb_en(regDAC_CGMS_LINES *reg, unsigned int dac_cgms_rb_en)
{
  reg->bitfields.DAC_CGMS_RB_EN = dac_cgms_rb_en;
  if (reg->bitfields.DAC_CGMS_RB_EN != dac_cgms_rb_en) HSLDPF(E_ERROR_MESSAGE,"DAC_CGMS_LINES::DAC_CGMS_RB_EN data too large\n");
}
__inline void set_DAC_CGMS_LINES_dac_cgms_yg_en(regDAC_CGMS_LINES *reg, unsigned int dac_cgms_yg_en)
{
  reg->bitfields.DAC_CGMS_YG_EN = dac_cgms_yg_en;
  if (reg->bitfields.DAC_CGMS_YG_EN != dac_cgms_yg_en) HSLDPF(E_ERROR_MESSAGE,"DAC_CGMS_LINES::DAC_CGMS_YG_EN data too large\n");
}
#else
#define set_DAC_CGMS_LINES_dac_cgms_vstart(reg, dac_cgms_vstart) (reg)->bitfields.DAC_CGMS_VSTART = dac_cgms_vstart
#define set_DAC_CGMS_LINES_dac_cgms_vend(reg, dac_cgms_vend) (reg)->bitfields.DAC_CGMS_VEND = dac_cgms_vend
#define set_DAC_CGMS_LINES_dac_cgms_rb_en(reg, dac_cgms_rb_en) (reg)->bitfields.DAC_CGMS_RB_EN = dac_cgms_rb_en
#define set_DAC_CGMS_LINES_dac_cgms_yg_en(reg, dac_cgms_yg_en) (reg)->bitfields.DAC_CGMS_YG_EN = dac_cgms_yg_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_CGMS_TIMING regDAC_CGMS_TIMING;

#ifdef DEBUG
__inline void set_DAC_CGMS_TIMING_dac_cgms_width(regDAC_CGMS_TIMING *reg, unsigned int dac_cgms_width)
{
  reg->bitfields.DAC_CGMS_WIDTH = dac_cgms_width;
  if (reg->bitfields.DAC_CGMS_WIDTH != dac_cgms_width) HSLDPF(E_ERROR_MESSAGE,"DAC_CGMS_TIMING::DAC_CGMS_WIDTH data too large\n");
}
__inline void set_DAC_CGMS_TIMING_dac_cgms_hstart(regDAC_CGMS_TIMING *reg, unsigned int dac_cgms_hstart)
{
  reg->bitfields.DAC_CGMS_HSTART = dac_cgms_hstart;
  if (reg->bitfields.DAC_CGMS_HSTART != dac_cgms_hstart) HSLDPF(E_ERROR_MESSAGE,"DAC_CGMS_TIMING::DAC_CGMS_HSTART data too large\n");
}
__inline void set_DAC_CGMS_TIMING_dac_cgms_1_level(regDAC_CGMS_TIMING *reg, unsigned int dac_cgms_1_level)
{
  reg->bitfields.DAC_CGMS_1_LEVEL = dac_cgms_1_level;
  if (reg->bitfields.DAC_CGMS_1_LEVEL != dac_cgms_1_level) HSLDPF(E_ERROR_MESSAGE,"DAC_CGMS_TIMING::DAC_CGMS_1_LEVEL data too large\n");
}
#else
#define set_DAC_CGMS_TIMING_dac_cgms_width(reg, dac_cgms_width) (reg)->bitfields.DAC_CGMS_WIDTH = dac_cgms_width
#define set_DAC_CGMS_TIMING_dac_cgms_hstart(reg, dac_cgms_hstart) (reg)->bitfields.DAC_CGMS_HSTART = dac_cgms_hstart
#define set_DAC_CGMS_TIMING_dac_cgms_1_level(reg, dac_cgms_1_level) (reg)->bitfields.DAC_CGMS_1_LEVEL = dac_cgms_1_level

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union DAC_CGMS_DATA regDAC_CGMS_DATA;

#ifdef DEBUG
__inline void set_DAC_CGMS_DATA_dac_cgms_data(regDAC_CGMS_DATA *reg, unsigned int dac_cgms_data)
{
  reg->bitfields.DAC_CGMS_DATA = dac_cgms_data;
  if (reg->bitfields.DAC_CGMS_DATA != dac_cgms_data) HSLDPF(E_ERROR_MESSAGE,"DAC_CGMS_DATA::DAC_CGMS_DATA data too large\n");
}
__inline void set_DAC_CGMS_DATA_dac_cgms_bits(regDAC_CGMS_DATA *reg, unsigned int dac_cgms_bits)
{
  reg->bitfields.DAC_CGMS_BITS = dac_cgms_bits;
  if (reg->bitfields.DAC_CGMS_BITS != dac_cgms_bits) HSLDPF(E_ERROR_MESSAGE,"DAC_CGMS_DATA::DAC_CGMS_BITS data too large\n");
}
__inline void set_DAC_CGMS_DATA_dac_cgms_data_pending(regDAC_CGMS_DATA *reg, unsigned int dac_cgms_data_pending)
{
  reg->bitfields.DAC_CGMS_DATA_PENDING = dac_cgms_data_pending;
  if (reg->bitfields.DAC_CGMS_DATA_PENDING != dac_cgms_data_pending) HSLDPF(E_ERROR_MESSAGE,"DAC_CGMS_DATA::DAC_CGMS_DATA_PENDING data too large\n");
}
#else
#define set_DAC_CGMS_DATA_dac_cgms_data(reg, dac_cgms_data) (reg)->bitfields.DAC_CGMS_DATA = dac_cgms_data
#define set_DAC_CGMS_DATA_dac_cgms_bits(reg, dac_cgms_bits) (reg)->bitfields.DAC_CGMS_BITS = dac_cgms_bits
#define set_DAC_CGMS_DATA_dac_cgms_data_pending(reg, dac_cgms_data_pending) (reg)->bitfields.DAC_CGMS_DATA_PENDING = dac_cgms_data_pending

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union HDCP_DEBUG_R2 regHDCP_DEBUG_R2;

#ifdef DEBUG
__inline void set_HDCP_DEBUG_R2_hdcp_debug_en(regHDCP_DEBUG_R2 *reg, unsigned int hdcp_debug_en)
{
  reg->bitfields.HDCP_DEBUG_EN = hdcp_debug_en;
  if (reg->bitfields.HDCP_DEBUG_EN != hdcp_debug_en) HSLDPF(E_ERROR_MESSAGE,"HDCP_DEBUG_R2::HDCP_DEBUG_EN data too large\n");
}
__inline void set_HDCP_DEBUG_R2_i2c_cntl_regs_affect_hdcp_i2c(regHDCP_DEBUG_R2 *reg, unsigned int i2c_cntl_regs_affect_hdcp_i2c)
{
  reg->bitfields.I2C_CNTL_REGS_AFFECT_HDCP_I2C = i2c_cntl_regs_affect_hdcp_i2c;
  if (reg->bitfields.I2C_CNTL_REGS_AFFECT_HDCP_I2C != i2c_cntl_regs_affect_hdcp_i2c) HSLDPF(E_ERROR_MESSAGE,"HDCP_DEBUG_R2::I2C_CNTL_REGS_AFFECT_HDCP_I2C data too large\n");
}
__inline void set_HDCP_DEBUG_R2_sw_can_queue_i2c_go(regHDCP_DEBUG_R2 *reg, unsigned int sw_can_queue_i2c_go)
{
  reg->bitfields.SW_CAN_QUEUE_I2C_GO = sw_can_queue_i2c_go;
  if (reg->bitfields.SW_CAN_QUEUE_I2C_GO != sw_can_queue_i2c_go) HSLDPF(E_ERROR_MESSAGE,"HDCP_DEBUG_R2::SW_CAN_QUEUE_I2C_GO data too large\n");
}
__inline void set_HDCP_DEBUG_R2_use_hdcp_i2c_short_reads(regHDCP_DEBUG_R2 *reg, unsigned int use_hdcp_i2c_short_reads)
{
  reg->bitfields.USE_HDCP_I2C_SHORT_READS = use_hdcp_i2c_short_reads;
  if (reg->bitfields.USE_HDCP_I2C_SHORT_READS != use_hdcp_i2c_short_reads) HSLDPF(E_ERROR_MESSAGE,"HDCP_DEBUG_R2::USE_HDCP_I2C_SHORT_READS data too large\n");
}
__inline void set_HDCP_DEBUG_R2_hdcp_mode(regHDCP_DEBUG_R2 *reg, unsigned int hdcp_mode)
{
  reg->bitfields.HDCP_MODE = hdcp_mode;
  if (reg->bitfields.HDCP_MODE != hdcp_mode) HSLDPF(E_ERROR_MESSAGE,"HDCP_DEBUG_R2::HDCP_MODE data too large\n");
}
__inline void set_HDCP_DEBUG_R2_hdcp_hotplug_sel_bypass_en(regHDCP_DEBUG_R2 *reg, unsigned int hdcp_hotplug_sel_bypass_en)
{
  reg->bitfields.HDCP_HOTPLUG_SEL_BYPASS_EN = hdcp_hotplug_sel_bypass_en;
  if (reg->bitfields.HDCP_HOTPLUG_SEL_BYPASS_EN != hdcp_hotplug_sel_bypass_en) HSLDPF(E_ERROR_MESSAGE,"HDCP_DEBUG_R2::HDCP_HOTPLUG_SEL_BYPASS_EN data too large\n");
}
__inline void set_HDCP_DEBUG_R2_hdcp_hotplug_select(regHDCP_DEBUG_R2 *reg, unsigned int hdcp_hotplug_select)
{
  reg->bitfields.HDCP_HOTPLUG_SELECT = hdcp_hotplug_select;
  if (reg->bitfields.HDCP_HOTPLUG_SELECT != hdcp_hotplug_select) HSLDPF(E_ERROR_MESSAGE,"HDCP_DEBUG_R2::HDCP_HOTPLUG_SELECT data too large\n");
}
__inline void set_HDCP_DEBUG_R2_hdcp_debug_bit7(regHDCP_DEBUG_R2 *reg, unsigned int hdcp_debug_bit7)
{
  reg->bitfields.HDCP_DEBUG_BIT7 = hdcp_debug_bit7;
  if (reg->bitfields.HDCP_DEBUG_BIT7 != hdcp_debug_bit7) HSLDPF(E_ERROR_MESSAGE,"HDCP_DEBUG_R2::HDCP_DEBUG_BIT7 data too large\n");
}
__inline void set_HDCP_DEBUG_R2_hdcp_debug_addr(regHDCP_DEBUG_R2 *reg, unsigned int hdcp_debug_addr)
{
  reg->bitfields.HDCP_DEBUG_ADDR = hdcp_debug_addr;
  if (reg->bitfields.HDCP_DEBUG_ADDR != hdcp_debug_addr) HSLDPF(E_ERROR_MESSAGE,"HDCP_DEBUG_R2::HDCP_DEBUG_ADDR data too large\n");
}
__inline void set_HDCP_DEBUG_R2_hdcp_debug_data(regHDCP_DEBUG_R2 *reg, unsigned int hdcp_debug_data)
{
  reg->bitfields.HDCP_DEBUG_DATA = hdcp_debug_data;
  if (reg->bitfields.HDCP_DEBUG_DATA != hdcp_debug_data) HSLDPF(E_ERROR_MESSAGE,"HDCP_DEBUG_R2::HDCP_DEBUG_DATA data too large\n");
}
#else
#define set_HDCP_DEBUG_R2_hdcp_debug_en(reg, hdcp_debug_en) (reg)->bitfields.HDCP_DEBUG_EN = hdcp_debug_en
#define set_HDCP_DEBUG_R2_i2c_cntl_regs_affect_hdcp_i2c(reg, i2c_cntl_regs_affect_hdcp_i2c) (reg)->bitfields.I2C_CNTL_REGS_AFFECT_HDCP_I2C = i2c_cntl_regs_affect_hdcp_i2c
#define set_HDCP_DEBUG_R2_sw_can_queue_i2c_go(reg, sw_can_queue_i2c_go) (reg)->bitfields.SW_CAN_QUEUE_I2C_GO = sw_can_queue_i2c_go
#define set_HDCP_DEBUG_R2_use_hdcp_i2c_short_reads(reg, use_hdcp_i2c_short_reads) (reg)->bitfields.USE_HDCP_I2C_SHORT_READS = use_hdcp_i2c_short_reads
#define set_HDCP_DEBUG_R2_hdcp_mode(reg, hdcp_mode) (reg)->bitfields.HDCP_MODE = hdcp_mode
#define set_HDCP_DEBUG_R2_hdcp_hotplug_sel_bypass_en(reg, hdcp_hotplug_sel_bypass_en) (reg)->bitfields.HDCP_HOTPLUG_SEL_BYPASS_EN = hdcp_hotplug_sel_bypass_en
#define set_HDCP_DEBUG_R2_hdcp_hotplug_select(reg, hdcp_hotplug_select) (reg)->bitfields.HDCP_HOTPLUG_SELECT = hdcp_hotplug_select
#define set_HDCP_DEBUG_R2_hdcp_debug_bit7(reg, hdcp_debug_bit7) (reg)->bitfields.HDCP_DEBUG_BIT7 = hdcp_debug_bit7
#define set_HDCP_DEBUG_R2_hdcp_debug_addr(reg, hdcp_debug_addr) (reg)->bitfields.HDCP_DEBUG_ADDR = hdcp_debug_addr
#define set_HDCP_DEBUG_R2_hdcp_debug_data(reg, hdcp_debug_data) (reg)->bitfields.HDCP_DEBUG_DATA = hdcp_debug_data

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CLOCK_CNTL_INDEX regCLOCK_CNTL_INDEX;

#ifdef DEBUG
__inline void set_CLOCK_CNTL_INDEX_pll_addr_r2(regCLOCK_CNTL_INDEX *reg, unsigned int pll_addr_r2)
{
  reg->bitfields.PLL_ADDR_R2 = pll_addr_r2;
  if (reg->bitfields.PLL_ADDR_R2 != pll_addr_r2) HSLDPF(E_ERROR_MESSAGE,"CLOCK_CNTL_INDEX::PLL_ADDR_R2 data too large\n");
}
__inline void set_CLOCK_CNTL_INDEX_pll_wr_en(regCLOCK_CNTL_INDEX *reg, unsigned int pll_wr_en)
{
  reg->bitfields.PLL_WR_EN = pll_wr_en;
  if (reg->bitfields.PLL_WR_EN != pll_wr_en) HSLDPF(E_ERROR_MESSAGE,"CLOCK_CNTL_INDEX::PLL_WR_EN data too large\n");
}
__inline void set_CLOCK_CNTL_INDEX_ppll_div_sel(regCLOCK_CNTL_INDEX *reg, unsigned int ppll_div_sel)
{
  reg->bitfields.PPLL_DIV_SEL = ppll_div_sel;
  if (reg->bitfields.PPLL_DIV_SEL != ppll_div_sel) HSLDPF(E_ERROR_MESSAGE,"CLOCK_CNTL_INDEX::PPLL_DIV_SEL data too large\n");
}
#else
#define set_CLOCK_CNTL_INDEX_pll_addr_r2(reg, pll_addr_r2) (reg)->bitfields.PLL_ADDR_R2 = pll_addr_r2
#define set_CLOCK_CNTL_INDEX_pll_wr_en(reg, pll_wr_en) (reg)->bitfields.PLL_WR_EN = pll_wr_en
#define set_CLOCK_CNTL_INDEX_ppll_div_sel(reg, ppll_div_sel) (reg)->bitfields.PPLL_DIV_SEL = ppll_div_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union PLL_TEST_CNTL regPLL_TEST_CNTL;

#ifdef DEBUG
__inline void set_PLL_TEST_CNTL_tst_src_sel_r2(regPLL_TEST_CNTL *reg, unsigned int tst_src_sel_r2)
{
  reg->bitfields.TST_SRC_SEL_R2 = tst_src_sel_r2;
  if (reg->bitfields.TST_SRC_SEL_R2 != tst_src_sel_r2) HSLDPF(E_ERROR_MESSAGE,"PLL_TEST_CNTL::TST_SRC_SEL_R2 data too large\n");
}
__inline void set_PLL_TEST_CNTL_tst_src_inv(regPLL_TEST_CNTL *reg, unsigned int tst_src_inv)
{
  reg->bitfields.TST_SRC_INV = tst_src_inv;
  if (reg->bitfields.TST_SRC_INV != tst_src_inv) HSLDPF(E_ERROR_MESSAGE,"PLL_TEST_CNTL::TST_SRC_INV data too large\n");
}
__inline void set_PLL_TEST_CNTL_tst_dividers(regPLL_TEST_CNTL *reg, unsigned int tst_dividers)
{
  reg->bitfields.TST_DIVIDERS = tst_dividers;
  if (reg->bitfields.TST_DIVIDERS != tst_dividers) HSLDPF(E_ERROR_MESSAGE,"PLL_TEST_CNTL::TST_DIVIDERS data too large\n");
}
__inline void set_PLL_TEST_CNTL_pll_mask_read_b(regPLL_TEST_CNTL *reg, unsigned int pll_mask_read_b)
{
  reg->bitfields.PLL_MASK_READ_B = pll_mask_read_b;
  if (reg->bitfields.PLL_MASK_READ_B != pll_mask_read_b) HSLDPF(E_ERROR_MESSAGE,"PLL_TEST_CNTL::PLL_MASK_READ_B data too large\n");
}
__inline void set_PLL_TEST_CNTL_testclk_mux_sel(regPLL_TEST_CNTL *reg, unsigned int testclk_mux_sel)
{
  reg->bitfields.TESTCLK_MUX_SEL = testclk_mux_sel;
  if (reg->bitfields.TESTCLK_MUX_SEL != testclk_mux_sel) HSLDPF(E_ERROR_MESSAGE,"PLL_TEST_CNTL::TESTCLK_MUX_SEL data too large\n");
}
__inline void set_PLL_TEST_CNTL_analog_mon_r2(regPLL_TEST_CNTL *reg, unsigned int analog_mon_r2)
{
  reg->bitfields.ANALOG_MON_R2 = analog_mon_r2;
  if (reg->bitfields.ANALOG_MON_R2 != analog_mon_r2) HSLDPF(E_ERROR_MESSAGE,"PLL_TEST_CNTL::ANALOG_MON_R2 data too large\n");
}
__inline void set_PLL_TEST_CNTL_test_count(regPLL_TEST_CNTL *reg, unsigned int test_count)
{
  reg->bitfields.TEST_COUNT = test_count;
  if (reg->bitfields.TEST_COUNT != test_count) HSLDPF(E_ERROR_MESSAGE,"PLL_TEST_CNTL::TEST_COUNT data too large\n");
}
#else
#define set_PLL_TEST_CNTL_tst_src_sel_r2(reg, tst_src_sel_r2) (reg)->bitfields.TST_SRC_SEL_R2 = tst_src_sel_r2
#define set_PLL_TEST_CNTL_tst_src_inv(reg, tst_src_inv) (reg)->bitfields.TST_SRC_INV = tst_src_inv
#define set_PLL_TEST_CNTL_tst_dividers(reg, tst_dividers) (reg)->bitfields.TST_DIVIDERS = tst_dividers
#define set_PLL_TEST_CNTL_pll_mask_read_b(reg, pll_mask_read_b) (reg)->bitfields.PLL_MASK_READ_B = pll_mask_read_b
#define set_PLL_TEST_CNTL_testclk_mux_sel(reg, testclk_mux_sel) (reg)->bitfields.TESTCLK_MUX_SEL = testclk_mux_sel
#define set_PLL_TEST_CNTL_analog_mon_r2(reg, analog_mon_r2) (reg)->bitfields.ANALOG_MON_R2 = analog_mon_r2
#define set_PLL_TEST_CNTL_test_count(reg, test_count) (reg)->bitfields.TEST_COUNT = test_count

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union r200DAC_CNTL2 regr200DAC_CNTL2;

#ifdef DEBUG
__inline void set_r200DAC_CNTL2_palette_access_cntl(regr200DAC_CNTL2 *reg, unsigned int palette_access_cntl)
{
  reg->bitfields.PALETTE_ACCESS_CNTL = palette_access_cntl;
  if (reg->bitfields.PALETTE_ACCESS_CNTL != palette_access_cntl) HSLDPF(E_ERROR_MESSAGE,"r200DAC_CNTL2::PALETTE_ACCESS_CNTL data too large\n");
}
__inline void set_r200DAC_CNTL2_palette_autofill_primary_w(regr200DAC_CNTL2 *reg, unsigned int palette_autofill_primary_w)
{
  reg->bitfields.PALETTE_AUTOFILL_PRIMARY_W = palette_autofill_primary_w;
  if (reg->bitfields.PALETTE_AUTOFILL_PRIMARY_W != palette_autofill_primary_w) HSLDPF(E_ERROR_MESSAGE,"r200DAC_CNTL2::PALETTE_AUTOFILL_PRIMARY_W data too large\n");
}
__inline void set_r200DAC_CNTL2_palette_autofill_secondary_w(regr200DAC_CNTL2 *reg, unsigned int palette_autofill_secondary_w)
{
  reg->bitfields.PALETTE_AUTOFILL_SECONDARY_W = palette_autofill_secondary_w;
  if (reg->bitfields.PALETTE_AUTOFILL_SECONDARY_W != palette_autofill_secondary_w) HSLDPF(E_ERROR_MESSAGE,"r200DAC_CNTL2::PALETTE_AUTOFILL_SECONDARY_W data too large\n");
}
__inline void set_r200DAC_CNTL2_dac2_expand_mode(regr200DAC_CNTL2 *reg, unsigned int dac2_expand_mode)
{
  reg->bitfields.DAC2_EXPAND_MODE = dac2_expand_mode;
  if (reg->bitfields.DAC2_EXPAND_MODE != dac2_expand_mode) HSLDPF(E_ERROR_MESSAGE,"r200DAC_CNTL2::DAC2_EXPAND_MODE data too large\n");
}
__inline void set_r200DAC_CNTL2_dac2_lut_counter_limit(regr200DAC_CNTL2 *reg, unsigned int dac2_lut_counter_limit)
{
  reg->bitfields.DAC2_LUT_COUNTER_LIMIT = dac2_lut_counter_limit;
  if (reg->bitfields.DAC2_LUT_COUNTER_LIMIT != dac2_lut_counter_limit) HSLDPF(E_ERROR_MESSAGE,"r200DAC_CNTL2::DAC2_LUT_COUNTER_LIMIT data too large\n");
}
#else
#define set_r200DAC_CNTL2_palette_access_cntl(reg, palette_access_cntl) (reg)->bitfields.PALETTE_ACCESS_CNTL = palette_access_cntl
#define set_r200DAC_CNTL2_palette_autofill_primary_w(reg, palette_autofill_primary_w) (reg)->bitfields.PALETTE_AUTOFILL_PRIMARY_W = palette_autofill_primary_w
#define set_r200DAC_CNTL2_palette_autofill_secondary_w(reg, palette_autofill_secondary_w) (reg)->bitfields.PALETTE_AUTOFILL_SECONDARY_W = palette_autofill_secondary_w
#define set_r200DAC_CNTL2_dac2_expand_mode(reg, dac2_expand_mode) (reg)->bitfields.DAC2_EXPAND_MODE = dac2_expand_mode
#define set_r200DAC_CNTL2_dac2_lut_counter_limit(reg, dac2_lut_counter_limit) (reg)->bitfields.DAC2_LUT_COUNTER_LIMIT = dac2_lut_counter_limit

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VAP_CNTL regSE_VAP_CNTL;

#ifdef DEBUG
__inline void set_SE_VAP_CNTL_tcl_ena(regSE_VAP_CNTL *reg, unsigned int tcl_ena)
{
  reg->bitfields.TCL_ENA = tcl_ena;
  if (reg->bitfields.TCL_ENA != tcl_ena) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_CNTL::TCL_ENA data too large\n");
}
__inline void set_SE_VAP_CNTL_hos_ena(regSE_VAP_CNTL *reg, unsigned int hos_ena)
{
  reg->bitfields.HOS_ENA = hos_ena;
  if (reg->bitfields.HOS_ENA != hos_ena) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_CNTL::HOS_ENA data too large\n");
}
__inline void set_SE_VAP_CNTL_prog_vtx_shader_ena(regSE_VAP_CNTL *reg, unsigned int prog_vtx_shader_ena)
{
  reg->bitfields.PROG_VTX_SHADER_ENA = prog_vtx_shader_ena;
  if (reg->bitfields.PROG_VTX_SHADER_ENA != prog_vtx_shader_ena) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_CNTL::PROG_VTX_SHADER_ENA data too large\n");
}
__inline void set_SE_VAP_CNTL_per_vtx_mtx_sel_ena(regSE_VAP_CNTL *reg, unsigned int per_vtx_mtx_sel_ena)
{
  reg->bitfields.PER_VTX_MTX_SEL_ENA = per_vtx_mtx_sel_ena;
  if (reg->bitfields.PER_VTX_MTX_SEL_ENA != per_vtx_mtx_sel_ena) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_CNTL::PER_VTX_MTX_SEL_ENA data too large\n");
}
__inline void set_SE_VAP_CNTL_single_buf_state_ena(regSE_VAP_CNTL *reg, unsigned int single_buf_state_ena)
{
  reg->bitfields.SINGLE_BUF_STATE_ENA = single_buf_state_ena;
  if (reg->bitfields.SINGLE_BUF_STATE_ENA != single_buf_state_ena) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_CNTL::SINGLE_BUF_STATE_ENA data too large\n");
}
__inline void set_SE_VAP_CNTL_force_w_to_one(regSE_VAP_CNTL *reg, unsigned int force_w_to_one)
{
  reg->bitfields.FORCE_W_TO_ONE = force_w_to_one;
  if (reg->bitfields.FORCE_W_TO_ONE != force_w_to_one) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_CNTL::FORCE_W_TO_ONE data too large\n");
}
__inline void set_SE_VAP_CNTL_d3d_tex_default(regSE_VAP_CNTL *reg, unsigned int d3d_tex_default)
{
  reg->bitfields.D3D_TEX_DEFAULT = d3d_tex_default;
  if (reg->bitfields.D3D_TEX_DEFAULT != d3d_tex_default) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_CNTL::D3D_TEX_DEFAULT data too large\n");
}
__inline void set_SE_VAP_CNTL_vf_max_vtx_num(regSE_VAP_CNTL *reg, unsigned int vf_max_vtx_num)
{
  reg->bitfields.VF_MAX_VTX_NUM = vf_max_vtx_num;
  if (reg->bitfields.VF_MAX_VTX_NUM != vf_max_vtx_num) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_CNTL::VF_MAX_VTX_NUM data too large\n");
}
__inline void set_SE_VAP_CNTL_dx_clip_space_def(regSE_VAP_CNTL *reg, unsigned int dx_clip_space_def)
{
  reg->bitfields.DX_CLIP_SPACE_DEF = dx_clip_space_def;
  if (reg->bitfields.DX_CLIP_SPACE_DEF != dx_clip_space_def) HSLDPF(E_ERROR_MESSAGE,"SE_VAP_CNTL::DX_CLIP_SPACE_DEF data too large\n");
}
#else
#define set_SE_VAP_CNTL_tcl_ena(reg, tcl_ena) (reg)->bitfields.TCL_ENA = tcl_ena
#define set_SE_VAP_CNTL_hos_ena(reg, hos_ena) (reg)->bitfields.HOS_ENA = hos_ena
#define set_SE_VAP_CNTL_prog_vtx_shader_ena(reg, prog_vtx_shader_ena) (reg)->bitfields.PROG_VTX_SHADER_ENA = prog_vtx_shader_ena
#define set_SE_VAP_CNTL_per_vtx_mtx_sel_ena(reg, per_vtx_mtx_sel_ena) (reg)->bitfields.PER_VTX_MTX_SEL_ENA = per_vtx_mtx_sel_ena
#define set_SE_VAP_CNTL_single_buf_state_ena(reg, single_buf_state_ena) (reg)->bitfields.SINGLE_BUF_STATE_ENA = single_buf_state_ena
#define set_SE_VAP_CNTL_force_w_to_one(reg, force_w_to_one) (reg)->bitfields.FORCE_W_TO_ONE = force_w_to_one
#define set_SE_VAP_CNTL_d3d_tex_default(reg, d3d_tex_default) (reg)->bitfields.D3D_TEX_DEFAULT = d3d_tex_default
#define set_SE_VAP_CNTL_vf_max_vtx_num(reg, vf_max_vtx_num) (reg)->bitfields.VF_MAX_VTX_NUM = vf_max_vtx_num
#define set_SE_VAP_CNTL_dx_clip_space_def(reg, dx_clip_space_def) (reg)->bitfields.DX_CLIP_SPACE_DEF = dx_clip_space_def

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_VTX_NUM_ARRAYS regSE_VTX_NUM_ARRAYS;

#ifdef DEBUG
__inline void set_SE_VTX_NUM_ARRAYS_vtx_num_arrays(regSE_VTX_NUM_ARRAYS *reg, unsigned int vtx_num_arrays)
{
  reg->bitfields.VTX_NUM_ARRAYS = vtx_num_arrays;
  if (reg->bitfields.VTX_NUM_ARRAYS != vtx_num_arrays) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_NUM_ARRAYS::VTX_NUM_ARRAYS data too large\n");
}
__inline void set_SE_VTX_NUM_ARRAYS_vc_pfetch(regSE_VTX_NUM_ARRAYS *reg, unsigned int vc_pfetch)
{
  reg->bitfields.VC_PFETCH = vc_pfetch;
  if (reg->bitfields.VC_PFETCH != vc_pfetch) HSLDPF(E_ERROR_MESSAGE,"SE_VTX_NUM_ARRAYS::VC_PFETCH data too large\n");
}
#else
#define set_SE_VTX_NUM_ARRAYS_vtx_num_arrays(reg, vtx_num_arrays) (reg)->bitfields.VTX_NUM_ARRAYS = vtx_num_arrays
#define set_SE_VTX_NUM_ARRAYS_vc_pfetch(reg, vc_pfetch) (reg)->bitfields.VC_PFETCH = vc_pfetch

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_HOS_CNTL_0 regSE_HOS_CNTL_0;

#ifdef DEBUG
__inline void set_SE_HOS_CNTL_0_hos_normalize_normals(regSE_HOS_CNTL_0 *reg, unsigned int hos_normalize_normals)
{
  reg->bitfields.HOS_NORMALIZE_NORMALS = hos_normalize_normals;
  if (reg->bitfields.HOS_NORMALIZE_NORMALS != hos_normalize_normals) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_CNTL_0::HOS_NORMALIZE_NORMALS data too large\n");
}
__inline void set_SE_HOS_CNTL_0_hos_homogenize_position(regSE_HOS_CNTL_0 *reg, unsigned int hos_homogenize_position)
{
  reg->bitfields.HOS_HOMOGENIZE_POSITION = hos_homogenize_position;
  if (reg->bitfields.HOS_HOMOGENIZE_POSITION != hos_homogenize_position) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_CNTL_0::HOS_HOMOGENIZE_POSITION data too large\n");
}
__inline void set_SE_HOS_CNTL_0_hos_tess_lvl(regSE_HOS_CNTL_0 *reg, unsigned int hos_tess_lvl)
{
  reg->bitfields.HOS_TESS_LVL = hos_tess_lvl;
  if (reg->bitfields.HOS_TESS_LVL != hos_tess_lvl) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_CNTL_0::HOS_TESS_LVL data too large\n");
}
__inline void set_SE_HOS_CNTL_0_pos_vector_loc(regSE_HOS_CNTL_0 *reg, unsigned int pos_vector_loc)
{
  reg->bitfields.POS_VECTOR_LOC = pos_vector_loc;
  if (reg->bitfields.POS_VECTOR_LOC != pos_vector_loc) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_CNTL_0::POS_VECTOR_LOC data too large\n");
}
__inline void set_SE_HOS_CNTL_0_norm_vector_loc(regSE_HOS_CNTL_0 *reg, unsigned int norm_vector_loc)
{
  reg->bitfields.NORM_VECTOR_LOC = norm_vector_loc;
  if (reg->bitfields.NORM_VECTOR_LOC != norm_vector_loc) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_CNTL_0::NORM_VECTOR_LOC data too large\n");
}
__inline void set_SE_HOS_CNTL_0_cyl_wrap_cntl_0(regSE_HOS_CNTL_0 *reg, unsigned int cyl_wrap_cntl_0)
{
  reg->bitfields.CYL_WRAP_CNTL_0 = cyl_wrap_cntl_0;
  if (reg->bitfields.CYL_WRAP_CNTL_0 != cyl_wrap_cntl_0) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_CNTL_0::CYL_WRAP_CNTL_0 data too large\n");
}
__inline void set_SE_HOS_CNTL_0_cyl_wrap_cntl_1(regSE_HOS_CNTL_0 *reg, unsigned int cyl_wrap_cntl_1)
{
  reg->bitfields.CYL_WRAP_CNTL_1 = cyl_wrap_cntl_1;
  if (reg->bitfields.CYL_WRAP_CNTL_1 != cyl_wrap_cntl_1) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_CNTL_0::CYL_WRAP_CNTL_1 data too large\n");
}
__inline void set_SE_HOS_CNTL_0_disp_map_pos_ena(regSE_HOS_CNTL_0 *reg, unsigned int disp_map_pos_ena)
{
  reg->bitfields.DISP_MAP_POS_ENA = disp_map_pos_ena;
  if (reg->bitfields.DISP_MAP_POS_ENA != disp_map_pos_ena) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_CNTL_0::DISP_MAP_POS_ENA data too large\n");
}
__inline void set_SE_HOS_CNTL_0_disp_map_norm_ena(regSE_HOS_CNTL_0 *reg, unsigned int disp_map_norm_ena)
{
  reg->bitfields.DISP_MAP_NORM_ENA = disp_map_norm_ena;
  if (reg->bitfields.DISP_MAP_NORM_ENA != disp_map_norm_ena) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_CNTL_0::DISP_MAP_NORM_ENA data too large\n");
}
__inline void set_SE_HOS_CNTL_0_disp_map_pos_func(regSE_HOS_CNTL_0 *reg, unsigned int disp_map_pos_func)
{
  reg->bitfields.DISP_MAP_POS_FUNC = disp_map_pos_func;
  if (reg->bitfields.DISP_MAP_POS_FUNC != disp_map_pos_func) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_CNTL_0::DISP_MAP_POS_FUNC data too large\n");
}
__inline void set_SE_HOS_CNTL_0_disp_map_norm_func(regSE_HOS_CNTL_0 *reg, unsigned int disp_map_norm_func)
{
  reg->bitfields.DISP_MAP_NORM_FUNC = disp_map_norm_func;
  if (reg->bitfields.DISP_MAP_NORM_FUNC != disp_map_norm_func) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_CNTL_0::DISP_MAP_NORM_FUNC data too large\n");
}
__inline void set_SE_HOS_CNTL_0_disp_map_fmt(regSE_HOS_CNTL_0 *reg, unsigned int disp_map_fmt)
{
  reg->bitfields.DISP_MAP_FMT = disp_map_fmt;
  if (reg->bitfields.DISP_MAP_FMT != disp_map_fmt) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_CNTL_0::DISP_MAP_FMT data too large\n");
}
#else
#define set_SE_HOS_CNTL_0_hos_normalize_normals(reg, hos_normalize_normals) (reg)->bitfields.HOS_NORMALIZE_NORMALS = hos_normalize_normals
#define set_SE_HOS_CNTL_0_hos_homogenize_position(reg, hos_homogenize_position) (reg)->bitfields.HOS_HOMOGENIZE_POSITION = hos_homogenize_position
#define set_SE_HOS_CNTL_0_hos_tess_lvl(reg, hos_tess_lvl) (reg)->bitfields.HOS_TESS_LVL = hos_tess_lvl
#define set_SE_HOS_CNTL_0_pos_vector_loc(reg, pos_vector_loc) (reg)->bitfields.POS_VECTOR_LOC = pos_vector_loc
#define set_SE_HOS_CNTL_0_norm_vector_loc(reg, norm_vector_loc) (reg)->bitfields.NORM_VECTOR_LOC = norm_vector_loc
#define set_SE_HOS_CNTL_0_cyl_wrap_cntl_0(reg, cyl_wrap_cntl_0) (reg)->bitfields.CYL_WRAP_CNTL_0 = cyl_wrap_cntl_0
#define set_SE_HOS_CNTL_0_cyl_wrap_cntl_1(reg, cyl_wrap_cntl_1) (reg)->bitfields.CYL_WRAP_CNTL_1 = cyl_wrap_cntl_1
#define set_SE_HOS_CNTL_0_disp_map_pos_ena(reg, disp_map_pos_ena) (reg)->bitfields.DISP_MAP_POS_ENA = disp_map_pos_ena
#define set_SE_HOS_CNTL_0_disp_map_norm_ena(reg, disp_map_norm_ena) (reg)->bitfields.DISP_MAP_NORM_ENA = disp_map_norm_ena
#define set_SE_HOS_CNTL_0_disp_map_pos_func(reg, disp_map_pos_func) (reg)->bitfields.DISP_MAP_POS_FUNC = disp_map_pos_func
#define set_SE_HOS_CNTL_0_disp_map_norm_func(reg, disp_map_norm_func) (reg)->bitfields.DISP_MAP_NORM_FUNC = disp_map_norm_func
#define set_SE_HOS_CNTL_0_disp_map_fmt(reg, disp_map_fmt) (reg)->bitfields.DISP_MAP_FMT = disp_map_fmt

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_HOS_CNTL_1 regSE_HOS_CNTL_1;

#ifdef DEBUG
__inline void set_SE_HOS_CNTL_1_disp_map_pos_mtx_sel(regSE_HOS_CNTL_1 *reg, unsigned int disp_map_pos_mtx_sel)
{
  reg->bitfields.DISP_MAP_POS_MTX_SEL = disp_map_pos_mtx_sel;
  if (reg->bitfields.DISP_MAP_POS_MTX_SEL != disp_map_pos_mtx_sel) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_CNTL_1::DISP_MAP_POS_MTX_SEL data too large\n");
}
__inline void set_SE_HOS_CNTL_1_disp_map_norm_mtx_sel(regSE_HOS_CNTL_1 *reg, unsigned int disp_map_norm_mtx_sel)
{
  reg->bitfields.DISP_MAP_NORM_MTX_SEL = disp_map_norm_mtx_sel;
  if (reg->bitfields.DISP_MAP_NORM_MTX_SEL != disp_map_norm_mtx_sel) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_CNTL_1::DISP_MAP_NORM_MTX_SEL data too large\n");
}
__inline void set_SE_HOS_CNTL_1_single_inst_pri_lvl(regSE_HOS_CNTL_1 *reg, unsigned int single_inst_pri_lvl)
{
  reg->bitfields.SINGLE_INST_PRI_LVL = single_inst_pri_lvl;
  if (reg->bitfields.SINGLE_INST_PRI_LVL != single_inst_pri_lvl) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_CNTL_1::SINGLE_INST_PRI_LVL data too large\n");
}
__inline void set_SE_HOS_CNTL_1_dual_inst_pri_lvl(regSE_HOS_CNTL_1 *reg, unsigned int dual_inst_pri_lvl)
{
  reg->bitfields.DUAL_INST_PRI_LVL = dual_inst_pri_lvl;
  if (reg->bitfields.DUAL_INST_PRI_LVL != dual_inst_pri_lvl) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_CNTL_1::DUAL_INST_PRI_LVL data too large\n");
}
#else
#define set_SE_HOS_CNTL_1_disp_map_pos_mtx_sel(reg, disp_map_pos_mtx_sel) (reg)->bitfields.DISP_MAP_POS_MTX_SEL = disp_map_pos_mtx_sel
#define set_SE_HOS_CNTL_1_disp_map_norm_mtx_sel(reg, disp_map_norm_mtx_sel) (reg)->bitfields.DISP_MAP_NORM_MTX_SEL = disp_map_norm_mtx_sel
#define set_SE_HOS_CNTL_1_single_inst_pri_lvl(reg, single_inst_pri_lvl) (reg)->bitfields.SINGLE_INST_PRI_LVL = single_inst_pri_lvl
#define set_SE_HOS_CNTL_1_dual_inst_pri_lvl(reg, dual_inst_pri_lvl) (reg)->bitfields.DUAL_INST_PRI_LVL = dual_inst_pri_lvl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_HOS_VEC_INTERP_0 regSE_HOS_VEC_INTERP_0;

#ifdef DEBUG
__inline void set_SE_HOS_VEC_INTERP_0_hos_interp_order_0(regSE_HOS_VEC_INTERP_0 *reg, unsigned int hos_interp_order_0)
{
  reg->bitfields.HOS_INTERP_ORDER_0 = hos_interp_order_0;
  if (reg->bitfields.HOS_INTERP_ORDER_0 != hos_interp_order_0) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_VEC_INTERP_0::HOS_INTERP_ORDER_0 data too large\n");
}
__inline void set_SE_HOS_VEC_INTERP_0_hos_interp_order_1(regSE_HOS_VEC_INTERP_0 *reg, unsigned int hos_interp_order_1)
{
  reg->bitfields.HOS_INTERP_ORDER_1 = hos_interp_order_1;
  if (reg->bitfields.HOS_INTERP_ORDER_1 != hos_interp_order_1) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_VEC_INTERP_0::HOS_INTERP_ORDER_1 data too large\n");
}
__inline void set_SE_HOS_VEC_INTERP_0_hos_interp_order_2(regSE_HOS_VEC_INTERP_0 *reg, unsigned int hos_interp_order_2)
{
  reg->bitfields.HOS_INTERP_ORDER_2 = hos_interp_order_2;
  if (reg->bitfields.HOS_INTERP_ORDER_2 != hos_interp_order_2) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_VEC_INTERP_0::HOS_INTERP_ORDER_2 data too large\n");
}
__inline void set_SE_HOS_VEC_INTERP_0_hos_interp_order_3(regSE_HOS_VEC_INTERP_0 *reg, unsigned int hos_interp_order_3)
{
  reg->bitfields.HOS_INTERP_ORDER_3 = hos_interp_order_3;
  if (reg->bitfields.HOS_INTERP_ORDER_3 != hos_interp_order_3) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_VEC_INTERP_0::HOS_INTERP_ORDER_3 data too large\n");
}
__inline void set_SE_HOS_VEC_INTERP_0_hos_interp_order_4(regSE_HOS_VEC_INTERP_0 *reg, unsigned int hos_interp_order_4)
{
  reg->bitfields.HOS_INTERP_ORDER_4 = hos_interp_order_4;
  if (reg->bitfields.HOS_INTERP_ORDER_4 != hos_interp_order_4) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_VEC_INTERP_0::HOS_INTERP_ORDER_4 data too large\n");
}
__inline void set_SE_HOS_VEC_INTERP_0_hos_interp_order_5(regSE_HOS_VEC_INTERP_0 *reg, unsigned int hos_interp_order_5)
{
  reg->bitfields.HOS_INTERP_ORDER_5 = hos_interp_order_5;
  if (reg->bitfields.HOS_INTERP_ORDER_5 != hos_interp_order_5) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_VEC_INTERP_0::HOS_INTERP_ORDER_5 data too large\n");
}
__inline void set_SE_HOS_VEC_INTERP_0_hos_interp_order_6(regSE_HOS_VEC_INTERP_0 *reg, unsigned int hos_interp_order_6)
{
  reg->bitfields.HOS_INTERP_ORDER_6 = hos_interp_order_6;
  if (reg->bitfields.HOS_INTERP_ORDER_6 != hos_interp_order_6) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_VEC_INTERP_0::HOS_INTERP_ORDER_6 data too large\n");
}
__inline void set_SE_HOS_VEC_INTERP_0_hos_interp_order_7(regSE_HOS_VEC_INTERP_0 *reg, unsigned int hos_interp_order_7)
{
  reg->bitfields.HOS_INTERP_ORDER_7 = hos_interp_order_7;
  if (reg->bitfields.HOS_INTERP_ORDER_7 != hos_interp_order_7) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_VEC_INTERP_0::HOS_INTERP_ORDER_7 data too large\n");
}
#else
#define set_SE_HOS_VEC_INTERP_0_hos_interp_order_0(reg, hos_interp_order_0) (reg)->bitfields.HOS_INTERP_ORDER_0 = hos_interp_order_0
#define set_SE_HOS_VEC_INTERP_0_hos_interp_order_1(reg, hos_interp_order_1) (reg)->bitfields.HOS_INTERP_ORDER_1 = hos_interp_order_1
#define set_SE_HOS_VEC_INTERP_0_hos_interp_order_2(reg, hos_interp_order_2) (reg)->bitfields.HOS_INTERP_ORDER_2 = hos_interp_order_2
#define set_SE_HOS_VEC_INTERP_0_hos_interp_order_3(reg, hos_interp_order_3) (reg)->bitfields.HOS_INTERP_ORDER_3 = hos_interp_order_3
#define set_SE_HOS_VEC_INTERP_0_hos_interp_order_4(reg, hos_interp_order_4) (reg)->bitfields.HOS_INTERP_ORDER_4 = hos_interp_order_4
#define set_SE_HOS_VEC_INTERP_0_hos_interp_order_5(reg, hos_interp_order_5) (reg)->bitfields.HOS_INTERP_ORDER_5 = hos_interp_order_5
#define set_SE_HOS_VEC_INTERP_0_hos_interp_order_6(reg, hos_interp_order_6) (reg)->bitfields.HOS_INTERP_ORDER_6 = hos_interp_order_6
#define set_SE_HOS_VEC_INTERP_0_hos_interp_order_7(reg, hos_interp_order_7) (reg)->bitfields.HOS_INTERP_ORDER_7 = hos_interp_order_7

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_HOS_VEC_INTERP_1 regSE_HOS_VEC_INTERP_1;

#ifdef DEBUG
__inline void set_SE_HOS_VEC_INTERP_1_hos_interp_order_8(regSE_HOS_VEC_INTERP_1 *reg, unsigned int hos_interp_order_8)
{
  reg->bitfields.HOS_INTERP_ORDER_8 = hos_interp_order_8;
  if (reg->bitfields.HOS_INTERP_ORDER_8 != hos_interp_order_8) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_VEC_INTERP_1::HOS_INTERP_ORDER_8 data too large\n");
}
__inline void set_SE_HOS_VEC_INTERP_1_hos_interp_order_9(regSE_HOS_VEC_INTERP_1 *reg, unsigned int hos_interp_order_9)
{
  reg->bitfields.HOS_INTERP_ORDER_9 = hos_interp_order_9;
  if (reg->bitfields.HOS_INTERP_ORDER_9 != hos_interp_order_9) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_VEC_INTERP_1::HOS_INTERP_ORDER_9 data too large\n");
}
__inline void set_SE_HOS_VEC_INTERP_1_hos_interp_order_10(regSE_HOS_VEC_INTERP_1 *reg, unsigned int hos_interp_order_10)
{
  reg->bitfields.HOS_INTERP_ORDER_10 = hos_interp_order_10;
  if (reg->bitfields.HOS_INTERP_ORDER_10 != hos_interp_order_10) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_VEC_INTERP_1::HOS_INTERP_ORDER_10 data too large\n");
}
__inline void set_SE_HOS_VEC_INTERP_1_hos_interp_order_11(regSE_HOS_VEC_INTERP_1 *reg, unsigned int hos_interp_order_11)
{
  reg->bitfields.HOS_INTERP_ORDER_11 = hos_interp_order_11;
  if (reg->bitfields.HOS_INTERP_ORDER_11 != hos_interp_order_11) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_VEC_INTERP_1::HOS_INTERP_ORDER_11 data too large\n");
}
__inline void set_SE_HOS_VEC_INTERP_1_hos_interp_order_12(regSE_HOS_VEC_INTERP_1 *reg, unsigned int hos_interp_order_12)
{
  reg->bitfields.HOS_INTERP_ORDER_12 = hos_interp_order_12;
  if (reg->bitfields.HOS_INTERP_ORDER_12 != hos_interp_order_12) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_VEC_INTERP_1::HOS_INTERP_ORDER_12 data too large\n");
}
__inline void set_SE_HOS_VEC_INTERP_1_hos_interp_order_13(regSE_HOS_VEC_INTERP_1 *reg, unsigned int hos_interp_order_13)
{
  reg->bitfields.HOS_INTERP_ORDER_13 = hos_interp_order_13;
  if (reg->bitfields.HOS_INTERP_ORDER_13 != hos_interp_order_13) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_VEC_INTERP_1::HOS_INTERP_ORDER_13 data too large\n");
}
__inline void set_SE_HOS_VEC_INTERP_1_hos_interp_order_14(regSE_HOS_VEC_INTERP_1 *reg, unsigned int hos_interp_order_14)
{
  reg->bitfields.HOS_INTERP_ORDER_14 = hos_interp_order_14;
  if (reg->bitfields.HOS_INTERP_ORDER_14 != hos_interp_order_14) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_VEC_INTERP_1::HOS_INTERP_ORDER_14 data too large\n");
}
__inline void set_SE_HOS_VEC_INTERP_1_hos_interp_order_15(regSE_HOS_VEC_INTERP_1 *reg, unsigned int hos_interp_order_15)
{
  reg->bitfields.HOS_INTERP_ORDER_15 = hos_interp_order_15;
  if (reg->bitfields.HOS_INTERP_ORDER_15 != hos_interp_order_15) HSLDPF(E_ERROR_MESSAGE,"SE_HOS_VEC_INTERP_1::HOS_INTERP_ORDER_15 data too large\n");
}
#else
#define set_SE_HOS_VEC_INTERP_1_hos_interp_order_8(reg, hos_interp_order_8) (reg)->bitfields.HOS_INTERP_ORDER_8 = hos_interp_order_8
#define set_SE_HOS_VEC_INTERP_1_hos_interp_order_9(reg, hos_interp_order_9) (reg)->bitfields.HOS_INTERP_ORDER_9 = hos_interp_order_9
#define set_SE_HOS_VEC_INTERP_1_hos_interp_order_10(reg, hos_interp_order_10) (reg)->bitfields.HOS_INTERP_ORDER_10 = hos_interp_order_10
#define set_SE_HOS_VEC_INTERP_1_hos_interp_order_11(reg, hos_interp_order_11) (reg)->bitfields.HOS_INTERP_ORDER_11 = hos_interp_order_11
#define set_SE_HOS_VEC_INTERP_1_hos_interp_order_12(reg, hos_interp_order_12) (reg)->bitfields.HOS_INTERP_ORDER_12 = hos_interp_order_12
#define set_SE_HOS_VEC_INTERP_1_hos_interp_order_13(reg, hos_interp_order_13) (reg)->bitfields.HOS_INTERP_ORDER_13 = hos_interp_order_13
#define set_SE_HOS_VEC_INTERP_1_hos_interp_order_14(reg, hos_interp_order_14) (reg)->bitfields.HOS_INTERP_ORDER_14 = hos_interp_order_14
#define set_SE_HOS_VEC_INTERP_1_hos_interp_order_15(reg, hos_interp_order_15) (reg)->bitfields.HOS_INTERP_ORDER_15 = hos_interp_order_15

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SE_TCL_FPU_LATENCY_R2 regSE_TCL_FPU_LATENCY_R2;

#ifdef DEBUG
__inline void set_SE_TCL_FPU_LATENCY_R2_ve_eng_latency(regSE_TCL_FPU_LATENCY_R2 *reg, unsigned int ve_eng_latency)
{
  reg->bitfields.VE_ENG_LATENCY = ve_eng_latency;
  if (reg->bitfields.VE_ENG_LATENCY != ve_eng_latency) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_FPU_LATENCY_R2::VE_ENG_LATENCY data too large\n");
}
__inline void set_SE_TCL_FPU_LATENCY_R2_ve_mult_latency(regSE_TCL_FPU_LATENCY_R2 *reg, unsigned int ve_mult_latency)
{
  reg->bitfields.VE_MULT_LATENCY = ve_mult_latency;
  if (reg->bitfields.VE_MULT_LATENCY != ve_mult_latency) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_FPU_LATENCY_R2::VE_MULT_LATENCY data too large\n");
}
__inline void set_SE_TCL_FPU_LATENCY_R2_ve_accum_latency(regSE_TCL_FPU_LATENCY_R2 *reg, unsigned int ve_accum_latency)
{
  reg->bitfields.VE_ACCUM_LATENCY = ve_accum_latency;
  if (reg->bitfields.VE_ACCUM_LATENCY != ve_accum_latency) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_FPU_LATENCY_R2::VE_ACCUM_LATENCY data too large\n");
}
__inline void set_SE_TCL_FPU_LATENCY_R2_sc_eng_latency(regSE_TCL_FPU_LATENCY_R2 *reg, unsigned int sc_eng_latency)
{
  reg->bitfields.SC_ENG_LATENCY = sc_eng_latency;
  if (reg->bitfields.SC_ENG_LATENCY != sc_eng_latency) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_FPU_LATENCY_R2::SC_ENG_LATENCY data too large\n");
}
__inline void set_SE_TCL_FPU_LATENCY_R2_ve_out_latency(regSE_TCL_FPU_LATENCY_R2 *reg, unsigned int ve_out_latency)
{
  reg->bitfields.VE_OUT_LATENCY = ve_out_latency;
  if (reg->bitfields.VE_OUT_LATENCY != ve_out_latency) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_FPU_LATENCY_R2::VE_OUT_LATENCY data too large\n");
}
__inline void set_SE_TCL_FPU_LATENCY_R2_sc_math_latency(regSE_TCL_FPU_LATENCY_R2 *reg, unsigned int sc_math_latency)
{
  reg->bitfields.SC_MATH_LATENCY = sc_math_latency;
  if (reg->bitfields.SC_MATH_LATENCY != sc_math_latency) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_FPU_LATENCY_R2::SC_MATH_LATENCY data too large\n");
}
__inline void set_SE_TCL_FPU_LATENCY_R2_rsvd_ltncy_2bit(regSE_TCL_FPU_LATENCY_R2 *reg, unsigned int rsvd_ltncy_2bit)
{
  reg->bitfields.RSVD_LTNCY_2BIT = rsvd_ltncy_2bit;
  if (reg->bitfields.RSVD_LTNCY_2BIT != rsvd_ltncy_2bit) HSLDPF(E_ERROR_MESSAGE,"SE_TCL_FPU_LATENCY_R2::RSVD_LTNCY_2BIT data too large\n");
}
#else
#define set_SE_TCL_FPU_LATENCY_R2_ve_eng_latency(reg, ve_eng_latency) (reg)->bitfields.VE_ENG_LATENCY = ve_eng_latency
#define set_SE_TCL_FPU_LATENCY_R2_ve_mult_latency(reg, ve_mult_latency) (reg)->bitfields.VE_MULT_LATENCY = ve_mult_latency
#define set_SE_TCL_FPU_LATENCY_R2_ve_accum_latency(reg, ve_accum_latency) (reg)->bitfields.VE_ACCUM_LATENCY = ve_accum_latency
#define set_SE_TCL_FPU_LATENCY_R2_sc_eng_latency(reg, sc_eng_latency) (reg)->bitfields.SC_ENG_LATENCY = sc_eng_latency
#define set_SE_TCL_FPU_LATENCY_R2_ve_out_latency(reg, ve_out_latency) (reg)->bitfields.VE_OUT_LATENCY = ve_out_latency
#define set_SE_TCL_FPU_LATENCY_R2_sc_math_latency(reg, sc_math_latency) (reg)->bitfields.SC_MATH_LATENCY = sc_math_latency
#define set_SE_TCL_FPU_LATENCY_R2_rsvd_ltncy_2bit(reg, rsvd_ltncy_2bit) (reg)->bitfields.RSVD_LTNCY_2BIT = rsvd_ltncy_2bit

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_HIZOFFSET regRE_HIZOFFSET;

#ifdef DEBUG
__inline void set_RE_HIZOFFSET_hizoffset(regRE_HIZOFFSET *reg, unsigned int hizoffset)
{
  reg->bitfields.HIZOFFSET = hizoffset;
  if (reg->bitfields.HIZOFFSET != hizoffset) HSLDPF(E_ERROR_MESSAGE,"RE_HIZOFFSET::HIZOFFSET data too large\n");
}
#else
#define set_RE_HIZOFFSET_hizoffset(reg, hizoffset) (reg)->bitfields.HIZOFFSET = hizoffset

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_HIZ_WRINDEX regRE_HIZ_WRINDEX;

#ifdef DEBUG
__inline void set_RE_HIZ_WRINDEX_hiz_wrindex(regRE_HIZ_WRINDEX *reg, unsigned int hiz_wrindex)
{
  reg->bitfields.HIZ_WRINDEX = hiz_wrindex;
  if (reg->bitfields.HIZ_WRINDEX != hiz_wrindex) HSLDPF(E_ERROR_MESSAGE,"RE_HIZ_WRINDEX::HIZ_WRINDEX data too large\n");
}
#else
#define set_RE_HIZ_WRINDEX_hiz_wrindex(reg, hiz_wrindex) (reg)->bitfields.HIZ_WRINDEX = hiz_wrindex

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_HIZ_RDINDEX regRE_HIZ_RDINDEX;

#ifdef DEBUG
__inline void set_RE_HIZ_RDINDEX_hiz_rdindex(regRE_HIZ_RDINDEX *reg, unsigned int hiz_rdindex)
{
  reg->bitfields.HIZ_RDINDEX = hiz_rdindex;
  if (reg->bitfields.HIZ_RDINDEX != hiz_rdindex) HSLDPF(E_ERROR_MESSAGE,"RE_HIZ_RDINDEX::HIZ_RDINDEX data too large\n");
}
#else
#define set_RE_HIZ_RDINDEX_hiz_rdindex(reg, hiz_rdindex) (reg)->bitfields.HIZ_RDINDEX = hiz_rdindex

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RE_HIZ_DWORD regRE_HIZ_DWORD;

#ifdef DEBUG
__inline void set_RE_HIZ_DWORD_hizdword(regRE_HIZ_DWORD *reg, unsigned int hizdword)
{
  reg->bitfields.HIZDWORD = hizdword;
  if (reg->bitfields.HIZDWORD != hizdword) HSLDPF(E_ERROR_MESSAGE,"RE_HIZ_DWORD::HIZDWORD data too large\n");
}
#else
#define set_RE_HIZ_DWORD_hizdword(reg, hizdword) (reg)->bitfields.HIZDWORD = hizdword

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250PP_TXPITCH_0 regrv250PP_TXPITCH_0;

#ifdef DEBUG
__inline void set_rv250PP_TXPITCH_0_txpitch(regrv250PP_TXPITCH_0 *reg, unsigned int txpitch)
{
  reg->bitfields.TXPITCH = txpitch;
  if (reg->bitfields.TXPITCH != txpitch) HSLDPF(E_ERROR_MESSAGE,"rv250PP_TXPITCH_0::TXPITCH data too large\n");
}
__inline void set_rv250PP_TXPITCH_0_tex_tag_cntl(regrv250PP_TXPITCH_0 *reg, unsigned int tex_tag_cntl)
{
  reg->bitfields.TEX_TAG_CNTL = tex_tag_cntl;
  if (reg->bitfields.TEX_TAG_CNTL != tex_tag_cntl) HSLDPF(E_ERROR_MESSAGE,"rv250PP_TXPITCH_0::TEX_TAG_CNTL data too large\n");
}
#else
#define set_rv250PP_TXPITCH_0_txpitch(reg, txpitch) (reg)->bitfields.TXPITCH = txpitch
#define set_rv250PP_TXPITCH_0_tex_tag_cntl(reg, tex_tag_cntl) (reg)->bitfields.TEX_TAG_CNTL = tex_tag_cntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250PP_TXPITCH_1 regrv250PP_TXPITCH_1;

#ifdef DEBUG
__inline void set_rv250PP_TXPITCH_1_txpitch(regrv250PP_TXPITCH_1 *reg, unsigned int txpitch)
{
  reg->bitfields.TXPITCH = txpitch;
  if (reg->bitfields.TXPITCH != txpitch) HSLDPF(E_ERROR_MESSAGE,"rv250PP_TXPITCH_1::TXPITCH data too large\n");
}
__inline void set_rv250PP_TXPITCH_1_tex_tag_cntl(regrv250PP_TXPITCH_1 *reg, unsigned int tex_tag_cntl)
{
  reg->bitfields.TEX_TAG_CNTL = tex_tag_cntl;
  if (reg->bitfields.TEX_TAG_CNTL != tex_tag_cntl) HSLDPF(E_ERROR_MESSAGE,"rv250PP_TXPITCH_1::TEX_TAG_CNTL data too large\n");
}
#else
#define set_rv250PP_TXPITCH_1_txpitch(reg, txpitch) (reg)->bitfields.TXPITCH = txpitch
#define set_rv250PP_TXPITCH_1_tex_tag_cntl(reg, tex_tag_cntl) (reg)->bitfields.TEX_TAG_CNTL = tex_tag_cntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250PP_TXPITCH_2 regrv250PP_TXPITCH_2;

#ifdef DEBUG
__inline void set_rv250PP_TXPITCH_2_txpitch(regrv250PP_TXPITCH_2 *reg, unsigned int txpitch)
{
  reg->bitfields.TXPITCH = txpitch;
  if (reg->bitfields.TXPITCH != txpitch) HSLDPF(E_ERROR_MESSAGE,"rv250PP_TXPITCH_2::TXPITCH data too large\n");
}
__inline void set_rv250PP_TXPITCH_2_tex_tag_cntl(regrv250PP_TXPITCH_2 *reg, unsigned int tex_tag_cntl)
{
  reg->bitfields.TEX_TAG_CNTL = tex_tag_cntl;
  if (reg->bitfields.TEX_TAG_CNTL != tex_tag_cntl) HSLDPF(E_ERROR_MESSAGE,"rv250PP_TXPITCH_2::TEX_TAG_CNTL data too large\n");
}
#else
#define set_rv250PP_TXPITCH_2_txpitch(reg, txpitch) (reg)->bitfields.TXPITCH = txpitch
#define set_rv250PP_TXPITCH_2_tex_tag_cntl(reg, tex_tag_cntl) (reg)->bitfields.TEX_TAG_CNTL = tex_tag_cntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250PP_TXPITCH_3 regrv250PP_TXPITCH_3;

#ifdef DEBUG
__inline void set_rv250PP_TXPITCH_3_txpitch(regrv250PP_TXPITCH_3 *reg, unsigned int txpitch)
{
  reg->bitfields.TXPITCH = txpitch;
  if (reg->bitfields.TXPITCH != txpitch) HSLDPF(E_ERROR_MESSAGE,"rv250PP_TXPITCH_3::TXPITCH data too large\n");
}
__inline void set_rv250PP_TXPITCH_3_tex_tag_cntl(regrv250PP_TXPITCH_3 *reg, unsigned int tex_tag_cntl)
{
  reg->bitfields.TEX_TAG_CNTL = tex_tag_cntl;
  if (reg->bitfields.TEX_TAG_CNTL != tex_tag_cntl) HSLDPF(E_ERROR_MESSAGE,"rv250PP_TXPITCH_3::TEX_TAG_CNTL data too large\n");
}
#else
#define set_rv250PP_TXPITCH_3_txpitch(reg, txpitch) (reg)->bitfields.TXPITCH = txpitch
#define set_rv250PP_TXPITCH_3_tex_tag_cntl(reg, tex_tag_cntl) (reg)->bitfields.TEX_TAG_CNTL = tex_tag_cntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250PP_TXPITCH_4 regrv250PP_TXPITCH_4;

#ifdef DEBUG
__inline void set_rv250PP_TXPITCH_4_txpitch(regrv250PP_TXPITCH_4 *reg, unsigned int txpitch)
{
  reg->bitfields.TXPITCH = txpitch;
  if (reg->bitfields.TXPITCH != txpitch) HSLDPF(E_ERROR_MESSAGE,"rv250PP_TXPITCH_4::TXPITCH data too large\n");
}
__inline void set_rv250PP_TXPITCH_4_tex_tag_cntl(regrv250PP_TXPITCH_4 *reg, unsigned int tex_tag_cntl)
{
  reg->bitfields.TEX_TAG_CNTL = tex_tag_cntl;
  if (reg->bitfields.TEX_TAG_CNTL != tex_tag_cntl) HSLDPF(E_ERROR_MESSAGE,"rv250PP_TXPITCH_4::TEX_TAG_CNTL data too large\n");
}
#else
#define set_rv250PP_TXPITCH_4_txpitch(reg, txpitch) (reg)->bitfields.TXPITCH = txpitch
#define set_rv250PP_TXPITCH_4_tex_tag_cntl(reg, tex_tag_cntl) (reg)->bitfields.TEX_TAG_CNTL = tex_tag_cntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union rv250PP_TXPITCH_5 regrv250PP_TXPITCH_5;

#ifdef DEBUG
__inline void set_rv250PP_TXPITCH_5_txpitch(regrv250PP_TXPITCH_5 *reg, unsigned int txpitch)
{
  reg->bitfields.TXPITCH = txpitch;
  if (reg->bitfields.TXPITCH != txpitch) HSLDPF(E_ERROR_MESSAGE,"rv250PP_TXPITCH_5::TXPITCH data too large\n");
}
__inline void set_rv250PP_TXPITCH_5_tex_tag_cntl(regrv250PP_TXPITCH_5 *reg, unsigned int tex_tag_cntl)
{
  reg->bitfields.TEX_TAG_CNTL = tex_tag_cntl;
  if (reg->bitfields.TEX_TAG_CNTL != tex_tag_cntl) HSLDPF(E_ERROR_MESSAGE,"rv250PP_TXPITCH_5::TEX_TAG_CNTL data too large\n");
}
#else
#define set_rv250PP_TXPITCH_5_txpitch(reg, txpitch) (reg)->bitfields.TXPITCH = txpitch
#define set_rv250PP_TXPITCH_5_tex_tag_cntl(reg, tex_tag_cntl) (reg)->bitfields.TEX_TAG_CNTL = tex_tag_cntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union RB3D_ZSTENCILCNTL regRB3D_ZSTENCILCNTL;

#ifdef DEBUG
__inline void set_RB3D_ZSTENCILCNTL_depthformat(regRB3D_ZSTENCILCNTL *reg, unsigned int depthformat)
{
  reg->bitfields.DEPTHFORMAT = depthformat;
  if (reg->bitfields.DEPTHFORMAT != depthformat) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZSTENCILCNTL::DEPTHFORMAT data too large\n");
}
__inline void set_RB3D_ZSTENCILCNTL_zfunc(regRB3D_ZSTENCILCNTL *reg, unsigned int zfunc)
{
  reg->bitfields.ZFUNC = zfunc;
  if (reg->bitfields.ZFUNC != zfunc) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZSTENCILCNTL::ZFUNC data too large\n");
}
__inline void set_RB3D_ZSTENCILCNTL_hierarchyenable(regRB3D_ZSTENCILCNTL *reg, unsigned int hierarchyenable)
{
  reg->bitfields.HIERARCHYENABLE = hierarchyenable;
  if (reg->bitfields.HIERARCHYENABLE != hierarchyenable) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZSTENCILCNTL::HIERARCHYENABLE data too large\n");
}
__inline void set_RB3D_ZSTENCILCNTL_stencilfunc(regRB3D_ZSTENCILCNTL *reg, unsigned int stencilfunc)
{
  reg->bitfields.STENCILFUNC = stencilfunc;
  if (reg->bitfields.STENCILFUNC != stencilfunc) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZSTENCILCNTL::STENCILFUNC data too large\n");
}
__inline void set_RB3D_ZSTENCILCNTL_stencilfail(regRB3D_ZSTENCILCNTL *reg, unsigned int stencilfail)
{
  reg->bitfields.STENCILFAIL = stencilfail;
  if (reg->bitfields.STENCILFAIL != stencilfail) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZSTENCILCNTL::STENCILFAIL data too large\n");
}
__inline void set_RB3D_ZSTENCILCNTL_stencilzpass(regRB3D_ZSTENCILCNTL *reg, unsigned int stencilzpass)
{
  reg->bitfields.STENCILZPASS = stencilzpass;
  if (reg->bitfields.STENCILZPASS != stencilzpass) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZSTENCILCNTL::STENCILZPASS data too large\n");
}
__inline void set_RB3D_ZSTENCILCNTL_stencilzfail(regRB3D_ZSTENCILCNTL *reg, unsigned int stencilzfail)
{
  reg->bitfields.STENCILZFAIL = stencilzfail;
  if (reg->bitfields.STENCILZFAIL != stencilzfail) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZSTENCILCNTL::STENCILZFAIL data too large\n");
}
__inline void set_RB3D_ZSTENCILCNTL_forcezclear(regRB3D_ZSTENCILCNTL *reg, unsigned int forcezclear)
{
  reg->bitfields.FORCEZCLEAR = forcezclear;
  if (reg->bitfields.FORCEZCLEAR != forcezclear) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZSTENCILCNTL::FORCEZCLEAR data too large\n");
}
__inline void set_RB3D_ZSTENCILCNTL_zcompression(regRB3D_ZSTENCILCNTL *reg, unsigned int zcompression)
{
  reg->bitfields.ZCOMPRESSION = zcompression;
  if (reg->bitfields.ZCOMPRESSION != zcompression) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZSTENCILCNTL::ZCOMPRESSION data too large\n");
}
__inline void set_RB3D_ZSTENCILCNTL_forcezdirty(regRB3D_ZSTENCILCNTL *reg, unsigned int forcezdirty)
{
  reg->bitfields.FORCEZDIRTY = forcezdirty;
  if (reg->bitfields.FORCEZDIRTY != forcezdirty) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZSTENCILCNTL::FORCEZDIRTY data too large\n");
}
__inline void set_RB3D_ZSTENCILCNTL_zwriteenable(regRB3D_ZSTENCILCNTL *reg, unsigned int zwriteenable)
{
  reg->bitfields.ZWRITEENABLE = zwriteenable;
  if (reg->bitfields.ZWRITEENABLE != zwriteenable) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZSTENCILCNTL::ZWRITEENABLE data too large\n");
}
__inline void set_RB3D_ZSTENCILCNTL_zdecompression(regRB3D_ZSTENCILCNTL *reg, unsigned int zdecompression)
{
  reg->bitfields.ZDECOMPRESSION = zdecompression;
  if (reg->bitfields.ZDECOMPRESSION != zdecompression) HSLDPF(E_ERROR_MESSAGE,"RB3D_ZSTENCILCNTL::ZDECOMPRESSION data too large\n");
}
#else
#define set_RB3D_ZSTENCILCNTL_depthformat(reg, depthformat) (reg)->bitfields.DEPTHFORMAT = depthformat
#define set_RB3D_ZSTENCILCNTL_zfunc(reg, zfunc) (reg)->bitfields.ZFUNC = zfunc
#define set_RB3D_ZSTENCILCNTL_hierarchyenable(reg, hierarchyenable) (reg)->bitfields.HIERARCHYENABLE = hierarchyenable
#define set_RB3D_ZSTENCILCNTL_stencilfunc(reg, stencilfunc) (reg)->bitfields.STENCILFUNC = stencilfunc
#define set_RB3D_ZSTENCILCNTL_stencilfail(reg, stencilfail) (reg)->bitfields.STENCILFAIL = stencilfail
#define set_RB3D_ZSTENCILCNTL_stencilzpass(reg, stencilzpass) (reg)->bitfields.STENCILZPASS = stencilzpass
#define set_RB3D_ZSTENCILCNTL_stencilzfail(reg, stencilzfail) (reg)->bitfields.STENCILZFAIL = stencilzfail
#define set_RB3D_ZSTENCILCNTL_forcezclear(reg, forcezclear) (reg)->bitfields.FORCEZCLEAR = forcezclear
#define set_RB3D_ZSTENCILCNTL_zcompression(reg, zcompression) (reg)->bitfields.ZCOMPRESSION = zcompression
#define set_RB3D_ZSTENCILCNTL_forcezdirty(reg, forcezdirty) (reg)->bitfields.FORCEZDIRTY = forcezdirty
#define set_RB3D_ZSTENCILCNTL_zwriteenable(reg, zwriteenable) (reg)->bitfields.ZWRITEENABLE = zwriteenable
#define set_RB3D_ZSTENCILCNTL_zdecompression(reg, zdecompression) (reg)->bitfields.ZDECOMPRESSION = zdecompression

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TVOUT_0_SCRATCH regTVOUT_0_SCRATCH;

#ifdef DEBUG
__inline void set_TVOUT_0_SCRATCH_tvout_0_scratch(regTVOUT_0_SCRATCH *reg, unsigned int tvout_0_scratch)
{
  reg->bitfields.TVOUT_0_SCRATCH = tvout_0_scratch;
  if (reg->bitfields.TVOUT_0_SCRATCH != tvout_0_scratch) HSLDPF(E_ERROR_MESSAGE,"TVOUT_0_SCRATCH::TVOUT_0_SCRATCH data too large\n");
}
#else
#define set_TVOUT_0_SCRATCH_tvout_0_scratch(reg, tvout_0_scratch) (reg)->bitfields.TVOUT_0_SCRATCH = tvout_0_scratch

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union TVOUT_1_SCRATCH regTVOUT_1_SCRATCH;

#ifdef DEBUG
__inline void set_TVOUT_1_SCRATCH_tvout_1_scratch(regTVOUT_1_SCRATCH *reg, unsigned int tvout_1_scratch)
{
  reg->bitfields.TVOUT_1_SCRATCH = tvout_1_scratch;
  if (reg->bitfields.TVOUT_1_SCRATCH != tvout_1_scratch) HSLDPF(E_ERROR_MESSAGE,"TVOUT_1_SCRATCH::TVOUT_1_SCRATCH data too large\n");
}
#else
#define set_TVOUT_1_SCRATCH_tvout_1_scratch(reg, tvout_1_scratch) (reg)->bitfields.TVOUT_1_SCRATCH = tvout_1_scratch

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CONFIG_XSTRAP regCONFIG_XSTRAP;

#ifdef DEBUG
__inline void set_CONFIG_XSTRAP_vga_disable(regCONFIG_XSTRAP *reg, unsigned int vga_disable)
{
  reg->bitfields.VGA_DISABLE = vga_disable;
  if (reg->bitfields.VGA_DISABLE != vga_disable) HSLDPF(E_ERROR_MESSAGE,"CONFIG_XSTRAP::VGA_DISABLE data too large\n");
}
__inline void set_CONFIG_XSTRAP_blank_rom(regCONFIG_XSTRAP *reg, unsigned int blank_rom)
{
  reg->bitfields.BLANK_ROM = blank_rom;
  if (reg->bitfields.BLANK_ROM != blank_rom) HSLDPF(E_ERROR_MESSAGE,"CONFIG_XSTRAP::BLANK_ROM data too large\n");
}
__inline void set_CONFIG_XSTRAP_enintb(regCONFIG_XSTRAP *reg, unsigned int enintb)
{
  reg->bitfields.ENINTB = enintb;
  if (reg->bitfields.ENINTB != enintb) HSLDPF(E_ERROR_MESSAGE,"CONFIG_XSTRAP::ENINTB data too large\n");
}
__inline void set_CONFIG_XSTRAP_ext_mem_en(regCONFIG_XSTRAP *reg, unsigned int ext_mem_en)
{
  reg->bitfields.EXT_MEM_EN = ext_mem_en;
  if (reg->bitfields.EXT_MEM_EN != ext_mem_en) HSLDPF(E_ERROR_MESSAGE,"CONFIG_XSTRAP::EXT_MEM_EN data too large\n");
}
__inline void set_CONFIG_XSTRAP_agpskew(regCONFIG_XSTRAP *reg, unsigned int agpskew)
{
  reg->bitfields.AGPSKEW = agpskew;
  if (reg->bitfields.AGPSKEW != agpskew) HSLDPF(E_ERROR_MESSAGE,"CONFIG_XSTRAP::AGPSKEW data too large\n");
}
__inline void set_CONFIG_XSTRAP_x1clk_skew(regCONFIG_XSTRAP *reg, unsigned int x1clk_skew)
{
  reg->bitfields.X1CLK_SKEW = x1clk_skew;
  if (reg->bitfields.X1CLK_SKEW != x1clk_skew) HSLDPF(E_ERROR_MESSAGE,"CONFIG_XSTRAP::X1CLK_SKEW data too large\n");
}
__inline void set_CONFIG_XSTRAP_vip_device(regCONFIG_XSTRAP *reg, unsigned int vip_device)
{
  reg->bitfields.VIP_DEVICE = vip_device;
  if (reg->bitfields.VIP_DEVICE != vip_device) HSLDPF(E_ERROR_MESSAGE,"CONFIG_XSTRAP::VIP_DEVICE data too large\n");
}
__inline void set_CONFIG_XSTRAP_id_disable(regCONFIG_XSTRAP *reg, unsigned int id_disable)
{
  reg->bitfields.ID_DISABLE = id_disable;
  if (reg->bitfields.ID_DISABLE != id_disable) HSLDPF(E_ERROR_MESSAGE,"CONFIG_XSTRAP::ID_DISABLE data too large\n");
}
__inline void set_CONFIG_XSTRAP_ap_size(regCONFIG_XSTRAP *reg, unsigned int ap_size)
{
  reg->bitfields.AP_SIZE = ap_size;
  if (reg->bitfields.AP_SIZE != ap_size) HSLDPF(E_ERROR_MESSAGE,"CONFIG_XSTRAP::AP_SIZE data too large\n");
}
__inline void set_CONFIG_XSTRAP_romidcfg_r2(regCONFIG_XSTRAP *reg, unsigned int romidcfg_r2)
{
  reg->bitfields.ROMIDCFG_R2 = romidcfg_r2;
  if (reg->bitfields.ROMIDCFG_R2 != romidcfg_r2) HSLDPF(E_ERROR_MESSAGE,"CONFIG_XSTRAP::ROMIDCFG_R2 data too large\n");
}
__inline void set_CONFIG_XSTRAP_buscfg(regCONFIG_XSTRAP *reg, unsigned int buscfg)
{
  reg->bitfields.BUSCFG = buscfg;
  if (reg->bitfields.BUSCFG != buscfg) HSLDPF(E_ERROR_MESSAGE,"CONFIG_XSTRAP::BUSCFG data too large\n");
}
__inline void set_CONFIG_XSTRAP_wsen(regCONFIG_XSTRAP *reg, unsigned int wsen)
{
  reg->bitfields.WSEN = wsen;
  if (reg->bitfields.WSEN != wsen) HSLDPF(E_ERROR_MESSAGE,"CONFIG_XSTRAP::WSEN data too large\n");
}
__inline void set_CONFIG_XSTRAP_wsdegrade(regCONFIG_XSTRAP *reg, unsigned int wsdegrade)
{
  reg->bitfields.WSDEGRADE = wsdegrade;
  if (reg->bitfields.WSDEGRADE != wsdegrade) HSLDPF(E_ERROR_MESSAGE,"CONFIG_XSTRAP::WSDEGRADE data too large\n");
}
__inline void set_CONFIG_XSTRAP_hdcp_disable(regCONFIG_XSTRAP *reg, unsigned int hdcp_disable)
{
  reg->bitfields.HDCP_DISABLE = hdcp_disable;
  if (reg->bitfields.HDCP_DISABLE != hdcp_disable) HSLDPF(E_ERROR_MESSAGE,"CONFIG_XSTRAP::HDCP_DISABLE data too large\n");
}
__inline void set_CONFIG_XSTRAP_fast_wt_disable(regCONFIG_XSTRAP *reg, unsigned int fast_wt_disable)
{
  reg->bitfields.FAST_WT_DISABLE = fast_wt_disable;
  if (reg->bitfields.FAST_WT_DISABLE != fast_wt_disable) HSLDPF(E_ERROR_MESSAGE,"CONFIG_XSTRAP::FAST_WT_DISABLE data too large\n");
}
__inline void set_CONFIG_XSTRAP_mv_disable(regCONFIG_XSTRAP *reg, unsigned int mv_disable)
{
  reg->bitfields.MV_DISABLE = mv_disable;
  if (reg->bitfields.MV_DISABLE != mv_disable) HSLDPF(E_ERROR_MESSAGE,"CONFIG_XSTRAP::MV_DISABLE data too large\n");
}
#else
#define set_CONFIG_XSTRAP_vga_disable(reg, vga_disable) (reg)->bitfields.VGA_DISABLE = vga_disable
#define set_CONFIG_XSTRAP_blank_rom(reg, blank_rom) (reg)->bitfields.BLANK_ROM = blank_rom
#define set_CONFIG_XSTRAP_enintb(reg, enintb) (reg)->bitfields.ENINTB = enintb
#define set_CONFIG_XSTRAP_ext_mem_en(reg, ext_mem_en) (reg)->bitfields.EXT_MEM_EN = ext_mem_en
#define set_CONFIG_XSTRAP_agpskew(reg, agpskew) (reg)->bitfields.AGPSKEW = agpskew
#define set_CONFIG_XSTRAP_x1clk_skew(reg, x1clk_skew) (reg)->bitfields.X1CLK_SKEW = x1clk_skew
#define set_CONFIG_XSTRAP_vip_device(reg, vip_device) (reg)->bitfields.VIP_DEVICE = vip_device
#define set_CONFIG_XSTRAP_id_disable(reg, id_disable) (reg)->bitfields.ID_DISABLE = id_disable
#define set_CONFIG_XSTRAP_ap_size(reg, ap_size) (reg)->bitfields.AP_SIZE = ap_size
#define set_CONFIG_XSTRAP_romidcfg_r2(reg, romidcfg_r2) (reg)->bitfields.ROMIDCFG_R2 = romidcfg_r2
#define set_CONFIG_XSTRAP_buscfg(reg, buscfg) (reg)->bitfields.BUSCFG = buscfg
#define set_CONFIG_XSTRAP_wsen(reg, wsen) (reg)->bitfields.WSEN = wsen
#define set_CONFIG_XSTRAP_wsdegrade(reg, wsdegrade) (reg)->bitfields.WSDEGRADE = wsdegrade
#define set_CONFIG_XSTRAP_hdcp_disable(reg, hdcp_disable) (reg)->bitfields.HDCP_DISABLE = hdcp_disable
#define set_CONFIG_XSTRAP_fast_wt_disable(reg, fast_wt_disable) (reg)->bitfields.FAST_WT_DISABLE = fast_wt_disable
#define set_CONFIG_XSTRAP_mv_disable(reg, mv_disable) (reg)->bitfields.MV_DISABLE = mv_disable

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPPAD_STRENGTH regVIPPAD_STRENGTH;

#ifdef DEBUG
__inline void set_VIPPAD_STRENGTH_i2c_strength(regVIPPAD_STRENGTH *reg, unsigned int i2c_strength)
{
  reg->bitfields.I2C_STRENGTH = i2c_strength;
  if (reg->bitfields.I2C_STRENGTH != i2c_strength) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_STRENGTH::I2C_STRENGTH data too large\n");
}
__inline void set_VIPPAD_STRENGTH_viphdat_strength(regVIPPAD_STRENGTH *reg, unsigned int viphdat_strength)
{
  reg->bitfields.VIPHDAT_STRENGTH = viphdat_strength;
  if (reg->bitfields.VIPHDAT_STRENGTH != viphdat_strength) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_STRENGTH::VIPHDAT_STRENGTH data too large\n");
}
__inline void set_VIPPAD_STRENGTH_viphclk_strength(regVIPPAD_STRENGTH *reg, unsigned int viphclk_strength)
{
  reg->bitfields.VIPHCLK_STRENGTH = viphclk_strength;
  if (reg->bitfields.VIPHCLK_STRENGTH != viphclk_strength) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_STRENGTH::VIPHCLK_STRENGTH data too large\n");
}
#else
#define set_VIPPAD_STRENGTH_i2c_strength(reg, i2c_strength) (reg)->bitfields.I2C_STRENGTH = i2c_strength
#define set_VIPPAD_STRENGTH_viphdat_strength(reg, viphdat_strength) (reg)->bitfields.VIPHDAT_STRENGTH = viphdat_strength
#define set_VIPPAD_STRENGTH_viphclk_strength(reg, viphclk_strength) (reg)->bitfields.VIPHCLK_STRENGTH = viphclk_strength

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPPAD_MASK regVIPPAD_MASK;

#ifdef DEBUG
__inline void set_VIPPAD_MASK_vippad_mask_tvodata(regVIPPAD_MASK *reg, unsigned int vippad_mask_tvodata)
{
  reg->bitfields.VIPPAD_MASK_TVODATA = vippad_mask_tvodata;
  if (reg->bitfields.VIPPAD_MASK_TVODATA != vippad_mask_tvodata) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_MASK::VIPPAD_MASK_TVODATA data too large\n");
}
__inline void set_VIPPAD_MASK_vippad_mask_tvoclko(regVIPPAD_MASK *reg, unsigned int vippad_mask_tvoclko)
{
  reg->bitfields.VIPPAD_MASK_TVOCLKO = vippad_mask_tvoclko;
  if (reg->bitfields.VIPPAD_MASK_TVOCLKO != vippad_mask_tvoclko) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_MASK::VIPPAD_MASK_TVOCLKO data too large\n");
}
__inline void set_VIPPAD_MASK_vippad_mask_romcsb(regVIPPAD_MASK *reg, unsigned int vippad_mask_romcsb)
{
  reg->bitfields.VIPPAD_MASK_ROMCSb = vippad_mask_romcsb;
  if (reg->bitfields.VIPPAD_MASK_ROMCSb != vippad_mask_romcsb) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_MASK::VIPPAD_MASK_ROMCSb data too large\n");
}
__inline void set_VIPPAD_MASK_vippad_mask_vhad(regVIPPAD_MASK *reg, unsigned int vippad_mask_vhad)
{
  reg->bitfields.VIPPAD_MASK_VHAD = vippad_mask_vhad;
  if (reg->bitfields.VIPPAD_MASK_VHAD != vippad_mask_vhad) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_MASK::VIPPAD_MASK_VHAD data too large\n");
}
__inline void set_VIPPAD_MASK_vippad_mask_vphctl(regVIPPAD_MASK *reg, unsigned int vippad_mask_vphctl)
{
  reg->bitfields.VIPPAD_MASK_VPHCTL = vippad_mask_vphctl;
  if (reg->bitfields.VIPPAD_MASK_VPHCTL != vippad_mask_vphctl) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_MASK::VIPPAD_MASK_VPHCTL data too large\n");
}
__inline void set_VIPPAD_MASK_vippad_mask_vipclk(regVIPPAD_MASK *reg, unsigned int vippad_mask_vipclk)
{
  reg->bitfields.VIPPAD_MASK_VIPCLK = vippad_mask_vipclk;
  if (reg->bitfields.VIPPAD_MASK_VIPCLK != vippad_mask_vipclk) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_MASK::VIPPAD_MASK_VIPCLK data too large\n");
}
__inline void set_VIPPAD_MASK_vippad_mask_si(regVIPPAD_MASK *reg, unsigned int vippad_mask_si)
{
  reg->bitfields.VIPPAD_MASK_SI = vippad_mask_si;
  if (reg->bitfields.VIPPAD_MASK_SI != vippad_mask_si) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_MASK::VIPPAD_MASK_SI data too large\n");
}
__inline void set_VIPPAD_MASK_vippad_mask_so(regVIPPAD_MASK *reg, unsigned int vippad_mask_so)
{
  reg->bitfields.VIPPAD_MASK_SO = vippad_mask_so;
  if (reg->bitfields.VIPPAD_MASK_SO != vippad_mask_so) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_MASK::VIPPAD_MASK_SO data too large\n");
}
__inline void set_VIPPAD_MASK_vippad_mask_sck(regVIPPAD_MASK *reg, unsigned int vippad_mask_sck)
{
  reg->bitfields.VIPPAD_MASK_SCK = vippad_mask_sck;
  if (reg->bitfields.VIPPAD_MASK_SCK != vippad_mask_sck) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_MASK::VIPPAD_MASK_SCK data too large\n");
}
#else
#define set_VIPPAD_MASK_vippad_mask_tvodata(reg, vippad_mask_tvodata) (reg)->bitfields.VIPPAD_MASK_TVODATA = vippad_mask_tvodata
#define set_VIPPAD_MASK_vippad_mask_tvoclko(reg, vippad_mask_tvoclko) (reg)->bitfields.VIPPAD_MASK_TVOCLKO = vippad_mask_tvoclko
#define set_VIPPAD_MASK_vippad_mask_romcsb(reg, vippad_mask_romcsb) (reg)->bitfields.VIPPAD_MASK_ROMCSb = vippad_mask_romcsb
#define set_VIPPAD_MASK_vippad_mask_vhad(reg, vippad_mask_vhad) (reg)->bitfields.VIPPAD_MASK_VHAD = vippad_mask_vhad
#define set_VIPPAD_MASK_vippad_mask_vphctl(reg, vippad_mask_vphctl) (reg)->bitfields.VIPPAD_MASK_VPHCTL = vippad_mask_vphctl
#define set_VIPPAD_MASK_vippad_mask_vipclk(reg, vippad_mask_vipclk) (reg)->bitfields.VIPPAD_MASK_VIPCLK = vippad_mask_vipclk
#define set_VIPPAD_MASK_vippad_mask_si(reg, vippad_mask_si) (reg)->bitfields.VIPPAD_MASK_SI = vippad_mask_si
#define set_VIPPAD_MASK_vippad_mask_so(reg, vippad_mask_so) (reg)->bitfields.VIPPAD_MASK_SO = vippad_mask_so
#define set_VIPPAD_MASK_vippad_mask_sck(reg, vippad_mask_sck) (reg)->bitfields.VIPPAD_MASK_SCK = vippad_mask_sck

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPPAD_A regVIPPAD_A;

#ifdef DEBUG
__inline void set_VIPPAD_A_vippad_a_tvodata(regVIPPAD_A *reg, unsigned int vippad_a_tvodata)
{
  reg->bitfields.VIPPAD_A_TVODATA = vippad_a_tvodata;
  if (reg->bitfields.VIPPAD_A_TVODATA != vippad_a_tvodata) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_A::VIPPAD_A_TVODATA data too large\n");
}
__inline void set_VIPPAD_A_vippad_a_tvoclko(regVIPPAD_A *reg, unsigned int vippad_a_tvoclko)
{
  reg->bitfields.VIPPAD_A_TVOCLKO = vippad_a_tvoclko;
  if (reg->bitfields.VIPPAD_A_TVOCLKO != vippad_a_tvoclko) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_A::VIPPAD_A_TVOCLKO data too large\n");
}
__inline void set_VIPPAD_A_vippad_a_romcsb(regVIPPAD_A *reg, unsigned int vippad_a_romcsb)
{
  reg->bitfields.VIPPAD_A_ROMCSb = vippad_a_romcsb;
  if (reg->bitfields.VIPPAD_A_ROMCSb != vippad_a_romcsb) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_A::VIPPAD_A_ROMCSb data too large\n");
}
__inline void set_VIPPAD_A_vippad_a_vhad(regVIPPAD_A *reg, unsigned int vippad_a_vhad)
{
  reg->bitfields.VIPPAD_A_VHAD = vippad_a_vhad;
  if (reg->bitfields.VIPPAD_A_VHAD != vippad_a_vhad) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_A::VIPPAD_A_VHAD data too large\n");
}
__inline void set_VIPPAD_A_vippad_a_vphctl(regVIPPAD_A *reg, unsigned int vippad_a_vphctl)
{
  reg->bitfields.VIPPAD_A_VPHCTL = vippad_a_vphctl;
  if (reg->bitfields.VIPPAD_A_VPHCTL != vippad_a_vphctl) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_A::VIPPAD_A_VPHCTL data too large\n");
}
__inline void set_VIPPAD_A_vippad_a_vipclk(regVIPPAD_A *reg, unsigned int vippad_a_vipclk)
{
  reg->bitfields.VIPPAD_A_VIPCLK = vippad_a_vipclk;
  if (reg->bitfields.VIPPAD_A_VIPCLK != vippad_a_vipclk) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_A::VIPPAD_A_VIPCLK data too large\n");
}
__inline void set_VIPPAD_A_vippad_a_si(regVIPPAD_A *reg, unsigned int vippad_a_si)
{
  reg->bitfields.VIPPAD_A_SI = vippad_a_si;
  if (reg->bitfields.VIPPAD_A_SI != vippad_a_si) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_A::VIPPAD_A_SI data too large\n");
}
__inline void set_VIPPAD_A_vippad_a_so(regVIPPAD_A *reg, unsigned int vippad_a_so)
{
  reg->bitfields.VIPPAD_A_SO = vippad_a_so;
  if (reg->bitfields.VIPPAD_A_SO != vippad_a_so) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_A::VIPPAD_A_SO data too large\n");
}
__inline void set_VIPPAD_A_vippad_a_sck(regVIPPAD_A *reg, unsigned int vippad_a_sck)
{
  reg->bitfields.VIPPAD_A_SCK = vippad_a_sck;
  if (reg->bitfields.VIPPAD_A_SCK != vippad_a_sck) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_A::VIPPAD_A_SCK data too large\n");
}
#else
#define set_VIPPAD_A_vippad_a_tvodata(reg, vippad_a_tvodata) (reg)->bitfields.VIPPAD_A_TVODATA = vippad_a_tvodata
#define set_VIPPAD_A_vippad_a_tvoclko(reg, vippad_a_tvoclko) (reg)->bitfields.VIPPAD_A_TVOCLKO = vippad_a_tvoclko
#define set_VIPPAD_A_vippad_a_romcsb(reg, vippad_a_romcsb) (reg)->bitfields.VIPPAD_A_ROMCSb = vippad_a_romcsb
#define set_VIPPAD_A_vippad_a_vhad(reg, vippad_a_vhad) (reg)->bitfields.VIPPAD_A_VHAD = vippad_a_vhad
#define set_VIPPAD_A_vippad_a_vphctl(reg, vippad_a_vphctl) (reg)->bitfields.VIPPAD_A_VPHCTL = vippad_a_vphctl
#define set_VIPPAD_A_vippad_a_vipclk(reg, vippad_a_vipclk) (reg)->bitfields.VIPPAD_A_VIPCLK = vippad_a_vipclk
#define set_VIPPAD_A_vippad_a_si(reg, vippad_a_si) (reg)->bitfields.VIPPAD_A_SI = vippad_a_si
#define set_VIPPAD_A_vippad_a_so(reg, vippad_a_so) (reg)->bitfields.VIPPAD_A_SO = vippad_a_so
#define set_VIPPAD_A_vippad_a_sck(reg, vippad_a_sck) (reg)->bitfields.VIPPAD_A_SCK = vippad_a_sck

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPPAD_EN regVIPPAD_EN;

#ifdef DEBUG
__inline void set_VIPPAD_EN_vippad_en_tvodata(regVIPPAD_EN *reg, unsigned int vippad_en_tvodata)
{
  reg->bitfields.VIPPAD_EN_TVODATA = vippad_en_tvodata;
  if (reg->bitfields.VIPPAD_EN_TVODATA != vippad_en_tvodata) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_EN::VIPPAD_EN_TVODATA data too large\n");
}
__inline void set_VIPPAD_EN_vippad_en_tvoclko(regVIPPAD_EN *reg, unsigned int vippad_en_tvoclko)
{
  reg->bitfields.VIPPAD_EN_TVOCLKO = vippad_en_tvoclko;
  if (reg->bitfields.VIPPAD_EN_TVOCLKO != vippad_en_tvoclko) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_EN::VIPPAD_EN_TVOCLKO data too large\n");
}
__inline void set_VIPPAD_EN_vippad_en_romcsb(regVIPPAD_EN *reg, unsigned int vippad_en_romcsb)
{
  reg->bitfields.VIPPAD_EN_ROMCSb = vippad_en_romcsb;
  if (reg->bitfields.VIPPAD_EN_ROMCSb != vippad_en_romcsb) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_EN::VIPPAD_EN_ROMCSb data too large\n");
}
__inline void set_VIPPAD_EN_vippad_en_vhad(regVIPPAD_EN *reg, unsigned int vippad_en_vhad)
{
  reg->bitfields.VIPPAD_EN_VHAD = vippad_en_vhad;
  if (reg->bitfields.VIPPAD_EN_VHAD != vippad_en_vhad) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_EN::VIPPAD_EN_VHAD data too large\n");
}
__inline void set_VIPPAD_EN_vippad_en_vphctl(regVIPPAD_EN *reg, unsigned int vippad_en_vphctl)
{
  reg->bitfields.VIPPAD_EN_VPHCTL = vippad_en_vphctl;
  if (reg->bitfields.VIPPAD_EN_VPHCTL != vippad_en_vphctl) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_EN::VIPPAD_EN_VPHCTL data too large\n");
}
__inline void set_VIPPAD_EN_vippad_en_vipclk(regVIPPAD_EN *reg, unsigned int vippad_en_vipclk)
{
  reg->bitfields.VIPPAD_EN_VIPCLK = vippad_en_vipclk;
  if (reg->bitfields.VIPPAD_EN_VIPCLK != vippad_en_vipclk) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_EN::VIPPAD_EN_VIPCLK data too large\n");
}
__inline void set_VIPPAD_EN_vippad_en_si(regVIPPAD_EN *reg, unsigned int vippad_en_si)
{
  reg->bitfields.VIPPAD_EN_SI = vippad_en_si;
  if (reg->bitfields.VIPPAD_EN_SI != vippad_en_si) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_EN::VIPPAD_EN_SI data too large\n");
}
__inline void set_VIPPAD_EN_vippad_en_so(regVIPPAD_EN *reg, unsigned int vippad_en_so)
{
  reg->bitfields.VIPPAD_EN_SO = vippad_en_so;
  if (reg->bitfields.VIPPAD_EN_SO != vippad_en_so) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_EN::VIPPAD_EN_SO data too large\n");
}
__inline void set_VIPPAD_EN_vippad_en_sck(regVIPPAD_EN *reg, unsigned int vippad_en_sck)
{
  reg->bitfields.VIPPAD_EN_SCK = vippad_en_sck;
  if (reg->bitfields.VIPPAD_EN_SCK != vippad_en_sck) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_EN::VIPPAD_EN_SCK data too large\n");
}
#else
#define set_VIPPAD_EN_vippad_en_tvodata(reg, vippad_en_tvodata) (reg)->bitfields.VIPPAD_EN_TVODATA = vippad_en_tvodata
#define set_VIPPAD_EN_vippad_en_tvoclko(reg, vippad_en_tvoclko) (reg)->bitfields.VIPPAD_EN_TVOCLKO = vippad_en_tvoclko
#define set_VIPPAD_EN_vippad_en_romcsb(reg, vippad_en_romcsb) (reg)->bitfields.VIPPAD_EN_ROMCSb = vippad_en_romcsb
#define set_VIPPAD_EN_vippad_en_vhad(reg, vippad_en_vhad) (reg)->bitfields.VIPPAD_EN_VHAD = vippad_en_vhad
#define set_VIPPAD_EN_vippad_en_vphctl(reg, vippad_en_vphctl) (reg)->bitfields.VIPPAD_EN_VPHCTL = vippad_en_vphctl
#define set_VIPPAD_EN_vippad_en_vipclk(reg, vippad_en_vipclk) (reg)->bitfields.VIPPAD_EN_VIPCLK = vippad_en_vipclk
#define set_VIPPAD_EN_vippad_en_si(reg, vippad_en_si) (reg)->bitfields.VIPPAD_EN_SI = vippad_en_si
#define set_VIPPAD_EN_vippad_en_so(reg, vippad_en_so) (reg)->bitfields.VIPPAD_EN_SO = vippad_en_so
#define set_VIPPAD_EN_vippad_en_sck(reg, vippad_en_sck) (reg)->bitfields.VIPPAD_EN_SCK = vippad_en_sck

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPPAD_Y regVIPPAD_Y;

#ifdef DEBUG
__inline void set_VIPPAD_Y_vippad_y_tvodata(regVIPPAD_Y *reg, unsigned int vippad_y_tvodata)
{
  reg->bitfields.VIPPAD_Y_TVODATA = vippad_y_tvodata;
  if (reg->bitfields.VIPPAD_Y_TVODATA != vippad_y_tvodata) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_Y::VIPPAD_Y_TVODATA data too large\n");
}
__inline void set_VIPPAD_Y_vippad_y_tvoclko(regVIPPAD_Y *reg, unsigned int vippad_y_tvoclko)
{
  reg->bitfields.VIPPAD_Y_TVOCLKO = vippad_y_tvoclko;
  if (reg->bitfields.VIPPAD_Y_TVOCLKO != vippad_y_tvoclko) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_Y::VIPPAD_Y_TVOCLKO data too large\n");
}
__inline void set_VIPPAD_Y_vippad_y_romcsb(regVIPPAD_Y *reg, unsigned int vippad_y_romcsb)
{
  reg->bitfields.VIPPAD_Y_ROMCSb = vippad_y_romcsb;
  if (reg->bitfields.VIPPAD_Y_ROMCSb != vippad_y_romcsb) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_Y::VIPPAD_Y_ROMCSb data too large\n");
}
__inline void set_VIPPAD_Y_vippad_y_vhad(regVIPPAD_Y *reg, unsigned int vippad_y_vhad)
{
  reg->bitfields.VIPPAD_Y_VHAD = vippad_y_vhad;
  if (reg->bitfields.VIPPAD_Y_VHAD != vippad_y_vhad) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_Y::VIPPAD_Y_VHAD data too large\n");
}
__inline void set_VIPPAD_Y_vippad_y_vphctl(regVIPPAD_Y *reg, unsigned int vippad_y_vphctl)
{
  reg->bitfields.VIPPAD_Y_VPHCTL = vippad_y_vphctl;
  if (reg->bitfields.VIPPAD_Y_VPHCTL != vippad_y_vphctl) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_Y::VIPPAD_Y_VPHCTL data too large\n");
}
__inline void set_VIPPAD_Y_vippad_y_vipclk(regVIPPAD_Y *reg, unsigned int vippad_y_vipclk)
{
  reg->bitfields.VIPPAD_Y_VIPCLK = vippad_y_vipclk;
  if (reg->bitfields.VIPPAD_Y_VIPCLK != vippad_y_vipclk) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_Y::VIPPAD_Y_VIPCLK data too large\n");
}
__inline void set_VIPPAD_Y_vippad_y_si(regVIPPAD_Y *reg, unsigned int vippad_y_si)
{
  reg->bitfields.VIPPAD_Y_SI = vippad_y_si;
  if (reg->bitfields.VIPPAD_Y_SI != vippad_y_si) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_Y::VIPPAD_Y_SI data too large\n");
}
__inline void set_VIPPAD_Y_vippad_y_so(regVIPPAD_Y *reg, unsigned int vippad_y_so)
{
  reg->bitfields.VIPPAD_Y_SO = vippad_y_so;
  if (reg->bitfields.VIPPAD_Y_SO != vippad_y_so) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_Y::VIPPAD_Y_SO data too large\n");
}
__inline void set_VIPPAD_Y_vippad_y_sck(regVIPPAD_Y *reg, unsigned int vippad_y_sck)
{
  reg->bitfields.VIPPAD_Y_SCK = vippad_y_sck;
  if (reg->bitfields.VIPPAD_Y_SCK != vippad_y_sck) HSLDPF(E_ERROR_MESSAGE,"VIPPAD_Y::VIPPAD_Y_SCK data too large\n");
}
#else
#define set_VIPPAD_Y_vippad_y_tvodata(reg, vippad_y_tvodata) (reg)->bitfields.VIPPAD_Y_TVODATA = vippad_y_tvodata
#define set_VIPPAD_Y_vippad_y_tvoclko(reg, vippad_y_tvoclko) (reg)->bitfields.VIPPAD_Y_TVOCLKO = vippad_y_tvoclko
#define set_VIPPAD_Y_vippad_y_romcsb(reg, vippad_y_romcsb) (reg)->bitfields.VIPPAD_Y_ROMCSb = vippad_y_romcsb
#define set_VIPPAD_Y_vippad_y_vhad(reg, vippad_y_vhad) (reg)->bitfields.VIPPAD_Y_VHAD = vippad_y_vhad
#define set_VIPPAD_Y_vippad_y_vphctl(reg, vippad_y_vphctl) (reg)->bitfields.VIPPAD_Y_VPHCTL = vippad_y_vphctl
#define set_VIPPAD_Y_vippad_y_vipclk(reg, vippad_y_vipclk) (reg)->bitfields.VIPPAD_Y_VIPCLK = vippad_y_vipclk
#define set_VIPPAD_Y_vippad_y_si(reg, vippad_y_si) (reg)->bitfields.VIPPAD_Y_SI = vippad_y_si
#define set_VIPPAD_Y_vippad_y_so(reg, vippad_y_so) (reg)->bitfields.VIPPAD_Y_SO = vippad_y_so
#define set_VIPPAD_Y_vippad_y_sck(reg, vippad_y_sck) (reg)->bitfields.VIPPAD_Y_SCK = vippad_y_sck

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPPAD1_MASK regVIPPAD1_MASK;

#ifdef DEBUG
__inline void set_VIPPAD1_MASK_vippad_mask_vid(regVIPPAD1_MASK *reg, unsigned int vippad_mask_vid)
{
  reg->bitfields.VIPPAD_MASK_VID = vippad_mask_vid;
  if (reg->bitfields.VIPPAD_MASK_VID != vippad_mask_vid) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_MASK::VIPPAD_MASK_VID data too large\n");
}
__inline void set_VIPPAD1_MASK_vippad_mask_vpclk0(regVIPPAD1_MASK *reg, unsigned int vippad_mask_vpclk0)
{
  reg->bitfields.VIPPAD_MASK_VPCLK0 = vippad_mask_vpclk0;
  if (reg->bitfields.VIPPAD_MASK_VPCLK0 != vippad_mask_vpclk0) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_MASK::VIPPAD_MASK_VPCLK0 data too large\n");
}
__inline void set_VIPPAD1_MASK_vippad_mask_dvalid(regVIPPAD1_MASK *reg, unsigned int vippad_mask_dvalid)
{
  reg->bitfields.VIPPAD_MASK_DVALID = vippad_mask_dvalid;
  if (reg->bitfields.VIPPAD_MASK_DVALID != vippad_mask_dvalid) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_MASK::VIPPAD_MASK_DVALID data too large\n");
}
__inline void set_VIPPAD1_MASK_vippad_mask_psync(regVIPPAD1_MASK *reg, unsigned int vippad_mask_psync)
{
  reg->bitfields.VIPPAD_MASK_PSYNC = vippad_mask_psync;
  if (reg->bitfields.VIPPAD_MASK_PSYNC != vippad_mask_psync) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_MASK::VIPPAD_MASK_PSYNC data too large\n");
}
__inline void set_VIPPAD1_MASK_gpio_sync_output_en(regVIPPAD1_MASK *reg, unsigned int gpio_sync_output_en)
{
  reg->bitfields.GPIO_SYNC_OUTPUT_EN = gpio_sync_output_en;
  if (reg->bitfields.GPIO_SYNC_OUTPUT_EN != gpio_sync_output_en) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_MASK::GPIO_SYNC_OUTPUT_EN data too large\n");
}
#else
#define set_VIPPAD1_MASK_vippad_mask_vid(reg, vippad_mask_vid) (reg)->bitfields.VIPPAD_MASK_VID = vippad_mask_vid
#define set_VIPPAD1_MASK_vippad_mask_vpclk0(reg, vippad_mask_vpclk0) (reg)->bitfields.VIPPAD_MASK_VPCLK0 = vippad_mask_vpclk0
#define set_VIPPAD1_MASK_vippad_mask_dvalid(reg, vippad_mask_dvalid) (reg)->bitfields.VIPPAD_MASK_DVALID = vippad_mask_dvalid
#define set_VIPPAD1_MASK_vippad_mask_psync(reg, vippad_mask_psync) (reg)->bitfields.VIPPAD_MASK_PSYNC = vippad_mask_psync
#define set_VIPPAD1_MASK_gpio_sync_output_en(reg, gpio_sync_output_en) (reg)->bitfields.GPIO_SYNC_OUTPUT_EN = gpio_sync_output_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPPAD1_A regVIPPAD1_A;

#ifdef DEBUG
__inline void set_VIPPAD1_A_vippad_a_vid(regVIPPAD1_A *reg, unsigned int vippad_a_vid)
{
  reg->bitfields.VIPPAD_A_VID = vippad_a_vid;
  if (reg->bitfields.VIPPAD_A_VID != vippad_a_vid) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_A::VIPPAD_A_VID data too large\n");
}
__inline void set_VIPPAD1_A_vippad_a_vpclk0(regVIPPAD1_A *reg, unsigned int vippad_a_vpclk0)
{
  reg->bitfields.VIPPAD_A_VPCLK0 = vippad_a_vpclk0;
  if (reg->bitfields.VIPPAD_A_VPCLK0 != vippad_a_vpclk0) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_A::VIPPAD_A_VPCLK0 data too large\n");
}
__inline void set_VIPPAD1_A_vippad_a_dvalid(regVIPPAD1_A *reg, unsigned int vippad_a_dvalid)
{
  reg->bitfields.VIPPAD_A_DVALID = vippad_a_dvalid;
  if (reg->bitfields.VIPPAD_A_DVALID != vippad_a_dvalid) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_A::VIPPAD_A_DVALID data too large\n");
}
__inline void set_VIPPAD1_A_vippad_a_psync(regVIPPAD1_A *reg, unsigned int vippad_a_psync)
{
  reg->bitfields.VIPPAD_A_PSYNC = vippad_a_psync;
  if (reg->bitfields.VIPPAD_A_PSYNC != vippad_a_psync) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_A::VIPPAD_A_PSYNC data too large\n");
}
__inline void set_VIPPAD1_A_vippad_a_dvodata(regVIPPAD1_A *reg, unsigned int vippad_a_dvodata)
{
  reg->bitfields.VIPPAD_A_DVODATA = vippad_a_dvodata;
  if (reg->bitfields.VIPPAD_A_DVODATA != vippad_a_dvodata) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_A::VIPPAD_A_DVODATA data too large\n");
}
__inline void set_VIPPAD1_A_vippad_a_dvocntl(regVIPPAD1_A *reg, unsigned int vippad_a_dvocntl)
{
  reg->bitfields.VIPPAD_A_DVOCNTL = vippad_a_dvocntl;
  if (reg->bitfields.VIPPAD_A_DVOCNTL != vippad_a_dvocntl) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_A::VIPPAD_A_DVOCNTL data too large\n");
}
#else
#define set_VIPPAD1_A_vippad_a_vid(reg, vippad_a_vid) (reg)->bitfields.VIPPAD_A_VID = vippad_a_vid
#define set_VIPPAD1_A_vippad_a_vpclk0(reg, vippad_a_vpclk0) (reg)->bitfields.VIPPAD_A_VPCLK0 = vippad_a_vpclk0
#define set_VIPPAD1_A_vippad_a_dvalid(reg, vippad_a_dvalid) (reg)->bitfields.VIPPAD_A_DVALID = vippad_a_dvalid
#define set_VIPPAD1_A_vippad_a_psync(reg, vippad_a_psync) (reg)->bitfields.VIPPAD_A_PSYNC = vippad_a_psync
#define set_VIPPAD1_A_vippad_a_dvodata(reg, vippad_a_dvodata) (reg)->bitfields.VIPPAD_A_DVODATA = vippad_a_dvodata
#define set_VIPPAD1_A_vippad_a_dvocntl(reg, vippad_a_dvocntl) (reg)->bitfields.VIPPAD_A_DVOCNTL = vippad_a_dvocntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPPAD1_EN regVIPPAD1_EN;

#ifdef DEBUG
__inline void set_VIPPAD1_EN_vippad_en_vid(regVIPPAD1_EN *reg, unsigned int vippad_en_vid)
{
  reg->bitfields.VIPPAD_EN_VID = vippad_en_vid;
  if (reg->bitfields.VIPPAD_EN_VID != vippad_en_vid) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_EN::VIPPAD_EN_VID data too large\n");
}
__inline void set_VIPPAD1_EN_vippad_en_vpclk0(regVIPPAD1_EN *reg, unsigned int vippad_en_vpclk0)
{
  reg->bitfields.VIPPAD_EN_VPCLK0 = vippad_en_vpclk0;
  if (reg->bitfields.VIPPAD_EN_VPCLK0 != vippad_en_vpclk0) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_EN::VIPPAD_EN_VPCLK0 data too large\n");
}
__inline void set_VIPPAD1_EN_vippad_en_dvalid(regVIPPAD1_EN *reg, unsigned int vippad_en_dvalid)
{
  reg->bitfields.VIPPAD_EN_DVALID = vippad_en_dvalid;
  if (reg->bitfields.VIPPAD_EN_DVALID != vippad_en_dvalid) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_EN::VIPPAD_EN_DVALID data too large\n");
}
__inline void set_VIPPAD1_EN_vippad_en_psync(regVIPPAD1_EN *reg, unsigned int vippad_en_psync)
{
  reg->bitfields.VIPPAD_EN_PSYNC = vippad_en_psync;
  if (reg->bitfields.VIPPAD_EN_PSYNC != vippad_en_psync) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_EN::VIPPAD_EN_PSYNC data too large\n");
}
__inline void set_VIPPAD1_EN_vippad_en_dvodata(regVIPPAD1_EN *reg, unsigned int vippad_en_dvodata)
{
  reg->bitfields.VIPPAD_EN_DVODATA = vippad_en_dvodata;
  if (reg->bitfields.VIPPAD_EN_DVODATA != vippad_en_dvodata) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_EN::VIPPAD_EN_DVODATA data too large\n");
}
__inline void set_VIPPAD1_EN_vippad_en_dvocntl(regVIPPAD1_EN *reg, unsigned int vippad_en_dvocntl)
{
  reg->bitfields.VIPPAD_EN_DVOCNTL = vippad_en_dvocntl;
  if (reg->bitfields.VIPPAD_EN_DVOCNTL != vippad_en_dvocntl) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_EN::VIPPAD_EN_DVOCNTL data too large\n");
}
#else
#define set_VIPPAD1_EN_vippad_en_vid(reg, vippad_en_vid) (reg)->bitfields.VIPPAD_EN_VID = vippad_en_vid
#define set_VIPPAD1_EN_vippad_en_vpclk0(reg, vippad_en_vpclk0) (reg)->bitfields.VIPPAD_EN_VPCLK0 = vippad_en_vpclk0
#define set_VIPPAD1_EN_vippad_en_dvalid(reg, vippad_en_dvalid) (reg)->bitfields.VIPPAD_EN_DVALID = vippad_en_dvalid
#define set_VIPPAD1_EN_vippad_en_psync(reg, vippad_en_psync) (reg)->bitfields.VIPPAD_EN_PSYNC = vippad_en_psync
#define set_VIPPAD1_EN_vippad_en_dvodata(reg, vippad_en_dvodata) (reg)->bitfields.VIPPAD_EN_DVODATA = vippad_en_dvodata
#define set_VIPPAD1_EN_vippad_en_dvocntl(reg, vippad_en_dvocntl) (reg)->bitfields.VIPPAD_EN_DVOCNTL = vippad_en_dvocntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VIPPAD1_Y regVIPPAD1_Y;

#ifdef DEBUG
__inline void set_VIPPAD1_Y_vippad_y_vid(regVIPPAD1_Y *reg, unsigned int vippad_y_vid)
{
  reg->bitfields.VIPPAD_Y_VID = vippad_y_vid;
  if (reg->bitfields.VIPPAD_Y_VID != vippad_y_vid) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_Y::VIPPAD_Y_VID data too large\n");
}
__inline void set_VIPPAD1_Y_vippad_y_vpclk0(regVIPPAD1_Y *reg, unsigned int vippad_y_vpclk0)
{
  reg->bitfields.VIPPAD_Y_VPCLK0 = vippad_y_vpclk0;
  if (reg->bitfields.VIPPAD_Y_VPCLK0 != vippad_y_vpclk0) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_Y::VIPPAD_Y_VPCLK0 data too large\n");
}
__inline void set_VIPPAD1_Y_vippad_y_dvalid(regVIPPAD1_Y *reg, unsigned int vippad_y_dvalid)
{
  reg->bitfields.VIPPAD_Y_DVALID = vippad_y_dvalid;
  if (reg->bitfields.VIPPAD_Y_DVALID != vippad_y_dvalid) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_Y::VIPPAD_Y_DVALID data too large\n");
}
__inline void set_VIPPAD1_Y_vippad_y_psync(regVIPPAD1_Y *reg, unsigned int vippad_y_psync)
{
  reg->bitfields.VIPPAD_Y_PSYNC = vippad_y_psync;
  if (reg->bitfields.VIPPAD_Y_PSYNC != vippad_y_psync) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_Y::VIPPAD_Y_PSYNC data too large\n");
}
__inline void set_VIPPAD1_Y_vippad_y_dvodata(regVIPPAD1_Y *reg, unsigned int vippad_y_dvodata)
{
  reg->bitfields.VIPPAD_Y_DVODATA = vippad_y_dvodata;
  if (reg->bitfields.VIPPAD_Y_DVODATA != vippad_y_dvodata) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_Y::VIPPAD_Y_DVODATA data too large\n");
}
__inline void set_VIPPAD1_Y_vippad_y_dvocntl(regVIPPAD1_Y *reg, unsigned int vippad_y_dvocntl)
{
  reg->bitfields.VIPPAD_Y_DVOCNTL = vippad_y_dvocntl;
  if (reg->bitfields.VIPPAD_Y_DVOCNTL != vippad_y_dvocntl) HSLDPF(E_ERROR_MESSAGE,"VIPPAD1_Y::VIPPAD_Y_DVOCNTL data too large\n");
}
#else
#define set_VIPPAD1_Y_vippad_y_vid(reg, vippad_y_vid) (reg)->bitfields.VIPPAD_Y_VID = vippad_y_vid
#define set_VIPPAD1_Y_vippad_y_vpclk0(reg, vippad_y_vpclk0) (reg)->bitfields.VIPPAD_Y_VPCLK0 = vippad_y_vpclk0
#define set_VIPPAD1_Y_vippad_y_dvalid(reg, vippad_y_dvalid) (reg)->bitfields.VIPPAD_Y_DVALID = vippad_y_dvalid
#define set_VIPPAD1_Y_vippad_y_psync(reg, vippad_y_psync) (reg)->bitfields.VIPPAD_Y_PSYNC = vippad_y_psync
#define set_VIPPAD1_Y_vippad_y_dvodata(reg, vippad_y_dvodata) (reg)->bitfields.VIPPAD_Y_DVODATA = vippad_y_dvodata
#define set_VIPPAD1_Y_vippad_y_dvocntl(reg, vippad_y_dvocntl) (reg)->bitfields.VIPPAD_Y_DVOCNTL = vippad_y_dvocntl

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MAXX_PWM regMAXX_PWM;

#ifdef DEBUG
__inline void set_MAXX_PWM_pwm_inc(regMAXX_PWM *reg, unsigned int pwm_inc)
{
  reg->bitfields.PWM_INC = pwm_inc;
  if (reg->bitfields.PWM_INC != pwm_inc) HSLDPF(E_ERROR_MESSAGE,"MAXX_PWM::PWM_INC data too large\n");
}
__inline void set_MAXX_PWM_pwm_clk_div(regMAXX_PWM *reg, unsigned int pwm_clk_div)
{
  reg->bitfields.PWM_CLK_DIV = pwm_clk_div;
  if (reg->bitfields.PWM_CLK_DIV != pwm_clk_div) HSLDPF(E_ERROR_MESSAGE,"MAXX_PWM::PWM_CLK_DIV data too large\n");
}
__inline void set_MAXX_PWM_pwm_out_en(regMAXX_PWM *reg, unsigned int pwm_out_en)
{
  reg->bitfields.PWM_OUT_EN = pwm_out_en;
  if (reg->bitfields.PWM_OUT_EN != pwm_out_en) HSLDPF(E_ERROR_MESSAGE,"MAXX_PWM::PWM_OUT_EN data too large\n");
}
#else
#define set_MAXX_PWM_pwm_inc(reg, pwm_inc) (reg)->bitfields.PWM_INC = pwm_inc
#define set_MAXX_PWM_pwm_clk_div(reg, pwm_clk_div) (reg)->bitfields.PWM_CLK_DIV = pwm_clk_div
#define set_MAXX_PWM_pwm_out_en(reg, pwm_out_en) (reg)->bitfields.PWM_OUT_EN = pwm_out_en

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union VID_BUFFER_CONTROL regVID_BUFFER_CONTROL;

#ifdef DEBUG
__inline void set_VID_BUFFER_CONTROL_cap0_buffer_water_mark_r2(regVID_BUFFER_CONTROL *reg, unsigned int cap0_buffer_water_mark_r2)
{
  reg->bitfields.CAP0_BUFFER_WATER_MARK_R2 = cap0_buffer_water_mark_r2;
  if (reg->bitfields.CAP0_BUFFER_WATER_MARK_R2 != cap0_buffer_water_mark_r2) HSLDPF(E_ERROR_MESSAGE,"VID_BUFFER_CONTROL::CAP0_BUFFER_WATER_MARK_R2 data too large\n");
}
__inline void set_VID_BUFFER_CONTROL_full_buffer_en(regVID_BUFFER_CONTROL *reg, unsigned int full_buffer_en)
{
  reg->bitfields.FULL_BUFFER_EN = full_buffer_en;
  if (reg->bitfields.FULL_BUFFER_EN != full_buffer_en) HSLDPF(E_ERROR_MESSAGE,"VID_BUFFER_CONTROL::FULL_BUFFER_EN data too large\n");
}
__inline void set_VID_BUFFER_CONTROL_cap0_anc_vbi_quad_buf(regVID_BUFFER_CONTROL *reg, unsigned int cap0_anc_vbi_quad_buf)
{
  reg->bitfields.CAP0_ANC_VBI_QUAD_BUF = cap0_anc_vbi_quad_buf;
  if (reg->bitfields.CAP0_ANC_VBI_QUAD_BUF != cap0_anc_vbi_quad_buf) HSLDPF(E_ERROR_MESSAGE,"VID_BUFFER_CONTROL::CAP0_ANC_VBI_QUAD_BUF data too large\n");
}
__inline void set_VID_BUFFER_CONTROL_vid_buffer_reset(regVID_BUFFER_CONTROL *reg, unsigned int vid_buffer_reset)
{
  reg->bitfields.VID_BUFFER_RESET = vid_buffer_reset;
  if (reg->bitfields.VID_BUFFER_RESET != vid_buffer_reset) HSLDPF(E_ERROR_MESSAGE,"VID_BUFFER_CONTROL::VID_BUFFER_RESET data too large\n");
}
__inline void set_VID_BUFFER_CONTROL_cap_swap(regVID_BUFFER_CONTROL *reg, unsigned int cap_swap)
{
  reg->bitfields.CAP_SWAP = cap_swap;
  if (reg->bitfields.CAP_SWAP != cap_swap) HSLDPF(E_ERROR_MESSAGE,"VID_BUFFER_CONTROL::CAP_SWAP data too large\n");
}
__inline void set_VID_BUFFER_CONTROL_cap0_buffer_empty(regVID_BUFFER_CONTROL *reg, unsigned int cap0_buffer_empty)
{
  reg->bitfields.CAP0_BUFFER_EMPTY = cap0_buffer_empty;
  if (reg->bitfields.CAP0_BUFFER_EMPTY != cap0_buffer_empty) HSLDPF(E_ERROR_MESSAGE,"VID_BUFFER_CONTROL::CAP0_BUFFER_EMPTY data too large\n");
}
#else
#define set_VID_BUFFER_CONTROL_cap0_buffer_water_mark_r2(reg, cap0_buffer_water_mark_r2) (reg)->bitfields.CAP0_BUFFER_WATER_MARK_R2 = cap0_buffer_water_mark_r2
#define set_VID_BUFFER_CONTROL_full_buffer_en(reg, full_buffer_en) (reg)->bitfields.FULL_BUFFER_EN = full_buffer_en
#define set_VID_BUFFER_CONTROL_cap0_anc_vbi_quad_buf(reg, cap0_anc_vbi_quad_buf) (reg)->bitfields.CAP0_ANC_VBI_QUAD_BUF = cap0_anc_vbi_quad_buf
#define set_VID_BUFFER_CONTROL_vid_buffer_reset(reg, vid_buffer_reset) (reg)->bitfields.VID_BUFFER_RESET = vid_buffer_reset
#define set_VID_BUFFER_CONTROL_cap_swap(reg, cap_swap) (reg)->bitfields.CAP_SWAP = cap_swap
#define set_VID_BUFFER_CONTROL_cap0_buffer_empty(reg, cap0_buffer_empty) (reg)->bitfields.CAP0_BUFFER_EMPTY = cap0_buffer_empty

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CAP0_CONFIG regCAP0_CONFIG;

#ifdef DEBUG
__inline void set_CAP0_CONFIG_cap_input_mode(regCAP0_CONFIG *reg, unsigned int cap_input_mode)
{
  reg->bitfields.CAP_INPUT_MODE = cap_input_mode;
  if (reg->bitfields.CAP_INPUT_MODE != cap_input_mode) HSLDPF(E_ERROR_MESSAGE,"CAP0_CONFIG::CAP_INPUT_MODE data too large\n");
}
__inline void set_CAP0_CONFIG_cap_start_field(regCAP0_CONFIG *reg, unsigned int cap_start_field)
{
  reg->bitfields.CAP_START_FIELD = cap_start_field;
  if (reg->bitfields.CAP_START_FIELD != cap_start_field) HSLDPF(E_ERROR_MESSAGE,"CAP0_CONFIG::CAP_START_FIELD data too large\n");
}
__inline void set_CAP0_CONFIG_cap_start_buf_r(regCAP0_CONFIG *reg, unsigned int cap_start_buf_r)
{
  reg->bitfields.CAP_START_BUF_R = cap_start_buf_r;
  if (reg->bitfields.CAP_START_BUF_R != cap_start_buf_r) HSLDPF(E_ERROR_MESSAGE,"CAP0_CONFIG::CAP_START_BUF_R data too large\n");
}
__inline void set_CAP0_CONFIG_cap_start_buf_w(regCAP0_CONFIG *reg, unsigned int cap_start_buf_w)
{
  reg->bitfields.CAP_START_BUF_W = cap_start_buf_w;
  if (reg->bitfields.CAP_START_BUF_W != cap_start_buf_w) HSLDPF(E_ERROR_MESSAGE,"CAP0_CONFIG::CAP_START_BUF_W data too large\n");
}
__inline void set_CAP0_CONFIG_cap_buf_type(regCAP0_CONFIG *reg, unsigned int cap_buf_type)
{
  reg->bitfields.CAP_BUF_TYPE = cap_buf_type;
  if (reg->bitfields.CAP_BUF_TYPE != cap_buf_type) HSLDPF(E_ERROR_MESSAGE,"CAP0_CONFIG::CAP_BUF_TYPE data too large\n");
}
__inline void set_CAP0_CONFIG_cap_oneshot_mode(regCAP0_CONFIG *reg, unsigned int cap_oneshot_mode)
{
  reg->bitfields.CAP_ONESHOT_MODE = cap_oneshot_mode;
  if (reg->bitfields.CAP_ONESHOT_MODE != cap_oneshot_mode) HSLDPF(E_ERROR_MESSAGE,"CAP0_CONFIG::CAP_ONESHOT_MODE data too large\n");
}
__inline void set_CAP0_CONFIG_cap_buf_mode(regCAP0_CONFIG *reg, unsigned int cap_buf_mode)
{
  reg->bitfields.CAP_BUF_MODE = cap_buf_mode;
  if (reg->bitfields.CAP_BUF_MODE != cap_buf_mode) HSLDPF(E_ERROR_MESSAGE,"CAP0_CONFIG::CAP_BUF_MODE data too large\n");
}
__inline void set_CAP0_CONFIG_cap_mirror_en(regCAP0_CONFIG *reg, unsigned int cap_mirror_en)
{
  reg->bitfields.CAP_MIRROR_EN = cap_mirror_en;
  if (reg->bitfields.CAP_MIRROR_EN != cap_mirror_en) HSLDPF(E_ERROR_MESSAGE,"CAP0_CONFIG::CAP_MIRROR_EN data too large\n");
}
__inline void set_CAP0_CONFIG_cap_oneshot_mirror_en(regCAP0_CONFIG *reg, unsigned int cap_oneshot_mirror_en)
{
  reg->bitfields.CAP_ONESHOT_MIRROR_EN = cap_oneshot_mirror_en;
  if (reg->bitfields.CAP_ONESHOT_MIRROR_EN != cap_oneshot_mirror_en) HSLDPF(E_ERROR_MESSAGE,"CAP0_CONFIG::CAP_ONESHOT_MIRROR_EN data too large\n");
}
__inline void set_CAP0_CONFIG_cap_video_signed_uv(regCAP0_CONFIG *reg, unsigned int cap_video_signed_uv)
{
  reg->bitfields.CAP_VIDEO_SIGNED_UV = cap_video_signed_uv;
  if (reg->bitfields.CAP_VIDEO_SIGNED_UV != cap_video_signed_uv) HSLDPF(E_ERROR_MESSAGE,"CAP0_CONFIG::CAP_VIDEO_SIGNED_UV data too large\n");
}
__inline void set_CAP0_CONFIG_cap_anc_decode_en(regCAP0_CONFIG *reg, unsigned int cap_anc_decode_en)
{
  reg->bitfields.CAP_ANC_DECODE_EN = cap_anc_decode_en;
  if (reg->bitfields.CAP_ANC_DECODE_EN != cap_anc_decode_en) HSLDPF(E_ERROR_MESSAGE,"CAP0_CONFIG::CAP_ANC_DECODE_EN data too large\n");
}
__inline void set_CAP0_CONFIG_cap_vbi_en(regCAP0_CONFIG *reg, unsigned int cap_vbi_en)
{
  reg->bitfields.CAP_VBI_EN = cap_vbi_en;
  if (reg->bitfields.CAP_VBI_EN != cap_vbi_en) HSLDPF(E_ERROR_MESSAGE,"CAP0_CONFIG::CAP_VBI_EN data too large\n");
}
__inline void set_CAP0_CONFIG_cap_soft_pull_down_en(regCAP0_CONFIG *reg, unsigned int cap_soft_pull_down_en)
{
  reg->bitfields.CAP_SOFT_PULL_DOWN_EN = cap_soft_pull_down_en;
  if (reg->bitfields.CAP_SOFT_PULL_DOWN_EN != cap_soft_pull_down_en) HSLDPF(E_ERROR_MESSAGE,"CAP0_CONFIG::CAP_SOFT_PULL_DOWN_EN data too large\n");
}
__inline void set_CAP0_CONFIG_cap_vip_extend_flag_en(regCAP0_CONFIG *reg, unsigned int cap_vip_extend_flag_en)
{
  reg->bitfields.CAP_VIP_EXTEND_FLAG_EN = cap_vip_extend_flag_en;
  if (reg->bitfields.CAP_VIP_EXTEND_FLAG_EN != cap_vip_extend_flag_en) HSLDPF(E_ERROR_MESSAGE,"CAP0_CONFIG::CAP_VIP_EXTEND_FLAG_EN data too large\n");
}
__inline void set_CAP0_CONFIG_cap_fake_field_en(regCAP0_CONFIG *reg, unsigned int cap_fake_field_en)
{
  reg->bitfields.CAP_FAKE_FIELD_EN = cap_fake_field_en;
  if (reg->bitfields.CAP_FAKE_FIELD_EN != cap_fake_field_en) HSLDPF(E_ERROR_MESSAGE,"CAP0_CONFIG::CAP_FAKE_FIELD_EN data too large\n");
}
__inline void set_CAP0_CONFIG_cap_field_start_line_diff(regCAP0_CONFIG *reg, unsigned int cap_field_start_line_diff)
{
  reg->bitfields.CAP_FIELD_START_LINE_DIFF = cap_field_start_line_diff;
  if (reg->bitfields.CAP_FIELD_START_LINE_DIFF != cap_field_start_line_diff) HSLDPF(E_ERROR_MESSAGE,"CAP0_CONFIG::CAP_FIELD_START_LINE_DIFF data too large\n");
}
__inline void set_CAP0_CONFIG_cap_horz_down(regCAP0_CONFIG *reg, unsigned int cap_horz_down)
{
  reg->bitfields.CAP_HORZ_DOWN = cap_horz_down;
  if (reg->bitfields.CAP_HORZ_DOWN != cap_horz_down) HSLDPF(E_ERROR_MESSAGE,"CAP0_CONFIG::CAP_HORZ_DOWN data too large\n");
}
__inline void set_CAP0_CONFIG_cap_vert_down(regCAP0_CONFIG *reg, unsigned int cap_vert_down)
{
  reg->bitfields.CAP_VERT_DOWN = cap_vert_down;
  if (reg->bitfields.CAP_VERT_DOWN != cap_vert_down) HSLDPF(E_ERROR_MESSAGE,"CAP0_CONFIG::CAP_VERT_DOWN data too large\n");
}
__inline void set_CAP0_CONFIG_cap_stream_format(regCAP0_CONFIG *reg, unsigned int cap_stream_format)
{
  reg->bitfields.CAP_STREAM_FORMAT = cap_stream_format;
  if (reg->bitfields.CAP_STREAM_FORMAT != cap_stream_format) HSLDPF(E_ERROR_MESSAGE,"CAP0_CONFIG::CAP_STREAM_FORMAT data too large\n");
}
__inline void set_CAP0_CONFIG_cap_hdwns_dec(regCAP0_CONFIG *reg, unsigned int cap_hdwns_dec)
{
  reg->bitfields.CAP_HDWNS_DEC = cap_hdwns_dec;
  if (reg->bitfields.CAP_HDWNS_DEC != cap_hdwns_dec) HSLDPF(E_ERROR_MESSAGE,"CAP0_CONFIG::CAP_HDWNS_DEC data too large\n");
}
__inline void set_CAP0_CONFIG_cap_video_in_format(regCAP0_CONFIG *reg, unsigned int cap_video_in_format)
{
  reg->bitfields.CAP_VIDEO_IN_FORMAT = cap_video_in_format;
  if (reg->bitfields.CAP_VIDEO_IN_FORMAT != cap_video_in_format) HSLDPF(E_ERROR_MESSAGE,"CAP0_CONFIG::CAP_VIDEO_IN_FORMAT data too large\n");
}
__inline void set_CAP0_CONFIG_vbi_horz_down(regCAP0_CONFIG *reg, unsigned int vbi_horz_down)
{
  reg->bitfields.VBI_HORZ_DOWN = vbi_horz_down;
  if (reg->bitfields.VBI_HORZ_DOWN != vbi_horz_down) HSLDPF(E_ERROR_MESSAGE,"CAP0_CONFIG::VBI_HORZ_DOWN data too large\n");
}
#else
#define set_CAP0_CONFIG_cap_input_mode(reg, cap_input_mode) (reg)->bitfields.CAP_INPUT_MODE = cap_input_mode
#define set_CAP0_CONFIG_cap_start_field(reg, cap_start_field) (reg)->bitfields.CAP_START_FIELD = cap_start_field
#define set_CAP0_CONFIG_cap_start_buf_r(reg, cap_start_buf_r) (reg)->bitfields.CAP_START_BUF_R = cap_start_buf_r
#define set_CAP0_CONFIG_cap_start_buf_w(reg, cap_start_buf_w) (reg)->bitfields.CAP_START_BUF_W = cap_start_buf_w
#define set_CAP0_CONFIG_cap_buf_type(reg, cap_buf_type) (reg)->bitfields.CAP_BUF_TYPE = cap_buf_type
#define set_CAP0_CONFIG_cap_oneshot_mode(reg, cap_oneshot_mode) (reg)->bitfields.CAP_ONESHOT_MODE = cap_oneshot_mode
#define set_CAP0_CONFIG_cap_buf_mode(reg, cap_buf_mode) (reg)->bitfields.CAP_BUF_MODE = cap_buf_mode
#define set_CAP0_CONFIG_cap_mirror_en(reg, cap_mirror_en) (reg)->bitfields.CAP_MIRROR_EN = cap_mirror_en
#define set_CAP0_CONFIG_cap_oneshot_mirror_en(reg, cap_oneshot_mirror_en) (reg)->bitfields.CAP_ONESHOT_MIRROR_EN = cap_oneshot_mirror_en
#define set_CAP0_CONFIG_cap_video_signed_uv(reg, cap_video_signed_uv) (reg)->bitfields.CAP_VIDEO_SIGNED_UV = cap_video_signed_uv
#define set_CAP0_CONFIG_cap_anc_decode_en(reg, cap_anc_decode_en) (reg)->bitfields.CAP_ANC_DECODE_EN = cap_anc_decode_en
#define set_CAP0_CONFIG_cap_vbi_en(reg, cap_vbi_en) (reg)->bitfields.CAP_VBI_EN = cap_vbi_en
#define set_CAP0_CONFIG_cap_soft_pull_down_en(reg, cap_soft_pull_down_en) (reg)->bitfields.CAP_SOFT_PULL_DOWN_EN = cap_soft_pull_down_en
#define set_CAP0_CONFIG_cap_vip_extend_flag_en(reg, cap_vip_extend_flag_en) (reg)->bitfields.CAP_VIP_EXTEND_FLAG_EN = cap_vip_extend_flag_en
#define set_CAP0_CONFIG_cap_fake_field_en(reg, cap_fake_field_en) (reg)->bitfields.CAP_FAKE_FIELD_EN = cap_fake_field_en
#define set_CAP0_CONFIG_cap_field_start_line_diff(reg, cap_field_start_line_diff) (reg)->bitfields.CAP_FIELD_START_LINE_DIFF = cap_field_start_line_diff
#define set_CAP0_CONFIG_cap_horz_down(reg, cap_horz_down) (reg)->bitfields.CAP_HORZ_DOWN = cap_horz_down
#define set_CAP0_CONFIG_cap_vert_down(reg, cap_vert_down) (reg)->bitfields.CAP_VERT_DOWN = cap_vert_down
#define set_CAP0_CONFIG_cap_stream_format(reg, cap_stream_format) (reg)->bitfields.CAP_STREAM_FORMAT = cap_stream_format
#define set_CAP0_CONFIG_cap_hdwns_dec(reg, cap_hdwns_dec) (reg)->bitfields.CAP_HDWNS_DEC = cap_hdwns_dec
#define set_CAP0_CONFIG_cap_video_in_format(reg, cap_video_in_format) (reg)->bitfields.CAP_VIDEO_IN_FORMAT = cap_video_in_format
#define set_CAP0_CONFIG_vbi_horz_down(reg, vbi_horz_down) (reg)->bitfields.VBI_HORZ_DOWN = vbi_horz_down

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union r200SPLL_AUX_CNTL regr200SPLL_AUX_CNTL;

#ifdef DEBUG
__inline void set_r200SPLL_AUX_CNTL_spll_pdc_c(regr200SPLL_AUX_CNTL *reg, unsigned int spll_pdc_c)
{
  reg->bitfields.SPLL_PDC_C = spll_pdc_c;
  if (reg->bitfields.SPLL_PDC_C != spll_pdc_c) HSLDPF(E_ERROR_MESSAGE,"r200SPLL_AUX_CNTL::SPLL_PDC_C data too large\n");
}
__inline void set_r200SPLL_AUX_CNTL_spll_ckinva(regr200SPLL_AUX_CNTL *reg, unsigned int spll_ckinva)
{
  reg->bitfields.SPLL_CKINVA = spll_ckinva;
  if (reg->bitfields.SPLL_CKINVA != spll_ckinva) HSLDPF(E_ERROR_MESSAGE,"r200SPLL_AUX_CNTL::SPLL_CKINVA data too large\n");
}
__inline void set_r200SPLL_AUX_CNTL_spll_ckinvc(regr200SPLL_AUX_CNTL *reg, unsigned int spll_ckinvc)
{
  reg->bitfields.SPLL_CKINVC = spll_ckinvc;
  if (reg->bitfields.SPLL_CKINVC != spll_ckinvc) HSLDPF(E_ERROR_MESSAGE,"r200SPLL_AUX_CNTL::SPLL_CKINVC data too large\n");
}
__inline void set_r200SPLL_AUX_CNTL_spll_x3_clk_skew(regr200SPLL_AUX_CNTL *reg, unsigned int spll_x3_clk_skew)
{
  reg->bitfields.SPLL_X3_CLK_SKEW = spll_x3_clk_skew;
  if (reg->bitfields.SPLL_X3_CLK_SKEW != spll_x3_clk_skew) HSLDPF(E_ERROR_MESSAGE,"r200SPLL_AUX_CNTL::SPLL_X3_CLK_SKEW data too large\n");
}
__inline void set_r200SPLL_AUX_CNTL_spll_modec(regr200SPLL_AUX_CNTL *reg, unsigned int spll_modec)
{
  reg->bitfields.SPLL_MODEC = spll_modec;
  if (reg->bitfields.SPLL_MODEC != spll_modec) HSLDPF(E_ERROR_MESSAGE,"r200SPLL_AUX_CNTL::SPLL_MODEC data too large\n");
}
__inline void set_r200SPLL_AUX_CNTL_transit_done_length(regr200SPLL_AUX_CNTL *reg, unsigned int transit_done_length)
{
  reg->bitfields.TRANSIT_DONE_LENGTH = transit_done_length;
  if (reg->bitfields.TRANSIT_DONE_LENGTH != transit_done_length) HSLDPF(E_ERROR_MESSAGE,"r200SPLL_AUX_CNTL::TRANSIT_DONE_LENGTH data too large\n");
}
#else
#define set_r200SPLL_AUX_CNTL_spll_pdc_c(reg, spll_pdc_c) (reg)->bitfields.SPLL_PDC_C = spll_pdc_c
#define set_r200SPLL_AUX_CNTL_spll_ckinva(reg, spll_ckinva) (reg)->bitfields.SPLL_CKINVA = spll_ckinva
#define set_r200SPLL_AUX_CNTL_spll_ckinvc(reg, spll_ckinvc) (reg)->bitfields.SPLL_CKINVC = spll_ckinvc
#define set_r200SPLL_AUX_CNTL_spll_x3_clk_skew(reg, spll_x3_clk_skew) (reg)->bitfields.SPLL_X3_CLK_SKEW = spll_x3_clk_skew
#define set_r200SPLL_AUX_CNTL_spll_modec(reg, spll_modec) (reg)->bitfields.SPLL_MODEC = spll_modec
#define set_r200SPLL_AUX_CNTL_transit_done_length(reg, transit_done_length) (reg)->bitfields.TRANSIT_DONE_LENGTH = transit_done_length

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union SCLK_CNTL regSCLK_CNTL;

#ifdef DEBUG
__inline void set_SCLK_CNTL_sclk_src_sel(regSCLK_CNTL *reg, unsigned int sclk_src_sel)
{
  reg->bitfields.SCLK_SRC_SEL = sclk_src_sel;
  if (reg->bitfields.SCLK_SRC_SEL != sclk_src_sel) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::SCLK_SRC_SEL data too large\n");
}
__inline void set_SCLK_CNTL_cp_max_dyn_stop_lat(regSCLK_CNTL *reg, unsigned int cp_max_dyn_stop_lat)
{
  reg->bitfields.CP_MAX_DYN_STOP_LAT = cp_max_dyn_stop_lat;
  if (reg->bitfields.CP_MAX_DYN_STOP_LAT != cp_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::CP_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_hdp_max_dyn_stop_lat(regSCLK_CNTL *reg, unsigned int hdp_max_dyn_stop_lat)
{
  reg->bitfields.HDP_MAX_DYN_STOP_LAT = hdp_max_dyn_stop_lat;
  if (reg->bitfields.HDP_MAX_DYN_STOP_LAT != hdp_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::HDP_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_e2_max_dyn_stop_lat(regSCLK_CNTL *reg, unsigned int e2_max_dyn_stop_lat)
{
  reg->bitfields.E2_MAX_DYN_STOP_LAT = e2_max_dyn_stop_lat;
  if (reg->bitfields.E2_MAX_DYN_STOP_LAT != e2_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::E2_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_se_max_dyn_stop_lat(regSCLK_CNTL *reg, unsigned int se_max_dyn_stop_lat)
{
  reg->bitfields.SE_MAX_DYN_STOP_LAT = se_max_dyn_stop_lat;
  if (reg->bitfields.SE_MAX_DYN_STOP_LAT != se_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::SE_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_idct_max_dyn_stop_lat(regSCLK_CNTL *reg, unsigned int idct_max_dyn_stop_lat)
{
  reg->bitfields.IDCT_MAX_DYN_STOP_LAT = idct_max_dyn_stop_lat;
  if (reg->bitfields.IDCT_MAX_DYN_STOP_LAT != idct_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::IDCT_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_vip_max_dyn_stop_lat(regSCLK_CNTL *reg, unsigned int vip_max_dyn_stop_lat)
{
  reg->bitfields.VIP_MAX_DYN_STOP_LAT = vip_max_dyn_stop_lat;
  if (reg->bitfields.VIP_MAX_DYN_STOP_LAT != vip_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::VIP_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_re_max_dyn_stop_lat(regSCLK_CNTL *reg, unsigned int re_max_dyn_stop_lat)
{
  reg->bitfields.RE_MAX_DYN_STOP_LAT = re_max_dyn_stop_lat;
  if (reg->bitfields.RE_MAX_DYN_STOP_LAT != re_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::RE_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_pb_max_dyn_stop_lat(regSCLK_CNTL *reg, unsigned int pb_max_dyn_stop_lat)
{
  reg->bitfields.PB_MAX_DYN_STOP_LAT = pb_max_dyn_stop_lat;
  if (reg->bitfields.PB_MAX_DYN_STOP_LAT != pb_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::PB_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_tam_max_dyn_stop_lat(regSCLK_CNTL *reg, unsigned int tam_max_dyn_stop_lat)
{
  reg->bitfields.TAM_MAX_DYN_STOP_LAT = tam_max_dyn_stop_lat;
  if (reg->bitfields.TAM_MAX_DYN_STOP_LAT != tam_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::TAM_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_tdm_max_dyn_stop_lat(regSCLK_CNTL *reg, unsigned int tdm_max_dyn_stop_lat)
{
  reg->bitfields.TDM_MAX_DYN_STOP_LAT = tdm_max_dyn_stop_lat;
  if (reg->bitfields.TDM_MAX_DYN_STOP_LAT != tdm_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::TDM_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_rb_max_dyn_stop_lat(regSCLK_CNTL *reg, unsigned int rb_max_dyn_stop_lat)
{
  reg->bitfields.RB_MAX_DYN_STOP_LAT = rb_max_dyn_stop_lat;
  if (reg->bitfields.RB_MAX_DYN_STOP_LAT != rb_max_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::RB_MAX_DYN_STOP_LAT data too large\n");
}
__inline void set_SCLK_CNTL_force_disp2(regSCLK_CNTL *reg, unsigned int force_disp2)
{
  reg->bitfields.FORCE_DISP2 = force_disp2;
  if (reg->bitfields.FORCE_DISP2 != force_disp2) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::FORCE_DISP2 data too large\n");
}
__inline void set_SCLK_CNTL_force_cp(regSCLK_CNTL *reg, unsigned int force_cp)
{
  reg->bitfields.FORCE_CP = force_cp;
  if (reg->bitfields.FORCE_CP != force_cp) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::FORCE_CP data too large\n");
}
__inline void set_SCLK_CNTL_force_hdp(regSCLK_CNTL *reg, unsigned int force_hdp)
{
  reg->bitfields.FORCE_HDP = force_hdp;
  if (reg->bitfields.FORCE_HDP != force_hdp) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::FORCE_HDP data too large\n");
}
__inline void set_SCLK_CNTL_force_disp1(regSCLK_CNTL *reg, unsigned int force_disp1)
{
  reg->bitfields.FORCE_DISP1 = force_disp1;
  if (reg->bitfields.FORCE_DISP1 != force_disp1) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::FORCE_DISP1 data too large\n");
}
__inline void set_SCLK_CNTL_force_top(regSCLK_CNTL *reg, unsigned int force_top)
{
  reg->bitfields.FORCE_TOP = force_top;
  if (reg->bitfields.FORCE_TOP != force_top) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::FORCE_TOP data too large\n");
}
__inline void set_SCLK_CNTL_force_e2(regSCLK_CNTL *reg, unsigned int force_e2)
{
  reg->bitfields.FORCE_E2 = force_e2;
  if (reg->bitfields.FORCE_E2 != force_e2) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::FORCE_E2 data too large\n");
}
__inline void set_SCLK_CNTL_force_se(regSCLK_CNTL *reg, unsigned int force_se)
{
  reg->bitfields.FORCE_SE = force_se;
  if (reg->bitfields.FORCE_SE != force_se) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::FORCE_SE data too large\n");
}
__inline void set_SCLK_CNTL_force_idct(regSCLK_CNTL *reg, unsigned int force_idct)
{
  reg->bitfields.FORCE_IDCT = force_idct;
  if (reg->bitfields.FORCE_IDCT != force_idct) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::FORCE_IDCT data too large\n");
}
__inline void set_SCLK_CNTL_force_vip(regSCLK_CNTL *reg, unsigned int force_vip)
{
  reg->bitfields.FORCE_VIP = force_vip;
  if (reg->bitfields.FORCE_VIP != force_vip) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::FORCE_VIP data too large\n");
}
__inline void set_SCLK_CNTL_force_re(regSCLK_CNTL *reg, unsigned int force_re)
{
  reg->bitfields.FORCE_RE = force_re;
  if (reg->bitfields.FORCE_RE != force_re) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::FORCE_RE data too large\n");
}
__inline void set_SCLK_CNTL_force_pb(regSCLK_CNTL *reg, unsigned int force_pb)
{
  reg->bitfields.FORCE_PB = force_pb;
  if (reg->bitfields.FORCE_PB != force_pb) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::FORCE_PB data too large\n");
}
__inline void set_SCLK_CNTL_force_tam(regSCLK_CNTL *reg, unsigned int force_tam)
{
  reg->bitfields.FORCE_TAM = force_tam;
  if (reg->bitfields.FORCE_TAM != force_tam) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::FORCE_TAM data too large\n");
}
__inline void set_SCLK_CNTL_force_tdm(regSCLK_CNTL *reg, unsigned int force_tdm)
{
  reg->bitfields.FORCE_TDM = force_tdm;
  if (reg->bitfields.FORCE_TDM != force_tdm) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::FORCE_TDM data too large\n");
}
__inline void set_SCLK_CNTL_force_rb(regSCLK_CNTL *reg, unsigned int force_rb)
{
  reg->bitfields.FORCE_RB = force_rb;
  if (reg->bitfields.FORCE_RB != force_rb) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::FORCE_RB data too large\n");
}
__inline void set_SCLK_CNTL_force_subpic(regSCLK_CNTL *reg, unsigned int force_subpic)
{
  reg->bitfields.FORCE_SUBPIC = force_subpic;
  if (reg->bitfields.FORCE_SUBPIC != force_subpic) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::FORCE_SUBPIC data too large\n");
}
__inline void set_SCLK_CNTL_force_ov0(regSCLK_CNTL *reg, unsigned int force_ov0)
{
  reg->bitfields.FORCE_OV0 = force_ov0;
  if (reg->bitfields.FORCE_OV0 != force_ov0) HSLDPF(E_ERROR_MESSAGE,"SCLK_CNTL::FORCE_OV0 data too large\n");
}
#else
#define set_SCLK_CNTL_sclk_src_sel(reg, sclk_src_sel) (reg)->bitfields.SCLK_SRC_SEL = sclk_src_sel
#define set_SCLK_CNTL_cp_max_dyn_stop_lat(reg, cp_max_dyn_stop_lat) (reg)->bitfields.CP_MAX_DYN_STOP_LAT = cp_max_dyn_stop_lat
#define set_SCLK_CNTL_hdp_max_dyn_stop_lat(reg, hdp_max_dyn_stop_lat) (reg)->bitfields.HDP_MAX_DYN_STOP_LAT = hdp_max_dyn_stop_lat
#define set_SCLK_CNTL_e2_max_dyn_stop_lat(reg, e2_max_dyn_stop_lat) (reg)->bitfields.E2_MAX_DYN_STOP_LAT = e2_max_dyn_stop_lat
#define set_SCLK_CNTL_se_max_dyn_stop_lat(reg, se_max_dyn_stop_lat) (reg)->bitfields.SE_MAX_DYN_STOP_LAT = se_max_dyn_stop_lat
#define set_SCLK_CNTL_idct_max_dyn_stop_lat(reg, idct_max_dyn_stop_lat) (reg)->bitfields.IDCT_MAX_DYN_STOP_LAT = idct_max_dyn_stop_lat
#define set_SCLK_CNTL_vip_max_dyn_stop_lat(reg, vip_max_dyn_stop_lat) (reg)->bitfields.VIP_MAX_DYN_STOP_LAT = vip_max_dyn_stop_lat
#define set_SCLK_CNTL_re_max_dyn_stop_lat(reg, re_max_dyn_stop_lat) (reg)->bitfields.RE_MAX_DYN_STOP_LAT = re_max_dyn_stop_lat
#define set_SCLK_CNTL_pb_max_dyn_stop_lat(reg, pb_max_dyn_stop_lat) (reg)->bitfields.PB_MAX_DYN_STOP_LAT = pb_max_dyn_stop_lat
#define set_SCLK_CNTL_tam_max_dyn_stop_lat(reg, tam_max_dyn_stop_lat) (reg)->bitfields.TAM_MAX_DYN_STOP_LAT = tam_max_dyn_stop_lat
#define set_SCLK_CNTL_tdm_max_dyn_stop_lat(reg, tdm_max_dyn_stop_lat) (reg)->bitfields.TDM_MAX_DYN_STOP_LAT = tdm_max_dyn_stop_lat
#define set_SCLK_CNTL_rb_max_dyn_stop_lat(reg, rb_max_dyn_stop_lat) (reg)->bitfields.RB_MAX_DYN_STOP_LAT = rb_max_dyn_stop_lat
#define set_SCLK_CNTL_force_disp2(reg, force_disp2) (reg)->bitfields.FORCE_DISP2 = force_disp2
#define set_SCLK_CNTL_force_cp(reg, force_cp) (reg)->bitfields.FORCE_CP = force_cp
#define set_SCLK_CNTL_force_hdp(reg, force_hdp) (reg)->bitfields.FORCE_HDP = force_hdp
#define set_SCLK_CNTL_force_disp1(reg, force_disp1) (reg)->bitfields.FORCE_DISP1 = force_disp1
#define set_SCLK_CNTL_force_top(reg, force_top) (reg)->bitfields.FORCE_TOP = force_top
#define set_SCLK_CNTL_force_e2(reg, force_e2) (reg)->bitfields.FORCE_E2 = force_e2
#define set_SCLK_CNTL_force_se(reg, force_se) (reg)->bitfields.FORCE_SE = force_se
#define set_SCLK_CNTL_force_idct(reg, force_idct) (reg)->bitfields.FORCE_IDCT = force_idct
#define set_SCLK_CNTL_force_vip(reg, force_vip) (reg)->bitfields.FORCE_VIP = force_vip
#define set_SCLK_CNTL_force_re(reg, force_re) (reg)->bitfields.FORCE_RE = force_re
#define set_SCLK_CNTL_force_pb(reg, force_pb) (reg)->bitfields.FORCE_PB = force_pb
#define set_SCLK_CNTL_force_tam(reg, force_tam) (reg)->bitfields.FORCE_TAM = force_tam
#define set_SCLK_CNTL_force_tdm(reg, force_tdm) (reg)->bitfields.FORCE_TDM = force_tdm
#define set_SCLK_CNTL_force_rb(reg, force_rb) (reg)->bitfields.FORCE_RB = force_rb
#define set_SCLK_CNTL_force_subpic(reg, force_subpic) (reg)->bitfields.FORCE_SUBPIC = force_subpic
#define set_SCLK_CNTL_force_ov0(reg, force_ov0) (reg)->bitfields.FORCE_OV0 = force_ov0

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union CLK_PWRMGT_CNTL regCLK_PWRMGT_CNTL;

#ifdef DEBUG
__inline void set_CLK_PWRMGT_CNTL_mpll_pwrmgt_off(regCLK_PWRMGT_CNTL *reg, unsigned int mpll_pwrmgt_off)
{
  reg->bitfields.MPLL_PWRMGT_OFF = mpll_pwrmgt_off;
  if (reg->bitfields.MPLL_PWRMGT_OFF != mpll_pwrmgt_off) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL::MPLL_PWRMGT_OFF data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_spll_pwrmgt_off(regCLK_PWRMGT_CNTL *reg, unsigned int spll_pwrmgt_off)
{
  reg->bitfields.SPLL_PWRMGT_OFF = spll_pwrmgt_off;
  if (reg->bitfields.SPLL_PWRMGT_OFF != spll_pwrmgt_off) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL::SPLL_PWRMGT_OFF data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_ppll_pwrmgt_off(regCLK_PWRMGT_CNTL *reg, unsigned int ppll_pwrmgt_off)
{
  reg->bitfields.PPLL_PWRMGT_OFF = ppll_pwrmgt_off;
  if (reg->bitfields.PPLL_PWRMGT_OFF != ppll_pwrmgt_off) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL::PPLL_PWRMGT_OFF data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_p2pll_pwrmgt_off(regCLK_PWRMGT_CNTL *reg, unsigned int p2pll_pwrmgt_off)
{
  reg->bitfields.P2PLL_PWRMGT_OFF = p2pll_pwrmgt_off;
  if (reg->bitfields.P2PLL_PWRMGT_OFF != p2pll_pwrmgt_off) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL::P2PLL_PWRMGT_OFF data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_mclk_turnoff(regCLK_PWRMGT_CNTL *reg, unsigned int mclk_turnoff)
{
  reg->bitfields.MCLK_TURNOFF = mclk_turnoff;
  if (reg->bitfields.MCLK_TURNOFF != mclk_turnoff) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL::MCLK_TURNOFF data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_sclk_turnoff(regCLK_PWRMGT_CNTL *reg, unsigned int sclk_turnoff)
{
  reg->bitfields.SCLK_TURNOFF = sclk_turnoff;
  if (reg->bitfields.SCLK_TURNOFF != sclk_turnoff) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL::SCLK_TURNOFF data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_pclk_turnoff(regCLK_PWRMGT_CNTL *reg, unsigned int pclk_turnoff)
{
  reg->bitfields.PCLK_TURNOFF = pclk_turnoff;
  if (reg->bitfields.PCLK_TURNOFF != pclk_turnoff) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL::PCLK_TURNOFF data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_p2clk_turnoff(regCLK_PWRMGT_CNTL *reg, unsigned int p2clk_turnoff)
{
  reg->bitfields.P2CLK_TURNOFF = p2clk_turnoff;
  if (reg->bitfields.P2CLK_TURNOFF != p2clk_turnoff) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL::P2CLK_TURNOFF data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_mc_ch_mode(regCLK_PWRMGT_CNTL *reg, unsigned int mc_ch_mode)
{
  reg->bitfields.MC_CH_MODE = mc_ch_mode;
  if (reg->bitfields.MC_CH_MODE != mc_ch_mode) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL::MC_CH_MODE data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_test_mode(regCLK_PWRMGT_CNTL *reg, unsigned int test_mode)
{
  reg->bitfields.TEST_MODE = test_mode;
  if (reg->bitfields.TEST_MODE != test_mode) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL::TEST_MODE data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_global_pman_en(regCLK_PWRMGT_CNTL *reg, unsigned int global_pman_en)
{
  reg->bitfields.GLOBAL_PMAN_EN = global_pman_en;
  if (reg->bitfields.GLOBAL_PMAN_EN != global_pman_en) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL::GLOBAL_PMAN_EN data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_engine_dynclk_mode(regCLK_PWRMGT_CNTL *reg, unsigned int engine_dynclk_mode)
{
  reg->bitfields.ENGINE_DYNCLK_MODE = engine_dynclk_mode;
  if (reg->bitfields.ENGINE_DYNCLK_MODE != engine_dynclk_mode) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL::ENGINE_DYNCLK_MODE data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_active_hilo_lat(regCLK_PWRMGT_CNTL *reg, unsigned int active_hilo_lat)
{
  reg->bitfields.ACTIVE_HILO_LAT = active_hilo_lat;
  if (reg->bitfields.ACTIVE_HILO_LAT != active_hilo_lat) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL::ACTIVE_HILO_LAT data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_disp_dyn_stop_lat(regCLK_PWRMGT_CNTL *reg, unsigned int disp_dyn_stop_lat)
{
  reg->bitfields.DISP_DYN_STOP_LAT = disp_dyn_stop_lat;
  if (reg->bitfields.DISP_DYN_STOP_LAT != disp_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL::DISP_DYN_STOP_LAT data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_mc_busy(regCLK_PWRMGT_CNTL *reg, unsigned int mc_busy)
{
  reg->bitfields.MC_BUSY = mc_busy;
  if (reg->bitfields.MC_BUSY != mc_busy) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL::MC_BUSY data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_mc_int_cntl(regCLK_PWRMGT_CNTL *reg, unsigned int mc_int_cntl)
{
  reg->bitfields.MC_INT_CNTL = mc_int_cntl;
  if (reg->bitfields.MC_INT_CNTL != mc_int_cntl) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL::MC_INT_CNTL data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_mc_switch(regCLK_PWRMGT_CNTL *reg, unsigned int mc_switch)
{
  reg->bitfields.MC_SWITCH = mc_switch;
  if (reg->bitfields.MC_SWITCH != mc_switch) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL::MC_SWITCH data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_dll_ready(regCLK_PWRMGT_CNTL *reg, unsigned int dll_ready)
{
  reg->bitfields.DLL_READY = dll_ready;
  if (reg->bitfields.DLL_READY != dll_ready) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL::DLL_READY data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_disp_pm(regCLK_PWRMGT_CNTL *reg, unsigned int disp_pm)
{
  reg->bitfields.DISP_PM = disp_pm;
  if (reg->bitfields.DISP_PM != disp_pm) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL::DISP_PM data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_dyn_stop_mode(regCLK_PWRMGT_CNTL *reg, unsigned int dyn_stop_mode)
{
  reg->bitfields.DYN_STOP_MODE = dyn_stop_mode;
  if (reg->bitfields.DYN_STOP_MODE != dyn_stop_mode) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL::DYN_STOP_MODE data too large\n");
}
__inline void set_CLK_PWRMGT_CNTL_cg_no1_debug(regCLK_PWRMGT_CNTL *reg, unsigned int cg_no1_debug)
{
  reg->bitfields.CG_NO1_DEBUG = cg_no1_debug;
  if (reg->bitfields.CG_NO1_DEBUG != cg_no1_debug) HSLDPF(E_ERROR_MESSAGE,"CLK_PWRMGT_CNTL::CG_NO1_DEBUG data too large\n");
}
#else
#define set_CLK_PWRMGT_CNTL_mpll_pwrmgt_off(reg, mpll_pwrmgt_off) (reg)->bitfields.MPLL_PWRMGT_OFF = mpll_pwrmgt_off
#define set_CLK_PWRMGT_CNTL_spll_pwrmgt_off(reg, spll_pwrmgt_off) (reg)->bitfields.SPLL_PWRMGT_OFF = spll_pwrmgt_off
#define set_CLK_PWRMGT_CNTL_ppll_pwrmgt_off(reg, ppll_pwrmgt_off) (reg)->bitfields.PPLL_PWRMGT_OFF = ppll_pwrmgt_off
#define set_CLK_PWRMGT_CNTL_p2pll_pwrmgt_off(reg, p2pll_pwrmgt_off) (reg)->bitfields.P2PLL_PWRMGT_OFF = p2pll_pwrmgt_off
#define set_CLK_PWRMGT_CNTL_mclk_turnoff(reg, mclk_turnoff) (reg)->bitfields.MCLK_TURNOFF = mclk_turnoff
#define set_CLK_PWRMGT_CNTL_sclk_turnoff(reg, sclk_turnoff) (reg)->bitfields.SCLK_TURNOFF = sclk_turnoff
#define set_CLK_PWRMGT_CNTL_pclk_turnoff(reg, pclk_turnoff) (reg)->bitfields.PCLK_TURNOFF = pclk_turnoff
#define set_CLK_PWRMGT_CNTL_p2clk_turnoff(reg, p2clk_turnoff) (reg)->bitfields.P2CLK_TURNOFF = p2clk_turnoff
#define set_CLK_PWRMGT_CNTL_mc_ch_mode(reg, mc_ch_mode) (reg)->bitfields.MC_CH_MODE = mc_ch_mode
#define set_CLK_PWRMGT_CNTL_test_mode(reg, test_mode) (reg)->bitfields.TEST_MODE = test_mode
#define set_CLK_PWRMGT_CNTL_global_pman_en(reg, global_pman_en) (reg)->bitfields.GLOBAL_PMAN_EN = global_pman_en
#define set_CLK_PWRMGT_CNTL_engine_dynclk_mode(reg, engine_dynclk_mode) (reg)->bitfields.ENGINE_DYNCLK_MODE = engine_dynclk_mode
#define set_CLK_PWRMGT_CNTL_active_hilo_lat(reg, active_hilo_lat) (reg)->bitfields.ACTIVE_HILO_LAT = active_hilo_lat
#define set_CLK_PWRMGT_CNTL_disp_dyn_stop_lat(reg, disp_dyn_stop_lat) (reg)->bitfields.DISP_DYN_STOP_LAT = disp_dyn_stop_lat
#define set_CLK_PWRMGT_CNTL_mc_busy(reg, mc_busy) (reg)->bitfields.MC_BUSY = mc_busy
#define set_CLK_PWRMGT_CNTL_mc_int_cntl(reg, mc_int_cntl) (reg)->bitfields.MC_INT_CNTL = mc_int_cntl
#define set_CLK_PWRMGT_CNTL_mc_switch(reg, mc_switch) (reg)->bitfields.MC_SWITCH = mc_switch
#define set_CLK_PWRMGT_CNTL_dll_ready(reg, dll_ready) (reg)->bitfields.DLL_READY = dll_ready
#define set_CLK_PWRMGT_CNTL_disp_pm(reg, disp_pm) (reg)->bitfields.DISP_PM = disp_pm
#define set_CLK_PWRMGT_CNTL_dyn_stop_mode(reg, dyn_stop_mode) (reg)->bitfields.DYN_STOP_MODE = dyn_stop_mode
#define set_CLK_PWRMGT_CNTL_cg_no1_debug(reg, cg_no1_debug) (reg)->bitfields.CG_NO1_DEBUG = cg_no1_debug

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union r200PLL_PWRMGT_CNTL regr200PLL_PWRMGT_CNTL;

#ifdef DEBUG
__inline void set_r200PLL_PWRMGT_CNTL_mpll_turnoff(regr200PLL_PWRMGT_CNTL *reg, unsigned int mpll_turnoff)
{
  reg->bitfields.MPLL_TURNOFF = mpll_turnoff;
  if (reg->bitfields.MPLL_TURNOFF != mpll_turnoff) HSLDPF(E_ERROR_MESSAGE,"r200PLL_PWRMGT_CNTL::MPLL_TURNOFF data too large\n");
}
__inline void set_r200PLL_PWRMGT_CNTL_spll_turnoff(regr200PLL_PWRMGT_CNTL *reg, unsigned int spll_turnoff)
{
  reg->bitfields.SPLL_TURNOFF = spll_turnoff;
  if (reg->bitfields.SPLL_TURNOFF != spll_turnoff) HSLDPF(E_ERROR_MESSAGE,"r200PLL_PWRMGT_CNTL::SPLL_TURNOFF data too large\n");
}
__inline void set_r200PLL_PWRMGT_CNTL_ppll_turnoff(regr200PLL_PWRMGT_CNTL *reg, unsigned int ppll_turnoff)
{
  reg->bitfields.PPLL_TURNOFF = ppll_turnoff;
  if (reg->bitfields.PPLL_TURNOFF != ppll_turnoff) HSLDPF(E_ERROR_MESSAGE,"r200PLL_PWRMGT_CNTL::PPLL_TURNOFF data too large\n");
}
__inline void set_r200PLL_PWRMGT_CNTL_p2pll_turnoff(regr200PLL_PWRMGT_CNTL *reg, unsigned int p2pll_turnoff)
{
  reg->bitfields.P2PLL_TURNOFF = p2pll_turnoff;
  if (reg->bitfields.P2PLL_TURNOFF != p2pll_turnoff) HSLDPF(E_ERROR_MESSAGE,"r200PLL_PWRMGT_CNTL::P2PLL_TURNOFF data too large\n");
}
__inline void set_r200PLL_PWRMGT_CNTL_agpclk_dyn_stop_lat(regr200PLL_PWRMGT_CNTL *reg, unsigned int agpclk_dyn_stop_lat)
{
  reg->bitfields.AGPCLK_DYN_STOP_LAT = agpclk_dyn_stop_lat;
  if (reg->bitfields.AGPCLK_DYN_STOP_LAT != agpclk_dyn_stop_lat) HSLDPF(E_ERROR_MESSAGE,"r200PLL_PWRMGT_CNTL::AGPCLK_DYN_STOP_LAT data too large\n");
}
__inline void set_r200PLL_PWRMGT_CNTL_apm_power_state(regr200PLL_PWRMGT_CNTL *reg, unsigned int apm_power_state)
{
  reg->bitfields.APM_POWER_STATE = apm_power_state;
  if (reg->bitfields.APM_POWER_STATE != apm_power_state) HSLDPF(E_ERROR_MESSAGE,"r200PLL_PWRMGT_CNTL::APM_POWER_STATE data too large\n");
}
__inline void set_r200PLL_PWRMGT_CNTL_apm_pwrstate_rd(regr200PLL_PWRMGT_CNTL *reg, unsigned int apm_pwrstate_rd)
{
  reg->bitfields.APM_PWRSTATE_RD = apm_pwrstate_rd;
  if (reg->bitfields.APM_PWRSTATE_RD != apm_pwrstate_rd) HSLDPF(E_ERROR_MESSAGE,"r200PLL_PWRMGT_CNTL::APM_PWRSTATE_RD data too large\n");
}
__inline void set_r200PLL_PWRMGT_CNTL_pm_mode_sel(regr200PLL_PWRMGT_CNTL *reg, unsigned int pm_mode_sel)
{
  reg->bitfields.PM_MODE_SEL = pm_mode_sel;
  if (reg->bitfields.PM_MODE_SEL != pm_mode_sel) HSLDPF(E_ERROR_MESSAGE,"r200PLL_PWRMGT_CNTL::PM_MODE_SEL data too large\n");
}
__inline void set_r200PLL_PWRMGT_CNTL_en_pwrseq_done_cond(regr200PLL_PWRMGT_CNTL *reg, unsigned int en_pwrseq_done_cond)
{
  reg->bitfields.EN_PWRSEQ_DONE_COND = en_pwrseq_done_cond;
  if (reg->bitfields.EN_PWRSEQ_DONE_COND != en_pwrseq_done_cond) HSLDPF(E_ERROR_MESSAGE,"r200PLL_PWRMGT_CNTL::EN_PWRSEQ_DONE_COND data too large\n");
}
__inline void set_r200PLL_PWRMGT_CNTL_en_disp_parked_cond(regr200PLL_PWRMGT_CNTL *reg, unsigned int en_disp_parked_cond)
{
  reg->bitfields.EN_DISP_PARKED_COND = en_disp_parked_cond;
  if (reg->bitfields.EN_DISP_PARKED_COND != en_disp_parked_cond) HSLDPF(E_ERROR_MESSAGE,"r200PLL_PWRMGT_CNTL::EN_DISP_PARKED_COND data too large\n");
}
__inline void set_r200PLL_PWRMGT_CNTL_mobile_su(regr200PLL_PWRMGT_CNTL *reg, unsigned int mobile_su)
{
  reg->bitfields.MOBILE_SU = mobile_su;
  if (reg->bitfields.MOBILE_SU != mobile_su) HSLDPF(E_ERROR_MESSAGE,"r200PLL_PWRMGT_CNTL::MOBILE_SU data too large\n");
}
__inline void set_r200PLL_PWRMGT_CNTL_su_sclk_use_bclk(regr200PLL_PWRMGT_CNTL *reg, unsigned int su_sclk_use_bclk)
{
  reg->bitfields.SU_SCLK_USE_BCLK = su_sclk_use_bclk;
  if (reg->bitfields.SU_SCLK_USE_BCLK != su_sclk_use_bclk) HSLDPF(E_ERROR_MESSAGE,"r200PLL_PWRMGT_CNTL::SU_SCLK_USE_BCLK data too large\n");
}
__inline void set_r200PLL_PWRMGT_CNTL_su_mclk_use_bclk(regr200PLL_PWRMGT_CNTL *reg, unsigned int su_mclk_use_bclk)
{
  reg->bitfields.SU_MCLK_USE_BCLK = su_mclk_use_bclk;
  if (reg->bitfields.SU_MCLK_USE_BCLK != su_mclk_use_bclk) HSLDPF(E_ERROR_MESSAGE,"r200PLL_PWRMGT_CNTL::SU_MCLK_USE_BCLK data too large\n");
}
__inline void set_r200PLL_PWRMGT_CNTL_su_sustain_disable(regr200PLL_PWRMGT_CNTL *reg, unsigned int su_sustain_disable)
{
  reg->bitfields.SU_SUSTAIN_DISABLE = su_sustain_disable;
  if (reg->bitfields.SU_SUSTAIN_DISABLE != su_sustain_disable) HSLDPF(E_ERROR_MESSAGE,"r200PLL_PWRMGT_CNTL::SU_SUSTAIN_DISABLE data too large\n");
}
__inline void set_r200PLL_PWRMGT_CNTL_tcl_bypass_disable(regr200PLL_PWRMGT_CNTL *reg, unsigned int tcl_bypass_disable)
{
  reg->bitfields.TCL_BYPASS_DISABLE = tcl_bypass_disable;
  if (reg->bitfields.TCL_BYPASS_DISABLE != tcl_bypass_disable) HSLDPF(E_ERROR_MESSAGE,"r200PLL_PWRMGT_CNTL::TCL_BYPASS_DISABLE data too large\n");
}
__inline void set_r200PLL_PWRMGT_CNTL_tcl_clock_active_rd(regr200PLL_PWRMGT_CNTL *reg, unsigned int tcl_clock_active_rd)
{
  reg->bitfields.TCL_CLOCK_ACTIVE_RD = tcl_clock_active_rd;
  if (reg->bitfields.TCL_CLOCK_ACTIVE_RD != tcl_clock_active_rd) HSLDPF(E_ERROR_MESSAGE,"r200PLL_PWRMGT_CNTL::TCL_CLOCK_ACTIVE_RD data too large\n");
}
__inline void set_r200PLL_PWRMGT_CNTL_cg_no2_debug(regr200PLL_PWRMGT_CNTL *reg, unsigned int cg_no2_debug)
{
  reg->bitfields.CG_NO2_DEBUG = cg_no2_debug;
  if (reg->bitfields.CG_NO2_DEBUG != cg_no2_debug) HSLDPF(E_ERROR_MESSAGE,"r200PLL_PWRMGT_CNTL::CG_NO2_DEBUG data too large\n");
}
#else
#define set_r200PLL_PWRMGT_CNTL_mpll_turnoff(reg, mpll_turnoff) (reg)->bitfields.MPLL_TURNOFF = mpll_turnoff
#define set_r200PLL_PWRMGT_CNTL_spll_turnoff(reg, spll_turnoff) (reg)->bitfields.SPLL_TURNOFF = spll_turnoff
#define set_r200PLL_PWRMGT_CNTL_ppll_turnoff(reg, ppll_turnoff) (reg)->bitfields.PPLL_TURNOFF = ppll_turnoff
#define set_r200PLL_PWRMGT_CNTL_p2pll_turnoff(reg, p2pll_turnoff) (reg)->bitfields.P2PLL_TURNOFF = p2pll_turnoff
#define set_r200PLL_PWRMGT_CNTL_agpclk_dyn_stop_lat(reg, agpclk_dyn_stop_lat) (reg)->bitfields.AGPCLK_DYN_STOP_LAT = agpclk_dyn_stop_lat
#define set_r200PLL_PWRMGT_CNTL_apm_power_state(reg, apm_power_state) (reg)->bitfields.APM_POWER_STATE = apm_power_state
#define set_r200PLL_PWRMGT_CNTL_apm_pwrstate_rd(reg, apm_pwrstate_rd) (reg)->bitfields.APM_PWRSTATE_RD = apm_pwrstate_rd
#define set_r200PLL_PWRMGT_CNTL_pm_mode_sel(reg, pm_mode_sel) (reg)->bitfields.PM_MODE_SEL = pm_mode_sel
#define set_r200PLL_PWRMGT_CNTL_en_pwrseq_done_cond(reg, en_pwrseq_done_cond) (reg)->bitfields.EN_PWRSEQ_DONE_COND = en_pwrseq_done_cond
#define set_r200PLL_PWRMGT_CNTL_en_disp_parked_cond(reg, en_disp_parked_cond) (reg)->bitfields.EN_DISP_PARKED_COND = en_disp_parked_cond
#define set_r200PLL_PWRMGT_CNTL_mobile_su(reg, mobile_su) (reg)->bitfields.MOBILE_SU = mobile_su
#define set_r200PLL_PWRMGT_CNTL_su_sclk_use_bclk(reg, su_sclk_use_bclk) (reg)->bitfields.SU_SCLK_USE_BCLK = su_sclk_use_bclk
#define set_r200PLL_PWRMGT_CNTL_su_mclk_use_bclk(reg, su_mclk_use_bclk) (reg)->bitfields.SU_MCLK_USE_BCLK = su_mclk_use_bclk
#define set_r200PLL_PWRMGT_CNTL_su_sustain_disable(reg, su_sustain_disable) (reg)->bitfields.SU_SUSTAIN_DISABLE = su_sustain_disable
#define set_r200PLL_PWRMGT_CNTL_tcl_bypass_disable(reg, tcl_bypass_disable) (reg)->bitfields.TCL_BYPASS_DISABLE = tcl_bypass_disable
#define set_r200PLL_PWRMGT_CNTL_tcl_clock_active_rd(reg, tcl_clock_active_rd) (reg)->bitfields.TCL_CLOCK_ACTIVE_RD = tcl_clock_active_rd
#define set_r200PLL_PWRMGT_CNTL_cg_no2_debug(reg, cg_no2_debug) (reg)->bitfields.CG_NO2_DEBUG = cg_no2_debug

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union M_SPLL_REF_FB_DIV regM_SPLL_REF_FB_DIV;

#ifdef DEBUG
__inline void set_M_SPLL_REF_FB_DIV_m_spll_ref_div(regM_SPLL_REF_FB_DIV *reg, unsigned int m_spll_ref_div)
{
  reg->bitfields.M_SPLL_REF_DIV = m_spll_ref_div;
  if (reg->bitfields.M_SPLL_REF_DIV != m_spll_ref_div) HSLDPF(E_ERROR_MESSAGE,"M_SPLL_REF_FB_DIV::M_SPLL_REF_DIV data too large\n");
}
__inline void set_M_SPLL_REF_FB_DIV_mpll_fb_div(regM_SPLL_REF_FB_DIV *reg, unsigned int mpll_fb_div)
{
  reg->bitfields.MPLL_FB_DIV = mpll_fb_div;
  if (reg->bitfields.MPLL_FB_DIV != mpll_fb_div) HSLDPF(E_ERROR_MESSAGE,"M_SPLL_REF_FB_DIV::MPLL_FB_DIV data too large\n");
}
__inline void set_M_SPLL_REF_FB_DIV_spll_fb_div(regM_SPLL_REF_FB_DIV *reg, unsigned int spll_fb_div)
{
  reg->bitfields.SPLL_FB_DIV = spll_fb_div;
  if (reg->bitfields.SPLL_FB_DIV != spll_fb_div) HSLDPF(E_ERROR_MESSAGE,"M_SPLL_REF_FB_DIV::SPLL_FB_DIV data too large\n");
}
__inline void set_M_SPLL_REF_FB_DIV_mpll_ref_src_sel(regM_SPLL_REF_FB_DIV *reg, unsigned int mpll_ref_src_sel)
{
  reg->bitfields.MPLL_REF_SRC_SEL = mpll_ref_src_sel;
  if (reg->bitfields.MPLL_REF_SRC_SEL != mpll_ref_src_sel) HSLDPF(E_ERROR_MESSAGE,"M_SPLL_REF_FB_DIV::MPLL_REF_SRC_SEL data too large\n");
}
#else
#define set_M_SPLL_REF_FB_DIV_m_spll_ref_div(reg, m_spll_ref_div) (reg)->bitfields.M_SPLL_REF_DIV = m_spll_ref_div
#define set_M_SPLL_REF_FB_DIV_mpll_fb_div(reg, mpll_fb_div) (reg)->bitfields.MPLL_FB_DIV = mpll_fb_div
#define set_M_SPLL_REF_FB_DIV_spll_fb_div(reg, spll_fb_div) (reg)->bitfields.SPLL_FB_DIV = spll_fb_div
#define set_M_SPLL_REF_FB_DIV_mpll_ref_src_sel(reg, mpll_ref_src_sel) (reg)->bitfields.MPLL_REF_SRC_SEL = mpll_ref_src_sel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union r200MPLL_AUX_CNTL regr200MPLL_AUX_CNTL;

#ifdef DEBUG
__inline void set_r200MPLL_AUX_CNTL_mpll_pdc_c(regr200MPLL_AUX_CNTL *reg, unsigned int mpll_pdc_c)
{
  reg->bitfields.MPLL_PDC_C = mpll_pdc_c;
  if (reg->bitfields.MPLL_PDC_C != mpll_pdc_c) HSLDPF(E_ERROR_MESSAGE,"r200MPLL_AUX_CNTL::MPLL_PDC_C data too large\n");
}
__inline void set_r200MPLL_AUX_CNTL_mpll_ckinva(regr200MPLL_AUX_CNTL *reg, unsigned int mpll_ckinva)
{
  reg->bitfields.MPLL_CKINVA = mpll_ckinva;
  if (reg->bitfields.MPLL_CKINVA != mpll_ckinva) HSLDPF(E_ERROR_MESSAGE,"r200MPLL_AUX_CNTL::MPLL_CKINVA data too large\n");
}
__inline void set_r200MPLL_AUX_CNTL_mpll_ckinvc(regr200MPLL_AUX_CNTL *reg, unsigned int mpll_ckinvc)
{
  reg->bitfields.MPLL_CKINVC = mpll_ckinvc;
  if (reg->bitfields.MPLL_CKINVC != mpll_ckinvc) HSLDPF(E_ERROR_MESSAGE,"r200MPLL_AUX_CNTL::MPLL_CKINVC data too large\n");
}
__inline void set_r200MPLL_AUX_CNTL_mpll_x3_clk_skew(regr200MPLL_AUX_CNTL *reg, unsigned int mpll_x3_clk_skew)
{
  reg->bitfields.MPLL_X3_CLK_SKEW = mpll_x3_clk_skew;
  if (reg->bitfields.MPLL_X3_CLK_SKEW != mpll_x3_clk_skew) HSLDPF(E_ERROR_MESSAGE,"r200MPLL_AUX_CNTL::MPLL_X3_CLK_SKEW data too large\n");
}
__inline void set_r200MPLL_AUX_CNTL_mpll_modec(regr200MPLL_AUX_CNTL *reg, unsigned int mpll_modec)
{
  reg->bitfields.MPLL_MODEC = mpll_modec;
  if (reg->bitfields.MPLL_MODEC != mpll_modec) HSLDPF(E_ERROR_MESSAGE,"r200MPLL_AUX_CNTL::MPLL_MODEC data too large\n");
}
#else
#define set_r200MPLL_AUX_CNTL_mpll_pdc_c(reg, mpll_pdc_c) (reg)->bitfields.MPLL_PDC_C = mpll_pdc_c
#define set_r200MPLL_AUX_CNTL_mpll_ckinva(reg, mpll_ckinva) (reg)->bitfields.MPLL_CKINVA = mpll_ckinva
#define set_r200MPLL_AUX_CNTL_mpll_ckinvc(reg, mpll_ckinvc) (reg)->bitfields.MPLL_CKINVC = mpll_ckinvc
#define set_r200MPLL_AUX_CNTL_mpll_x3_clk_skew(reg, mpll_x3_clk_skew) (reg)->bitfields.MPLL_X3_CLK_SKEW = mpll_x3_clk_skew
#define set_r200MPLL_AUX_CNTL_mpll_modec(reg, mpll_modec) (reg)->bitfields.MPLL_MODEC = mpll_modec

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union MCLK_CNTL regMCLK_CNTL;

#ifdef DEBUG
__inline void set_MCLK_CNTL_mclka_src_sel(regMCLK_CNTL *reg, unsigned int mclka_src_sel)
{
  reg->bitfields.MCLKA_SRC_SEL = mclka_src_sel;
  if (reg->bitfields.MCLKA_SRC_SEL != mclka_src_sel) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL::MCLKA_SRC_SEL data too large\n");
}
__inline void set_MCLK_CNTL_yclka_src_sel(regMCLK_CNTL *reg, unsigned int yclka_src_sel)
{
  reg->bitfields.YCLKA_SRC_SEL = yclka_src_sel;
  if (reg->bitfields.YCLKA_SRC_SEL != yclka_src_sel) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL::YCLKA_SRC_SEL data too large\n");
}
__inline void set_MCLK_CNTL_mclkb_src_sel(regMCLK_CNTL *reg, unsigned int mclkb_src_sel)
{
  reg->bitfields.MCLKB_SRC_SEL = mclkb_src_sel;
  if (reg->bitfields.MCLKB_SRC_SEL != mclkb_src_sel) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL::MCLKB_SRC_SEL data too large\n");
}
__inline void set_MCLK_CNTL_yclkb_src_sel(regMCLK_CNTL *reg, unsigned int yclkb_src_sel)
{
  reg->bitfields.YCLKB_SRC_SEL = yclkb_src_sel;
  if (reg->bitfields.YCLKB_SRC_SEL != yclkb_src_sel) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL::YCLKB_SRC_SEL data too large\n");
}
__inline void set_MCLK_CNTL_force_mclka(regMCLK_CNTL *reg, unsigned int force_mclka)
{
  reg->bitfields.FORCE_MCLKA = force_mclka;
  if (reg->bitfields.FORCE_MCLKA != force_mclka) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL::FORCE_MCLKA data too large\n");
}
__inline void set_MCLK_CNTL_force_mclkb(regMCLK_CNTL *reg, unsigned int force_mclkb)
{
  reg->bitfields.FORCE_MCLKB = force_mclkb;
  if (reg->bitfields.FORCE_MCLKB != force_mclkb) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL::FORCE_MCLKB data too large\n");
}
__inline void set_MCLK_CNTL_force_yclka(regMCLK_CNTL *reg, unsigned int force_yclka)
{
  reg->bitfields.FORCE_YCLKA = force_yclka;
  if (reg->bitfields.FORCE_YCLKA != force_yclka) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL::FORCE_YCLKA data too large\n");
}
__inline void set_MCLK_CNTL_force_yclkb(regMCLK_CNTL *reg, unsigned int force_yclkb)
{
  reg->bitfields.FORCE_YCLKB = force_yclkb;
  if (reg->bitfields.FORCE_YCLKB != force_yclkb) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL::FORCE_YCLKB data too large\n");
}
__inline void set_MCLK_CNTL_force_mc(regMCLK_CNTL *reg, unsigned int force_mc)
{
  reg->bitfields.FORCE_MC = force_mc;
  if (reg->bitfields.FORCE_MC != force_mc) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL::FORCE_MC data too large\n");
}
__inline void set_MCLK_CNTL_force_aic(regMCLK_CNTL *reg, unsigned int force_aic)
{
  reg->bitfields.FORCE_AIC = force_aic;
  if (reg->bitfields.FORCE_AIC != force_aic) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL::FORCE_AIC data too large\n");
}
__inline void set_MCLK_CNTL_mrdcka0_soutsel(regMCLK_CNTL *reg, unsigned int mrdcka0_soutsel)
{
  reg->bitfields.MRDCKA0_SOUTSEL = mrdcka0_soutsel;
  if (reg->bitfields.MRDCKA0_SOUTSEL != mrdcka0_soutsel) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL::MRDCKA0_SOUTSEL data too large\n");
}
__inline void set_MCLK_CNTL_mrdcka1_soutsel(regMCLK_CNTL *reg, unsigned int mrdcka1_soutsel)
{
  reg->bitfields.MRDCKA1_SOUTSEL = mrdcka1_soutsel;
  if (reg->bitfields.MRDCKA1_SOUTSEL != mrdcka1_soutsel) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL::MRDCKA1_SOUTSEL data too large\n");
}
__inline void set_MCLK_CNTL_mrdckb0_soutsel(regMCLK_CNTL *reg, unsigned int mrdckb0_soutsel)
{
  reg->bitfields.MRDCKB0_SOUTSEL = mrdckb0_soutsel;
  if (reg->bitfields.MRDCKB0_SOUTSEL != mrdckb0_soutsel) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL::MRDCKB0_SOUTSEL data too large\n");
}
__inline void set_MCLK_CNTL_mrdckb1_soutsel(regMCLK_CNTL *reg, unsigned int mrdckb1_soutsel)
{
  reg->bitfields.MRDCKB1_SOUTSEL = mrdckb1_soutsel;
  if (reg->bitfields.MRDCKB1_SOUTSEL != mrdckb1_soutsel) HSLDPF(E_ERROR_MESSAGE,"MCLK_CNTL::MRDCKB1_SOUTSEL data too large\n");
}
#else
#define set_MCLK_CNTL_mclka_src_sel(reg, mclka_src_sel) (reg)->bitfields.MCLKA_SRC_SEL = mclka_src_sel
#define set_MCLK_CNTL_yclka_src_sel(reg, yclka_src_sel) (reg)->bitfields.YCLKA_SRC_SEL = yclka_src_sel
#define set_MCLK_CNTL_mclkb_src_sel(reg, mclkb_src_sel) (reg)->bitfields.MCLKB_SRC_SEL = mclkb_src_sel
#define set_MCLK_CNTL_yclkb_src_sel(reg, yclkb_src_sel) (reg)->bitfields.YCLKB_SRC_SEL = yclkb_src_sel
#define set_MCLK_CNTL_force_mclka(reg, force_mclka) (reg)->bitfields.FORCE_MCLKA = force_mclka
#define set_MCLK_CNTL_force_mclkb(reg, force_mclkb) (reg)->bitfields.FORCE_MCLKB = force_mclkb
#define set_MCLK_CNTL_force_yclka(reg, force_yclka) (reg)->bitfields.FORCE_YCLKA = force_yclka
#define set_MCLK_CNTL_force_yclkb(reg, force_yclkb) (reg)->bitfields.FORCE_YCLKB = force_yclkb
#define set_MCLK_CNTL_force_mc(reg, force_mc) (reg)->bitfields.FORCE_MC = force_mc
#define set_MCLK_CNTL_force_aic(reg, force_aic) (reg)->bitfields.FORCE_AIC = force_aic
#define set_MCLK_CNTL_mrdcka0_soutsel(reg, mrdcka0_soutsel) (reg)->bitfields.MRDCKA0_SOUTSEL = mrdcka0_soutsel
#define set_MCLK_CNTL_mrdcka1_soutsel(reg, mrdcka1_soutsel) (reg)->bitfields.MRDCKA1_SOUTSEL = mrdcka1_soutsel
#define set_MCLK_CNTL_mrdckb0_soutsel(reg, mrdckb0_soutsel) (reg)->bitfields.MRDCKB0_SOUTSEL = mrdckb0_soutsel
#define set_MCLK_CNTL_mrdckb1_soutsel(reg, mrdckb1_soutsel) (reg)->bitfields.MRDCKB1_SOUTSEL = mrdckb1_soutsel

#endif // DEBUG
///////////////////////////////////////////////////////////////
typedef union r200MCLK_MISC regr200MCLK_MISC;

#ifdef DEBUG
__inline void set_r200MCLK_MISC_sclk_sourced_from_mpll_sel(regr200MCLK_MISC *reg, unsigned int sclk_sourced_from_mpll_sel)
{
  reg->bitfields.SCLK_SOURCED_FROM_MPLL_SEL = sclk_sourced_from_mpll_sel;
  if (reg->bitfields.SCLK_SOURCED_FROM_MPLL_SEL != sclk_sourced_from_mpll_sel) HSLDPF(E_ERROR_MESSAGE,"r200MCLK_MISC::SCLK_SOURCED_FROM_MPLL_SEL data too large\n");
}
__inline void set_r200MCLK_MISC_mclk_from_spll_div_sel(regr200MCLK_MISC *reg, unsigned int mclk_from_spll_div_sel)
{
  reg->bitfields.MCLK_FROM_SPLL_DIV_SEL = mclk_from_spll_div_sel;
  if (reg->bitfields.MCLK_FROM_SPLL_DIV_SEL != mclk_from_spll_div_sel) HSLDPF(E_ERROR_MESSAGE,"r200MCLK_MISC::MCLK_FROM_SPLL_DIV_SEL data too large\n");
}
__inline void set_r200MCLK_MISC_enable_sclk_from_mpll(regr200MCLK_MISC *reg, unsigned int enable_sclk_from_mpll)
{
  reg->bitfields.ENABLE_SCLK_FROM_MPLL = enable_sclk_from_mpll;
  if (reg->bitfields.ENABLE_SCLK_FROM_MPLL != enable_sclk_from_mpll) HSLDPF(E_ERROR_MESSAGE,"r200MCLK_MISC::ENABLE_SCLK_FROM_MPLL data too large\n");
}
__inline void set_r200MCLK_MISC_mpll_modea_modec_hw_sel_en(regr200MCLK_MISC *reg, unsigned int mpll_modea_modec_hw_sel_en)
{
  reg->bitfields.MPLL_MODEA_MODEC_HW_SEL_EN = mpll_modea_modec_hw_sel_en;
  if (reg->bitfields.MPLL_MODEA_MODEC_HW_SEL_EN != mpll_modea_modec_hw_sel_en) HSLDPF(E_ERROR_MESSAGE,"r200MCLK_MISC::MPLL_MODEA_MODEC_HW_SEL_EN data too large\n");
}
__inline void set_r200MCLK_MISC_dll_ready_lat(regr200MCLK_MISC *reg, unsigned int dll_ready_lat)
{
  reg->bitfields.DLL_READY_LAT = dll_ready_lat;
  if (reg->bitfields.DLL_READY_LAT != dll_ready_lat) HSLDPF(E_ERROR_MESSAGE,"r200MCLK_MISC::DLL_READY_LAT data too large\n");
}
__inline void set_r200MCLK_MISC_cgm_clk_to_outpin(regr200MCLK_MISC *reg, unsigned int cgm_clk_to_outpin)
{
  reg->bitfields.CGM_CLK_TO_OUTPIN = cgm_clk_to_outpin;
  if (reg->bitfields.CGM_CLK_TO_OUTPIN != cgm_clk_to_outpin) HSLDPF(E_ERROR_MESSAGE,"r200MCLK_MISC::CGM_CLK_TO_OUTPIN data too large\n");
}
__inline void set_r200MCLK_MISC_clk_or_count_sel(regr200MCLK_MISC *reg, unsigned int clk_or_count_sel)
{
  reg->bitfields.CLK_OR_COUNT_SEL = clk_or_count_sel;
  if (reg->bitfields.CLK_OR_COUNT_SEL != clk_or_count_sel) HSLDPF(E_ERROR_MESSAGE,"r200MCLK_MISC::CLK_OR_COUNT_SEL data too large\n");
}
__inline void set_r200MCLK_MISC_en_mclk_tristate_in_suspend(regr200MCLK_MISC *reg, unsigned int en_mclk_tristate_in_suspend)
{
  reg->bitfields.EN_MCLK_TRISTATE_IN_SUSPEND = en_mclk_tristate_in_suspend;
  if (reg->bitfields.EN_MCLK_TRISTATE_IN_SUSPEND != en_mclk_tristate_in_suspend) HSLDPF(E_ERROR_MESSAGE,"r200MCLK_MISC::EN_MCLK_TRISTATE_IN_SUSPEND data too large\n");
}
__inline void set_r200MCLK_MISC_cgm_spare_rd(regr200MCLK_MISC *reg, unsigned int cgm_spare_rd)
{
  reg->bitfields.CGM_SPARE_RD = cgm_spare_rd;
  if (reg->bitfields.CGM_SPARE_RD != cgm_spare_rd) HSLDPF(E_ERROR_MESSAGE,"r200MCLK_MISC::CGM_SPARE_RD data too large\n");
}
#else
#define set_r200MCLK_MISC_sclk_sourced_from_mpll_sel(reg, sclk_sourced_from_mpll_sel) (reg)->bitfields.SCLK_SOURCED_FROM_MPLL_SEL = sclk_sourced_from_mpll_sel
#define set_r200MCLK_MISC_mclk_from_spll_div_sel(reg, mclk_from_spll_div_sel) (reg)->bitfields.MCLK_FROM_SPLL_DIV_SEL = mclk_from_spll_div_sel
#define set_r200MCLK_MISC_enable_sclk_from_mpll(reg, enable_sclk_from_mpll) (reg)->bitfields.ENABLE_SCLK_FROM_MPLL = enable_sclk_from_mpll
#define set_r200MCLK_MISC_mpll_modea_modec_hw_sel_en(reg, mpll_modea_modec_hw_sel_en) (reg)->bitfields.MPLL_MODEA_MODEC_HW_SEL_EN = mpll_modea_modec_hw_sel_en
#define set_r200MCLK_MISC_dll_ready_lat(reg, dll_ready_lat) (reg)->bitfields.DLL_READY_LAT = dll_ready_lat
#define set_r200MCLK_MISC_cgm_clk_to_outpin(reg, cgm_clk_to_outpin) (reg)->bitfields.CGM_CLK_TO_OUTPIN = cgm_clk_to_outpin
#define set_r200MCLK_MISC_clk_or_count_sel(reg, clk_or_count_sel) (reg)->bitfields.CLK_OR_COUNT_SEL = clk_or_count_sel
#define set_r200MCLK_MISC_en_mclk_tristate_in_suspend(reg, en_mclk_tristate_in_suspend) (reg)->bitfields.EN_MCLK_TRISTATE_IN_SUSPEND = en_mclk_tristate_in_suspend
#define set_r200MCLK_MISC_cgm_spare_rd(reg, cgm_spare_rd) (reg)->bitfields.CGM_SPARE_RD = cgm_spare_rd

#endif // DEBUG
///////////////////////////////////////////////////////////////

#endif // CHAPLIN_BF_FUNC_H

